
erika3app.elf:     file format elf32-tricore
erika3app.elf
architecture: TriCore:V1_6_1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x80000020

Program Header:
    LOAD off    0x00004020 vaddr 0x80000020 paddr 0x80000020 align 2**14
         filesz 0x00013fe0 memsz 0x00013fe0 flags r-x
    LOAD off    0x00018000 vaddr 0x70000000 paddr 0x80014000 align 2**14
         filesz 0x00000868 memsz 0x00000868 flags rw-
    LOAD off    0x0001c000 vaddr 0x50000000 paddr 0x80014868 align 2**14
         filesz 0x0000005c memsz 0x0000005c flags rw-
    LOAD off    0x0001c868 vaddr 0x70000868 paddr 0x80014868 align 2**14
         filesz 0x00000000 memsz 0x00000308 flags rw-
    LOAD off    0x0001c05c vaddr 0x5000005c paddr 0x800148c4 align 2**14
         filesz 0x00000000 memsz 0x00000004 flags rw-
    LOAD off    0x00020000 vaddr 0x60000000 paddr 0x800148c4 align 2**14
         filesz 0x0000005c memsz 0x0000005c flags rw-
    LOAD off    0x00022600 vaddr 0x5001a600 paddr 0x800148c8 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00023700 vaddr 0x5001b700 paddr 0x800148c8 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00023c00 vaddr 0x5001bc00 paddr 0x80014900 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x0002005c vaddr 0x6000005c paddr 0x80014920 align 2**14
         filesz 0x00000000 memsz 0x00000004 flags rw-
    LOAD off    0x00022600 vaddr 0x6001a600 paddr 0x80014920 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00023700 vaddr 0x6001b700 paddr 0x80014920 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00020b70 vaddr 0x70000b70 paddr 0x80014920 align 2**14
         filesz 0x00000094 memsz 0x00000094 flags rw-
    LOAD off    0x00023c00 vaddr 0x6001bc00 paddr 0x80014940 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-
    LOAD off    0x00020c04 vaddr 0x70000c04 paddr 0x800149b4 align 2**14
         filesz 0x00000000 memsz 0x0000003c flags rw-
    LOAD off    0x00024000 vaddr 0xb0000000 paddr 0x800149b4 align 2**14
         filesz 0x00000000 memsz 0x00000018 flags rw-
    LOAD off    0x00024600 vaddr 0x70018600 paddr 0x800149b8 align 2**14
         filesz 0x00000000 memsz 0x00001000 flags rw-
    LOAD off    0x00021700 vaddr 0x70019700 paddr 0x800149b8 align 2**14
         filesz 0x00000000 memsz 0x00000400 flags rw-
    LOAD off    0x00021c00 vaddr 0x70019c00 paddr 0x800149c0 align 2**14
         filesz 0x00000000 memsz 0x00002000 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .startup      00000006  80000020  80000020  00004020  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000012a8  80000028  80000028  00004028  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .CPU2.bss     00000004  5000005c  800148c4  0001c05c  2**2
                  ALLOC, CPU2
  3 .CPU1.bss     00000004  6000005c  80014920  0002005c  2**2
                  ALLOC, CPU1
  4 .CPU0.bss     0000003c  70000c04  800149b4  00020c04  2**2
                  ALLOC, CPU0
  5 .bss          00000308  70000868  80014868  0001c868  2**3
                  ALLOC
  6 .lmu_bss      00000018  b0000000  800149b4  00024000  2**2
                  ALLOC
  7 .CPU2.data    0000005c  50000000  80014868  0001c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU2
  8 .CPU1.data    0000005c  60000000  800148c4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU1
  9 .CPU0.data    00000094  70000b70  80014920  00020b70  2**2
                  CONTENTS, ALLOC, LOAD, DATA, CPU0
 10 .data         00000868  70000000  80014000  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 11 .traptab      00000100  80001300  80001300  00005300  2**8
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .ctors        00000008  80001400  80001400  00005400  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .dtors        00000008  80001408  80001408  00005408  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .inttab_cpu0  00002000  80002000  80002000  00006000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text         0000bae8  80004000  80004000  00008000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .inttab_cpu1  00002000  80010000  80010000  00014000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .inttab_cpu2  00002000  80012000  80012000  00016000  2**13
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .CPU2.ustack  00001000  5001a600  800148c8  00022600  2**3
                  ALLOC, CPU2
 19 .CPU2.istack  00000400  5001b700  800148c8  00023700  2**3
                  ALLOC, CPU2
 20 .CPU2.csa     00002000  5001bc00  80014900  00023c00  2**6
                  ALLOC, CPU2
 21 .CPU1.ustack  00001000  6001a600  80014920  00022600  2**3
                  ALLOC, CPU1
 22 .CPU1.istack  00000400  6001b700  80014920  00023700  2**3
                  ALLOC, CPU1
 23 .CPU1.csa     00002000  6001bc00  80014940  00023c00  2**6
                  ALLOC, CPU1
 24 .CPU0.ustack  00001000  70018600  800149b8  00024600  2**3
                  ALLOC, CPU0
 25 .CPU0.istack  00000400  70019700  800149b8  00021700  2**3
                  ALLOC, CPU0
 26 .CPU0.csa     00002000  70019c00  800149c0  00021c00  2**6
                  ALLOC, CPU0
 27 .comment      00000053  00000000  00000000  00020c04  2**0
                  CONTENTS, READONLY
 28 .debug_aranges 00000d08  00000000  00000000  00020c58  2**3
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_info   000cee74  00000000  00000000  00021960  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_abbrev 0000c52c  00000000  00000000  000f07d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_line   0000f271  00000000  00000000  000fcd00  2**0
                  CONTENTS, READONLY, DEBUGGING
 32 .debug_frame  00002360  00000000  00000000  0010bf74  2**2
                  CONTENTS, READONLY, DEBUGGING
 33 .debug_str    000021f9  00000000  00000000  0010e2d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 34 .debug_loc    000175b8  00000000  00000000  001104cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 35 .debug_ranges 000017f0  00000000  00000000  00127a85  2**0
                  CONTENTS, READONLY, DEBUGGING
 36 .version_info 0004c67a  00000000  00000000  00129275  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
80000020 l    d  .startup	00000000 .startup
80000028 l    d  .rodata	00000000 .rodata
5000005c l    d  .CPU2.bss	00000000 .CPU2.bss
6000005c l    d  .CPU1.bss	00000000 .CPU1.bss
70000c04 l    d  .CPU0.bss	00000000 .CPU0.bss
70000868 l    d  .bss	00000000 .bss
b0000000 l    d  .lmu_bss	00000000 .lmu_bss
50000000 l    d  .CPU2.data	00000000 .CPU2.data
60000000 l    d  .CPU1.data	00000000 .CPU1.data
70000b70 l    d  .CPU0.data	00000000 .CPU0.data
70000000 l    d  .data	00000000 .data
80001300 l    d  .traptab	00000000 .traptab
80001400 l    d  .ctors	00000000 .ctors
80001408 l    d  .dtors	00000000 .dtors
80002000 l    d  .inttab_cpu0	00000000 .inttab_cpu0
80004000 l    d  .text	00000000 .text
80010000 l    d  .inttab_cpu1	00000000 .inttab_cpu1
80012000 l    d  .inttab_cpu2	00000000 .inttab_cpu2
5001a600 l    d  .CPU2.ustack	00000000 .CPU2.ustack
5001b700 l    d  .CPU2.istack	00000000 .CPU2.istack
5001bc00 l    d  .CPU2.csa	00000000 .CPU2.csa
6001a600 l    d  .CPU1.ustack	00000000 .CPU1.ustack
6001b700 l    d  .CPU1.istack	00000000 .CPU1.istack
6001bc00 l    d  .CPU1.csa	00000000 .CPU1.csa
70018600 l    d  .CPU0.ustack	00000000 .CPU0.ustack
70019700 l    d  .CPU0.istack	00000000 .CPU0.istack
70019c00 l    d  .CPU0.csa	00000000 .CPU0.csa
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .version_info	00000000 .version_info
00000000 l    df *ABS*	00000000 ee_tc_cstart.c
00000000 l    df *ABS*	00000000 asw.c
70000000 l     O .data	00000004 c.15847
00000000 l    df *ABS*	00000000 bsw.c
00000000 l    df *ABS*	00000000 ee_applcfg.c
b0000004 l     O .lmu_bss	00000004 osEE_kernel_lock
b0000000 l     O .lmu_bss	00000004 osEE_kernel_barrier
800002c0 l     O .rodata	00000020 osEE_tdb_ptr_array
800002a8 l     O .rodata	00000004 osEE_counter_db_ptr_array
80000248 l     O .rodata	0000000c osEE_alarm_db_ptr_array
80000200 l     O .rodata	0000000c osEE_spinlock_db_array
800003e0 l     O .rodata	00000010 osEE_sdb_array_core2
50000054 l     O .CPU2.data	00000008 0x60 osEE_scb_array_core2
5000005c l     O .CPU2.bss	00000004 0x60 osEE_lock_core2
800002e0 l     O .rodata	00000040 osEE_tdb_array_core2
8000020c l     O .rodata	00000008 osEE_autostart_trigger_db_core2
50000024 l     O .CPU2.data	00000008 0x60 osEE_sn_array_core2
800003f0 l     O .rodata	00000010 osEE_sdb_array_core1
60000054 l     O .CPU1.data	00000008 0x40 osEE_scb_array_core1
6000005c l     O .CPU1.bss	00000004 0x40 osEE_lock_core1
80000320 l     O .rodata	00000040 osEE_tdb_array_core1
80000214 l     O .rodata	00000008 osEE_autostart_trigger_db_core1
60000024 l     O .CPU1.data	00000008 0x40 osEE_sn_array_core1
80000400 l     O .rodata	00000010 osEE_sdb_array_core0
70000bfc l     O .CPU0.data	00000008 0x20 osEE_scb_array_core0
70000c04 l     O .CPU0.bss	00000004 0x20 osEE_lock_core0
80000360 l     O .rodata	00000080 osEE_tdb_array_core0
8000021c l     O .rodata	00000008 osEE_autostart_trigger_db_core0
70000b94 l     O .CPU0.data	00000018 0x20 osEE_sn_array_core0
b000000c l     O .lmu_bss	0000000c osEE_spinlock_cb_array
b0000008 l     O .lmu_bss	00000004 osEE_spinlock_S1
80000224 l     O .rodata	00000024 osEE_trigger_autostart_info_core0_OSDEFAULTAPPMODE
80000254 l     O .rodata	00000054 osEE_alarm_db_array_core0
70000c08 l     O .CPU0.bss	00000030 0x20 osEE_alarm_cb_array_core0
800002ac l     O .rodata	00000014 osEE_counter_db_array_core0
70000c38 l     O .CPU0.bss	00000008 0x20 osEE_counter_cb_array_core0
5000002c l     O .CPU2.data	00000028 0x60 osEE_tcb_array_core2
6000002c l     O .CPU1.data	00000028 0x40 osEE_tcb_array_core1
70000bac l     O .CPU0.data	00000050 0x20 osEE_tcb_array_core0
5001a600 l     O .CPU2.ustack	00000404 0x60 osEE_task_stack_5
6001a600 l     O .CPU1.ustack	00000404 0x40 osEE_task_stack_3
70018600 l     O .CPU0.ustack	00000404 0x20 osEE_task_stack_1
00000000 l    df *ABS*	00000000 IfxVadc.c
80000410 l     O .rodata	00000006 CSWTCH.25
00000000 l    df *ABS*	00000000 IfxVadc_cfg.c
00000000 l    df *ABS*	00000000 IfxAsclin_PinMap.c
00000000 l    df *ABS*	00000000 IfxAsclin_cfg.c
00000000 l    df *ABS*	00000000 IfxPort_cfg.c
00000000 l    df *ABS*	00000000 IfxScuCcu.c
70000020 l     O .data	00000004 IfxScuCcu_xtalFrequency
80005ec8 l     F .text	00000034 IfxScuCcu_wait
80000ce4 l     O .rodata	00000024 IfxScuCcu_aDefaultPllConfigSteps
00000000 l    df *ABS*	00000000 IfxScu_PinMap.c
00000000 l    df *ABS*	00000000 IfxVadc_Adc.c
80000f80 l     O .rodata	00000040 IfxVadc_Adc_masterIndex
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 impure.c
7000043c l     O .data	00000424 impure_data
00000000 l    df *ABS*	00000000 vfprintf.c
80001020 l     O .rodata	00000010 blanks.4035
80001010 l     O .rodata	00000010 zeroes.4036
00000000 l    df *ABS*	00000000 dtoa.c
8000dd2c l     F .text	0000011a quorem
00000000 l    df *ABS*	00000000 locale.c
8000104c l     O .rodata	00000038 lconv
00000000 l    df *ABS*	00000000 mprec.c
80001084 l     O .rodata	0000000c p05.2553
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_sbrk.c
70000860 l     O .data	00000004 heap_top.2289
00000000 l    df *ABS*	00000000 ee_tc_trapvec.c
00000000 l    df *ABS*	00000000 ee_tc_intvec.c
80009636 l     F .text	000000c6 osEE_tc_isr2_wrapper
00000000 l    df *ABS*	00000000 IfxAsclin.c
00000000 l    df *ABS*	00000000 IfxAsclin_Asc.c
00000000 l    df *ABS*	00000000 IfxPort.c
00000000 l    df *ABS*	00000000 IfxScuEru.c
00000000 l    df *ABS*	00000000 IfxScuWdt.c
00000000 l    df *ABS*	00000000 Ifx_CircularBuffer.c
00000000 l    df *ABS*	00000000 Ifx_Fifo.c
00000000 l    df *ABS*	00000000 ee_tc_system.c
80009166 l     F .text	00000054 osEE_tc_stm_us_ticks
70000b20 l     O .bss	00000004 osEE_tc_stm_freq_khz
00000000 l    df *ABS*	00000000 ee_oo_api_osek.c
800096fc l     F .text	0000001e osEE_shutdown_os
00000000 l    df *ABS*	00000000 ee_oo_sched_entry_points.c
8000ac94 l     F .text	0000004c osEE_release_all_m
00000000 l    df *ABS*	00000000 ee_oo_scheduler.c
00000000 l    df *ABS*	00000000 ee_oo_kernel.c
00000000 l    df *ABS*	00000000 ee_oo_sched_partitioned.c
8000afac l     F .text	00000026 osEE_scheduler_task_insert_rq
00000000 l    df *ABS*	00000000 ee_oo_counter.c
00000000 l    df *ABS*	00000000 ee_oo_alarm.c
00000000 l    df *ABS*	00000000 ee_std_change_context.c
00000000 l    df *ABS*	00000000 ee_tc_hal.c
00000000 l    df *ABS*	00000000 ee_tc_hal_mc.c
00000000 l    df *ABS*	00000000 ee_tc_ctx.c
8000b92c l     F .text	00000022 osEE_tc_change_context_from_task_end
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
8000bb04 l     F .text	0000019c _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vsnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 libos_exit.c
00000000 l    df *ABS*	00000000 libos.c
00000000 l    df *ABS*	00000000 libos_abort.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udivdi3.c
00000000 l    df *ABS*	00000000 umoddi3.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 udiv6432.c
00000000 l    df *ABS*	00000000 Bsp.c
00000000 l    df *ABS*	00000000 CompilerGnuc.c
00000000 l    df *ABS*	00000000 IfxCpu.c
00000000 l    df *ABS*	00000000 IfxCpu_Irq.c
00000000 l    df *ABS*	00000000 IfxCpu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc.c
00000000 l    df *ABS*	00000000 IfxStdIf_DPipe.c
00000000 l    df *ABS*	00000000 IfxStm.c
00000000 l    df *ABS*	00000000 IfxStm_cfg.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 IfxScu_cfg.c
00000000 l    df *ABS*	00000000 IfxSrc_cfg.c
80000618 g     O .rodata	00000010 IfxAsclin1_TX_P33_12_OUT
70000b70 g     O .inttab_cpu2	00000001 __HEAP
800056bc g     F .text	00000062 IfxAsclin_Asc_write
80004f5a g     F .text	0000000a IfxAsclin_Asc_getWriteEvent
80006fe4 g     F .text	00000032 IfxScuWdt_clearSafetyEndinit
80013bc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_222
80012000 g     F .inttab_cpu2	00002000 __INTTAB2
80007218 g     F .text	00000036 IfxScuWdt_setCpuEndinit
80001090 g     O .rodata	00000028 __mprec_tinytens
80011820 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_193
80000d28 g     O .rodata	00000010 IfxScu_WDT1LCK_P20_7_OUT
80003260 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_147
800041e0 g     F .text	000000e8 mdelay
800021c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_14
80012fa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_125
800103a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_29
80002200 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_16
8000c0a8 g     F .text	0000001a .hidden __ashldi3
80011ae0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_215
80011460 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_163
80006f7a g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogReload
80010c40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_98
800106a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_53
800028e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_71
80009cee g     F .text	00000086 TerminateTask
80010d00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_104
80004fd6 g     F .text	00000006 IfxAsclin_Asc_resetSendCount
80000418 g     O .rodata	000000a0 IfxVadc_cfg_srcAddresses
80011380 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_156
70000010 g     O .data	00000010 osEE_kcb_var
80011560 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_171
800005c8 g     O .rodata	00000010 IfxAsclin2_TX_P14_2_OUT
80003000 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_128
80010e00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_112
800116e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_183
800038e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_199
80011180 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_140
80007fc2 g     F .text	00000020 Ifx_CircularBuffer_addDataIncr
80002fe0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_127
80002e80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_116
800037c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_190
80004a86 g     F .text	00000014 IfxVadc_setScan
8000f74c g     F .text	00000040 .hidden __eqdf2
800055ec g     F .text	00000088 IfxAsclin_Asc_initModuleConfig
80006f0e g     F .text	00000038 IfxScuWdt_changeCpuWatchdogReload
800046f8 g     F .text	00000010 IfxVadc_getQueueStatus
800102a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_21
80013320 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_153
80012e80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_116
80011280 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_148
800136c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_182
00000000 g       *ABS*	00000000 __HEAP_SIZE
80008278 g     F .text	00000176 Ifx_Fifo_read
8000b668 g     F .text	00000066 osEE_alarm_get
80004ae0 g     F .text	0000001c IfxAsclin_disableModule
800035e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_175
80000968 g     O .rodata	00000010 IfxAsclin3_RXC_P20_3_IN
8000adb2 g     F .text	00000018 osEE_idle_hook_wrapper
6001a600 g       .CPU1.ustack	00000000 __USTACK1_AREA_END
80010220 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_17
8000869a g     F .text	0000046c osEE_tc_core0_start
800027e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_63
800125c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_46
80002380 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_28
80012600 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_48
8000813e g     F .text	00000004 Ifx_Fifo_destroy
80012560 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_43
80003320 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_153
70019b00 g     O .CPU0.istack	00000000 __ISTACK0
80007452 g     F .text	00000108 IfxVadc_Adc_getChannelConfig
80012ac0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_86
80010800 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_64
800046a8 g     F .text	00000018 IfxVadc_getAdcAnalogFrequency
70000000 g       *ABS*	00000000 __DSPR0_START
8000b5a0 g     F .text	0000006a osEE_alarm_set_abs
80012b20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_89
80003920 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_201
8000b98c g     F .text	00000024 osEE_hal_save_ctx_and_ready2stacked
80012100 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_8
80010740 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_58
80003f80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_252
80006784 g     F .text	00000012 IfxScuCcu_initErayPllConfig
8000b6ce g     F .text	00000028 osEE_change_context_from_running
80003b00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_216
80003c80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_228
80004f4c g     F .text	0000000e IfxAsclin_Asc_getWriteCount
80002080 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_4
80000988 g     O .rodata	00000010 IfxAsclin3_RXA_P15_7_IN
70000b70 g     O .CPU0.data	00000024 0x20 osEE_ccb_var_core0
80013140 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_138
80003580 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_172
800115a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_173
80010b60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_91
80013f00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_248
80011540 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_170
80006ea4 g     F .text	00000032 IfxScuEru_setInterruptGatingPattern
80005098 g     F .text	00000014 IfxAsclin_Asc_clearTx
8000573a g     F .text	000000c6 IfxAsclin_Asc_stdIfDPipeInit
80002840 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_66
80013ae0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_215
8000c88c g     F .text	00000002 __malloc_unlock
80004f36 g     F .text	0000000a IfxAsclin_Asc_getReadEvent
80013600 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_176
80004000 g     F .text	00000034 TimerISR
80008424 g     F .text	000000f0 Ifx_Fifo_canWriteCount
80007d8a g     F .text	000000e8 IfxVadc_Adc_initModule
80009f9c g     F .text	000000b6 SetRelAlarm
80002280 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_20
80011e20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_241
800045c2 g     F .text	0000003c IfxVadc_disablePostCalibration
800047a6 g     F .text	00000028 IfxVadc_getSrcAddress
800047f2 g     F .text	00000024 IfxVadc_initialiseAdcConverterClock
80004c0a g     F .text	00000024 IfxAsclin_getOvsFrequency
80013f60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_251
80012940 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_74
800132c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_150
80012e20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_113
8000755a g     F .text	00000038 IfxVadc_Adc_getChannelConversionTime
8000a386 g     F .text	000000dc SetEvent
80010240 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_18
80002d00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_104
800130c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_134
8000a76c g     F .text	0000000e GetNumberOfActivatedCores
80006e66 g     F .text	00000012 IfxScuEru_setEventFlag
80010600 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_48
80002800 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_64
50000000 g     O .CPU2.data	00000024 0x60 osEE_ccb_var_core2
80003ba0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_221
800030c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_134
8000ace0 g     F .text	00000026 osEE_scheduler_task_wrapper_restore
80003e60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_243
80000f30 g     O .rodata	00000010 IfxScu_EVRWUPA_P14_1_IN
80000738 g     O .rodata	00000010 IfxAsclin3_SLSO_P12_1_OUT
70019600 g     O .CPU0.ustack	00000000 __USTACK0
8000f294 g     F .text	00000050 memmove
800023a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_29
80002fa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_125
80002e60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_115
70018600 g       .CPU0.ustack	00000000 __USTACK0_AREA_END
80013c20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_225
80010000 g     F .inttab_cpu1	00002000 __INTTAB1
800139c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_206
80012cc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_102
8000eb5a g     F .text	00000056 _Balloc
80000f10 g     O .rodata	00000010 IfxScu_EXTCLK0_P23_1_OUT
80011400 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_160
80010d40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_106
800138e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_199
80002980 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_76
80000a28 g     O .rodata	00000010 IfxAsclin1_RXE_P11_10_IN
80000808 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_8_OUT
80010b80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_92
8000609e g     F .text	0000004a IfxScuCcu_getModuleFrequency
80003040 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_130
80006210 g     F .text	000003be IfxScuCcu_init
800100a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_5
8000f7cc g     F .text	00000040 .hidden __gtdf2
80002700 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_56
8000f730  w    F .text	0000000a __errno
800022a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_21
8000976e g     F .text	00000056 SuspendAllInterrupts
80004fdc g     F .text	00000008 IfxAsclin_Asc_canReadCount
80011600 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_176
00001000 g       *ABS*	00000000 __USTACK0_SIZE
80002ba0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_93
80011ca0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_229
80011c80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_228
80000a08 g     O .rodata	00000010 IfxAsclin1_RXG_P02_3_IN
80011be0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_223
8000b9fa g     F .text	00000066 osEE_hal_terminate_ctx
800004b8 g     O .rodata	00000010 IfxAsclin3_TX_P32_3_OUT
8000ae3c g     F .text	00000048 osEE_sn_priority_insert
80003ca0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_229
80012920 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_73
8000ab8e g     F .text	00000106 TryToGetSpinlock
80009f02 g     F .text	0000009a GetTaskState
80003120 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_137
80007f80 g     F .text	00000020 Ifx_CircularBuffer_get32
8000af18 g     F .text	00000072 osEE_task_event_set_mask
800126a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_53
80000548 g     O .rodata	00000010 IfxAsclin3_TX_P11_1_OUT
80000978 g     O .rodata	00000010 IfxAsclin3_RXB_P11_0_IN
8000724e g     F .text	0000009e IfxScuWdt_initCpuWatchdog
800134c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_166
800059a0 g     F .text	00000092 IfxPort_setGroupModeOutput
80012700 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_56
80012c40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_98
80012ba0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_93
80012260 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_19
80013260 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_147
80003440 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_162
80010a80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_84
80010520 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_41
5001dc00 g     O .CPU2.csa	00000000 __CSA2_END
00000400 g       *ABS*	00000000 __ISTACK1_SIZE
80010f20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_121
80005dee g     F .text	00000072 IfxScuCcu_getPllFrequency
70000b60 g     O .bss	00000004 errno
8000c01c g     F .text	0000001e .hidden __make_dp
80003400 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_160
8000a18e g     F .text	0000009a GetAlarm
0001a600 g       *ABS*	00000000 __USTACK1_OFFSET
800112c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_150
80001360 g       .traptab	00000000 osEE_tc_trap_context
800124a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_37
800073d0 g     F .text	00000040 IfxScuWdt_enableWatchdogWithDebugger
80000918 g     O .rodata	00000010 IfxAsclin3_RXG_P21_3_IN
80000ab8 g     O .rodata	00000010 IfxAsclin2_RTS_P33_4_OUT
800136e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_183
80013700 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_184
80010300 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_24
80011140 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_138
80000778 g     O .rodata	00000010 IfxAsclin2_SLSO_P02_3_OUT
80003f60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_251
8000c13c g     F .text	00000016 .hidden __make_fp
800127a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_61
80004318 g     F .text	0000007e initVADCChannels
800029a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_77
800004e8 g     O .rodata	00000010 IfxAsclin3_TX_P22_0_OUT
80010c20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_97
80010680 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_52
80003d40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_234
80012da0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_109
80000e10 g     O .rodata	00000014 IfxScu_REQ15_P14_1_IN
80002420 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_33
80002f40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_122
80002460 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_35
80000e88 g     O .rodata	00000014 IfxScu_REQ0_P15_4_IN
8000a77a g     F .text	000000b8 StartCore
80013d00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_232
80006ed6 g     F .text	00000038 IfxScuWdt_changeCpuWatchdogPassword
80013200 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_144
800135c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_174
800039a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_205
8000a4e4 g     F .text	000000b2 ClearEvent
80006162 g     F .text	00000042 IfxScuCcu_getCpuFrequency
80002c40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_98
80010860 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_67
80011b40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_218
800035c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_174
8000ad06 g     F .text	000000ac osEE_scheduler_task_wrapper_run
80011b20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_217
80010ce0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_103
800034e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_167
80000858 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_0_OUT
80013280 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_148
80012d80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_108
800131e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_143
80000b88 g     O .rodata	00000080 IfxPort_cfg_indexMap
8000523e g     F .text	000003ae IfxAsclin_Asc_initModule
80003e40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_242
800135a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_173
800130a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_133
80010480 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_36
80010140 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_10
80011640 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_178
80003380 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_156
8000b27e g     F .text	0000003e osEE_scheduler_task_preemption_point
80011680 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_180
8000eb3e g     F .text	0000001c memcpy
80002b00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_88
80003240 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_146
80011d20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_233
800136a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_181
80002560 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_43
80011220 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_145
800110e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_135
8000a596 g     F .text	00000070 GetCounterValue
80013c60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_227
80002480 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_36
8000cb88 g     F .text	000011a4 _svfprintf_r
80003bc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_222
8000bfd4 g     F .text	00000048 .hidden __floatsidf
80007592 g     F .text	0000023e IfxVadc_Adc_getGroupConfig
80006d38 g     F .text	00000026 IfxScuEru_enablePatternDetectionTrigger
8000ae84 g     F .text	0000000e osEE_scheduler_rq_insert
80003020 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_129
8000f84c g     F .text	00000040 .hidden __ltdf2
8000479c g     F .text	0000000a IfxVadc_getScanStatus
80001410 g       .dtors	00000000 __DTOR_END__
80006796 g     F .text	00000076 IfxScuCcu_setCpuFrequency
80006e78 g     F .text	0000002c IfxScuEru_setFlagPatternDetection
8000b716 g     F .text	00000026 osEE_idle_task_terminate
80010d60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_107
80000e74 g     O .rodata	00000014 IfxScu_REQ10_P14_3_IN
80000aa8 g     O .rodata	00000010 IfxAsclin3_RTS_P00_9_OUT
80011da0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_237
80012340 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_26
80012060 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_3
80010c80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_100
80003620 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_177
800128a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_69
80012860 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_67
80003c60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_227
800008d8 g     O .rodata	00000010 IfxAsclin1_SCLK_P20_10_OUT
80012300 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_24
800130e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_135
800123a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_29
8000f100 g     F .text	00000042 __fpclassifyd
800035a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_173
800105e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_47
80006f46 g     F .text	00000034 IfxScuWdt_changeSafetyWatchdogPassword
800110c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_134
800114c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_166
800070e0 g     F .text	0000005c IfxScuWdt_enableCpuWatchdog
80010920 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_73
8000b138 g     F .text	000000a4 osEE_scheduler_task_unblocked
80011fe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_255
80013a60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_211
8000c3d6 g     F .text	0000000c malloc
80003700 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_184
80002340 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_26
80006ba8 g     F .text	00000028 IfxScuEru_clearInputChannelConfiguration
800104a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_37
00000000 g       *ABS*	00000000 NULL
80000938 g     O .rodata	00000010 IfxAsclin3_RXF_P21_6_IN
80009544 g     F .text	0000001e osEE_tc_stm_set_sr0_next_match
800036c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_182
80002a60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_83
80002600 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_48
80002b20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_89
800031a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_141
80001340 g       .traptab	00000000 osEE_tc_trap_instruction
800010e0 g     O .rodata	000000c8 __mprec_tens
70000008 g     O .data	00000004 g_vadcChannelIDs
80002d80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_108
80002580 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_44
80003280 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_148
800138c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_198
80005080 g     F .text	00000008 IfxAsclin_Asc_canWriteCount
800005d8 g     O .rodata	00000010 IfxAsclin2_TX_P10_5_OUT
800006c8 g     O .rodata	00000010 IfxAsclin0_TX_P15_2_OUT
80002120 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_9
80012e00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_112
8000c90a g     F .text	00000016 vsnprintf
80003da0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_237
80000b08 g     O .rodata	00000010 IfxAsclin3_CTSA_P00_12_IN
80013b00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_216
80011940 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_202
80013b60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_219
70000b58 g     O .bss	00000004 __malloc_top_pad
800043b8 g     F .text	00000026 readADCValue
80013d20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_233
80003780 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_188
8000b8b4 g     F .text	0000002a osEE_get_core
80012020 g       .inttab_cpu2	00000000 osEE_tc_core2_isr2_entry_1
80013300 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_152
80012e60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_115
8000680c g     F .text	0000008e IfxScuCcu_setGtmFrequency
80005b2c g     F .text	00000064 IfxPort_setPinModeLvdsHigh
8000b9b0 g     F .text	0000002c osEE_hal_ready2stacked
80000de8 g     O .rodata	00000014 IfxScu_REQ1_P15_8_IN
80002de0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_111
80011200 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_144
800080ee g     F .text	00000050 Ifx_CircularBuffer_write32
8000eb1c g     F .text	0000000a _localeconv_r
80013160 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_139
80002ce0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_103
80004bd0 g     F .text	00000022 IfxAsclin_getIndex
8000ecec g     F .text	00000010 __i2b
80009d74 g     F .text	000000a4 Schedule
80004c2e g     F .text	00000016 IfxAsclin_getShiftFrequency
800077d0 g     F .text	000001ec IfxVadc_Adc_initChannel
80002060 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_3
800004d8 g     O .rodata	00000010 IfxAsclin3_TX_P22_1_OUT
80006a6e g     F .text	00000112 IfxScuCcu_switchToBackupClock
80012660 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_51
800008f8 g     O .rodata	00000010 IfxAsclin0_SCLK_P15_2_OUT
8000713c g     F .text	00000072 IfxScuWdt_enableSafetyWatchdog
80011720 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_185
8000c88e g     F .text	0000001e _sbrk_r
80010940 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_74
800111c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_142
80000688 g     O .rodata	00000010 IfxAsclin1_TX_P11_12_OUT
800114a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_165
80000ea8 g     O .rodata	0000000c IfxScu_HWCFG5_P10_6_IN
80012c00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_96
80000698 g     O .rodata	00000010 IfxAsclin1_TX_P02_2_OUT
80002740 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_58
80011860 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_195
80013a20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_209
80002ec0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_118
80003800 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_192
80011ea0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_245
70000888 g     O .bss	0000000c g_vadcGroup
80006cec g     F .text	00000026 IfxScuEru_enableAutoClear
80013c80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_228
80010d80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_108
80002be0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_95
800124e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_39
800102e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_23
80013680 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_180
80004034 g     F .text	00000034 FuncTaskCPU0
800008e8 g     O .rodata	00000010 IfxAsclin1_SCLK_P15_0_OUT
800113c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_158
8000c264 g     F .text	000000ac .hidden __unpack_d
00002700 g     O *ABS*	00000000 __TRICORE_DERIVATE_NAME__
8000aace g     F .text	000000c0 ReleaseSpinlock
80005bd2 g     F .text	0000003c IfxPort_setPinPadDriver
80013220 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_145
80013e60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_243
80010100 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_8
80011a20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_209
80013de0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_239
80000648 g     O .rodata	00000010 IfxAsclin1_TX_P15_4_OUT
800116a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_181
70000b54 g     O .bss	00000004 __malloc_max_sbrked_mem
80013620 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_177
80003e80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_244
80002020 g       .inttab_cpu0	00000000 osEE_tc_core0_isr2_entry_1
80003f20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_249
800013a0 g       .traptab	00000000 osEE_tc_trap_assertion
80003360 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_155
80010840 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_66
80012440 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_34
800123e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_31
80011040 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_130
80008000 g       *ABS*	00000000 __A1_MEM
8000bad2 g     F .text	00000032 .hidden __extendsfdf2
80012980 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_76
800129e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_79
80011240 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_146
80004b46 g     F .text	00000016 IfxAsclin_getAddress
80002940 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_74
8000bca0 g     F .text	00000038 .hidden __adddf3
80009b22 g     F .text	00000022 GetActiveApplicationMode
80002d20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_105
800060e8 g     F .text	0000007a IfxScuCcu_getSriFrequency
800097c4 g     F .text	00000040 ResumeAllInterrupts
800119a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_205
80012740 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_58
80012640 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_50
800069ee g     F .text	00000080 IfxScuCcu_setSriFrequency
800121e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_15
80003860 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_195
8000f97a g     F .text	00000026 .hidden __umoddi3
80012be0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_95
70019c00 g     O .CPU0.csa	00000000 __CSA0
80002760 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_59
80000ad8 g     O .rodata	00000010 IfxAsclin1_RTS_P23_1_OUT
80002c00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_96
80000fd4 g     O .rodata	00000004 _global_impure_ptr
80006bf8 g     F .text	00000036 IfxScuEru_connectTrigger
70000868 g     O .bss	00000020 g_vadcChannel
80003fc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_254
800061a4 g     F .text	00000036 IfxScuCcu_getFsi2Frequency
8000f2f4 g     F .text	000003f0 _realloc_r
800008b8 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_12_OUT
80013020 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_129
80013fa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_253
80004c80 g     F .text	00000012 IfxAsclin_read16
800058d4 g     F .text	0000003c IfxPort_enableEmergencyStop
80000508 g     O .rodata	00000010 IfxAsclin3_TX_P20_3_OUT
80013880 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_196
80011a60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_211
8000f8da g     F .text	000000a0 .hidden __udivdi3
80013ee0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_247
80000a88 g     O .rodata	00000010 IfxAsclin0_RXB_P15_3_IN
80000518 g     O .rodata	00000010 IfxAsclin3_TX_P20_0_OUT
70008000 g       *ABS*	00000000 __A0_MEM
80003c00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_224
8000adca g     F .text	00000072 osEE_scheduler_core_rq_preempt_stk
80013420 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_161
6001dc00 g     O .CPU1.csa	00000000 __CSA1_END
800006d8 g     O .rodata	00000010 IfxAsclin0_TX_P14_1_OUT
800010b8 g     O .rodata	00000028 __mprec_bigtens
80013440 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_162
8000f73a g     F .text	00000012 abort
80012f20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_121
8000c076 g     F .text	00000032 .hidden __floatunsidf
80010040 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_2
80012500 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_40
8000ef4c g     F .text	00000042 __mcmp
800037a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_189
80009b44 g     F .text	000000a4 ActivateTask
800050ac g     F .text	0000001c IfxAsclin_Asc_read
80000e24 g     O .rodata	00000014 IfxScu_REQ14_P02_1_IN
800118a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_197
80012a60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_83
80012a20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_81
80002140 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_10
80006c54 g     F .text	00000026 IfxScuEru_disableFallingEdgeDetection
80012fc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_126
80002180 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_12
80011d80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_236
80013f40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_250
80011160 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_139
80008142 g     F .text	0000003a Ifx_Fifo_init
80011f80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_252
80011d60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_235
70000b68  w    O .bss	00000004 _my_errno
800138a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_197
80010bc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_94
80000718 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_2_OUT
80005800 g     F .text	00000030 IfxPort_getAddress
80010e20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_113
800028a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_69
00019c00 g       *ABS*	00000000 __CSA0_OFFSET
8000a8d6 g     F .text	00000100 ShutdownAllCores
80003080 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_132
80000b38 g     O .rodata	00000010 IfxAsclin1_CTSB_P32_4_IN
80009e8a g     F .text	00000078 GetTaskID
80010aa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_85
80010540 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_42
800065e2 g     F .text	000001a2 IfxScuCcu_initErayPll
800005b8 g     O .rodata	00000010 IfxAsclin2_TX_P14_3_OUT
80010f00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_120
80010060 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_3
80002f80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_124
80003980 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_204
80000558 g     O .rodata	00000010 IfxAsclin3_TX_P11_0_OUT
80000c90 g     O .rodata	00000054 IfxScuCcu_defaultClockConfig
80002dc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_110
80010fa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_125
0001bc00 g       *ABS*	00000000 __CSA1_OFFSET
800020c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_6
80006daa g     F .text	0000000e IfxScuEru_getAllEventFlagsStatus
80003140 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_138
80000ecc g     O .rodata	0000000c IfxScu_HWCFG2EVR13_P14_2_IN
80009804 g     F .text	00000070 SuspendOSInterrupts
80013520 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_169
80007016 g     F .text	0000005a IfxScuWdt_disableCpuWatchdog
8000c0c2 g     F .text	0000007a .hidden __unpack_f
8000948c g     F .text	00000034 osEE_tc_stm_set_clockpersec
80013b40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_218
80004396 g     F .text	00000022 initADC
800027a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_61
8000b2bc g     F .text	00000058 osEE_scheduler_task_set_running
800125a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_45
b0008000 g       *ABS*	00000000 _SMALL_DATA4_
80009562 g     F .text	0000008e osEE_tc_stm_set_sr1
80012b00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_88
80012a00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_80
80003a20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_209
800032e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_151
80000958 g     O .rodata	00000010 IfxAsclin3_RXD_P32_2_IN
80004480 g     F .text	0000000c asclin0TxISR
80000838 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_1_OUT
80007070 g     F .text	00000070 IfxScuWdt_disableSafetyWatchdog
80003720 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_185
800073cc g     F .text	00000004 IfxScuWdt_serviceSafetyWatchdog
800009b8 g     O .rodata	00000010 IfxAsclin2_RXE_P33_8_IN
80000868 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_9_OUT
8000ec44 g     F .text	00000042 __hi0bits
80000a58 g     O .rodata	00000010 IfxAsclin1_RXB_P15_5_IN
80013ea0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_245
80000628 g     O .rodata	00000010 IfxAsclin1_TX_P20_10_OUT
8000b3c8 g     F .text	00000152 osEE_counter_increment
80000638 g     O .rodata	00000010 IfxAsclin1_TX_P15_5_OUT
80003a60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_211
8000f88c g     F .text	0000004e .hidden __fixdfsi
80010340 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_26
80011d00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_232
80010c60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_99
800106c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_54
8000afd2 g     F .text	000000d6 osEE_scheduler_task_activated
80005efc g     F .text	00000078 IfxScuCcu_getBbbFrequency
800120c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_6
80011b60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_219
0001bc00 g       *ABS*	00000000 __CSA2_OFFSET
0001e000 g       *ABS*	00000000 __DSPR2_SIZE
80003b20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_217
80000568 g     O .rodata	00000010 IfxAsclin3_TX_P00_1_OUT
800006e8 g     O .rodata	00000010 IfxAsclin0_TX_P14_0_OUT
6001aa08 g     O .CPU1.ustack	00000000 __USTACK1_END
800061da g     F .text	00000036 IfxScuCcu_getFsiFrequency
80000d38 g     O .rodata	00000010 IfxScu_WDT0LCK_P20_8_OUT
80006fae g     F .text	00000036 IfxScuWdt_clearCpuEndinit
80013580 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_172
80011660 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_179
800108a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_69
80011020 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_129
80003e20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_241
80000888 g     O .rodata	00000010 IfxAsclin2_SCLK_P14_2_OUT
80004d76 g     F .text	00000182 IfxAsclin_setBitTiming
80013180 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_140
80013740 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_186
80011b80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_220
80000ef0 g     O .rodata	00000010 IfxScu_EXTCLK1_P32_4_OUT
800006f8 g     O .rodata	00000010 IfxAsclin3_SLSO_P33_1_OUT
80012d20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_105
80000528 g     O .rodata	00000010 IfxAsclin3_TX_P15_7_OUT
80010f40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_122
80000a38 g     O .rodata	00000010 IfxAsclin1_RXD_P14_8_IN
80000eb4 g     O .rodata	0000000c IfxScu_HWCFG4_P10_5_IN
80013100 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_136
800101c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_14
80007410 g     F .text	00000026 IfxVadc_Adc_deInitGroup
8000ba60 g     F .text	00000026 .hidden __lshrdi3
80012140 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_10
80011980 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_204
80000948 g     O .rodata	00000010 IfxAsclin3_RXE_P00_1_IN
80003be0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_223
80012b40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_90
80012200 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_16
80013ce0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_231
800027c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_62
80000a78 g     O .rodata	00000010 IfxAsclin0_RXD_P34_2_IN
800116c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_182
80002360 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_27
800007d8 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_7_OUT
800079d2 g     F .text	0000038a IfxVadc_Adc_initGroup
800033c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_158
800039c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_206
800133a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_157
80003340 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_154
80011840 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_194
8000ee16 g     F .text	0000007c __pow5mult
80011e40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_242
80013060 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_131
80013b80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_220
80011e80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_244
70000898 g     O .bss	0000000c g_ERUconfig
800117a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_189
80003fe0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_255
80002d60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_107
800107a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_61
800036a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_181
80011440 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_162
80011260 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_147
800106e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_55
800113a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_157
80003640 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_178
80006ca0 g     F .text	00000026 IfxScuEru_disableRisingEdgeDetection
80003160 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_139
80000798 g     O .rodata	00000010 IfxAsclin1_SLSO_P20_8_OUT
80010ca0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_101
800137e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_191
8000b1dc g     F .text	000000a2 osEE_scheduler_task_terminated
80000578 g     O .rodata	00000010 IfxAsclin3_TX_P00_0_OUT
800034c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_166
8000c310 g     F .text	000000c6 .hidden __pack_f
800026c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_54
8000a104 g     F .text	0000008a CancelAlarm
80007fe2 g     F .text	0000005e Ifx_CircularBuffer_read8
80002b60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_91
80011120 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_137
800123c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_30
800031c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_142
80000ac8 g     O .rodata	00000010 IfxAsclin2_RTS_P10_8_OUT
80011c60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_227
80012960 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_75
80008e36 g     F .text	00000330 osEE_tc_core2_start
00002700 g       *ABS*	00000000 __TRICORE_DERIVATE_MEMORY_MAP__
80010260 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_19
80008b06 g     F .text	00000330 osEE_tc_core1_start
80010620 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_49
80002260 g       .inttab_cpu0	00000000 osEE_tc_core0_isr2_entry_19
800071fe g     F .text	0000001a IfxScuWdt_initConfig
80013ec0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_246
800024e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_39
80003c20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_225
80001400 g       .ctors	00000000 __CTOR_LIST__
800126e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_55
80011500 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_168
800093e8 g     F .text	000000a4 osEE_tc_get_fsource
80004c92 g     F .text	00000012 IfxAsclin_read32
80000e4c g     O .rodata	00000014 IfxScu_REQ12_P11_10_IN
800072ec g     F .text	00000004 IfxScuWdt_serviceCpuWatchdog
800111e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_143
80000af8 g     O .rodata	00000010 IfxAsclin0_RTS_P14_7_OUT
800009c8 g     O .rodata	00000010 IfxAsclin2_RXD_P10_6_IN
800094c0 g     F .text	00000084 osEE_tc_stm_set_sr0
80000d48 g     O .rodata	00000014 IfxScu_REQ9_P20_0_IN
80000898 g     O .rodata	00000010 IfxAsclin2_SCLK_P10_6_OUT
800104e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_39
80013980 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_204
80012480 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_36
80011f20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_249
8000b9dc g     F .text	0000001e osEE_tc_change_context_from_isr2_end
8000eb26 g     F .text	00000018 memchr
80013940 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_202
80010760 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_59
80012fe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_127
8000c9da g     F .text	000001ac _free_r
80005674 g     F .text	00000048 IfxAsclin_Asc_initiateTransmission
80011480 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_164
800127e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_63
80012280 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_20
8000a758 g     F .text	00000014 GetISRID
800118e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_199
80002960 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_75
8000b94e g     F .text	00000024 osEE_hal_save_ctx_and_restore_ctx
80010ba0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_93
80003d80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_236
8000b51c g     F .text	00000084 osEE_alarm_set_rel
80013e40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_242
800023e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_31
800103e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_31
800026e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_55
80001380 g       .traptab	00000000 osEE_tc_trap_bus
80013d60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_235
80002040 g       .inttab_cpu0	00000000 osEE_tc_core0_isr2_entry_2
80005c10 g     F .text	000000f8 IfxScuCcu_calculateSysPllDividers
80002f60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_123
80002f00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_120
80013ca0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_229
8000b8de g     F .text	0000004e osEE_hal_start_core
80000b18 g     O .rodata	00000010 IfxAsclin2_CTSB_P33_5_IN
70000028 g     O .data	00000004 __malloc_sbrk_base
80000020 g     F .startup	00000006 _start
80002b80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_92
80013ba0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_221
800032a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_149
80002e20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_113
80002d40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_106
80012d00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_104
8000817c g     F .text	00000022 Ifx_Fifo_create
800071ce g     F .text	0000001c IfxScuWdt_getCpuWatchdogEndInit
80003680 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_180
00001000 g       *ABS*	00000000 __USTACK2_SIZE
800013e0 g       .traptab	00000000 osEE_tc_trap_nmi
80003a80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_212
80003d00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_232
8000ee92 g     F .text	000000ba __lshift
80010ea0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_117
800132a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_149
80000878 g     O .rodata	00000010 IfxAsclin2_SCLK_P33_7_OUT
80010980 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_76
80007436 g     F .text	0000001c IfxVadc_Adc_disableModule
80011920 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_201
80010a20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_81
00002000 g       *ABS*	00000000 __CSA_SIZE
8000f142 g     F .text	000000f0 __ssprint_r
80013660 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_179
800046c0 g     F .text	0000001a IfxVadc_getAdcDigitalFrequency
80013040 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_130
5001bc00 g     O .CPU2.csa	00000000 __CSA2
80002a40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_82
800101a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_13
8000b83e g     F .text	00000076 osEE_hal_sync_barrier
800025e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_47
800032c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_150
800001b8 g     O .rodata	00000024 osEE_cdb_var_core1
7001bc00 g     O .CPU0.csa	00000000 __CSA0_END
80002ac0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_86
80004544 g     F .text	00000038 IfxVadc_enableAccess
80002520 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_41
80010320 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_25
800127c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_62
80012780 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_60
80002400 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_32
80003540 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_170
8000ecfc g     F .text	0000011a __multiply
800100c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_6
8000a9d6 g     F .text	000000f8 GetSpinlock
80002440 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_34
00000001 g       *ABS*	00000000 _.
80006db8 g     F .text	00000012 IfxScuEru_getEventFlagStatus
80000758 g     O .rodata	00000010 IfxAsclin2_SLSO_P33_6_OUT
800005a8 g     O .rodata	00000010 IfxAsclin2_TX_P32_5_OUT
80004a0c g     F .text	00000024 IfxVadc_selectPowerSupplyVoltage
80006c7a g     F .text	00000026 IfxScuEru_disablePatternDetectionTrigger
80003a00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_208
70000b28 g     O .bss	00000028 __malloc_current_mallinfo
800135e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_175
80010880 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_68
8000f058 g     F .text	000000a8 __d2b
80010d20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_105
80013920 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_201
80011de0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_239
80012ca0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_101
80012380 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_28
80012840 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_66
800122e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_23
80000d84 g     O .rodata	00000014 IfxScu_REQ6_P02_0_IN
80013800 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_192
80007fa0 g     F .text	00000022 Ifx_CircularBuffer_get16
80003560 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_171
80011080 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_132
80000678 g     O .rodata	00000010 IfxAsclin1_TX_P14_10_OUT
80005daa g     F .text	00000044 IfxScuCcu_getPllErayVcoFrequency
80001400 g       .ctors	00000000 __EH_FRAME_END__
80006c2e g     F .text	00000026 IfxScuEru_disableAutoClear
8000689a g     F .text	00000050 IfxScuCcu_setPll2ErayFrequency
6001bb00 g     O .CPU1.istack	00000000 __ISTACK1
80010420 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_33
80006004 g     F .text	00000022 IfxScuCcu_getBaud2Frequency
80000818 g     O .rodata	00000010 IfxAsclin3_SCLK_P15_6_OUT
80003ea0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_245
8000f9a0 g     F .text	000000a6 .hidden __fpcmp_parts_d
800039e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_207
80003760 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_187
80002300 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_24
80004b2a g     F .text	0000001c IfxAsclin_enableModule
80013360 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_155
80012ec0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_118
0001a600 g       *ABS*	00000000 __USTACK2_OFFSET
80002ae0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_87
8000ae92 g     F .text	00000028 osEE_scheduler_core_pop_running
80010780 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_60
800128c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_70
80002540 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_42
8000b73c g     F .text	00000102 osEE_cpu_startos
80011ac0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_214
800020e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_7
80013840 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_194
80006d5e g     F .text	00000026 IfxScuEru_enableRisingEdgeDetection
800009f8 g     O .rodata	00000010 IfxAsclin2_RXA_P14_3_IN
800118c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_198
800030a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_133
80013f20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_249
80003460 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_163
80003de0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_239
800134a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_165
80005830 g     F .text	00000022 IfxPort_getIndex
8000a462 g     F .text	00000082 GetEvent
80003d60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_235
80005222 g     F .text	0000001c IfxAsclin_Asc_disableModule
800109c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_78
800119c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_206
80013ac0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_214
8000ba86 g     F .text	0000004c .hidden __floatundisf
6001b600 g     O .CPU1.ustack	00000000 __USTACK1
80013340 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_154
80012ea0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_117
80004ca4 g     F .text	00000012 IfxAsclin_read8
8000b0a8 g     F .text	00000090 osEE_scheduler_task_insert
80011bc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_222
8000bebc g     F .text	00000118 .hidden __divdf3
80000f50 g     O .rodata	00000010 IfxScu_EMGSTOPA_P33_8_IN
80000f00 g     O .rodata	00000010 IfxScu_EXTCLK1_P11_12_OUT
8000571e g     F .text	0000001c IfxAsclin_Asc_blockingWrite
80007e72 g     F .text	0000003a IfxVadc_Adc_initModuleConfig
70000030 g     O .data	00000408 __malloc_av_
80009e18 g     F .text	00000072 ShutdownOS
8000c8c0 g     F .text	0000004a _vsnprintf_r
70018a08 g     O .CPU0.ustack	00000000 __USTACK0_END
80010ae0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_87
80010580 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_44
800137c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_190
80011580 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_172
8000bd18 g     F .text	000001a4 .hidden __muldf3
80003ce0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_231
80000908 g     O .rodata	00000010 IfxAsclin0_SCLK_P14_0_OUT
80012180 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_12
80010e60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_115
80013480 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_164
80012f40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_122
80002fc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_126
800104c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_38
800033a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_157
800108c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_70
80002320 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_25
80002680 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_52
80000f40 g     O .rodata	00000010 IfxScu_EMGSTOPB_P21_2_IN
8000c88a g     F .text	00000002 __malloc_lock
8000f6f4 g     F .text	0000003c sbrk
80005d08 g     F .text	0000000e IfxScuCcu_getOsc0Frequency
8000450c g     F .text	00000038 IfxVadc_disableAccess
80000000 g       .startup	00000000 BootModeHeader0
800120e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_7
800013c0 g       .traptab	00000000 osEE_tc_trap_system
80000ec0 g     O .rodata	0000000c IfxScu_HWCFG3_BMI_P14_3_IN
80004068 g     F .text	00000048 FuncTaskCPU1
80010f80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_124
80004c6c g     F .text	00000014 IfxAsclin_getSrcPointerTx
80010ec0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_118
80004708 g     F .text	00000094 IfxVadc_getResultBasedOnRequestSource
8000f232 g     F .text	00000062 _calloc_r
80003aa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_213
800115e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_175
00002000 g       *ABS*	00000000 __CSA0_SIZE
80006026 g     F .text	00000078 IfxScuCcu_getSpbFrequency
800009e8 g     O .rodata	00000010 IfxAsclin2_RXB_P02_1_IN
80010de0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_111
80003500 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_168
800045fe g     F .text	000000aa IfxVadc_enableGroupSync
80006e12 g     F .text	00000012 IfxScuEru_getPatternDetectionResult
80012d60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_107
800131c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_142
800103c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_30
800050c8 g     F .text	0000009e IfxAsclin_Asc_isrTransmit
80000598 g     O .rodata	00000010 IfxAsclin2_TX_P33_8_OUT
80012420 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_33
8000f2e4 g     F .text	00000010 memset
80011ec0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_246
80003900 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_200
8000448c g     F .text	00000080 main
800071ae g     F .text	00000020 IfxScuWdt_getCpuWatchdogPassword
80010380 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_28
800129c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_78
800021e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_15
80002220 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_17
80006d84 g     F .text	00000026 IfxScuEru_enableTriggerPulse
80010f60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_123
80002900 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_72
70000b50 g     O .bss	00000004 __malloc_max_total_mem
80004afc g     F .text	0000002e IfxAsclin_enableAscErrorFlags
80000194 g     O .rodata	00000024 osEE_cdb_var_core2
8000fa46 g     F .text	0000009c .hidden __udiv6432
00000400 g       *ABS*	00000000 __ISTACK_SIZE
80012680 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_52
80005fe4 g     F .text	00000020 IfxScuCcu_getBaud1Frequency
80012720 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_57
80007eee g     F .text	00000092 IfxVadc_Adc_initExternalMultiplexerMode
80000dfc g     O .rodata	00000014 IfxScu_REQ16_P15_1_IN
80003820 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_193
80010960 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_75
700008a4 g     O .bss	0000027c g_AsclinAsc
80010a00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_80
80012c20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_97
80000e9c g     O .rodata	0000000c IfxScu_HWCFG6_P14_4_IN
8000aeba g     F .text	00000040 osEE_task_activated
80002ee0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_119
80002720 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_57
5001bb00 g     O .CPU2.istack	00000000 __ISTACK2
80000168 g     O .rodata	0000002c osEE_kdb_var
800033e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_159
800139a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_205
80010280 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_20
80013c00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_224
80002bc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_94
80003b60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_219
00018600 g       *ABS*	00000000 __USTACK0_OFFSET
800071ea g     F .text	00000014 IfxScuWdt_getSafetyWatchdogPassword
80012ce0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_103
8000c03a g     F .text	0000003c .hidden __truncdfsf2
80011420 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_161
8000de48 g     F .text	00000cd2 _dtoa_r
0001b700 g       *ABS*	00000000 __ISTACK1_OFFSET
8000c3f0 g     F .text	0000049a _malloc_r
80011f40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_250
80010200 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_16
80000708 g     O .rodata	00000010 IfxAsclin3_SLSO_P21_6_OUT
80005b90 g     F .text	00000042 IfxPort_setPinModeLvdsMedium
800009d8 g     O .rodata	00000010 IfxAsclin2_RXC_P02_10_IN
80011aa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_213
80011ee0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_247
800051fc g     F .text	00000026 IfxAsclin_Asc_blockingRead
8000b314 g     F .text	00000062 osEE_counter_insert_abs_trigger
800134e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_167
800007c8 g     O .rodata	00000010 IfxAsclin3_SCLK_P32_3_OUT
80004f30 g     F .text	00000006 IfxAsclin_Asc_getReadCount
80008000 g       *ABS*	00000000 __A8_MEM
800007b8 g     O .rodata	00000010 IfxAsclin3_SCLK_P33_2_OUT
b0008000 g       *ABS*	00000000 __A9_MEM
80012540 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_42
80004f0c g     F .text	00000012 IfxAsclin_write32
80011880 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_196
80012aa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_85
800112e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_151
800107e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_63
80002240 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_18
80002e00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_112
80013000 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_128
8000416a g     F .text	00000076 printfSerial
80012f60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_123
80002da0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_109
800036e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_183
80010720 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_57
80002920 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_73
80000fc0 g     O .rodata	00000014 .hidden __thenan_df
80010ee0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_119
8000c920 g     F .text	000000ba _malloc_trim_r
80001408 g       .ctors	00000000 __CTOR_END__
80012de0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_111
80008000 g     O *ABS*	00000000 _SMALL_DATA2_
80010b40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_90
800005e8 g     O .rodata	00000010 IfxAsclin2_TX_P02_9_OUT
80004910 g     F .text	000000aa IfxVadc_getChannelConversionTime
50000000 g       *ABS*	00000000 __DSPR2_START
80003100 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_136
8000457c g     F .text	00000046 IfxVadc_configExternalMultiplexerMode
80002860 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_67
80013b20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_217
80013da0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_237
80011fc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_254
80007eac g     F .text	00000042 IfxVadc_Adc_initExternalMultiplexerModeConfig
80004bf2 g     F .text	00000018 IfxAsclin_getPdFrequency
800113e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_159
800046de g     F .text	0000001a IfxVadc_getBackgroundScanStatus
80013d40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_234
80001408 g       .dtors	00000000 __DTOR_LIST__
60000000 g       *ABS*	00000000 __DSPR1_START
00001000 g       *ABS*	00000000 __USTACK1_SIZE
800049ba g     F .text	00000052 IfxVadc_resetKernel
80000ae8 g     O .rodata	00000010 IfxAsclin1_RTS_P20_6_OUT
80003200 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_144
80012c80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_100
80000ee4 g     O .rodata	0000000c IfxScu_HWCFG0DCLDO_P14_6_IN
60000000 g     O .CPU1.data	00000024 0x40 osEE_ccb_var_core1
8000f78c g     F .text	00000040 .hidden __nedf2
80004d24 g     F .text	00000052 IfxAsclin_setBaudrateBitFields
80002820 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_65
80003dc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_238
800114e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_167
80005e60 g     F .text	00000044 IfxScuCcu_getPllVcoFrequency
8000693a g     F .text	000000b4 IfxScuCcu_setSpbFrequency
80012580 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_44
80010dc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_110
800125e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_47
80006dee g     F .text	00000024 IfxScuEru_getOutputChannelConfiguration
80000d18 g     O .rodata	00000010 IfxScu_WDT2LCK_P20_6_OUT
80012620 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_49
80012520 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_41
80000c08 g     O .rodata	00000080 IfxPort_cfg_esrMasks
800133c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_158
80012ae0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_87
80000928 g     O .rodata	00000010 IfxAsclin3_RXG_P21_2_IN
80012a80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_84
80012a40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_82
80002e40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_114
80005088 g     F .text	00000010 IfxAsclin_Asc_clearRx
80011d40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_234
80000b58 g     O .rodata	00000010 IfxAsclin0_CTSA_P14_9_IN
80000f70 g     O .rodata	00000010 IfxScu_DCDCSYNC_P32_2_OUT
800058aa g     F .text	0000002a IfxPort_setESR
80013820 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_193
80000728 g     O .rodata	00000010 IfxAsclin3_SLSO_P14_3_OUT
80010be0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_95
80010640 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_50
80000668 g     O .rodata	00000010 IfxAsclin1_TX_P15_0_OUT
80003480 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_164
80013e80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_244
80010120 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_9
80002880 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_68
80010ac0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_86
80010560 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_43
800111a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_141
80011cc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_230
80000b48 g     O .rodata	00000010 IfxAsclin1_CTSA_P20_7_IN
800022c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_22
80013540 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_170
80013be0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_223
80010fe0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_127
80000dc0 g     O .rodata	00000014 IfxScu_REQ3_P10_3_IN
80013760 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_187
80000658 g     O .rodata	00000010 IfxAsclin1_TX_P15_1_OUT
8000a606 g     F .text	00000096 GetElapsedValue
70000438 g     O .data	00000004 _impure_ptr
80011c00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_224
80012900 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_72
80005852 g     F .text	00000028 IfxPort_resetESR
80002100 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_8
80004f64 g     F .text	00000072 IfxAsclin_Asc_isrError
80003ae0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_215
80013120 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_137
800047ce g     F .text	00000024 IfxVadc_initialiseAdcArbiterClock
800034a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_165
800119e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_207
80012b80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_92
80012240 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_18
80010e40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_114
80002780 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_60
80010a60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_83
80010500 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_40
80004c58 g     F .text	00000014 IfxAsclin_getSrcPointerRx
8000a228 g     F .text	0000006a GetAlarmBase
800006b8 g     O .rodata	00000010 IfxAsclin0_TX_P15_3_OUT
800133e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_159
80004c44 g     F .text	00000014 IfxAsclin_getSrcPointerEr
00002000 g       *ABS*	00000000 __CSA1_SIZE
80003fa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_253
80000608 g     O .rodata	00000010 IfxAsclin1_TX_P33_13_OUT
80000a48 g     O .rodata	00000010 IfxAsclin1_RXC_P20_9_IN
80003f40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_250
8000971a g     F .text	0000001e DisableAllInterrupts
80010360 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_27
5001aa08 g     O .CPU2.ustack	00000000 __USTACK2_END
80008090 g     F .text	0000005e Ifx_CircularBuffer_write8
80005166 g     F .text	00000096 IfxAsclin_Asc_isrReceive
80003220 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_145
80005910 g     F .text	00000090 IfxPort_setGroupModeInput
8000819e g     F .text	000000da Ifx_Fifo_canReadCount
80012040 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_2
00001000 g       *ABS*	00000000 __USTACK_SIZE
800117e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_191
80003600 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_176
80010cc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_102
80009be8 g     F .text	00000106 ChainTask
80002ca0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_101
800029c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_78
80010c00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_96
80010660 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_51
80011340 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_154
80011060 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_131
80011520 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_169
80006e32 g     F .text	00000034 IfxScuEru_selectExternalInput
80013a40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_210
80013640 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_178
80006d12 g     F .text	00000026 IfxScuEru_enableFallingEdgeDetection
80002c60 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_99
80011ba0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_221
80012080 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_4
80011c40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_226
80000b28 g     O .rodata	00000010 IfxAsclin2_CTSA_P10_7_IN
5001a600 g       .CPU2.ustack	00000000 __USTACK2_AREA_END
80011a40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_210
800009a8 g     O .rodata	00000010 IfxAsclin2_RXF_P32_6_IN
80013d80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_236
80000828 g     O .rodata	00000010 IfxAsclin3_SCLK_P11_4_OUT
800065ce g     F .text	00000014 IfxScuCcu_initConfig
800101e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_15
80003b80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_220
800028c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_70
800126c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_54
800004f8 g     O .rodata	00000010 IfxAsclin3_TX_P21_7_OUT
80004840 g     F .text	00000066 IfxVadc_initializeFAdcI
80013900 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_200
80003c40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_226
80012160 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_11
80000768 g     O .rodata	00000010 IfxAsclin2_SLSO_P10_5_OUT
80000d5c g     O .rodata	00000014 IfxScu_REQ8_P33_7_IN
800004c8 g     O .rodata	00000010 IfxAsclin3_TX_P32_2_OUT
80012c60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_99
80001300 g       .traptab	00000000 osEE_tc_trap_mmu
80012b60 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_91
80012220 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_17
80008040 g     F .text	00000050 Ifx_CircularBuffer_read32
80003840 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_194
80004fe4 g     F .text	0000009c IfxAsclin_Asc_flushTx
8000a832 g     F .text	000000a4 StartNonAutosarCore
8000960e g     F .text	00000028 osEE_tc_delay
80000848 g     O .rodata	00000010 IfxAsclin3_SCLK_P00_2_OUT
800011a8 g     O .rodata	00000000 __clear_table
80010460 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_35
80005d46 g     F .text	00000064 IfxScuCcu_getPllErayFrequency
80012460 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_35
800107c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_62
80000a18 g     O .rodata	00000010 IfxAsclin1_RXF_P33_13_IN
8000aefa g     F .text	0000001e osEE_task_end
800124c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_38
80003b40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_218
800007f8 g     O .rodata	00000010 IfxAsclin3_SCLK_P20_0_OUT
80012f80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_124
80010700 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_56
80003660 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_179
80000a68 g     O .rodata	00000010 IfxAsclin1_RXA_P15_1_IN
80001400 g       .ctors	00000000 __EH_FRAME_BEGIN__
80000748 g     O .rodata	00000010 IfxAsclin3_SLSO_P00_3_OUT
800024a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_37
800110a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_133
8000b376 g     F .text	00000022 osEE_counter_insert_rel_trigger
80013460 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_163
80005ea4 g     F .text	00000024 IfxScuCcu_getSourceFrequency
800006a8 g     O .rodata	00000010 IfxAsclin0_TX_P34_1_OUT
80000f60 g     O .rodata	00000010 IfxScu_DCDCSYNC_P33_13_OUT
80000e38 g     O .rodata	00000014 IfxScu_REQ13_P15_5_IN
80003f00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_248
80003cc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_230
800026a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_53
8000b6f6 g     F .text	00000020 osEE_change_context_from_task_end
800037e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_191
80011ce0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_231
80003300 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_152
80002ea0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_117
8000a292 g     F .text	000000f4 WaitEvent
80013a00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_208
800117c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_190
80002b40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_90
8000587a g     F .text	00000030 IfxPort_disableEmergencyStop
800137a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_189
800031e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_143
80011f60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_251
80000538 g     O .rodata	00000010 IfxAsclin3_TX_P15_6_OUT
80003a40 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_210
80007d5c g     F .text	0000002e IfxVadc_Adc_initGroupConfig
80003ac0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_214
80011fa0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_253
80002cc0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_102
80013e00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_240
80003520 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_169
80011320 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_153
00000400 g       *ABS*	00000000 __ISTACK0_SIZE
800115c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_174
80010b20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_89
800105c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_46
8000a69c g     F .text	000000bc IncrementCounter
800024c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_38
800038a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_197
800131a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_141
80012f00 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_120
5001b600 g     O .CPU2.ustack	00000000 __USTACK2
80013240 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_146
80012d40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_106
8000b60a g     F .text	0000005e osEE_alarm_cancel
80010900 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_72
800095f0 g     F .text	0000001e osEE_tc_stm_set_sr1_next_match
0001e000 g       *ABS*	00000000 __DSPR1_SIZE
80000020 g       .startup	00000000 BootModeIndex
80010160 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_11
7000002c g     O .data	00000004 __malloc_trim_threshold
800025a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_45
80010180 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_12
800001dc g     O .rodata	00000024 osEE_cdb_var_core0
80002a80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_84
800046da g     F .text	00000004 IfxVadc_getAdcModuleFrequency
80002620 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_49
80002a00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_80
80010fc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_126
80012800 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_64
8000b398 g     F .text	00000030 osEE_counter_cancel_trigger
80008514 g     F .text	00000186 Ifx_Fifo_write
800122a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_21
8000ef8e g     F .text	000000ca __mdiff
800100e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_7
8000af8a g     F .text	00000022 osEE_activate_isr2
800023c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_30
80011700 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_184
80013400 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_160
800079bc g     F .text	00000016 IfxVadc_Adc_initChannelConfig
80004b5c g     F .text	00000074 IfxAsclin_getFaFrequency
80010400 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_32
800068ea g     F .text	00000050 IfxScuCcu_setPll2Frequency
80011620 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_177
80013380 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_156
80012ee0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_119
80011300 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_152
80020000 g       .startup	00000000 BootModeHeader1
800091ba g     F .text	0000022e osEE_tc_set_pll_fsource
80004816 g     F .text	0000002a IfxVadc_initializeFAdcD
800040f8 g     F .text	00000072 UART_init
80011800 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_192
80005a32 g     F .text	000000a4 IfxPort_setGroupPadDriver
800112a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_149
0001c000 g       *ABS*	00000000 __DSPR0_SIZE
80013fe0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_255
80012820 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_65
80000f20 g     O .rodata	00000010 IfxScu_EVRWUPB_P15_1_IN
80013f80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_252
80012360 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_27
80012320 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_25
800120a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_5
800122c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_22
80000a98 g     O .rodata	00000010 IfxAsclin0_RXA_P14_1_IN
80012880 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_68
80004f1e g     F .text	00000012 IfxAsclin_write8
80006e24 g     F .text	0000000e IfxScuEru_getWholePatternDetectionResult
80011360 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_155
80013500 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_168
80001210 g     O .rodata	00000000 __copy_table
00019700 g       *ABS*	00000000 __ISTACK0_OFFSET
80003d20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_233
80004ef8 g     F .text	00000014 IfxAsclin_write16
80011dc0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_238
800109a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_77
80010080 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_4
80013aa0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_213
80010a40 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_82
800083ee g     F .text	00000036 Ifx_Fifo_clear
80003ee0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_247
80000dd4 g     O .rodata	00000014 IfxScu_REQ2_P10_2_IN
80003740 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_186
00000400 g       *ABS*	00000000 __ISTACK2_SIZE
80013c40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_226
800025c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_46
800102c0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_22
80003960 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_203
8000f6e4 g     F .text	00000010 _exit
80002aa0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_85
80011780 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_188
80001320 g       .traptab	00000000 osEE_tc_trap_protection
80001300 g     F .traptab	00000000 __TRAPTAB
80000e60 g     O .rodata	00000014 IfxScu_REQ11_P20_9_IN
80002500 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_40
80002a20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_81
00002000 g       *ABS*	00000000 __CSA2_SIZE
80006bd0 g     F .text	00000028 IfxScuEru_clearOutputChannelConfiguration
800020a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_5
80006cc6 g     F .text	00000026 IfxScuEru_disableTriggerPulse
80002c80 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_100
80011b00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_216
80007322 g     F .text	000000aa IfxScuWdt_initSafetyWatchdog
80004f40 g     F .text	00000006 IfxAsclin_Asc_getSendCount
80003060 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_131
8000c8ac g     F .text	00000014 strlen
80011900 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_200
0001b700 g       *ABS*	00000000 __ISTACK2_OFFSET
80013dc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_238
80013cc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_230
80004d02 g     F .text	00000022 IfxAsclin_setClockSource
80013560 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_171
80013080 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_132
8000f80c g     F .text	00000040 .hidden __gedf2
80010820 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_65
80000c88 g     O .rodata	00000008 IfxScuCcu_defaultErayPllConfig
800043de g     F .text	000000a2 initPeripheralsAndERU
80000998 g     O .rodata	00000010 IfxAsclin2_RXG_P02_0_IN
80003e00 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_240
80011c20 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_225
80010da0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_109
800005f8 g     O .rodata	00000010 IfxAsclin2_TX_P02_0_OUT
80011a80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_212
80013e20 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_241
80000d98 g     O .rodata	00000014 IfxScu_REQ5_P10_8_IN
80004a30 g     F .text	00000056 IfxVadc_setArbiterPriority
70000b70 g     O .inttab_cpu2	00000001 __HEAP_END
800121c0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_14
80000788 g     O .rodata	00000010 IfxAsclin1_SLSO_P33_10_OUT
800038c0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_198
80012bc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_94
80011740 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_186
80002f20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_121
6001bc00 g     O .CPU1.csa	00000000 __CSA1
80005f74 g     F .text	00000070 IfxScuCcu_getMaxFrequency
80009738 g     F .text	00000036 EnableAllInterrupts
80003420 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_161
800007a8 g     O .rodata	00000010 IfxAsclin1_SLSO_P14_3_OUT
800022e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_23
80010440 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_34
80002c20 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_97
80012dc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_110
80002640 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_50
80011e60 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_243
80013780 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_188
800128e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_71
80004a9a g     F .text	00000044 IfxVadc_startupCalibration
70000894 g     O .bss	00000004 g_vadc
80012120 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_9
80005ad6 g     F .text	00000056 IfxPort_setPinMode
800040b0 g     F .text	00000048 FuncTaskCPU2
80010e80 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_116
80000d70 g     O .rodata	00000014 IfxScu_REQ7_P00_4_IN
8000b972 g     F .text	0000001a osEE_hal_restore_ctx
800042e6 g     F .text	00000032 initVADCGroup
80011000 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_128
80011100 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_136
800007e8 g     O .rodata	00000010 IfxAsclin3_SCLK_P21_5_OUT
8000bcd8 g     F .text	00000040 .hidden __subdf3
80010020 g       .inttab_cpu1	00000000 osEE_tc_core1_isr2_entry_1
800030e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_135
70008000 g     O *ABS*	00000000 _SMALL_DATA_
80004f46 g     F .text	00000006 IfxAsclin_Asc_getTxTimeStamp
800048a6 g     F .text	0000006a IfxVadc_isPostCalibration
800042c8 g     F .text	0000001e initVADCModule
80006b92 g     F .text	00000016 IfxScuEru_clearEventFlag
800072f0 g     F .text	00000032 IfxScuWdt_setSafetyEndinit
8000ec86 g     F .text	00000066 __lo0bits
800109e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_79
80013a80 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_212
800139e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_207
80011f00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_248
80012400 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_32
80003940 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_202
80002000 g     F .inttab_cpu0	00002000 __INTTAB0
80002160 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_11
800129a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_77
800021a0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_13
80000588 g     O .rodata	00000010 IfxAsclin2_TX_P33_9_OUT
80003180 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_140
80011960 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_203
80005d16 g     F .text	00000030 IfxScuCcu_getOscFrequency
80009874 g     F .text	00000056 ResumeOSInterrupts
80011a00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_208
80010b00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_88
800105a0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_45
80012760 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_59
80011e00 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_240
800121a0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_13
80004cb6 g     F .text	0000004c IfxAsclin_resetModule
80003880 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_196
800108e0 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_71
80006dca g     F .text	00000024 IfxScuEru_getInputChannelConfiguration
800008a8 g     O .rodata	00000010 IfxAsclin2_SCLK_P02_4_OUT
80006b80 g     F .text	00000012 IfxScuEru_clearAllEventFlags
80013fc0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_254
80003ec0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_246
8000c152 g     F .text	00000112 .hidden __pack_d
80000b68 g     O .rodata	00000020 IfxAsclin_cfg_indexMap
80002660 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_51
80013960 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_203
8000a052 g     F .text	000000b2 SetAbsAlarm
80013720 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_185
800098ca g     F .text	00000258 StartOS
80000ed8 g     O .rodata	0000000c IfxScu_HWCFG1EVR33_P14_5_IN
80000dac g     O .rodata	00000014 IfxScu_REQ4_P10_7_IN
80011760 g       .inttab_cpu1	00000000 osEE_tc_core1_isr_dummy_entry_187
800029e0 g       .inttab_cpu0	00000000 osEE_tc_core0_isr_dummy_entry_79
8000c3e2 g     F .text	0000000e free
80000d08 g     O .rodata	00000010 IfxScu_WDTSLCK_P20_9_OUT
8000ebc2 g     F .text	00000082 __multadd
80013860 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_195
8000ebb0 g     F .text	00000012 _Bfree
800132e0 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_151
80012e40 g       .inttab_cpu2	00000000 osEE_tc_core2_isr_dummy_entry_114
800008c8 g     O .rodata	00000010 IfxAsclin1_SCLK_P33_11_OUT
80008000 g     O *ABS*	00000000 _SMALL_DATA3_



Disassembly of section .startup:

80000020 <_start>:
#endif

void _start(void)
{
  /* asm instruction to jump to the core startup */
  osEE_tc_jump_abs(osEE_tc_core0_start);
80000020:	9d 80 4d 43 	ja 8000869a <osEE_tc_core0_start>
80000024:	00 90       	ret 

Disassembly of section .traptab:

80001300 <__TRAPTAB>:
80001300:	00 a0       	debug 
80001302:	1d ff ff ff 	j 80001300 <__TRAPTAB>
	...

80001320 <osEE_tc_trap_protection>:
80001320:	00 a0       	debug 
80001322:	1d ff ff ff 	j 80001320 <osEE_tc_trap_protection>
	...

80001340 <osEE_tc_trap_instruction>:
80001340:	00 a0       	debug 
80001342:	1d ff ff ff 	j 80001340 <osEE_tc_trap_instruction>
	...

80001360 <osEE_tc_trap_context>:
80001360:	00 a0       	debug 
80001362:	1d ff ff ff 	j 80001360 <osEE_tc_trap_context>
	...

80001380 <osEE_tc_trap_bus>:
80001380:	00 a0       	debug 
80001382:	1d ff ff ff 	j 80001380 <osEE_tc_trap_bus>
	...

800013a0 <osEE_tc_trap_assertion>:
800013a0:	00 a0       	debug 
800013a2:	1d ff ff ff 	j 800013a0 <osEE_tc_trap_assertion>
	...

800013c0 <osEE_tc_trap_system>:
800013c0:	00 a0       	debug 
800013c2:	1d ff ff ff 	j 800013c0 <osEE_tc_trap_system>
	...

800013e0 <osEE_tc_trap_nmi>:
800013e0:	00 a0       	debug 
800013e2:	1d ff ff ff 	j 800013e0 <osEE_tc_trap_nmi>
	...

Disassembly of section .ctors:

80001400 <__CTOR_LIST__>:
	...

Disassembly of section .dtors:

80001408 <__DTOR_LIST__>:
	...

Disassembly of section .inttab_cpu0:

80002000 <__INTTAB0>:
	...

80002020 <osEE_tc_core0_isr2_entry_1>:
80002020:	0d 00 00 02 	svlcx 
80002024:	82 f4       	mov %d4,-1
80002026:	1d 00 08 3b 	j 80009636 <osEE_tc_isr2_wrapper>
	...

80002040 <osEE_tc_core0_isr2_entry_2>:
80002040:	0d 00 00 02 	svlcx 
80002044:	82 04       	mov %d4,0
80002046:	1d 00 f8 3a 	j 80009636 <osEE_tc_isr2_wrapper>
	...

80002060 <osEE_tc_core0_isr_dummy_entry_3>:
80002060:	3c 00       	j 80002060 <osEE_tc_core0_isr_dummy_entry_3>
	...

80002080 <osEE_tc_core0_isr_dummy_entry_4>:
80002080:	3c 00       	j 80002080 <osEE_tc_core0_isr_dummy_entry_4>
	...

800020a0 <osEE_tc_core0_isr_dummy_entry_5>:
800020a0:	3c 00       	j 800020a0 <osEE_tc_core0_isr_dummy_entry_5>
	...

800020c0 <osEE_tc_core0_isr_dummy_entry_6>:
800020c0:	3c 00       	j 800020c0 <osEE_tc_core0_isr_dummy_entry_6>
	...

800020e0 <osEE_tc_core0_isr_dummy_entry_7>:
800020e0:	3c 00       	j 800020e0 <osEE_tc_core0_isr_dummy_entry_7>
	...

80002100 <osEE_tc_core0_isr_dummy_entry_8>:
80002100:	3c 00       	j 80002100 <osEE_tc_core0_isr_dummy_entry_8>
	...

80002120 <osEE_tc_core0_isr_dummy_entry_9>:
80002120:	3c 00       	j 80002120 <osEE_tc_core0_isr_dummy_entry_9>
	...

80002140 <osEE_tc_core0_isr_dummy_entry_10>:
80002140:	3c 00       	j 80002140 <osEE_tc_core0_isr_dummy_entry_10>
	...

80002160 <osEE_tc_core0_isr_dummy_entry_11>:
80002160:	3c 00       	j 80002160 <osEE_tc_core0_isr_dummy_entry_11>
	...

80002180 <osEE_tc_core0_isr_dummy_entry_12>:
80002180:	3c 00       	j 80002180 <osEE_tc_core0_isr_dummy_entry_12>
	...

800021a0 <osEE_tc_core0_isr_dummy_entry_13>:
800021a0:	3c 00       	j 800021a0 <osEE_tc_core0_isr_dummy_entry_13>
	...

800021c0 <osEE_tc_core0_isr_dummy_entry_14>:
800021c0:	3c 00       	j 800021c0 <osEE_tc_core0_isr_dummy_entry_14>
	...

800021e0 <osEE_tc_core0_isr_dummy_entry_15>:
800021e0:	3c 00       	j 800021e0 <osEE_tc_core0_isr_dummy_entry_15>
	...

80002200 <osEE_tc_core0_isr_dummy_entry_16>:
80002200:	3c 00       	j 80002200 <osEE_tc_core0_isr_dummy_entry_16>
	...

80002220 <osEE_tc_core0_isr_dummy_entry_17>:
80002220:	3c 00       	j 80002220 <osEE_tc_core0_isr_dummy_entry_17>
	...

80002240 <osEE_tc_core0_isr_dummy_entry_18>:
80002240:	3c 00       	j 80002240 <osEE_tc_core0_isr_dummy_entry_18>
	...

80002260 <osEE_tc_core0_isr2_entry_19>:
80002260:	0d 00 00 02 	svlcx 
80002264:	82 14       	mov %d4,1
80002266:	1d 00 e8 39 	j 80009636 <osEE_tc_isr2_wrapper>
	...

80002280 <osEE_tc_core0_isr_dummy_entry_20>:
80002280:	3c 00       	j 80002280 <osEE_tc_core0_isr_dummy_entry_20>
	...

800022a0 <osEE_tc_core0_isr_dummy_entry_21>:
800022a0:	3c 00       	j 800022a0 <osEE_tc_core0_isr_dummy_entry_21>
	...

800022c0 <osEE_tc_core0_isr_dummy_entry_22>:
800022c0:	3c 00       	j 800022c0 <osEE_tc_core0_isr_dummy_entry_22>
	...

800022e0 <osEE_tc_core0_isr_dummy_entry_23>:
800022e0:	3c 00       	j 800022e0 <osEE_tc_core0_isr_dummy_entry_23>
	...

80002300 <osEE_tc_core0_isr_dummy_entry_24>:
80002300:	3c 00       	j 80002300 <osEE_tc_core0_isr_dummy_entry_24>
	...

80002320 <osEE_tc_core0_isr_dummy_entry_25>:
80002320:	3c 00       	j 80002320 <osEE_tc_core0_isr_dummy_entry_25>
	...

80002340 <osEE_tc_core0_isr_dummy_entry_26>:
80002340:	3c 00       	j 80002340 <osEE_tc_core0_isr_dummy_entry_26>
	...

80002360 <osEE_tc_core0_isr_dummy_entry_27>:
80002360:	3c 00       	j 80002360 <osEE_tc_core0_isr_dummy_entry_27>
	...

80002380 <osEE_tc_core0_isr_dummy_entry_28>:
80002380:	3c 00       	j 80002380 <osEE_tc_core0_isr_dummy_entry_28>
	...

800023a0 <osEE_tc_core0_isr_dummy_entry_29>:
800023a0:	3c 00       	j 800023a0 <osEE_tc_core0_isr_dummy_entry_29>
	...

800023c0 <osEE_tc_core0_isr_dummy_entry_30>:
800023c0:	3c 00       	j 800023c0 <osEE_tc_core0_isr_dummy_entry_30>
	...

800023e0 <osEE_tc_core0_isr_dummy_entry_31>:
800023e0:	3c 00       	j 800023e0 <osEE_tc_core0_isr_dummy_entry_31>
	...

80002400 <osEE_tc_core0_isr_dummy_entry_32>:
80002400:	3c 00       	j 80002400 <osEE_tc_core0_isr_dummy_entry_32>
	...

80002420 <osEE_tc_core0_isr_dummy_entry_33>:
80002420:	3c 00       	j 80002420 <osEE_tc_core0_isr_dummy_entry_33>
	...

80002440 <osEE_tc_core0_isr_dummy_entry_34>:
80002440:	3c 00       	j 80002440 <osEE_tc_core0_isr_dummy_entry_34>
	...

80002460 <osEE_tc_core0_isr_dummy_entry_35>:
80002460:	3c 00       	j 80002460 <osEE_tc_core0_isr_dummy_entry_35>
	...

80002480 <osEE_tc_core0_isr_dummy_entry_36>:
80002480:	3c 00       	j 80002480 <osEE_tc_core0_isr_dummy_entry_36>
	...

800024a0 <osEE_tc_core0_isr_dummy_entry_37>:
800024a0:	3c 00       	j 800024a0 <osEE_tc_core0_isr_dummy_entry_37>
	...

800024c0 <osEE_tc_core0_isr_dummy_entry_38>:
800024c0:	3c 00       	j 800024c0 <osEE_tc_core0_isr_dummy_entry_38>
	...

800024e0 <osEE_tc_core0_isr_dummy_entry_39>:
800024e0:	3c 00       	j 800024e0 <osEE_tc_core0_isr_dummy_entry_39>
	...

80002500 <osEE_tc_core0_isr_dummy_entry_40>:
80002500:	3c 00       	j 80002500 <osEE_tc_core0_isr_dummy_entry_40>
	...

80002520 <osEE_tc_core0_isr_dummy_entry_41>:
80002520:	3c 00       	j 80002520 <osEE_tc_core0_isr_dummy_entry_41>
	...

80002540 <osEE_tc_core0_isr_dummy_entry_42>:
80002540:	3c 00       	j 80002540 <osEE_tc_core0_isr_dummy_entry_42>
	...

80002560 <osEE_tc_core0_isr_dummy_entry_43>:
80002560:	3c 00       	j 80002560 <osEE_tc_core0_isr_dummy_entry_43>
	...

80002580 <osEE_tc_core0_isr_dummy_entry_44>:
80002580:	3c 00       	j 80002580 <osEE_tc_core0_isr_dummy_entry_44>
	...

800025a0 <osEE_tc_core0_isr_dummy_entry_45>:
800025a0:	3c 00       	j 800025a0 <osEE_tc_core0_isr_dummy_entry_45>
	...

800025c0 <osEE_tc_core0_isr_dummy_entry_46>:
800025c0:	3c 00       	j 800025c0 <osEE_tc_core0_isr_dummy_entry_46>
	...

800025e0 <osEE_tc_core0_isr_dummy_entry_47>:
800025e0:	3c 00       	j 800025e0 <osEE_tc_core0_isr_dummy_entry_47>
	...

80002600 <osEE_tc_core0_isr_dummy_entry_48>:
80002600:	3c 00       	j 80002600 <osEE_tc_core0_isr_dummy_entry_48>
	...

80002620 <osEE_tc_core0_isr_dummy_entry_49>:
80002620:	3c 00       	j 80002620 <osEE_tc_core0_isr_dummy_entry_49>
	...

80002640 <osEE_tc_core0_isr_dummy_entry_50>:
80002640:	3c 00       	j 80002640 <osEE_tc_core0_isr_dummy_entry_50>
	...

80002660 <osEE_tc_core0_isr_dummy_entry_51>:
80002660:	3c 00       	j 80002660 <osEE_tc_core0_isr_dummy_entry_51>
	...

80002680 <osEE_tc_core0_isr_dummy_entry_52>:
80002680:	3c 00       	j 80002680 <osEE_tc_core0_isr_dummy_entry_52>
	...

800026a0 <osEE_tc_core0_isr_dummy_entry_53>:
800026a0:	3c 00       	j 800026a0 <osEE_tc_core0_isr_dummy_entry_53>
	...

800026c0 <osEE_tc_core0_isr_dummy_entry_54>:
800026c0:	3c 00       	j 800026c0 <osEE_tc_core0_isr_dummy_entry_54>
	...

800026e0 <osEE_tc_core0_isr_dummy_entry_55>:
800026e0:	3c 00       	j 800026e0 <osEE_tc_core0_isr_dummy_entry_55>
	...

80002700 <osEE_tc_core0_isr_dummy_entry_56>:
80002700:	3c 00       	j 80002700 <osEE_tc_core0_isr_dummy_entry_56>
	...

80002720 <osEE_tc_core0_isr_dummy_entry_57>:
80002720:	3c 00       	j 80002720 <osEE_tc_core0_isr_dummy_entry_57>
	...

80002740 <osEE_tc_core0_isr_dummy_entry_58>:
80002740:	3c 00       	j 80002740 <osEE_tc_core0_isr_dummy_entry_58>
	...

80002760 <osEE_tc_core0_isr_dummy_entry_59>:
80002760:	3c 00       	j 80002760 <osEE_tc_core0_isr_dummy_entry_59>
	...

80002780 <osEE_tc_core0_isr_dummy_entry_60>:
80002780:	3c 00       	j 80002780 <osEE_tc_core0_isr_dummy_entry_60>
	...

800027a0 <osEE_tc_core0_isr_dummy_entry_61>:
800027a0:	3c 00       	j 800027a0 <osEE_tc_core0_isr_dummy_entry_61>
	...

800027c0 <osEE_tc_core0_isr_dummy_entry_62>:
800027c0:	3c 00       	j 800027c0 <osEE_tc_core0_isr_dummy_entry_62>
	...

800027e0 <osEE_tc_core0_isr_dummy_entry_63>:
800027e0:	3c 00       	j 800027e0 <osEE_tc_core0_isr_dummy_entry_63>
	...

80002800 <osEE_tc_core0_isr_dummy_entry_64>:
80002800:	3c 00       	j 80002800 <osEE_tc_core0_isr_dummy_entry_64>
	...

80002820 <osEE_tc_core0_isr_dummy_entry_65>:
80002820:	3c 00       	j 80002820 <osEE_tc_core0_isr_dummy_entry_65>
	...

80002840 <osEE_tc_core0_isr_dummy_entry_66>:
80002840:	3c 00       	j 80002840 <osEE_tc_core0_isr_dummy_entry_66>
	...

80002860 <osEE_tc_core0_isr_dummy_entry_67>:
80002860:	3c 00       	j 80002860 <osEE_tc_core0_isr_dummy_entry_67>
	...

80002880 <osEE_tc_core0_isr_dummy_entry_68>:
80002880:	3c 00       	j 80002880 <osEE_tc_core0_isr_dummy_entry_68>
	...

800028a0 <osEE_tc_core0_isr_dummy_entry_69>:
800028a0:	3c 00       	j 800028a0 <osEE_tc_core0_isr_dummy_entry_69>
	...

800028c0 <osEE_tc_core0_isr_dummy_entry_70>:
800028c0:	3c 00       	j 800028c0 <osEE_tc_core0_isr_dummy_entry_70>
	...

800028e0 <osEE_tc_core0_isr_dummy_entry_71>:
800028e0:	3c 00       	j 800028e0 <osEE_tc_core0_isr_dummy_entry_71>
	...

80002900 <osEE_tc_core0_isr_dummy_entry_72>:
80002900:	3c 00       	j 80002900 <osEE_tc_core0_isr_dummy_entry_72>
	...

80002920 <osEE_tc_core0_isr_dummy_entry_73>:
80002920:	3c 00       	j 80002920 <osEE_tc_core0_isr_dummy_entry_73>
	...

80002940 <osEE_tc_core0_isr_dummy_entry_74>:
80002940:	3c 00       	j 80002940 <osEE_tc_core0_isr_dummy_entry_74>
	...

80002960 <osEE_tc_core0_isr_dummy_entry_75>:
80002960:	3c 00       	j 80002960 <osEE_tc_core0_isr_dummy_entry_75>
	...

80002980 <osEE_tc_core0_isr_dummy_entry_76>:
80002980:	3c 00       	j 80002980 <osEE_tc_core0_isr_dummy_entry_76>
	...

800029a0 <osEE_tc_core0_isr_dummy_entry_77>:
800029a0:	3c 00       	j 800029a0 <osEE_tc_core0_isr_dummy_entry_77>
	...

800029c0 <osEE_tc_core0_isr_dummy_entry_78>:
800029c0:	3c 00       	j 800029c0 <osEE_tc_core0_isr_dummy_entry_78>
	...

800029e0 <osEE_tc_core0_isr_dummy_entry_79>:
800029e0:	3c 00       	j 800029e0 <osEE_tc_core0_isr_dummy_entry_79>
	...

80002a00 <osEE_tc_core0_isr_dummy_entry_80>:
80002a00:	3c 00       	j 80002a00 <osEE_tc_core0_isr_dummy_entry_80>
	...

80002a20 <osEE_tc_core0_isr_dummy_entry_81>:
80002a20:	3c 00       	j 80002a20 <osEE_tc_core0_isr_dummy_entry_81>
	...

80002a40 <osEE_tc_core0_isr_dummy_entry_82>:
80002a40:	3c 00       	j 80002a40 <osEE_tc_core0_isr_dummy_entry_82>
	...

80002a60 <osEE_tc_core0_isr_dummy_entry_83>:
80002a60:	3c 00       	j 80002a60 <osEE_tc_core0_isr_dummy_entry_83>
	...

80002a80 <osEE_tc_core0_isr_dummy_entry_84>:
80002a80:	3c 00       	j 80002a80 <osEE_tc_core0_isr_dummy_entry_84>
	...

80002aa0 <osEE_tc_core0_isr_dummy_entry_85>:
80002aa0:	3c 00       	j 80002aa0 <osEE_tc_core0_isr_dummy_entry_85>
	...

80002ac0 <osEE_tc_core0_isr_dummy_entry_86>:
80002ac0:	3c 00       	j 80002ac0 <osEE_tc_core0_isr_dummy_entry_86>
	...

80002ae0 <osEE_tc_core0_isr_dummy_entry_87>:
80002ae0:	3c 00       	j 80002ae0 <osEE_tc_core0_isr_dummy_entry_87>
	...

80002b00 <osEE_tc_core0_isr_dummy_entry_88>:
80002b00:	3c 00       	j 80002b00 <osEE_tc_core0_isr_dummy_entry_88>
	...

80002b20 <osEE_tc_core0_isr_dummy_entry_89>:
80002b20:	3c 00       	j 80002b20 <osEE_tc_core0_isr_dummy_entry_89>
	...

80002b40 <osEE_tc_core0_isr_dummy_entry_90>:
80002b40:	3c 00       	j 80002b40 <osEE_tc_core0_isr_dummy_entry_90>
	...

80002b60 <osEE_tc_core0_isr_dummy_entry_91>:
80002b60:	3c 00       	j 80002b60 <osEE_tc_core0_isr_dummy_entry_91>
	...

80002b80 <osEE_tc_core0_isr_dummy_entry_92>:
80002b80:	3c 00       	j 80002b80 <osEE_tc_core0_isr_dummy_entry_92>
	...

80002ba0 <osEE_tc_core0_isr_dummy_entry_93>:
80002ba0:	3c 00       	j 80002ba0 <osEE_tc_core0_isr_dummy_entry_93>
	...

80002bc0 <osEE_tc_core0_isr_dummy_entry_94>:
80002bc0:	3c 00       	j 80002bc0 <osEE_tc_core0_isr_dummy_entry_94>
	...

80002be0 <osEE_tc_core0_isr_dummy_entry_95>:
80002be0:	3c 00       	j 80002be0 <osEE_tc_core0_isr_dummy_entry_95>
	...

80002c00 <osEE_tc_core0_isr_dummy_entry_96>:
80002c00:	3c 00       	j 80002c00 <osEE_tc_core0_isr_dummy_entry_96>
	...

80002c20 <osEE_tc_core0_isr_dummy_entry_97>:
80002c20:	3c 00       	j 80002c20 <osEE_tc_core0_isr_dummy_entry_97>
	...

80002c40 <osEE_tc_core0_isr_dummy_entry_98>:
80002c40:	3c 00       	j 80002c40 <osEE_tc_core0_isr_dummy_entry_98>
	...

80002c60 <osEE_tc_core0_isr_dummy_entry_99>:
80002c60:	3c 00       	j 80002c60 <osEE_tc_core0_isr_dummy_entry_99>
	...

80002c80 <osEE_tc_core0_isr_dummy_entry_100>:
80002c80:	3c 00       	j 80002c80 <osEE_tc_core0_isr_dummy_entry_100>
	...

80002ca0 <osEE_tc_core0_isr_dummy_entry_101>:
80002ca0:	3c 00       	j 80002ca0 <osEE_tc_core0_isr_dummy_entry_101>
	...

80002cc0 <osEE_tc_core0_isr_dummy_entry_102>:
80002cc0:	3c 00       	j 80002cc0 <osEE_tc_core0_isr_dummy_entry_102>
	...

80002ce0 <osEE_tc_core0_isr_dummy_entry_103>:
80002ce0:	3c 00       	j 80002ce0 <osEE_tc_core0_isr_dummy_entry_103>
	...

80002d00 <osEE_tc_core0_isr_dummy_entry_104>:
80002d00:	3c 00       	j 80002d00 <osEE_tc_core0_isr_dummy_entry_104>
	...

80002d20 <osEE_tc_core0_isr_dummy_entry_105>:
80002d20:	3c 00       	j 80002d20 <osEE_tc_core0_isr_dummy_entry_105>
	...

80002d40 <osEE_tc_core0_isr_dummy_entry_106>:
80002d40:	3c 00       	j 80002d40 <osEE_tc_core0_isr_dummy_entry_106>
	...

80002d60 <osEE_tc_core0_isr_dummy_entry_107>:
80002d60:	3c 00       	j 80002d60 <osEE_tc_core0_isr_dummy_entry_107>
	...

80002d80 <osEE_tc_core0_isr_dummy_entry_108>:
80002d80:	3c 00       	j 80002d80 <osEE_tc_core0_isr_dummy_entry_108>
	...

80002da0 <osEE_tc_core0_isr_dummy_entry_109>:
80002da0:	3c 00       	j 80002da0 <osEE_tc_core0_isr_dummy_entry_109>
	...

80002dc0 <osEE_tc_core0_isr_dummy_entry_110>:
80002dc0:	3c 00       	j 80002dc0 <osEE_tc_core0_isr_dummy_entry_110>
	...

80002de0 <osEE_tc_core0_isr_dummy_entry_111>:
80002de0:	3c 00       	j 80002de0 <osEE_tc_core0_isr_dummy_entry_111>
	...

80002e00 <osEE_tc_core0_isr_dummy_entry_112>:
80002e00:	3c 00       	j 80002e00 <osEE_tc_core0_isr_dummy_entry_112>
	...

80002e20 <osEE_tc_core0_isr_dummy_entry_113>:
80002e20:	3c 00       	j 80002e20 <osEE_tc_core0_isr_dummy_entry_113>
	...

80002e40 <osEE_tc_core0_isr_dummy_entry_114>:
80002e40:	3c 00       	j 80002e40 <osEE_tc_core0_isr_dummy_entry_114>
	...

80002e60 <osEE_tc_core0_isr_dummy_entry_115>:
80002e60:	3c 00       	j 80002e60 <osEE_tc_core0_isr_dummy_entry_115>
	...

80002e80 <osEE_tc_core0_isr_dummy_entry_116>:
80002e80:	3c 00       	j 80002e80 <osEE_tc_core0_isr_dummy_entry_116>
	...

80002ea0 <osEE_tc_core0_isr_dummy_entry_117>:
80002ea0:	3c 00       	j 80002ea0 <osEE_tc_core0_isr_dummy_entry_117>
	...

80002ec0 <osEE_tc_core0_isr_dummy_entry_118>:
80002ec0:	3c 00       	j 80002ec0 <osEE_tc_core0_isr_dummy_entry_118>
	...

80002ee0 <osEE_tc_core0_isr_dummy_entry_119>:
80002ee0:	3c 00       	j 80002ee0 <osEE_tc_core0_isr_dummy_entry_119>
	...

80002f00 <osEE_tc_core0_isr_dummy_entry_120>:
80002f00:	3c 00       	j 80002f00 <osEE_tc_core0_isr_dummy_entry_120>
	...

80002f20 <osEE_tc_core0_isr_dummy_entry_121>:
80002f20:	3c 00       	j 80002f20 <osEE_tc_core0_isr_dummy_entry_121>
	...

80002f40 <osEE_tc_core0_isr_dummy_entry_122>:
80002f40:	3c 00       	j 80002f40 <osEE_tc_core0_isr_dummy_entry_122>
	...

80002f60 <osEE_tc_core0_isr_dummy_entry_123>:
80002f60:	3c 00       	j 80002f60 <osEE_tc_core0_isr_dummy_entry_123>
	...

80002f80 <osEE_tc_core0_isr_dummy_entry_124>:
80002f80:	3c 00       	j 80002f80 <osEE_tc_core0_isr_dummy_entry_124>
	...

80002fa0 <osEE_tc_core0_isr_dummy_entry_125>:
80002fa0:	3c 00       	j 80002fa0 <osEE_tc_core0_isr_dummy_entry_125>
	...

80002fc0 <osEE_tc_core0_isr_dummy_entry_126>:
80002fc0:	3c 00       	j 80002fc0 <osEE_tc_core0_isr_dummy_entry_126>
	...

80002fe0 <osEE_tc_core0_isr_dummy_entry_127>:
80002fe0:	3c 00       	j 80002fe0 <osEE_tc_core0_isr_dummy_entry_127>
	...

80003000 <osEE_tc_core0_isr_dummy_entry_128>:
80003000:	3c 00       	j 80003000 <osEE_tc_core0_isr_dummy_entry_128>
	...

80003020 <osEE_tc_core0_isr_dummy_entry_129>:
80003020:	3c 00       	j 80003020 <osEE_tc_core0_isr_dummy_entry_129>
	...

80003040 <osEE_tc_core0_isr_dummy_entry_130>:
80003040:	3c 00       	j 80003040 <osEE_tc_core0_isr_dummy_entry_130>
	...

80003060 <osEE_tc_core0_isr_dummy_entry_131>:
80003060:	3c 00       	j 80003060 <osEE_tc_core0_isr_dummy_entry_131>
	...

80003080 <osEE_tc_core0_isr_dummy_entry_132>:
80003080:	3c 00       	j 80003080 <osEE_tc_core0_isr_dummy_entry_132>
	...

800030a0 <osEE_tc_core0_isr_dummy_entry_133>:
800030a0:	3c 00       	j 800030a0 <osEE_tc_core0_isr_dummy_entry_133>
	...

800030c0 <osEE_tc_core0_isr_dummy_entry_134>:
800030c0:	3c 00       	j 800030c0 <osEE_tc_core0_isr_dummy_entry_134>
	...

800030e0 <osEE_tc_core0_isr_dummy_entry_135>:
800030e0:	3c 00       	j 800030e0 <osEE_tc_core0_isr_dummy_entry_135>
	...

80003100 <osEE_tc_core0_isr_dummy_entry_136>:
80003100:	3c 00       	j 80003100 <osEE_tc_core0_isr_dummy_entry_136>
	...

80003120 <osEE_tc_core0_isr_dummy_entry_137>:
80003120:	3c 00       	j 80003120 <osEE_tc_core0_isr_dummy_entry_137>
	...

80003140 <osEE_tc_core0_isr_dummy_entry_138>:
80003140:	3c 00       	j 80003140 <osEE_tc_core0_isr_dummy_entry_138>
	...

80003160 <osEE_tc_core0_isr_dummy_entry_139>:
80003160:	3c 00       	j 80003160 <osEE_tc_core0_isr_dummy_entry_139>
	...

80003180 <osEE_tc_core0_isr_dummy_entry_140>:
80003180:	3c 00       	j 80003180 <osEE_tc_core0_isr_dummy_entry_140>
	...

800031a0 <osEE_tc_core0_isr_dummy_entry_141>:
800031a0:	3c 00       	j 800031a0 <osEE_tc_core0_isr_dummy_entry_141>
	...

800031c0 <osEE_tc_core0_isr_dummy_entry_142>:
800031c0:	3c 00       	j 800031c0 <osEE_tc_core0_isr_dummy_entry_142>
	...

800031e0 <osEE_tc_core0_isr_dummy_entry_143>:
800031e0:	3c 00       	j 800031e0 <osEE_tc_core0_isr_dummy_entry_143>
	...

80003200 <osEE_tc_core0_isr_dummy_entry_144>:
80003200:	3c 00       	j 80003200 <osEE_tc_core0_isr_dummy_entry_144>
	...

80003220 <osEE_tc_core0_isr_dummy_entry_145>:
80003220:	3c 00       	j 80003220 <osEE_tc_core0_isr_dummy_entry_145>
	...

80003240 <osEE_tc_core0_isr_dummy_entry_146>:
80003240:	3c 00       	j 80003240 <osEE_tc_core0_isr_dummy_entry_146>
	...

80003260 <osEE_tc_core0_isr_dummy_entry_147>:
80003260:	3c 00       	j 80003260 <osEE_tc_core0_isr_dummy_entry_147>
	...

80003280 <osEE_tc_core0_isr_dummy_entry_148>:
80003280:	3c 00       	j 80003280 <osEE_tc_core0_isr_dummy_entry_148>
	...

800032a0 <osEE_tc_core0_isr_dummy_entry_149>:
800032a0:	3c 00       	j 800032a0 <osEE_tc_core0_isr_dummy_entry_149>
	...

800032c0 <osEE_tc_core0_isr_dummy_entry_150>:
800032c0:	3c 00       	j 800032c0 <osEE_tc_core0_isr_dummy_entry_150>
	...

800032e0 <osEE_tc_core0_isr_dummy_entry_151>:
800032e0:	3c 00       	j 800032e0 <osEE_tc_core0_isr_dummy_entry_151>
	...

80003300 <osEE_tc_core0_isr_dummy_entry_152>:
80003300:	3c 00       	j 80003300 <osEE_tc_core0_isr_dummy_entry_152>
	...

80003320 <osEE_tc_core0_isr_dummy_entry_153>:
80003320:	3c 00       	j 80003320 <osEE_tc_core0_isr_dummy_entry_153>
	...

80003340 <osEE_tc_core0_isr_dummy_entry_154>:
80003340:	3c 00       	j 80003340 <osEE_tc_core0_isr_dummy_entry_154>
	...

80003360 <osEE_tc_core0_isr_dummy_entry_155>:
80003360:	3c 00       	j 80003360 <osEE_tc_core0_isr_dummy_entry_155>
	...

80003380 <osEE_tc_core0_isr_dummy_entry_156>:
80003380:	3c 00       	j 80003380 <osEE_tc_core0_isr_dummy_entry_156>
	...

800033a0 <osEE_tc_core0_isr_dummy_entry_157>:
800033a0:	3c 00       	j 800033a0 <osEE_tc_core0_isr_dummy_entry_157>
	...

800033c0 <osEE_tc_core0_isr_dummy_entry_158>:
800033c0:	3c 00       	j 800033c0 <osEE_tc_core0_isr_dummy_entry_158>
	...

800033e0 <osEE_tc_core0_isr_dummy_entry_159>:
800033e0:	3c 00       	j 800033e0 <osEE_tc_core0_isr_dummy_entry_159>
	...

80003400 <osEE_tc_core0_isr_dummy_entry_160>:
80003400:	3c 00       	j 80003400 <osEE_tc_core0_isr_dummy_entry_160>
	...

80003420 <osEE_tc_core0_isr_dummy_entry_161>:
80003420:	3c 00       	j 80003420 <osEE_tc_core0_isr_dummy_entry_161>
	...

80003440 <osEE_tc_core0_isr_dummy_entry_162>:
80003440:	3c 00       	j 80003440 <osEE_tc_core0_isr_dummy_entry_162>
	...

80003460 <osEE_tc_core0_isr_dummy_entry_163>:
80003460:	3c 00       	j 80003460 <osEE_tc_core0_isr_dummy_entry_163>
	...

80003480 <osEE_tc_core0_isr_dummy_entry_164>:
80003480:	3c 00       	j 80003480 <osEE_tc_core0_isr_dummy_entry_164>
	...

800034a0 <osEE_tc_core0_isr_dummy_entry_165>:
800034a0:	3c 00       	j 800034a0 <osEE_tc_core0_isr_dummy_entry_165>
	...

800034c0 <osEE_tc_core0_isr_dummy_entry_166>:
800034c0:	3c 00       	j 800034c0 <osEE_tc_core0_isr_dummy_entry_166>
	...

800034e0 <osEE_tc_core0_isr_dummy_entry_167>:
800034e0:	3c 00       	j 800034e0 <osEE_tc_core0_isr_dummy_entry_167>
	...

80003500 <osEE_tc_core0_isr_dummy_entry_168>:
80003500:	3c 00       	j 80003500 <osEE_tc_core0_isr_dummy_entry_168>
	...

80003520 <osEE_tc_core0_isr_dummy_entry_169>:
80003520:	3c 00       	j 80003520 <osEE_tc_core0_isr_dummy_entry_169>
	...

80003540 <osEE_tc_core0_isr_dummy_entry_170>:
80003540:	3c 00       	j 80003540 <osEE_tc_core0_isr_dummy_entry_170>
	...

80003560 <osEE_tc_core0_isr_dummy_entry_171>:
80003560:	3c 00       	j 80003560 <osEE_tc_core0_isr_dummy_entry_171>
	...

80003580 <osEE_tc_core0_isr_dummy_entry_172>:
80003580:	3c 00       	j 80003580 <osEE_tc_core0_isr_dummy_entry_172>
	...

800035a0 <osEE_tc_core0_isr_dummy_entry_173>:
800035a0:	3c 00       	j 800035a0 <osEE_tc_core0_isr_dummy_entry_173>
	...

800035c0 <osEE_tc_core0_isr_dummy_entry_174>:
800035c0:	3c 00       	j 800035c0 <osEE_tc_core0_isr_dummy_entry_174>
	...

800035e0 <osEE_tc_core0_isr_dummy_entry_175>:
800035e0:	3c 00       	j 800035e0 <osEE_tc_core0_isr_dummy_entry_175>
	...

80003600 <osEE_tc_core0_isr_dummy_entry_176>:
80003600:	3c 00       	j 80003600 <osEE_tc_core0_isr_dummy_entry_176>
	...

80003620 <osEE_tc_core0_isr_dummy_entry_177>:
80003620:	3c 00       	j 80003620 <osEE_tc_core0_isr_dummy_entry_177>
	...

80003640 <osEE_tc_core0_isr_dummy_entry_178>:
80003640:	3c 00       	j 80003640 <osEE_tc_core0_isr_dummy_entry_178>
	...

80003660 <osEE_tc_core0_isr_dummy_entry_179>:
80003660:	3c 00       	j 80003660 <osEE_tc_core0_isr_dummy_entry_179>
	...

80003680 <osEE_tc_core0_isr_dummy_entry_180>:
80003680:	3c 00       	j 80003680 <osEE_tc_core0_isr_dummy_entry_180>
	...

800036a0 <osEE_tc_core0_isr_dummy_entry_181>:
800036a0:	3c 00       	j 800036a0 <osEE_tc_core0_isr_dummy_entry_181>
	...

800036c0 <osEE_tc_core0_isr_dummy_entry_182>:
800036c0:	3c 00       	j 800036c0 <osEE_tc_core0_isr_dummy_entry_182>
	...

800036e0 <osEE_tc_core0_isr_dummy_entry_183>:
800036e0:	3c 00       	j 800036e0 <osEE_tc_core0_isr_dummy_entry_183>
	...

80003700 <osEE_tc_core0_isr_dummy_entry_184>:
80003700:	3c 00       	j 80003700 <osEE_tc_core0_isr_dummy_entry_184>
	...

80003720 <osEE_tc_core0_isr_dummy_entry_185>:
80003720:	3c 00       	j 80003720 <osEE_tc_core0_isr_dummy_entry_185>
	...

80003740 <osEE_tc_core0_isr_dummy_entry_186>:
80003740:	3c 00       	j 80003740 <osEE_tc_core0_isr_dummy_entry_186>
	...

80003760 <osEE_tc_core0_isr_dummy_entry_187>:
80003760:	3c 00       	j 80003760 <osEE_tc_core0_isr_dummy_entry_187>
	...

80003780 <osEE_tc_core0_isr_dummy_entry_188>:
80003780:	3c 00       	j 80003780 <osEE_tc_core0_isr_dummy_entry_188>
	...

800037a0 <osEE_tc_core0_isr_dummy_entry_189>:
800037a0:	3c 00       	j 800037a0 <osEE_tc_core0_isr_dummy_entry_189>
	...

800037c0 <osEE_tc_core0_isr_dummy_entry_190>:
800037c0:	3c 00       	j 800037c0 <osEE_tc_core0_isr_dummy_entry_190>
	...

800037e0 <osEE_tc_core0_isr_dummy_entry_191>:
800037e0:	3c 00       	j 800037e0 <osEE_tc_core0_isr_dummy_entry_191>
	...

80003800 <osEE_tc_core0_isr_dummy_entry_192>:
80003800:	3c 00       	j 80003800 <osEE_tc_core0_isr_dummy_entry_192>
	...

80003820 <osEE_tc_core0_isr_dummy_entry_193>:
80003820:	3c 00       	j 80003820 <osEE_tc_core0_isr_dummy_entry_193>
	...

80003840 <osEE_tc_core0_isr_dummy_entry_194>:
80003840:	3c 00       	j 80003840 <osEE_tc_core0_isr_dummy_entry_194>
	...

80003860 <osEE_tc_core0_isr_dummy_entry_195>:
80003860:	3c 00       	j 80003860 <osEE_tc_core0_isr_dummy_entry_195>
	...

80003880 <osEE_tc_core0_isr_dummy_entry_196>:
80003880:	3c 00       	j 80003880 <osEE_tc_core0_isr_dummy_entry_196>
	...

800038a0 <osEE_tc_core0_isr_dummy_entry_197>:
800038a0:	3c 00       	j 800038a0 <osEE_tc_core0_isr_dummy_entry_197>
	...

800038c0 <osEE_tc_core0_isr_dummy_entry_198>:
800038c0:	3c 00       	j 800038c0 <osEE_tc_core0_isr_dummy_entry_198>
	...

800038e0 <osEE_tc_core0_isr_dummy_entry_199>:
800038e0:	3c 00       	j 800038e0 <osEE_tc_core0_isr_dummy_entry_199>
	...

80003900 <osEE_tc_core0_isr_dummy_entry_200>:
80003900:	3c 00       	j 80003900 <osEE_tc_core0_isr_dummy_entry_200>
	...

80003920 <osEE_tc_core0_isr_dummy_entry_201>:
80003920:	3c 00       	j 80003920 <osEE_tc_core0_isr_dummy_entry_201>
	...

80003940 <osEE_tc_core0_isr_dummy_entry_202>:
80003940:	3c 00       	j 80003940 <osEE_tc_core0_isr_dummy_entry_202>
	...

80003960 <osEE_tc_core0_isr_dummy_entry_203>:
80003960:	3c 00       	j 80003960 <osEE_tc_core0_isr_dummy_entry_203>
	...

80003980 <osEE_tc_core0_isr_dummy_entry_204>:
80003980:	3c 00       	j 80003980 <osEE_tc_core0_isr_dummy_entry_204>
	...

800039a0 <osEE_tc_core0_isr_dummy_entry_205>:
800039a0:	3c 00       	j 800039a0 <osEE_tc_core0_isr_dummy_entry_205>
	...

800039c0 <osEE_tc_core0_isr_dummy_entry_206>:
800039c0:	3c 00       	j 800039c0 <osEE_tc_core0_isr_dummy_entry_206>
	...

800039e0 <osEE_tc_core0_isr_dummy_entry_207>:
800039e0:	3c 00       	j 800039e0 <osEE_tc_core0_isr_dummy_entry_207>
	...

80003a00 <osEE_tc_core0_isr_dummy_entry_208>:
80003a00:	3c 00       	j 80003a00 <osEE_tc_core0_isr_dummy_entry_208>
	...

80003a20 <osEE_tc_core0_isr_dummy_entry_209>:
80003a20:	3c 00       	j 80003a20 <osEE_tc_core0_isr_dummy_entry_209>
	...

80003a40 <osEE_tc_core0_isr_dummy_entry_210>:
80003a40:	3c 00       	j 80003a40 <osEE_tc_core0_isr_dummy_entry_210>
	...

80003a60 <osEE_tc_core0_isr_dummy_entry_211>:
80003a60:	3c 00       	j 80003a60 <osEE_tc_core0_isr_dummy_entry_211>
	...

80003a80 <osEE_tc_core0_isr_dummy_entry_212>:
80003a80:	3c 00       	j 80003a80 <osEE_tc_core0_isr_dummy_entry_212>
	...

80003aa0 <osEE_tc_core0_isr_dummy_entry_213>:
80003aa0:	3c 00       	j 80003aa0 <osEE_tc_core0_isr_dummy_entry_213>
	...

80003ac0 <osEE_tc_core0_isr_dummy_entry_214>:
80003ac0:	3c 00       	j 80003ac0 <osEE_tc_core0_isr_dummy_entry_214>
	...

80003ae0 <osEE_tc_core0_isr_dummy_entry_215>:
80003ae0:	3c 00       	j 80003ae0 <osEE_tc_core0_isr_dummy_entry_215>
	...

80003b00 <osEE_tc_core0_isr_dummy_entry_216>:
80003b00:	3c 00       	j 80003b00 <osEE_tc_core0_isr_dummy_entry_216>
	...

80003b20 <osEE_tc_core0_isr_dummy_entry_217>:
80003b20:	3c 00       	j 80003b20 <osEE_tc_core0_isr_dummy_entry_217>
	...

80003b40 <osEE_tc_core0_isr_dummy_entry_218>:
80003b40:	3c 00       	j 80003b40 <osEE_tc_core0_isr_dummy_entry_218>
	...

80003b60 <osEE_tc_core0_isr_dummy_entry_219>:
80003b60:	3c 00       	j 80003b60 <osEE_tc_core0_isr_dummy_entry_219>
	...

80003b80 <osEE_tc_core0_isr_dummy_entry_220>:
80003b80:	3c 00       	j 80003b80 <osEE_tc_core0_isr_dummy_entry_220>
	...

80003ba0 <osEE_tc_core0_isr_dummy_entry_221>:
80003ba0:	3c 00       	j 80003ba0 <osEE_tc_core0_isr_dummy_entry_221>
	...

80003bc0 <osEE_tc_core0_isr_dummy_entry_222>:
80003bc0:	3c 00       	j 80003bc0 <osEE_tc_core0_isr_dummy_entry_222>
	...

80003be0 <osEE_tc_core0_isr_dummy_entry_223>:
80003be0:	3c 00       	j 80003be0 <osEE_tc_core0_isr_dummy_entry_223>
	...

80003c00 <osEE_tc_core0_isr_dummy_entry_224>:
80003c00:	3c 00       	j 80003c00 <osEE_tc_core0_isr_dummy_entry_224>
	...

80003c20 <osEE_tc_core0_isr_dummy_entry_225>:
80003c20:	3c 00       	j 80003c20 <osEE_tc_core0_isr_dummy_entry_225>
	...

80003c40 <osEE_tc_core0_isr_dummy_entry_226>:
80003c40:	3c 00       	j 80003c40 <osEE_tc_core0_isr_dummy_entry_226>
	...

80003c60 <osEE_tc_core0_isr_dummy_entry_227>:
80003c60:	3c 00       	j 80003c60 <osEE_tc_core0_isr_dummy_entry_227>
	...

80003c80 <osEE_tc_core0_isr_dummy_entry_228>:
80003c80:	3c 00       	j 80003c80 <osEE_tc_core0_isr_dummy_entry_228>
	...

80003ca0 <osEE_tc_core0_isr_dummy_entry_229>:
80003ca0:	3c 00       	j 80003ca0 <osEE_tc_core0_isr_dummy_entry_229>
	...

80003cc0 <osEE_tc_core0_isr_dummy_entry_230>:
80003cc0:	3c 00       	j 80003cc0 <osEE_tc_core0_isr_dummy_entry_230>
	...

80003ce0 <osEE_tc_core0_isr_dummy_entry_231>:
80003ce0:	3c 00       	j 80003ce0 <osEE_tc_core0_isr_dummy_entry_231>
	...

80003d00 <osEE_tc_core0_isr_dummy_entry_232>:
80003d00:	3c 00       	j 80003d00 <osEE_tc_core0_isr_dummy_entry_232>
	...

80003d20 <osEE_tc_core0_isr_dummy_entry_233>:
80003d20:	3c 00       	j 80003d20 <osEE_tc_core0_isr_dummy_entry_233>
	...

80003d40 <osEE_tc_core0_isr_dummy_entry_234>:
80003d40:	3c 00       	j 80003d40 <osEE_tc_core0_isr_dummy_entry_234>
	...

80003d60 <osEE_tc_core0_isr_dummy_entry_235>:
80003d60:	3c 00       	j 80003d60 <osEE_tc_core0_isr_dummy_entry_235>
	...

80003d80 <osEE_tc_core0_isr_dummy_entry_236>:
80003d80:	3c 00       	j 80003d80 <osEE_tc_core0_isr_dummy_entry_236>
	...

80003da0 <osEE_tc_core0_isr_dummy_entry_237>:
80003da0:	3c 00       	j 80003da0 <osEE_tc_core0_isr_dummy_entry_237>
	...

80003dc0 <osEE_tc_core0_isr_dummy_entry_238>:
80003dc0:	3c 00       	j 80003dc0 <osEE_tc_core0_isr_dummy_entry_238>
	...

80003de0 <osEE_tc_core0_isr_dummy_entry_239>:
80003de0:	3c 00       	j 80003de0 <osEE_tc_core0_isr_dummy_entry_239>
	...

80003e00 <osEE_tc_core0_isr_dummy_entry_240>:
80003e00:	3c 00       	j 80003e00 <osEE_tc_core0_isr_dummy_entry_240>
	...

80003e20 <osEE_tc_core0_isr_dummy_entry_241>:
80003e20:	3c 00       	j 80003e20 <osEE_tc_core0_isr_dummy_entry_241>
	...

80003e40 <osEE_tc_core0_isr_dummy_entry_242>:
80003e40:	3c 00       	j 80003e40 <osEE_tc_core0_isr_dummy_entry_242>
	...

80003e60 <osEE_tc_core0_isr_dummy_entry_243>:
80003e60:	3c 00       	j 80003e60 <osEE_tc_core0_isr_dummy_entry_243>
	...

80003e80 <osEE_tc_core0_isr_dummy_entry_244>:
80003e80:	3c 00       	j 80003e80 <osEE_tc_core0_isr_dummy_entry_244>
	...

80003ea0 <osEE_tc_core0_isr_dummy_entry_245>:
80003ea0:	3c 00       	j 80003ea0 <osEE_tc_core0_isr_dummy_entry_245>
	...

80003ec0 <osEE_tc_core0_isr_dummy_entry_246>:
80003ec0:	3c 00       	j 80003ec0 <osEE_tc_core0_isr_dummy_entry_246>
	...

80003ee0 <osEE_tc_core0_isr_dummy_entry_247>:
80003ee0:	3c 00       	j 80003ee0 <osEE_tc_core0_isr_dummy_entry_247>
	...

80003f00 <osEE_tc_core0_isr_dummy_entry_248>:
80003f00:	3c 00       	j 80003f00 <osEE_tc_core0_isr_dummy_entry_248>
	...

80003f20 <osEE_tc_core0_isr_dummy_entry_249>:
80003f20:	3c 00       	j 80003f20 <osEE_tc_core0_isr_dummy_entry_249>
	...

80003f40 <osEE_tc_core0_isr_dummy_entry_250>:
80003f40:	3c 00       	j 80003f40 <osEE_tc_core0_isr_dummy_entry_250>
	...

80003f60 <osEE_tc_core0_isr_dummy_entry_251>:
80003f60:	3c 00       	j 80003f60 <osEE_tc_core0_isr_dummy_entry_251>
	...

80003f80 <osEE_tc_core0_isr_dummy_entry_252>:
80003f80:	3c 00       	j 80003f80 <osEE_tc_core0_isr_dummy_entry_252>
	...

80003fa0 <osEE_tc_core0_isr_dummy_entry_253>:
80003fa0:	3c 00       	j 80003fa0 <osEE_tc_core0_isr_dummy_entry_253>
	...

80003fc0 <osEE_tc_core0_isr_dummy_entry_254>:
80003fc0:	3c 00       	j 80003fc0 <osEE_tc_core0_isr_dummy_entry_254>
	...

80003fe0 <osEE_tc_core0_isr_dummy_entry_255>:
80003fe0:	3c 00       	j 80003fe0 <osEE_tc_core0_isr_dummy_entry_255>
	...

Disassembly of section .text:

80004000 <TimerISR>:
#include "bsw.h"

ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004000:	7b f0 00 40 	movh %d4,15
#include "bsw.h"

ISR2(TimerISR)
{
80004004:	20 08       	sub.a %sp,8
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
80004006:	1b 04 24 44 	addi %d4,%d4,16960
8000400a:	6d 00 9d 2a 	call 80009544 <osEE_tc_stm_set_sr0_next_match>
    printfSerial("\n%4ld: ", c++);
8000400e:	91 00 00 f7 	movh.a %a15,28672
80004012:	19 ff 00 00 	ld.w %d15,[%a15]0 <70000000 <__DSPR0_START>>
80004016:	91 00 00 48 	movh.a %a4,32768
8000401a:	78 00       	st.w [%sp]0,%d15
8000401c:	d9 44 28 00 	lea %a4,[%a4]40 <80000028 <_start+0x8>>
80004020:	c2 1f       	add %d15,1
80004022:	59 ff 00 00 	st.w [%a15]0 <70000000 <__DSPR0_START>>,%d15
80004026:	6d 00 a2 00 	call 8000416a <printfSerial>
    IncrementCounter(myCounter);
8000402a:	82 04       	mov %d4,0
}
8000402c:	d9 aa 08 00 	lea %sp,[%sp]8
ISR2(TimerISR)
{
    static long c = -4;
    osEE_tc_stm_set_sr0_next_match(1000000U);
    printfSerial("\n%4ld: ", c++);
    IncrementCounter(myCounter);
80004030:	1d 00 36 33 	j 8000a69c <IncrementCounter>

80004034 <FuncTaskCPU0>:
}

TASK(TaskCPU0)
{
    printfSerial("TaskCPU0 Begins...");
80004034:	91 00 00 48 	movh.a %a4,32768
80004038:	d9 44 30 00 	lea %a4,[%a4]48 <80000030 <_start+0x10>>
8000403c:	6d 00 97 00 	call 8000416a <printfSerial>
    mdelay(5000);
80004040:	3b 80 38 41 	mov %d4,5000
80004044:	6d 00 ce 00 	call 800041e0 <mdelay>
    SetEvent(TaskCPU1, Event1);
80004048:	82 34       	mov %d4,3
8000404a:	82 15       	mov %d5,1
8000404c:	6d 00 9d 31 	call 8000a386 <SetEvent>
    SetEvent(TaskCPU2, Event1);
80004050:	82 44       	mov %d4,4
80004052:	82 15       	mov %d5,1
80004054:	6d 00 99 31 	call 8000a386 <SetEvent>
    printfSerial("TaskCPU0 Finishes...");
80004058:	91 00 00 48 	movh.a %a4,32768
8000405c:	d9 44 03 10 	lea %a4,[%a4]67 <80000043 <_start+0x23>>
80004060:	6d 00 85 00 	call 8000416a <printfSerial>
    TerminateTask();
80004064:	1d 00 45 2e 	j 80009cee <TerminateTask>

80004068 <FuncTaskCPU1>:
}

TASK(TaskCPU1)
{
    printfSerial("TaskCPU1 Begins...");
80004068:	91 00 00 48 	movh.a %a4,32768
8000406c:	d9 44 18 10 	lea %a4,[%a4]88 <80000058 <_start+0x38>>
80004070:	6d 00 7d 00 	call 8000416a <printfSerial>

    printfSerial("TaskCPU1 waits...");
80004074:	91 00 00 48 	movh.a %a4,32768
80004078:	d9 44 2b 10 	lea %a4,[%a4]107 <8000006b <_start+0x4b>>
8000407c:	6d 00 77 00 	call 8000416a <printfSerial>
    WaitEvent(Event1);
80004080:	82 14       	mov %d4,1
80004082:	6d 00 08 31 	call 8000a292 <WaitEvent>
    printfSerial("TaskCPU1 wakes up. ");
80004086:	91 00 00 48 	movh.a %a4,32768
8000408a:	d9 44 3d 10 	lea %a4,[%a4]125 <8000007d <_start+0x5d>>
8000408e:	6d 00 6e 00 	call 8000416a <printfSerial>
    mdelay(3000);
80004092:	3b 80 bb 40 	mov %d4,3000
80004096:	6d 00 a5 00 	call 800041e0 <mdelay>
    ClearEvent(Event1);
8000409a:	82 14       	mov %d4,1
8000409c:	6d 00 24 32 	call 8000a4e4 <ClearEvent>
    printfSerial("TaskCPU1 Finishes...");
800040a0:	91 00 00 48 	movh.a %a4,32768
800040a4:	d9 44 11 20 	lea %a4,[%a4]145 <80000091 <_start+0x71>>
800040a8:	6d 00 61 00 	call 8000416a <printfSerial>
    TerminateTask();
800040ac:	1d 00 21 2e 	j 80009cee <TerminateTask>

800040b0 <FuncTaskCPU2>:
}

TASK(TaskCPU2)
{
    printfSerial("TaskCPU2 Begins...");
800040b0:	91 00 00 48 	movh.a %a4,32768
800040b4:	d9 44 26 20 	lea %a4,[%a4]166 <800000a6 <_start+0x86>>
800040b8:	6d 00 59 00 	call 8000416a <printfSerial>

    printfSerial("TaskCPU2 waits...");
800040bc:	91 00 00 48 	movh.a %a4,32768
800040c0:	d9 44 39 20 	lea %a4,[%a4]185 <800000b9 <_start+0x99>>
800040c4:	6d 00 53 00 	call 8000416a <printfSerial>
    WaitEvent(Event1);
800040c8:	82 14       	mov %d4,1
800040ca:	6d 00 e4 30 	call 8000a292 <WaitEvent>
    printfSerial("TaskCPU2 wakes up. ");
800040ce:	91 00 00 48 	movh.a %a4,32768
800040d2:	d9 44 0b 30 	lea %a4,[%a4]203 <800000cb <_start+0xab>>
800040d6:	6d 00 4a 00 	call 8000416a <printfSerial>
    mdelay(3000);
800040da:	3b 80 bb 40 	mov %d4,3000
800040de:	6d 00 81 00 	call 800041e0 <mdelay>
    ClearEvent(Event1);
800040e2:	82 14       	mov %d4,1
800040e4:	6d 00 00 32 	call 8000a4e4 <ClearEvent>
    printfSerial("TaskCPU2 Finishes...");
800040e8:	91 00 00 48 	movh.a %a4,32768
800040ec:	d9 44 1f 30 	lea %a4,[%a4]223 <800000df <_start+0xbf>>
800040f0:	6d 00 3d 00 	call 8000416a <printfSerial>
    TerminateTask();
800040f4:	1d 00 fd 2d 	j 80009cee <TerminateTask>

800040f8 <UART_init>:
                                        IfxVadc_ChannelId_6,  /* AN38: channel 6 of group 4                         */
                                        IfxVadc_ChannelId_7}; /* AN39: channel 7 of group 4                         */


void UART_init(void)
{
800040f8:	20 60       	sub.a %sp,96

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
800040fa:	d9 a4 24 00 	lea %a4,[%sp]36
800040fe:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x3fff8900>
    ascConfig.baudrate.prescaler    = 1;
80004102:	82 1f       	mov %d15,1

void UART_init(void)
{

    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);
80004104:	6d 00 74 0a 	call 800055ec <IfxAsclin_Asc_initModuleConfig>
    ascConfig.baudrate.prescaler    = 1;
80004108:	f9 af 2c 00 	st.h [%sp]44,%d15
    ascConfig.baudrate.baudrate     = 115200;
8000410c:	7b 10 7e f4 	movh %d15,18401
80004110:	78 0a       	st.w [%sp]40,%d15
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;
80004112:	82 3f       	mov %d15,3
80004114:	e9 af 2e 00 	st.b [%sp]46,%d15

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;
80004118:	da 13       	mov %d15,19
8000411a:	f9 af 00 10 	st.h [%sp]64,%d15


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000411e:	4d c0 e1 ff 	mfcr %d15,$core_id
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
80004122:	7b 00 00 28 	movh %d2,32768
80004126:	60 23       	mov.a %a3,%d2
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80004128:	37 0f 63 f0 	extr.u %d15,%d15,0,3
8000412c:	d9 af 04 00 	lea %a15,[%sp]4
80004130:	40 f4       	mov.aa %a4,%a15
80004132:	d9 32 34 30 	lea %a2,[%a3]244
    ascConfig.baudrate.baudrate     = 115200;
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
80004136:	e9 af 06 10 	st.b [%sp]70,%d15
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
8000413a:	a0 33       	mov.a %a3,3
8000413c:	09 22 48 01 	ld.d %e2,[%a2+]8
80004140:	89 42 48 01 	st.d [%a4+]8 <80000008 <BootModeHeader0+0x8>>,%e2
80004144:	fc 3c       	loop %a3,8000413c <UART_init+0x44>

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
80004146:	7b 00 00 f7 	movh %d15,28672
8000414a:	1b 4f 8a f0 	addi %d15,%d15,2212
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000414e:	91 00 00 47 	movh.a %a4,28672

    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
80004152:	78 14       	st.w [%sp]80,%d15
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004154:	d9 44 b8 b0 	lea %a4,[%a4]2808 <70000af8 <g_AsclinAsc+0x254>>
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80004158:	3b 20 10 f0 	mov %d15,258
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
8000415c:	d9 a5 24 00 	lea %a5,[%sp]36
    ascConfig.interrupt.txPriority    = ISR_PRIORITY_ASC_3_TX;

    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* FIFO configuration */
    ascConfig.txBuffer     = g_AsclinAsc.ascBuffer.tx;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;
80004160:	f9 af 0e 10 	st.h [%sp]78,%d15
        &IfxAsclin3_RXD_P32_2_IN, IfxPort_InputMode_pullUp,        /* Rx pin */
        NULL_PTR,                     IfxPort_OutputMode_pushPull,     /* RTS pin not used */
        &IfxAsclin3_TX_P15_7_OUT, IfxPort_OutputMode_pushPull,     /* Tx pin */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
80004164:	f8 12       	st.a [%sp]72,%a15
    /* initialize module */
    IfxAsclin_Asc_initModule(&g_AsclinAsc.drivers.asc, &ascConfig);
80004166:	1d 00 6c 08 	j 8000523e <IfxAsclin_Asc_initModule>

8000416a <printfSerial>:
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
8000416a:	20 e8       	sub.a %sp,232
    GetSpinlock(S1);
8000416c:	82 04       	mov %d4,0
    //printf("Asclin Asc is initialised\n");
}


void printfSerial(const char *fmt,...)
{
8000416e:	40 4f       	mov.aa %a15,%a4
    GetSpinlock(S1);
80004170:	6d 00 33 34 	call 8000a9d6 <GetSpinlock>
//    EnableAllInterrupts();
    char buf[LEN_BUF];
    va_list args;
    va_start (args, fmt );
    vsnprintf(buf, LEN_BUF, fmt, args);
80004174:	40 f5       	mov.aa %a5,%a15
80004176:	d9 a4 28 10 	lea %a4,[%sp]104
8000417a:	3b 00 08 40 	mov %d4,128
8000417e:	d9 a6 28 30 	lea %a6,[%sp]232
80004182:	6d 00 c4 43 	call 8000c90a <vsnprintf>
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
80004186:	d9 a4 28 10 	lea %a4,[%sp]104
8000418a:	6d 00 91 43 	call 8000c8ac <strlen>
8000418e:	91 00 00 f7 	movh.a %a15,28672
80004192:	d9 ff a4 20 	lea %a15,[%a15]2212 <700008a4 <g_AsclinAsc>>
80004196:	f9 f2 3a 90 	st.h [%a15]634 <7000027a <__malloc_av_+0x24a>>,%d2
    unsigned int i =0;
8000419a:	82 0f       	mov %d15,0
    for(; i<strlen(buf);i++) {
8000419c:	d9 a4 28 10 	lea %a4,[%sp]104
800041a0:	6d 00 86 43 	call 8000c8ac <strlen>
800041a4:	7f 2f 0c 80 	jge.u %d15,%d2,800041bc <printfSerial+0x52>
        txData[i] = buf[i];
800041a8:	d9 a3 04 00 	lea %a3,[%sp]4
800041ac:	10 32       	addsc.a %a2,%a3,%d15,0
800041ae:	d9 a3 28 10 	lea %a3,[%sp]104
800041b2:	10 3f       	addsc.a %a15,%a3,%d15,0
    va_end (args);
    /* prepare data to transmit and receive */
    uint8 txData[100];
    g_AsclinAsc.count = strlen(buf);
    unsigned int i =0;
    for(; i<strlen(buf);i++) {
800041b4:	c2 1f       	add %d15,1
        txData[i] = buf[i];
800041b6:	08 02       	ld.bu %d2,[%a15]0
800041b8:	34 22       	st.b [%a2],%d2
800041ba:	3c f1       	j 8000419c <printfSerial+0x32>
    }
    /* Transmit data */
    IfxAsclin_Asc_write(&g_AsclinAsc.drivers.asc, txData, &g_AsclinAsc.count, TIME_INFINITE);
800041bc:	82 f4       	mov %d4,-1
800041be:	91 00 00 47 	movh.a %a4,28672
800041c2:	91 00 00 67 	movh.a %a6,28672
800041c6:	9b 04 00 58 	addih %d5,%d4,32768
800041ca:	d9 44 b8 b0 	lea %a4,[%a4]2808 <70000af8 <g_AsclinAsc+0x254>>
800041ce:	d9 a5 04 00 	lea %a5,[%sp]4 <70000af8 <g_AsclinAsc+0x254>>
800041d2:	d9 66 9e c0 	lea %a6,[%a6]2846 <70000b1e <g_AsclinAsc+0x27a>>
800041d6:	6d 00 73 0a 	call 800056bc <IfxAsclin_Asc_write>
    ReleaseSpinlock(S1);
800041da:	82 04       	mov %d4,0
800041dc:	1d 00 79 34 	j 8000aace <ReleaseSpinlock>

800041e0 <mdelay>:

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800041e0:	85 fa 10 00 	ld.w %d10,f0000010 <_SMALL_DATA4_+0x3fff8010>
}

void mdelay(unsigned long delay_ms)
{
800041e4:	02 4b       	mov %d11,%d4
    result |= ((uint64)stm->CAP.U) << 32;
800041e6:	85 fc 2c 00 	ld.w %d12,f000002c <_SMALL_DATA4_+0x3fff802c>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800041ea:	6d 00 5d 0e 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
800041ee:	91 30 00 ff 	movh.a %a15,61443
800041f2:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
800041f6:	4c f0       	ld.w %d15,[%a15]0

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800041f8:	53 1a 40 80 	mul.u %e8,%d10,1
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800041fc:	0b ac 10 48 	mov %e4,%d12,%d10
80004200:	37 0f 64 f4 	extr.u %d15,%d15,8,4
80004204:	a6 95       	or %d5,%d9
80004206:	02 28       	mov %d8,%d2
80004208:	6d 00 3f 3c 	call 8000ba86 <__floatundisf>
8000420c:	4b 0f 41 f1 	itof %d15,%d15
80004210:	7b a0 47 a4 	movh %d10,17530
80004214:	4b f8 51 f0 	div.f %d15,%d8,%d15
80004218:	40 fc       	mov.aa %a12,%a15
8000421a:	40 fd       	mov.aa %a13,%a15
8000421c:	4b af 51 f0 	div.f %d15,%d15,%d10
80004220:	4b f2 51 20 	div.f %d2,%d2,%d15
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004224:	02 ae       	mov %d14,%d10
    ReleaseSpinlock(S1);
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004226:	4b 02 71 f1 	ftouz %d15,%d2
8000422a:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000422e:	85 f2 2c 00 	ld.w %d2,f000002c <_SMALL_DATA4_+0x3fff802c>
80004232:	6d 00 39 0e 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
80004236:	3b 40 01 40 	mov %d4,20
8000423a:	4b 4b 11 42 	div.u %e4,%d11,%d4
8000423e:	48 02       	ld.w %d2,[%a15]0
}

void mdelay(unsigned long delay_ms)
{
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
80004240:	82 0b       	mov %d11,0
    while (cnt < (delay_ms / period_ms)) {
80004242:	02 4d       	mov %d13,%d4
80004244:	5f db 41 00 	jeq %d11,%d13,800042c6 <mdelay+0xe6>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004248:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000424c:	85 fe 2c 08 	ld.a %a14,f000002c <_SMALL_DATA4_+0x3fff802c>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004250:	53 1c 40 80 	mul.u %e8,%d12,1
80004254:	6d 00 28 0e 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
80004258:	54 c3       	ld.w %d3,[%a12]
    result |= ((uint64)stm->CAP.U) << 32;
8000425a:	80 e5       	mov.d %d5,%a14
8000425c:	37 03 64 34 	extr.u %d3,%d3,8,4
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
80004260:	02 c4       	mov %d4,%d12
80004262:	a6 95       	or %d5,%d9
80004264:	60 3f       	mov.a %a15,%d3
80004266:	02 28       	mov %d8,%d2
80004268:	6d 00 0f 3c 	call 8000ba86 <__floatundisf>
8000426c:	80 f4       	mov.d %d4,%a15
8000426e:	4b 04 41 31 	itof %d3,%d4
80004272:	4b 38 51 80 	div.f %d8,%d8,%d3
80004276:	4b a8 51 80 	div.f %d8,%d8,%d10
8000427a:	4b 82 51 20 	div.f %d2,%d2,%d8
8000427e:	4b 02 71 21 	ftouz %d2,%d2
        if (current_ms - prev_ms >= period_ms) {
80004282:	a2 f2       	sub %d2,%d15
80004284:	8b 42 61 22 	lt.u %d2,%d2,20
80004288:	df 02 de ff 	jne %d2,0,80004244 <mdelay+0x64>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000428c:	85 fc 10 00 	ld.w %d12,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80004290:	85 ff 2c 08 	ld.a %a15,f000002c <_SMALL_DATA4_+0x3fff802c>
80004294:	6d 00 08 0e 	call 80005ea4 <IfxScuCcu_getSourceFrequency>

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80004298:	53 1c 40 80 	mul.u %e8,%d12,1
8000429c:	4c d0       	ld.w %d15,[%a13]0
    result |= ((uint64)stm->CAP.U) << 32;
8000429e:	80 f5       	mov.d %d5,%a15
800042a0:	37 0f 64 f4 	extr.u %d15,%d15,8,4
            cnt++;
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800042a4:	02 c4       	mov %d4,%d12
800042a6:	a6 95       	or %d5,%d9
800042a8:	02 28       	mov %d8,%d2
800042aa:	6d 00 ee 3b 	call 8000ba86 <__floatundisf>
800042ae:	4b 0f 41 f1 	itof %d15,%d15
    unsigned long prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 )), current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
    unsigned long period_ms = 20, cnt = 0;
    while (cnt < (delay_ms / period_ms)) {
        current_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
        if (current_ms - prev_ms >= period_ms) {
            cnt++;
800042b2:	c2 1b       	add %d11,1
800042b4:	4b f8 51 f0 	div.f %d15,%d8,%d15
            prev_ms = IfxStm_get(&MODULE_STM0) / (IfxStm_getFrequency(&MODULE_STM0) / ( 1000 /1 ));
800042b8:	4b ef 51 f0 	div.f %d15,%d15,%d14
800042bc:	4b f2 51 20 	div.f %d2,%d2,%d15
800042c0:	4b 02 71 f1 	ftouz %d15,%d2
800042c4:	3c c0       	j 80004244 <mdelay+0x64>
        }
    }
}
800042c6:	00 90       	ret 

800042c8 <initVADCModule>:
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
800042c8:	20 28       	sub.a %sp,40
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
800042ca:	d9 a4 04 00 	lea %a4,[%sp]4
800042ce:	91 20 00 5f 	movh.a %a5,61442
800042d2:	6d 00 d0 1d 	call 80007e72 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the configuration                  */
800042d6:	91 00 00 47 	movh.a %a4,28672
800042da:	d9 44 94 20 	lea %a4,[%a4]2196 <70000894 <g_vadc>>
800042de:	d9 a5 04 00 	lea %a5,[%sp]4 <70000894 <g_vadc>>
800042e2:	1d 00 54 1d 	j 80007d8a <IfxVadc_Adc_initModule>

800042e6 <initVADCGroup>:
}

/* Function to initialize the VADC group */
void initVADCGroup(void)
{
800042e6:	20 38       	sub.a %sp,56
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */
800042e8:	91 00 00 57 	movh.a %a5,28672
800042ec:	40 a4       	mov.aa %a4,%sp
800042ee:	d9 55 94 20 	lea %a5,[%a5]2196 <70000894 <g_vadc>>
800042f2:	6d 00 35 1d 	call 80007d5c <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800042f6:	82 4f       	mov %d15,4
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
800042f8:	91 00 00 47 	movh.a %a4,28672
void initVADCGroup(void)
{
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
800042fc:	2c a4       	st.b [%sp]4,%d15
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */
800042fe:	2c a5       	st.b [%sp]5,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004300:	d9 44 88 20 	lea %a4,[%a4]2184 <70000888 <g_vadcGroup>>

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
80004304:	82 1f       	mov %d15,1
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004306:	40 a5       	mov.aa %a5,%sp

    adcGroupConf.groupId = IfxVadc_GroupId_4;                           /* Select the Group 4                       */
    adcGroupConf.master = adcGroupConf.groupId;                         /* Set the same group as master group       */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
80004308:	e9 af 35 00 	st.b [%sp]53,%d15
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;
8000430c:	e9 af 28 00 	st.b [%sp]40,%d15

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80004310:	e9 af 2c 00 	st.b [%sp]44,%d15

    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
80004314:	1d 00 5f 1b 	j 800079d2 <IfxVadc_Adc_initGroup>

80004318 <initVADCChannels>:
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004318:	91 00 00 e7 	movh.a %a14,28672

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
8000431c:	7b 00 00 b7 	movh %d11,28672
80004320:	7b 00 00 a7 	movh %d10,28672
}


IFX_INLINE void IfxVadc_Adc_setBackgroundScan(IfxVadc_Adc *vadc, IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setBackgroundScan(vadc->vadc, group->groupId, channels, mask);
80004324:	91 00 00 d7 	movh.a %a13,28672
    IfxVadc_Adc_initGroup(&g_vadcGroup, &adcGroupConf);                 /* Apply the configuration                  */
}

/* Function to initialize the VADC used channels */
void initVADCChannels(void)
{
80004328:	20 60       	sub.a %sp,96
8000432a:	82 0f       	mov %d15,0
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
8000432c:	d9 ee 88 20 	lea %a14,[%a14]2184 <70000888 <g_vadcGroup>>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004330:	1b 8b 00 b0 	addi %d11,%d11,8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
80004334:	82 19       	mov %d9,1
80004336:	1b 8a 86 a0 	addi %d10,%d10,2152
8000433a:	d9 dd 94 20 	lea %a13,[%a13]2196
8000433e:	53 8f 21 80 	mul %d8,%d15,24
80004342:	40 ac       	mov.aa %a12,%sp
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
80004344:	40 e5       	mov.aa %a5,%a14
80004346:	60 82       	mov.a %a2,%d8

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004348:	d9 af 20 10 	lea %a15,[%sp]96
8000434c:	30 2c       	add.a %a12,%a2
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);
8000434e:	40 c4       	mov.aa %a4,%a12
80004350:	6d 00 36 1b 	call 800079bc <IfxVadc_Adc_initChannelConfig>

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004354:	60 83       	mov.a %a3,%d8
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004356:	40 c5       	mov.aa %a5,%a12
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004358:	30 3f       	add.a %a15,%a3
8000435a:	60 b3       	mov.a %a3,%d11
8000435c:	10 32       	addsc.a %a2,%a3,%d15,0
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
8000435e:	e9 ff ef ef 	st.b [%a15]-81,%d15
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004362:	14 22       	ld.bu %d2,[%a2]
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004364:	60 a2       	mov.a %a2,%d10
80004366:	d0 24       	addsc.a %a4,%a2,%d15,3
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf[chn], &g_vadcGroup);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf[chn].channelId = g_vadcChannelIDs[chn];          /* The channels 4..7 are initialized        */
80004368:	e9 f2 ec ef 	st.b [%a15]-84,%d2
        adcChannelConf[chn].resultRegister = (IfxVadc_ChannelResult)(chn);
        adcChannelConf[chn].backgroundChannel = TRUE;                   /* Enable background scan for the channel   */
8000436c:	e9 f9 e2 ef 	st.b [%a15]-94,%d9


        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chn], &adcChannelConf[chn]);
80004370:	6d 00 30 1a 	call 800077d0 <IfxVadc_Adc_initChannel>
80004374:	d4 d2       	ld.a %a2,[%a13]
80004376:	39 e2 08 00 	ld.bu %d2,[%a14]8 <70000008 <g_vadcChannelIDs>>
8000437a:	c2 1f       	add %d15,1
8000437c:	01 22 02 26 	addsc.a %a2,%a2,%d2,2

        /* Add the channel to background scan */
        unsigned chnEnableBit = (1 << adcChannelConf[chn].channelId);   /* Set the the corresponding input channel  */
80004380:	79 f2 ec ef 	ld.b %d2,[%a15]-84
}


IFX_INLINE void IfxVadc_setBackgroundScan(Ifx_VADC *vadc, IfxVadc_GroupId groupId, uint32 channels, uint32 mask)
{
    channels                = (vadc->BRSSEL[groupId].U & ~mask) | channels;
80004384:	19 23 00 60 	ld.w %d3,[%a2]384
80004388:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
    vadc->BRSSEL[groupId].U = channels;
8000438c:	59 22 00 60 	st.w [%a2]384,%d2
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf[CHANNELS_NUM];             /* Array of configuration structures        */

    uint16 chn;
    for (chn = 0; chn < CHANNELS_NUM; chn++) {                             /* Initialize all the channels in a loop    */
80004390:	df 4f d7 ff 	jne %d15,4,8000433e <initVADCChannels+0x26>
        unsigned mask = chnEnableBit;                                   /* of the respective group to be added in   */
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup, chnEnableBit, mask); /* the background scan sequence.  */

    }

}
80004394:	00 90       	ret 

80004396 <initADC>:
}


IFX_INLINE void IfxVadc_Adc_startBackgroundScan(IfxVadc_Adc *vadc)
{
    IfxVadc_startBackgroundScan(vadc->vadc);
80004396:	91 00 00 f7 	movh.a %a15,28672
}

/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
8000439a:	6d ff 97 ff 	call 800042c8 <initVADCModule>
    initVADCGroup();                                                    /* Initialize the VADC group                */
8000439e:	6d ff a4 ff 	call 800042e6 <initVADCGroup>
    initVADCChannels();                                                 /* Initialize the used channels             */
800043a2:	6d ff bb ff 	call 80004318 <initVADCChannels>
800043a6:	99 ff 94 20 	ld.a %a15,[%a15]2196 <70000894 <g_vadc>>
}


IFX_INLINE void IfxVadc_startBackgroundScan(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.LDEV = 1;     /* execute Load event to start the conversion */
800043aa:	19 ff 04 80 	ld.w %d15,[%a15]516 <70000894 <g_vadc>>
800043ae:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
800043b2:	59 ff 04 80 	st.w [%a15]516,%d15
800043b6:	00 90       	ret 

800043b8 <readADCValue>:
}


IFX_INLINE Ifx_VADC_RES IfxVadc_Adc_getResult(IfxVadc_Adc_Channel *channel)
{
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
800043b8:	91 00 00 f7 	movh.a %a15,28672
800043bc:	d9 ff a8 10 	lea %a15,[%a15]2152 <70000868 <g_vadcChannel>>
800043c0:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
800043c4:	c8 12       	ld.a %a2,[%a15]4
800043c6:	0c f1       	ld.bu %d15,[%a15]1
800043c8:	99 22 04 00 	ld.a %a2,[%a2]4

IFX_INLINE Ifx_VADC_RES IfxVadc_getResult(Ifx_VADC_G *group, uint32 resultIdx)
{
    Ifx_VADC_RES tmpResult;

    tmpResult.U = group->RES[resultIdx].U;
800043cc:	1b 0f 0a f0 	addi %d15,%d15,160
800043d0:	90 2f       	addsc.a %a15,%a2,%d15,2
800043d2:	4c f0       	ld.w %d15,[%a15]0
800043d4:	37 0f 70 20 	extr.u %d2,%d15,0,16
{
    Ifx_VADC_RES conversionResult;
    do
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    } while(!conversionResult.B.VF);
800043d8:	ff 0f fd 7f 	jge %d15,0,800043d2 <readADCValue+0x1a>

    return conversionResult.B.RESULT;
}
800043dc:	00 90       	ret 

800043de <initPeripheralsAndERU>:

void initPeripheralsAndERU(void)
{
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */
800043de:	91 40 00 4f 	movh.a %a4,61444
800043e2:	d9 44 00 0e 	lea %a4,[%a4]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
800043e6:	82 74       	mov %d4,7
800043e8:	3b 00 01 50 	mov %d5,16
800043ec:	6d 00 75 0b 	call 80005ad6 <IfxPort_setPinMode>


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
800043f0:	91 00 00 f8 	movh.a %a15,32768
800043f4:	d9 ff c4 60 	lea %a15,[%a15]3460 <80000d84 <IfxScu_REQ6_P02_0_IN>>
}


IFX_INLINE void IfxPort_setPinModeInput(Ifx_P *port, uint8 pinIndex, IfxPort_InputMode mode)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
800043f8:	c8 24       	ld.a %a4,[%a15]8
800043fa:	91 00 00 d7 	movh.a %a13,28672
800043fe:	08 c4       	ld.bu %d4,[%a15]12
80004400:	3b 80 00 50 	mov %d5,8
80004404:	b5 df 98 20 	st.a [%a13]2200 <70000898 <g_ERUconfig>>,%a15
80004408:	6d 00 67 0b 	call 80005ad6 <IfxPort_setPinMode>
/******************************************************************************/

IFX_INLINE void IfxScuEru_initReqPin(IfxScu_Req_In *req, IfxPort_InputMode inputMode)
{
    IfxPort_setPinModeInput(req->pin.port, req->pin.pinIndex, inputMode);
    IfxScuEru_selectExternalInput((IfxScuEru_InputChannel)req->channelId, (IfxScuEru_ExternalInputSelection)req->select);
8000440c:	39 f5 10 00 	ld.bu %d5,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80004410:	08 44       	ld.bu %d4,[%a15]4
80004412:	6d 00 10 15 	call 80006e32 <IfxScuEru_selectExternalInput>
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
80004416:	99 df 98 20 	ld.a %a15,[%a13]2200 <70000898 <g_ERUconfig>>
    /* Initialize pins which are used to trigger and visualize the interrupt and set the default states */
    IfxPort_setPinMode(TRIGGER_PIN, IfxPort_Mode_inputPullUp);              /* Initialize TRIGGER_PIN port pin  */


    /* Trigger pin */
    g_ERUconfig.reqPin = REQ_IN; /* Select external request pin */
8000441a:	d9 dc 98 20 	lea %a12,[%a13]2200 <70000898 <g_ERUconfig>>
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
8000441e:	82 0f       	mov %d15,0
     * This function will also configure the input multiplexers of the ERU (Register EXISx)
     */
    IfxScuEru_initReqPin(g_ERUconfig.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_ERUconfig.inputChannel = (IfxScuEru_InputChannel) g_ERUconfig.reqPin->channelId;
80004420:	08 44       	ld.bu %d4,[%a15]4
80004422:	e9 c4 04 00 	st.b [%a12]4 <70000004 <__DSPR0_START+0x4>>,%d4

    /* Input channel configuration */
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */
80004426:	6d 00 76 14 	call 80006d12 <IfxScuEru_enableFallingEdgeDetection>
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
8000442a:	39 c4 04 00 	ld.bu %d4,[%a12]4
  //  IfxScuEru_enableRisingEdgeDetection(g_ERUconfig.inputChannel);          /* Interrupt triggers on
                                                                             //  rising edge (Register RENx) and  */
    IfxScuEru_enableFallingEdgeDetection(g_ERUconfig.inputChannel);         /* on falling edge (Register FENx)  */

    /* Signal destination */
    g_ERUconfig.outputChannel = IfxScuEru_OutputChannel_0;                  /* OGU channel 0                    */
8000442e:	2c c6       	st.b [%a12]6,%d15
    /* Event from input ETL0 triggers output OGU0 (signal TRx0) */
    g_ERUconfig.triggerSelect = IfxScuEru_InputNodePointer_0;
80004430:	2c c5       	st.b [%a12]5,%d15

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_ERUconfig.inputChannel);
80004432:	6d 00 a9 14 	call 80006d84 <IfxScuEru_enableTriggerPulse>
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_ERUconfig.inputChannel, g_ERUconfig.triggerSelect);
80004436:	39 c4 04 00 	ld.bu %d4,[%a12]4
8000443a:	39 c5 05 00 	ld.bu %d5,[%a12]5
8000443e:	6d 00 dd 13 	call 80006bf8 <IfxScuEru_connectTrigger>

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_ERUconfig.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);
80004442:	39 c4 06 00 	ld.bu %d4,[%a12]6
80004446:	82 15       	mov %d5,1
80004448:	6d 00 2e 15 	call 80006ea4 <IfxScuEru_setInterruptGatingPattern>

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_ERUconfig.src = &MODULE_SRC.SCU.SCU.ERU[(int) g_ERUconfig.outputChannel % 4];
8000444c:	0c c6       	ld.bu %d15,[%a12]6
8000444e:	16 03       	and %d15,3
80004450:	06 2f       	sh %d15,2
80004452:	60 f2       	mov.a %a2,%d15
80004454:	d9 2f d4 38 	lea %a15,[%a2]-29484
80004458:	11 4f 00 ff 	addih.a %a15,%a15,61444
8000445c:	ec c2       	st.a [%a12]8,%a15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000445e:	4c f0       	ld.w %d15,[%a15]0
80004460:	b7 af 08 f0 	insert %d15,%d15,10,0,8
80004464:	68 0f       	st.w [%a15]0,%d15
    src->B.TOS  = typOfService;
80004466:	4c f0       	ld.w %d15,[%a15]0
80004468:	b7 0f 82 f5 	insert %d15,%d15,0,11,2
8000446c:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
8000446e:	4c f0       	ld.w %d15,[%a15]0
80004470:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80004474:	68 0f       	st.w [%a15]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80004476:	4c f0       	ld.w %d15,[%a15]0
80004478:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
8000447c:	68 0f       	st.w [%a15]0,%d15
8000447e:	00 90       	ret 

80004480 <asclin0TxISR>:
    IfxSrc_enable(g_ERUconfig.src);
}

ISR(asclin0TxISR)
{
    IfxAsclin_Asc_isrTransmit(&g_AsclinAsc.drivers.asc);
80004480:	91 00 00 47 	movh.a %a4,28672
80004484:	d9 44 b8 b0 	lea %a4,[%a4]2808 <70000af8 <g_AsclinAsc+0x254>>
80004488:	1d 00 20 06 	j 800050c8 <IfxAsclin_Asc_isrTransmit>

8000448c <main>:
}

int main(void)
{
8000448c:	20 08       	sub.a %sp,8
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000448e:	4d c0 e1 ff 	mfcr %d15,$core_id
    StatusType status1, status2;
    CoreIdType core_id = GetCoreID();
    if (core_id == OS_CORE_ID_MASTER) {
80004492:	37 0f 48 f0 	extr %d15,%d15,0,8
80004496:	91 00 00 c8 	movh.a %a12,32768
8000449a:	91 00 00 f8 	movh.a %a15,32768
8000449e:	d9 cc 14 40 	lea %a12,[%a12]276 <80000114 <_start+0xf4>>
800044a2:	d9 ff 3e 40 	lea %a15,[%a15]318 <8000013e <_start+0x11e>>
800044a6:	ee 22       	jnz %d15,800044ea <main+0x5e>
        osEE_tc_stm_set_clockpersec();
800044a8:	6d 00 f2 27 	call 8000948c <osEE_tc_stm_set_clockpersec>
        osEE_tc_stm_set_sr0(1000000U, 1U);
800044ac:	7b f0 00 40 	movh %d4,15
800044b0:	82 15       	mov %d5,1
800044b2:	1b 04 24 44 	addi %d4,%d4,16960
800044b6:	6d 00 05 28 	call 800094c0 <osEE_tc_stm_set_sr0>
        UART_init();
800044ba:	6d ff 1f fe 	call 800040f8 <UART_init>
        initADC();
800044be:	6d ff 6c ff 	call 80004396 <initADC>
        initPeripheralsAndERU();
800044c2:	6d ff 8e ff 	call 800043de <initPeripheralsAndERU>
        StartCore(OS_CORE_ID_1, &status1);
800044c6:	82 14       	mov %d4,1
800044c8:	d9 a4 06 00 	lea %a4,[%sp]6
800044cc:	6d 00 57 31 	call 8000a77a <StartCore>
        StartCore(OS_CORE_ID_2, &status2);
800044d0:	82 24       	mov %d4,2
800044d2:	d9 a4 07 00 	lea %a4,[%sp]7
800044d6:	6d 00 52 31 	call 8000a77a <StartCore>
        printfSerial("\n...............\n");
800044da:	40 c4       	mov.aa %a4,%a12
800044dc:	6d ff 47 fe 	call 8000416a <printfSerial>
        printfSerial("...Master OS Starts...\n");
800044e0:	91 00 00 48 	movh.a %a4,32768
800044e4:	d9 44 26 40 	lea %a4,[%a4]294 <80000126 <_start+0x106>>
800044e8:	3c 08       	j 800044f8 <main+0x6c>
        printfSerial("...............\n");
        StartOS(OSDEFAULTAPPMODE);
    } else {
        printfSerial("\n...............\n");
800044ea:	40 c4       	mov.aa %a4,%a12
800044ec:	6d ff 3f fe 	call 8000416a <printfSerial>
        printfSerial("...Slave OS Starts...\n");
800044f0:	91 00 00 48 	movh.a %a4,32768
800044f4:	d9 44 0f 50 	lea %a4,[%a4]335 <8000014f <_start+0x12f>>
800044f8:	6d ff 39 fe 	call 8000416a <printfSerial>
        printfSerial("...............\n");
800044fc:	40 f4       	mov.aa %a4,%a15
800044fe:	6d ff 36 fe 	call 8000416a <printfSerial>
        StartOS(OSDEFAULTAPPMODE);
80004502:	82 04       	mov %d4,0
80004504:	6d 00 e3 29 	call 800098ca <StartOS>
    }
    return 0;
80004508:	82 02       	mov %d2,0
8000450a:	00 90       	ret 

8000450c <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
8000450c:	02 4f       	mov %d15,%d4
8000450e:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004510:	6d 00 6d 16 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
80004514:	02 24       	mov %d4,%d2
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004516:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004518:	6d 00 66 15 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
8000451c:	8b 0f a2 22 	ge.u %d2,%d15,32
80004520:	f6 28       	jnz %d2,80004530 <IfxVadc_disableAccess+0x24>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
80004522:	19 f2 08 20 	ld.w %d2,[%a15]136
80004526:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
8000452a:	59 ff 08 20 	st.w [%a15]136,%d15
8000452e:	3c 08       	j 8000453e <IfxVadc_disableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80004530:	19 f2 0c 20 	ld.w %d2,[%a15]140
80004534:	16 1f       	and %d15,31
80004536:	d7 12 01 ff 	insert %d15,%d2,1,%d15,1
8000453a:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
8000453e:	02 84       	mov %d4,%d8
80004540:	1d 00 d8 16 	j 800072f0 <IfxScuWdt_setSafetyEndinit>

80004544 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80004544:	02 4f       	mov %d15,%d4
80004546:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80004548:	6d 00 51 16 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(passwd);
8000454c:	02 24       	mov %d4,%d2
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000454e:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80004550:	6d 00 4a 15 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80004554:	8b 0f a2 22 	ge.u %d2,%d15,32
80004558:	f6 28       	jnz %d2,80004568 <IfxVadc_enableAccess+0x24>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
8000455a:	19 f2 08 20 	ld.w %d2,[%a15]136
8000455e:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80004562:	59 ff 08 20 	st.w [%a15]136,%d15
80004566:	3c 08       	j 80004576 <IfxVadc_enableAccess+0x32>
    }
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
80004568:	19 f2 0c 20 	ld.w %d2,[%a15]140
8000456c:	16 1f       	and %d15,31
8000456e:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80004572:	59 ff 0c 20 	st.w [%a15]140,%d15
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80004576:	02 84       	mov %d4,%d8
80004578:	1d 00 bc 16 	j 800072f0 <IfxScuWdt_setSafetyEndinit>

8000457c <IfxVadc_configExternalMultiplexerMode>:

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
8000457c:	82 0f       	mov %d15,0
8000457e:	b7 1f 81 ff 	insert %d15,%d15,1,31,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
80004582:	39 a3 04 00 	ld.bu %d3,[%sp]4
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
80004586:	37 4f 02 fd 	insert %d15,%d15,%d4,26,2
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
8000458a:	14 a2       	ld.bu %d2,[%sp]
    Ifx_VADC_G_EMUXCTR emuxctr;

    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
8000458c:	67 3f 1e f0 	ins.t %d15,%d15,30,%d3,0
    emuxctr.B.EMUXCH   = channels;
80004590:	37 5f 0a f8 	insert %d15,%d15,%d5,16,10
    emuxctr.B.EMUXSET  = startChannel;
80004594:	37 6f 03 f0 	insert %d15,%d15,%d6,0,3
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
80004598:	3b f0 00 40 	mov %d4,15
    emuxctr.B.EMXWC    = 1;
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
8000459c:	67 7f 1c f0 	ins.t %d15,%d15,28,%d7,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800045a0:	40 5f       	mov.aa %a15,%a5
    emuxctr.B.EMUXMODE = mode;
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
800045a2:	67 2f 1d f0 	ins.t %d15,%d15,29,%d2,0
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVadc_configExternalMultiplexerMode(Ifx_VADC *vadc, Ifx_VADC_G *vadcG, IfxVadc_ExternalMultiplexerMode mode, uint8 channels, IfxVadc_EmuxSelectValue startChannel, IfxVadc_EmuxCodingScheme code, IfxVadc_EmuxSampleTimeControl sampleTimeControl, IfxVadc_ChannelSelectionStyle channelSelectionStyle)
{
800045a6:	40 4c       	mov.aa %a12,%a4
    emuxctr.B.EMXCSS   = channelSelectionStyle;
    emuxctr.B.EMUXCH   = channels;
    emuxctr.B.EMUXSET  = startChannel;
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800045a8:	6d ff ce ff 	call 80004544 <IfxVadc_enableAccess>
    vadcG->EMUXCTR.U   = emuxctr.U;
800045ac:	59 ff 30 50 	st.w [%a15]368,%d15
    emuxctr.B.EMXWC    = 0;
800045b0:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
    vadcG->EMUXCTR.U   = emuxctr.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800045b4:	40 c4       	mov.aa %a4,%a12
    emuxctr.B.EMXCOD   = code;
    emuxctr.B.EMXST    = sampleTimeControl;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
    vadcG->EMUXCTR.U   = emuxctr.U;
    emuxctr.B.EMXWC    = 0;
    vadcG->EMUXCTR.U   = emuxctr.U;
800045b6:	59 ff 30 50 	st.w [%a15]368,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
800045ba:	3b f0 00 40 	mov %d4,15
800045be:	1d ff a7 ff 	j 8000450c <IfxVadc_disableAccess>

800045c2 <IfxVadc_disablePostCalibration>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_disablePostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group, boolean disable)
{
800045c2:	40 4f       	mov.aa %a15,%a4
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
800045c4:	ff 84 1c 80 	jge.u %d4,8,800045fc <IfxVadc_disablePostCalibration+0x3a>
800045c8:	02 4f       	mov %d15,%d4
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800045ca:	3b f0 01 40 	mov %d4,31
800045ce:	02 58       	mov %d8,%d5
800045d0:	6d ff ba ff 	call 80004544 <IfxVadc_enableAccess>

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800045d4:	1b 0f 01 40 	addi %d4,%d15,16

        if (disable == TRUE)
        {
            vadc->GLOBCFG.U |= mask;
800045d8:	19 f2 00 20 	ld.w %d2,[%a15]128
{
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
    {
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);

        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800045dc:	82 1f       	mov %d15,1
800045de:	0f 4f 00 f0 	sh %d15,%d15,%d4

        if (disable == TRUE)
800045e2:	df 18 04 80 	jne %d8,1,800045ea <IfxVadc_disablePostCalibration+0x28>
        {
            vadc->GLOBCFG.U |= mask;
800045e6:	a6 2f       	or %d15,%d2
800045e8:	3c 03       	j 800045ee <IfxVadc_disablePostCalibration+0x2c>
        }
        else
        {
            vadc->GLOBCFG.U &= ~mask;
800045ea:	0f f2 e0 f0 	andn %d15,%d2,%d15
800045ee:	59 ff 00 20 	st.w [%a15]128,%d15
        }

        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800045f2:	40 f4       	mov.aa %a4,%a15
800045f4:	3b f0 01 40 	mov %d4,31
800045f8:	1d ff 8a ff 	j 8000450c <IfxVadc_disableAccess>
800045fc:	00 90       	ret 

800045fe <IfxVadc_enableGroupSync>:
    IfxScuWdt_setSafetyEndinit(passwd);
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
800045fe:	40 4f       	mov.aa %a15,%a4
80004600:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004602:	6d 00 d6 15 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004606:	02 24       	mov %d4,%d2
}


void IfxVadc_enableGroupSync(Ifx_VADC *vadc, uint32 ccu6Num)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004608:	02 29       	mov %d9,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
8000460a:	6d 00 d2 14 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000460e:	40 f4       	mov.aa %a4,%a15
80004610:	3b f0 01 40 	mov %d4,31
    IfxScuWdt_clearCpuEndinit(passwd);

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
80004614:	19 ff 00 20 	ld.w %d15,[%a15]128
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004618:	6d ff 96 ff 	call 80004544 <IfxVadc_enableAccess>

    // VADC Config: enable ADC group sync
    {
        Ifx_VADC_GLOBCFG vadcGlobCfg;
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
8000461c:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
        vadcGlobCfg.B.DCMSB = 1;
80004620:	b7 1f 81 f3 	insert %d15,%d15,1,7,1

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004624:	40 f4       	mov.aa %a4,%a15
        vadcGlobCfg.U       = vadc->GLOBCFG.U;
        vadcGlobCfg.B.DIVWC = 1;
        vadcGlobCfg.B.DCMSB = 1;

        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
        vadc->GLOBCFG.U = vadcGlobCfg.U;
80004626:	59 ff 00 20 	st.w [%a15]128,%d15
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000462a:	3b f0 01 40 	mov %d4,31
8000462e:	6d ff 6f ff 	call 8000450c <IfxVadc_disableAccess>
    }

    if (ccu6Num == 0)
80004632:	df 08 1a 80 	jne %d8,0,80004666 <IfxVadc_enableGroupSync+0x68>
    {
        // CCU60 Config
        CCU60_CLC.U = 0;
80004636:	a5 f8 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d8

        if (CCU60_CLC.U)
8000463a:	85 ff 80 82 	ld.w %d15,f0002a00 <_SMALL_DATA4_+0x3fffaa00>
        {}

        CCU60_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
8000463e:	82 4f       	mov %d15,4
80004640:	a5 ff 94 92 	st.w f0002a54 <_SMALL_DATA4_+0x3fffaa54>,%d15
        CCU60_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
80004644:	a5 ff 9c 92 	st.w f0002a5c <_SMALL_DATA4_+0x3fffaa5c>,%d15
        CCU60_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004648:	85 ff 80 a2 	ld.w %d15,f0002a80 <_SMALL_DATA4_+0x3fffaa80>
8000464c:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
80004650:	a5 ff 80 a2 	st.w f0002a80 <_SMALL_DATA4_+0x3fffaa80>,%d15
        CCU60_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
80004654:	3b 00 20 f4 	mov %d15,16896
80004658:	a5 ff b8 92 	st.w f0002a78 <_SMALL_DATA4_+0x3fffaa78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 0;                                                                  // CCU60_COUT63 routed to output signal CCU6061 TRIG1
8000465c:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
80004660:	8f 8f c3 f1 	andn %d15,%d15,56
80004664:	3c 1d       	j 8000469e <IfxVadc_enableGroupSync+0xa0>
    }
    else if (ccu6Num == 1)
80004666:	df 18 1e 80 	jne %d8,1,800046a2 <IfxVadc_enableGroupSync+0xa4>
    {
        // CCU60 + CCU61 Config
        CCU60_CLC.U = 0;
8000466a:	82 0f       	mov %d15,0
8000466c:	a5 ff 80 82 	st.w f0002a00 <_SMALL_DATA4_+0x3fffaa00>,%d15
        CCU61_CLC.U = 0;
80004670:	a5 ff 80 c2 	st.w f0002b00 <_SMALL_DATA4_+0x3fffab00>,%d15

        if (CCU61_CLC.U)
80004674:	85 ff 80 c2 	ld.w %d15,f0002b00 <_SMALL_DATA4_+0x3fffab00>
        {}

        CCU61_T13PR.U          = 4;                                                                  // results in  4+1 clock periods (100MHz)  = 20MHz
80004678:	82 4f       	mov %d15,4
8000467a:	a5 ff 94 d2 	st.w f0002b54 <_SMALL_DATA4_+0x3fffab54>,%d15
        CCU61_CC63SR.U         = 4;                                                                  // configures duty cycle of 40ns low and 10ns high
8000467e:	a5 ff 9c d2 	st.w f0002b5c <_SMALL_DATA4_+0x3fffab5c>,%d15
        CCU61_MODCTR.B.ECT13O  = 1;                                                                  // bit ECT130 = 1 serves to route  CC63ST signals out to  COUT63
80004682:	85 ff 80 e2 	ld.w %d15,f0002b80 <_SMALL_DATA4_+0x3fffab80>
80004686:	b7 ff 81 f7 	insert %d15,%d15,15,15,1
8000468a:	a5 ff 80 e2 	st.w f0002b80 <_SMALL_DATA4_+0x3fffab80>,%d15
        CCU61_TCTR4.U          = (1 << IFX_CCU6_TCTR4_T13STR_OFF) | (1 << IFX_CCU6_TCTR4_T13RS_OFF); // set bit T13STR  & T13RS  -> enable shadow transfer & start timer T13
8000468e:	3b 00 20 f4 	mov %d15,16896
80004692:	a5 ff b8 d2 	st.w f0002b78 <_SMALL_DATA4_+0x3fffab78>,%d15
        CCU60_MOSEL.B.TRIG1SEL = 1;                                                                  // CCU61_COUT63 routed to output signal CCU6061 TRIG1
80004696:	85 ff 8c 82 	ld.w %d15,f0002a0c <_SMALL_DATA4_+0x3fffaa0c>
8000469a:	b7 1f 83 f1 	insert %d15,%d15,1,3,3
8000469e:	a5 ff 8c 82 	st.w f0002a0c <_SMALL_DATA4_+0x3fffaa0c>,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
800046a2:	02 94       	mov %d4,%d9
800046a4:	1d 00 ba 15 	j 80007218 <IfxScuWdt_setCpuEndinit>

800046a8 <IfxVadc_getAdcAnalogFrequency>:
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
800046a8:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
800046aa:	6d 00 be 0c 	call 80006026 <IfxScuCcu_getSpbFrequency>
800046ae:	19 ff 00 20 	ld.w %d15,[%a15]128
800046b2:	16 1f       	and %d15,31
800046b4:	c2 1f       	add %d15,1
800046b6:	4b 0f 41 f1 	itof %d15,%d15
}
800046ba:	4b f2 51 20 	div.f %d2,%d2,%d15
800046be:	00 90       	ret 

800046c0 <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
800046c0:	40 4f       	mov.aa %a15,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
800046c2:	6d 00 b2 0c 	call 80006026 <IfxScuCcu_getSpbFrequency>
800046c6:	19 ff 00 20 	ld.w %d15,[%a15]128
800046ca:	37 0f 62 f4 	extr.u %d15,%d15,8,2
800046ce:	c2 1f       	add %d15,1
800046d0:	4b 0f 41 f1 	itof %d15,%d15
}
800046d4:	4b f2 51 20 	div.f %d2,%d2,%d15
800046d8:	00 90       	ret 

800046da <IfxVadc_getAdcModuleFrequency>:


float32 IfxVadc_getAdcModuleFrequency(void)
{
    return IfxScuCcu_getSpbFrequency();
800046da:	1d 00 a6 0c 	j 80006026 <IfxScuCcu_getSpbFrequency>

800046de <IfxVadc_getBackgroundScanStatus>:
}


IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
800046de:	82 0f       	mov %d15,0
800046e0:	a0 7f       	mov.a %a15,7
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
    {
        if (vadc->BRSPND[i].U)
800046e2:	1b 0f 07 20 	addi %d2,%d15,112
800046e6:	01 42 02 26 	addsc.a %a2,%a4,%d2,2
800046ea:	54 22       	ld.w %d2,[%a2]
800046ec:	f6 24       	jnz %d2,800046f4 <IfxVadc_getBackgroundScanStatus+0x16>
800046ee:	c2 1f       	add %d15,1
IfxVadc_Status IfxVadc_getBackgroundScanStatus(Ifx_VADC *vadc)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    uint8          i;

    for (i = 0; i < IFXVADC_NUM_ADC_GROUPS; i++)
800046f0:	fc f9       	loop %a15,800046e2 <IfxVadc_getBackgroundScanStatus+0x4>
800046f2:	00 90       	ret 
    {
        if (vadc->BRSPND[i].U)
        {
            return IfxVadc_Status_channelsStillPending;
800046f4:	82 62       	mov %d2,6
            continue;
        }
    }

    return status;
}
800046f6:	00 90       	ret 

800046f8 <IfxVadc_getQueueStatus>:
IfxVadc_Status IfxVadc_getQueueStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    /* just fill level is checked */
    if (0x7 == group->QSR0.B.FILL)
800046f8:	19 42 08 20 	ld.w %d2,[%a4]136
800046fc:	8f f2 00 21 	and %d2,%d2,15
    {
        status = IfxVadc_Status_queueFull;
    }
    else
    {
        status = IfxVadc_Status_noError;
80004700:	8b 72 00 22 	eq %d2,%d2,7
    }

    return status;
}
80004704:	06 22       	sh %d2,2
80004706:	00 90       	ret 

80004708 <IfxVadc_getResultBasedOnRequestSource>:
Ifx_VADC_RES IfxVadc_getResultBasedOnRequestSource(Ifx_VADC *vadc, Ifx_VADC_G *group, IfxVadc_ChannelId channel, IfxVadc_RequestSource sourceType)
{
    sint32       sourceResultRegister = -1;
    Ifx_VADC_RES tmpResult;

    switch (sourceType)
80004708:	df 15 09 00 	jeq %d5,1,8000471a <IfxVadc_getResultBasedOnRequestSource+0x12>
8000470c:	76 54       	jz %d5,80004714 <IfxVadc_getResultBasedOnRequestSource+0xc>
8000470e:	df 25 0b 00 	jeq %d5,2,80004724 <IfxVadc_getResultBasedOnRequestSource+0x1c>
80004712:	3c 39       	j 80004784 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    {
    case IfxVadc_RequestSource_queue:
        sourceResultRegister = group->QCTRL0.B.SRCRESREG;
80004714:	19 5f 00 20 	ld.w %d15,[%a5]128
80004718:	3c 03       	j 8000471e <IfxVadc_getResultBasedOnRequestSource+0x16>
        break;

    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
8000471a:	19 5f 20 20 	ld.w %d15,[%a5]160
8000471e:	16 0f       	and %d15,15
    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
        break;
    }

    if (sourceResultRegister > 0)
80004720:	ee 39       	jnz %d15,80004792 <IfxVadc_getResultBasedOnRequestSource+0x8a>
80004722:	3c 31       	j 80004784 <IfxVadc_getResultBasedOnRequestSource+0x7c>
    case IfxVadc_RequestSource_scan:
        sourceResultRegister = group->ASCTRL.B.SRCRESREG;
        break;

    case IfxVadc_RequestSource_background:
        sourceResultRegister = vadc->BRSCTRL.B.SRCRESREG;
80004724:	19 4f 00 80 	ld.w %d15,[%a4]512
80004728:	16 0f       	and %d15,15
        break;
    }

    if (sourceResultRegister > 0)
8000472a:	ee 34       	jnz %d15,80004792 <IfxVadc_getResultBasedOnRequestSource+0x8a>

        return tmpResult;
    }
    else
    {
        if ((sourceType == IfxVadc_RequestSource_background) && (group->CHCTR[channel].B.RESTBS == 1))
8000472c:	1b 04 06 f0 	addi %d15,%d4,96
80004730:	90 5f       	addsc.a %a15,%a5,%d15,2
80004732:	4c f0       	ld.w %d15,[%a15]0
80004734:	ef 4f 28 00 	jz.t %d15,20,80004784 <IfxVadc_getResultBasedOnRequestSource+0x7c>
        {
            tmpResult.B.VF     = vadc->GLOBRES.B.VF;
80004738:	19 42 00 c0 	ld.w %d2,[%a4]768
8000473c:	82 0f       	mov %d15,0
8000473e:	67 2f 9f ff 	ins.t %d15,%d15,31,%d2,31
            tmpResult.B.FCR    = vadc->GLOBRES.B.FCR;
80004742:	19 42 00 c0 	ld.w %d2,[%a4]768
80004746:	67 2f 1e ff 	ins.t %d15,%d15,30,%d2,30
            tmpResult.B.CRS    = vadc->GLOBRES.B.CRS;
8000474a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000474e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80004752:	37 2f 02 fe 	insert %d15,%d15,%d2,28,2
            tmpResult.B.EMUX   = vadc->GLOBRES.B.EMUX;
80004756:	19 42 00 c0 	ld.w %d2,[%a4]768
8000475a:	37 02 e3 2c 	extr.u %d2,%d2,25,3
8000475e:	37 2f 83 fc 	insert %d15,%d15,%d2,25,3
            tmpResult.B.CHNR   = vadc->GLOBRES.B.CHNR;
80004762:	19 42 00 c0 	ld.w %d2,[%a4]768
80004766:	37 02 65 2a 	extr.u %d2,%d2,20,5
8000476a:	37 2f 05 fa 	insert %d15,%d15,%d2,20,5
            tmpResult.B.DRC    = vadc->GLOBRES.B.GNR; //The bitfields are the same but interpretation is different. TODO- define a generic result register type.
8000476e:	19 42 00 c0 	ld.w %d2,[%a4]768
80004772:	37 02 64 28 	extr.u %d2,%d2,16,4
80004776:	37 2f 04 f8 	insert %d15,%d15,%d2,16,4
            tmpResult.B.RESULT = vadc->GLOBRES.B.RESULT;
8000477a:	19 42 00 c0 	ld.w %d2,[%a4]768
8000477e:	37 2f 10 20 	insert %d2,%d15,%d2,0,16

            return tmpResult;
80004782:	00 90       	ret 
        }
        else
        {
            tmpResult.U = group->RES[group->CHCTR[channel].B.RESREG].U;
80004784:	1b 04 06 40 	addi %d4,%d4,96
80004788:	01 54 02 f6 	addsc.a %a15,%a5,%d4,2
8000478c:	4c f0       	ld.w %d15,[%a15]0
8000478e:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004792:	1b 0f 0a f0 	addi %d15,%d15,160
80004796:	90 55       	addsc.a %a5,%a5,%d15,2
80004798:	54 52       	ld.w %d2,[%a5]

            return tmpResult;
8000479a:	00 90       	ret 

8000479c <IfxVadc_getScanStatus>:

IfxVadc_Status IfxVadc_getScanStatus(Ifx_VADC_G *group)
{
    IfxVadc_Status status = IfxVadc_Status_noError;

    if (group->ASPND.U)
8000479c:	19 42 2c 20 	ld.w %d2,[%a4]172
    }
    else
    {
        return status;
    }
}
800047a0:	ab 62 a0 22 	seln %d2,%d2,%d2,6
800047a4:	00 90       	ret 

800047a6 <IfxVadc_getSrcAddress>:

volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
800047a6:	bf 45 0a 80 	jlt.u %d5,4,800047ba <IfxVadc_getSrcAddress+0x14>
    {
        index -= 4;
800047aa:	9a c5       	add %d15,%d5,-4
800047ac:	8f ff 0f 51 	and %d5,%d15,255

        if ((group & 0x1) != 0)
800047b0:	8f 14 00 41 	and %d4,%d4,1
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
800047b4:	da 08       	mov %d15,8
800047b6:	ab 9f a0 44 	seln %d4,%d4,%d15,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
800047ba:	13 44 20 45 	madd %d4,%d5,%d4,4
800047be:	91 00 00 f8 	movh.a %a15,32768
800047c2:	d9 ff 58 00 	lea %a15,[%a15]1048 <80000418 <IfxVadc_cfg_srcAddresses>>
800047c6:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2

    return &(base[0]);
}
800047ca:	c8 02       	ld.a %a2,[%a15]0
800047cc:	00 90       	ret 

800047ce <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800047ce:	19 4f 00 20 	ld.w %d15,[%a4]128
    return &(base[0]);
}


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
800047d2:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
800047d4:	37 4f 02 f4 	insert %d15,%d15,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047d8:	3b f0 01 40 	mov %d4,31
800047dc:	6d ff b4 fe 	call 80004544 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
800047e0:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047e4:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
800047e6:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800047ea:	3b f0 01 40 	mov %d4,31
800047ee:	1d ff 8f fe 	j 8000450c <IfxVadc_disableAccess>

800047f2 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
800047f2:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
}


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
800047f6:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
800047f8:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800047fc:	3b f0 01 40 	mov %d4,31
80004800:	6d ff a2 fe 	call 80004544 <IfxVadc_enableAccess>
void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
80004804:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004808:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.DIVA  = converterClockDivider;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
8000480a:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000480e:	3b f0 01 40 	mov %d4,31
80004812:	1d ff 7d fe 	j 8000450c <IfxVadc_disableAccess>

80004816 <IfxVadc_initializeFAdcD>:
}


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
80004816:	02 4f       	mov %d15,%d4
80004818:	40 4f       	mov.aa %a15,%a4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
8000481a:	6d 00 06 0c 	call 80006026 <IfxScuCcu_getSpbFrequency>
8000481e:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
80004822:	4b f2 11 42 	div.u %e4,%d2,%d15
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004826:	82 3f       	mov %d15,3
80004828:	c2 f4       	add %d4,-1
8000482a:	0b f4 90 41 	min.u %d4,%d4,%d15

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
8000482e:	1b 14 00 80 	addi %d8,%d4,1
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004832:	40 f4       	mov.aa %a4,%a15

    divD   = (fadc / fAdcD - 1);

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80004834:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80004838:	6d ff cb ff 	call 800047ce <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
8000483c:	02 82       	mov %d2,%d8
8000483e:	00 90       	ret 

80004840 <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
80004840:	02 4f       	mov %d15,%d4
80004842:	40 4f       	mov.aa %a15,%a4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80004844:	6d 00 f1 0b 	call 80006026 <IfxScuCcu_getSpbFrequency>
80004848:	4b 02 71 21 	ftouz %d2,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
8000484c:	8f 22 00 40 	sh %d4,%d2,2
80004850:	4b f4 11 42 	div.u %e4,%d4,%d15
80004854:	3b f0 01 50 	mov %d5,31

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80004858:	c2 24       	add %d4,2
8000485a:	06 e4       	sh %d4,-2
    divA   = __minu(divA - 1, 0x1Fu);
8000485c:	c2 f4       	add %d4,-1
8000485e:	0b 54 90 41 	min.u %d4,%d4,%d5
    result = fadc / (divA + 1);
80004862:	1b 14 00 30 	addi %d3,%d4,1
80004866:	4b 32 11 62 	div.u %e6,%d2,%d3
8000486a:	02 6f       	mov %d15,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
8000486c:	7b 10 13 60 	movh %d6,305
80004870:	1b 16 d0 62 	addi %d6,%d6,11521
80004874:	3f 6f 08 80 	jlt.u %d15,%d6,80004884 <IfxVadc_initializeFAdcI+0x44>
80004878:	0b 53 90 41 	min.u %d4,%d3,%d5
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
8000487c:	9a 14       	add %d15,%d4,1
8000487e:	4b f2 11 22 	div.u %e2,%d2,%d15
80004882:	02 2f       	mov %d15,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80004884:	1b 0f ee 25 	addi %d2,%d15,24288
80004888:	7b a0 12 30 	movh %d3,298
8000488c:	9b 82 ff 2f 	addih %d2,%d2,65528
80004890:	1b 13 be 38 	addi %d3,%d3,-29727
80004894:	7f 32 06 80 	jge.u %d2,%d3,800048a0 <IfxVadc_initializeFAdcI+0x60>
    {
        result = 0;             /* Min / Max FAdcI frequency */
    }
    else
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80004898:	40 f4       	mov.aa %a4,%a15
8000489a:	6d ff ac ff 	call 800047f2 <IfxVadc_initialiseAdcConverterClock>
8000489e:	3c 02       	j 800048a2 <IfxVadc_initializeFAdcI+0x62>
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
    {
        result = 0;             /* Min / Max FAdcI frequency */
800048a0:	82 0f       	mov %d15,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
800048a2:	02 f2       	mov %d2,%d15
800048a4:	00 90       	ret 

800048a6 <IfxVadc_isPostCalibration>:
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
        break;
    default: pcEnabled                = FALSE;
800048a6:	82 02       	mov %d2,0

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
800048a8:	ff 84 33 80 	jge.u %d4,8,8000490e <IfxVadc_isPostCalibration+0x68>
800048ac:	91 00 00 f8 	movh.a %a15,32768
800048b0:	d9 ff 80 34 	lea %a15,[%a15]18624 <800048c0 <IfxVadc_isPostCalibration+0x1a>>
800048b4:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
        break;
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
        break;
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
        break;
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
800048b8:	19 42 00 20 	ld.w %d2,[%a4]128

boolean IfxVadc_isPostCalibration(Ifx_VADC *vadc, IfxVadc_GroupId group)
{
    boolean pcEnabled;

    switch (group)
800048bc:	dc 0f       	ji %a15
800048be:	00 00       	nop 
800048c0:	1d 00 10 00 	j 800048e0 <IfxVadc_isPostCalibration+0x3a>
800048c4:	1d 00 11 00 	j 800048e6 <IfxVadc_isPostCalibration+0x40>
800048c8:	1d 00 12 00 	j 800048ec <IfxVadc_isPostCalibration+0x46>
800048cc:	1d 00 13 00 	j 800048f2 <IfxVadc_isPostCalibration+0x4c>
800048d0:	1d 00 14 00 	j 800048f8 <IfxVadc_isPostCalibration+0x52>
800048d4:	1d 00 15 00 	j 800048fe <IfxVadc_isPostCalibration+0x58>
800048d8:	1d 00 16 00 	j 80004904 <IfxVadc_isPostCalibration+0x5e>
800048dc:	1d 00 17 00 	j 8000490a <IfxVadc_isPostCalibration+0x64>
    {
    case IfxVadc_GroupId_0: pcEnabled = vadc->GLOBCFG.B.DPCAL0 == 0;
800048e0:	07 22 10 28 	nand.t %d2,%d2,16,%d2,16
        break;
800048e4:	00 90       	ret 
    case IfxVadc_GroupId_1: pcEnabled = vadc->GLOBCFG.B.DPCAL1 == 0;
800048e6:	07 22 91 28 	nand.t %d2,%d2,17,%d2,17
        break;
800048ea:	00 90       	ret 
    case IfxVadc_GroupId_2: pcEnabled = vadc->GLOBCFG.B.DPCAL2 == 0;
800048ec:	07 22 12 29 	nand.t %d2,%d2,18,%d2,18
        break;
800048f0:	00 90       	ret 
    case IfxVadc_GroupId_3: pcEnabled = vadc->GLOBCFG.B.DPCAL3 == 0;
800048f2:	07 22 93 29 	nand.t %d2,%d2,19,%d2,19
        break;
800048f6:	00 90       	ret 
    case IfxVadc_GroupId_4: pcEnabled = vadc->GLOBCFG.B.DPCAL4 == 0;
800048f8:	07 22 14 2a 	nand.t %d2,%d2,20,%d2,20
        break;
800048fc:	00 90       	ret 
    case IfxVadc_GroupId_5: pcEnabled = vadc->GLOBCFG.B.DPCAL5 == 0;
800048fe:	07 22 95 2a 	nand.t %d2,%d2,21,%d2,21
        break;
80004902:	00 90       	ret 
    case IfxVadc_GroupId_6: pcEnabled = vadc->GLOBCFG.B.DPCAL6 == 0;
80004904:	07 22 16 2b 	nand.t %d2,%d2,22,%d2,22
        break;
80004908:	00 90       	ret 
    case IfxVadc_GroupId_7: pcEnabled = vadc->GLOBCFG.B.DPCAL7 == 0;
8000490a:	07 22 97 2b 	nand.t %d2,%d2,23,%d2,23
    default: pcEnabled                = FALSE;
        break;
    }

    return pcEnabled;
}
8000490e:	00 90       	ret 

80004910 <IfxVadc_getChannelConversionTime>:
    return status;
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
80004910:	02 40       	mov %d0,%d4
80004912:	02 68       	mov %d8,%d6
80004914:	02 7a       	mov %d10,%d7
80004916:	14 a4       	ld.bu %d4,[%sp]
    IfxVadc_ChannelResolution resolution;
    uint32                    n;

    uint32                    inputClassNum;

    if (inputClass <= IfxVadc_InputClasses_group1)
80004918:	ff 25 08 80 	jge.u %d5,2,80004928 <IfxVadc_getChannelConversionTime+0x18>
    {
        inputClassNum = inputClass;
        stcs          = vadcG->ICLASS[inputClassNum].B.STCS;
8000491c:	8f 80 00 f0 	sh %d15,%d0,8
80004920:	42 f5       	add %d5,%d15
80004922:	1b 85 12 50 	addi %d5,%d5,296
80004926:	3c 03       	j 8000492c <IfxVadc_getChannelConversionTime+0x1c>
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004928:	1b 65 02 50 	addi %d5,%d5,38
8000492c:	01 45 02 f6 	addsc.a %a15,%a4,%d5,2
80004930:	4c f0       	ld.w %d15,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
80004932:	48 03       	ld.w %d3,[%a15]0
        resolution    = (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
80004934:	16 1f       	and %d15,31
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
    }

    if (stcs > 16)
80004936:	8b 1f 61 22 	lt.u %d2,%d15,17
    }
    else
    {
        inputClassNum = inputClass - IfxVadc_InputClasses_global0;
        stcs          = vadc->GLOBICLASS[inputClassNum].B.STCS;
        resolution    = (IfxVadc_ChannelResolution)vadc->GLOBICLASS[inputClassNum].B.CMS;
8000493a:	37 03 63 34 	extr.u %d3,%d3,8,3
    }

    if (stcs > 16)
8000493e:	f6 24       	jnz %d2,80004946 <IfxVadc_getChannelConversionTime+0x36>
    {
        stcs = (stcs - 15) * 16; // Reference for the logic: Table 28-4 of TC29xB User Manual v1.3
80004940:	1b 1f ff ff 	addi %d15,%d15,-15
80004944:	06 4f       	sh %d15,4
80004946:	ff 63 35 80 	jge.u %d3,6,800049b0 <IfxVadc_getChannelConversionTime+0xa0>
8000494a:	91 00 00 f8 	movh.a %a15,32768
8000494e:	d9 ff 50 00 	lea %a15,[%a15]1040 <80000410 <CSWTCH.25>>
80004952:	01 f3 00 f6 	addsc.a %a15,%a15,%d3,0
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
80004956:	82 02       	mov %d2,0
80004958:	08 09       	ld.bu %d9,[%a15]0
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
8000495a:	df 04 2f 80 	jne %d4,0,800049b8 <IfxVadc_getChannelConversionTime+0xa8>
    {
        if (resolution != IfxVadc_ChannelResolution_10bitFast)
8000495e:	df 53 0d 00 	jeq %d3,5,80004978 <IfxVadc_getChannelConversionTime+0x68>
        {
            /* Standard conversion */
            uint32 pc = IfxVadc_isPostCalibration(vadc, group) ? 2 : 0;
80004962:	02 04       	mov %d4,%d0
80004964:	6d ff a1 ff 	call 800048a6 <IfxVadc_isPostCalibration>
80004968:	92 24       	add %d4,%d15,2
8000496a:	ab 22 a0 22 	seln %d2,%d2,%d2,2
8000496e:	42 94       	add %d4,%d9
            conversionTime = (float32)(2 + stcs + n + pc) / analogFrequency + 2.0 / moduleFrequency;
80004970:	42 24       	add %d4,%d2
80004972:	4b 04 41 41 	itof %d4,%d4
80004976:	3c 04       	j 8000497e <IfxVadc_getChannelConversionTime+0x6e>
        }
        else
        {
            /* Fast compare mode */
            conversionTime = (float32)(2 + stcs + 2) / analogFrequency + 2.0 / moduleFrequency;
80004978:	c2 4f       	add %d15,4
8000497a:	4b 0f 41 41 	itof %d4,%d15
8000497e:	4b 84 51 40 	div.f %d4,%d4,%d8
80004982:	6d 00 a8 38 	call 8000bad2 <__extendsfdf2>
80004986:	02 a4       	mov %d4,%d10
80004988:	0b 23 10 88 	mov %e8,%d3,%d2
8000498c:	6d 00 a3 38 	call 8000bad2 <__extendsfdf2>
80004990:	b7 00 21 4f 	imask %e4,0,30,1
80004994:	0b 23 10 68 	mov %e6,%d3,%d2
80004998:	6d 00 92 3a 	call 8000bebc <__divdf3>
8000499c:	0b 89 10 48 	mov %e4,%d9,%d8
800049a0:	0b 23 10 68 	mov %e6,%d3,%d2
800049a4:	6d 00 7e 39 	call 8000bca0 <__adddf3>
800049a8:	0b 23 10 48 	mov %e4,%d3,%d2
800049ac:	1d 00 47 3b 	j 8000c03a <__truncdfsf2>
        break;
    default: n                                  = 0;
        break;
    }

    if (conversionMode == IfxVadc_ConversionType_Compatible)
800049b0:	82 09       	mov %d9,0
800049b2:	df 04 d8 7f 	jeq %d4,0,80004962 <IfxVadc_getChannelConversionTime+0x52>
}


float32 IfxVadc_getChannelConversionTime(Ifx_VADC *vadc, IfxVadc_GroupId group, IfxVadc_InputClasses inputClass, float32 analogFrequency, float32 moduleFrequency, IfxVadc_ConversionType conversionMode)
{
    float32                   conversionTime = 0.0;
800049b6:	82 02       	mov %d2,0
    {
        // do nothing
    }

    return conversionTime;
}
800049b8:	00 90       	ret 

800049ba <IfxVadc_resetKernel>:
    return pcEnabled;
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
800049ba:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800049bc:	6d 00 f9 13 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800049c0:	02 24       	mov %d4,%d2
}


void IfxVadc_resetKernel(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800049c2:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800049c4:	6d 00 f5 12 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800049c8:	3b f0 01 40 	mov %d4,31
800049cc:	40 f4       	mov.aa %a4,%a15
800049ce:	6d ff bb fd 	call 80004544 <IfxVadc_enableAccess>
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
800049d2:	48 c2       	ld.w %d2,[%a15]48
    vadc->KRST0.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
800049d4:	02 f4       	mov %d4,%d15
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->KRST1.B.RST = 1;      /* Only if both Kernel reset bits are set a reset is executed */
800049d6:	8f 12 40 21 	or %d2,%d2,1
800049da:	68 c2       	st.w [%a15]48,%d2
    vadc->KRST0.B.RST = 1;
800049dc:	48 d2       	ld.w %d2,[%a15]52
800049de:	8f 12 40 21 	or %d2,%d2,1
800049e2:	68 d2       	st.w [%a15]52,%d2
    IfxScuWdt_setCpuEndinit(passwd);
800049e4:	6d 00 1a 14 	call 80007218 <IfxScuWdt_setCpuEndinit>

    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */
800049e8:	48 d2       	ld.w %d2,[%a15]52
800049ea:	6f 12 ff 7f 	jz.t %d2,1,800049e8 <IfxVadc_resetKernel+0x2e>

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
800049ee:	02 f4       	mov %d4,%d15
800049f0:	6d 00 df 12 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
800049f4:	48 b2       	ld.w %d2,[%a15]44
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800049f6:	3b f0 01 40 	mov %d4,31
    while (vadc->KRST0.B.RSTSTAT == 0)  /* Wait until reset is executed */

    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->KRSTCLR.B.CLR = 1;    /* Clear Kernel reset status bit */
800049fa:	8f 12 40 21 	or %d2,%d2,1
800049fe:	68 b2       	st.w [%a15]44,%d2
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a00:	40 f4       	mov.aa %a4,%a15
80004a02:	6d ff 85 fd 	call 8000450c <IfxVadc_disableAccess>
    IfxScuWdt_setCpuEndinit(passwd);
80004a06:	02 f4       	mov %d4,%d15
80004a08:	1d 00 08 14 	j 80007218 <IfxScuWdt_setCpuEndinit>

80004a0c <IfxVadc_selectPowerSupplyVoltage>:


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80004a0c:	19 4f 00 20 	ld.w %d15,[%a4]128
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80004a10:	40 4f       	mov.aa %a15,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80004a12:	67 4f 0e f0 	ins.t %d15,%d15,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a16:	3b f0 01 40 	mov %d4,31
80004a1a:	6d ff 95 fd 	call 80004544 <IfxVadc_enableAccess>
void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
80004a1e:	b7 1f 81 f7 	insert %d15,%d15,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a22:	40 f4       	mov.aa %a4,%a15
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
    tempGLOBCFG.B.LOSUP = supplyVoltage;
    tempGLOBCFG.B.DIVWC = 1;
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80004a24:	59 ff 00 20 	st.w [%a15]128,%d15
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a28:	3b f0 01 40 	mov %d4,31
80004a2c:	1d ff 70 fd 	j 8000450c <IfxVadc_disableAccess>

80004a30 <IfxVadc_setArbiterPriority>:
}


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80004a30:	1b 87 01 f0 	addi %d15,%d7,24
    if (slotEnable != FALSE)
80004a34:	df 04 23 00 	jeq %d4,0,80004a7a <IfxVadc_setArbiterPriority+0x4a>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80004a38:	19 42 04 00 	ld.w %d2,[%a4]4
80004a3c:	0f f4 00 40 	sh %d4,%d4,%d15
80004a40:	a6 24       	or %d4,%d2
80004a42:	59 44 04 00 	st.w [%a4]4,%d4
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80004a46:	19 42 04 00 	ld.w %d2,[%a4]4
80004a4a:	06 27       	sh %d7,2
80004a4c:	82 3f       	mov %d15,3
80004a4e:	0f 7f 00 f0 	sh %d15,%d15,%d7
80004a52:	0f f2 e0 f0 	andn %d15,%d2,%d15
80004a56:	6c 41       	st.w [%a4]4,%d15
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80004a58:	4c 41       	ld.w %d15,[%a4]4
80004a5a:	0f 75 00 50 	sh %d5,%d5,%d7
80004a5e:	a6 f5       	or %d5,%d15
80004a60:	59 45 04 00 	st.w [%a4]4,%d5

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004a64:	4c 41       	ld.w %d15,[%a4]4
80004a66:	c2 37       	add %d7,3
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80004a68:	76 64       	jz %d6,80004a70 <IfxVadc_setArbiterPriority+0x40>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80004a6a:	d7 1f 01 77 	insert %d7,%d15,1,%d7,1
80004a6e:	3c 03       	j 80004a74 <IfxVadc_setArbiterPriority+0x44>
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80004a70:	d7 0f 01 77 	insert %d7,%d15,0,%d7,1
80004a74:	59 47 04 00 	st.w [%a4]4,%d7
80004a78:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80004a7a:	19 44 04 00 	ld.w %d4,[%a4]4
80004a7e:	d7 04 01 ff 	insert %d15,%d4,0,%d15,1
80004a82:	6c 41       	st.w [%a4]4,%d15
80004a84:	00 90       	ret 

80004a86 <IfxVadc_setScan>:

void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80004a86:	19 4f 28 20 	ld.w %d15,[%a4]168
80004a8a:	26 54       	and %d4,%d5
80004a8c:	0f 5f e0 f0 	andn %d15,%d15,%d5
80004a90:	0f 4f a0 50 	or %d5,%d15,%d4
80004a94:	59 45 28 20 	st.w [%a4]168,%d5
80004a98:	00 90       	ret 

80004a9a <IfxVadc_startupCalibration>:
{
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004a9a:	3b f0 01 40 	mov %d4,31
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004a9e:	40 4f       	mov.aa %a15,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80004aa0:	6d ff 52 fd 	call 80004544 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80004aa4:	19 ff 00 20 	ld.w %d15,[%a15]128
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80004aa8:	40 f4       	mov.aa %a4,%a15
80004aaa:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80004aae:	3b f0 01 40 	mov %d4,31
80004ab2:	59 ff 00 20 	st.w [%a15]128,%d15
80004ab6:	6d ff 2b fd 	call 8000450c <IfxVadc_disableAccess>
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
}


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80004aba:	82 02       	mov %d2,0

    /* Wait for hardware self-test and calibration to complete */
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;
80004abc:	82 0f       	mov %d15,0
80004abe:	a0 72       	mov.a %a2,7


IFX_INLINE uint8 IfxVadc_getAdcCalibrationActiveState(Ifx_VADC *vadc, uint8 adcCalGroupNum)
{
    uint8 status;
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80004ac0:	8f a2 00 30 	sh %d3,%d2,10
80004ac4:	01 f3 00 36 	addsc.a %a3,%a15,%d3,0
80004ac8:	c2 12       	add %d2,1
80004aca:	19 33 40 20 	ld.w %d3,[%a3]1152
80004ace:	37 03 61 3e 	extr.u %d3,%d3,28,1

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
            {
                calibrationRunning = TRUE;
80004ad2:	ab 1f a0 f3 	seln %d15,%d3,%d15,1
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80004ad6:	fc 25       	loop %a2,80004ac0 <IfxVadc_startupCalibration+0x26>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80004ad8:	df 1f f1 7f 	jeq %d15,1,80004aba <IfxVadc_startupCalibration+0x20>
}
80004adc:	00 90       	ret 
	...

80004ae0 <IfxAsclin_disableModule>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
80004ae0:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004ae2:	6d 00 66 13 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004ae6:	02 24       	mov %d4,%d2
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004ae8:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);            /* clears the endinit protection*/
80004aea:	6d 00 62 12 	call 80006fae <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80004aee:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclin); /* disables the module*/
    IfxScuWdt_setCpuEndinit(psw);              /* sets the endinit protection back on*/
80004af0:	02 f4       	mov %d4,%d15
80004af2:	8f 12 40 21 	or %d2,%d2,1
80004af6:	68 02       	st.w [%a15]0,%d2
80004af8:	1d 00 90 13 	j 80007218 <IfxScuWdt_setCpuEndinit>

80004afc <IfxAsclin_enableAscErrorFlags>:
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80004afc:	7b 10 00 f0 	movh %d15,1
80004b00:	ab 0f 80 44 	sel %d4,%d4,%d15,0
80004b04:	19 4f 00 10 	ld.w %d15,[%a4]64
80004b08:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80004b0c:	a6 f4       	or %d4,%d15
80004b0e:	59 44 00 10 	st.w [%a4]64,%d4
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80004b12:	7b 00 40 f0 	movh %d15,1024
80004b16:	ab 0f 80 55 	sel %d5,%d5,%d15,0
80004b1a:	19 4f 00 10 	ld.w %d15,[%a4]64
80004b1e:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80004b22:	a6 f5       	or %d5,%d15
80004b24:	59 45 00 10 	st.w [%a4]64,%d5
80004b28:	00 90       	ret 

80004b2a <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80004b2a:	40 4f       	mov.aa %a15,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004b2c:	6d 00 41 13 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004b30:	02 24       	mov %d4,%d2
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004b32:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80004b34:	6d 00 3d 12 	call 80006fae <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80004b38:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80004b3a:	02 f4       	mov %d4,%d15
80004b3c:	8f 12 c0 21 	andn %d2,%d2,1
80004b40:	68 02       	st.w [%a15]0,%d2
80004b42:	1d 00 6b 13 	j 80007218 <IfxScuWdt_setCpuEndinit>

80004b46 <IfxAsclin_getAddress>:
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
80004b46:	a0 02       	mov.a %a2,0

Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
80004b48:	ff 44 09 00 	jge %d4,4,80004b5a <IfxAsclin_getAddress+0x14>
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
80004b4c:	91 00 00 f8 	movh.a %a15,32768
80004b50:	d9 ff a8 d0 	lea %a15,[%a15]2920 <80000b68 <IfxAsclin_cfg_indexMap>>
80004b54:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
80004b58:	c8 02       	ld.a %a2,[%a15]0
    {
        module = NULL_PTR;
    }

    return module;
}
80004b5a:	00 90       	ret 

80004b5c <IfxAsclin_getFaFrequency>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004b5c:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004b60:	16 1f       	and %d15,31
float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80004b62:	c2 ff       	add %d15,-1
80004b64:	8b 0f a1 22 	ge.u %d2,%d15,16
80004b68:	df 02 32 80 	jne %d2,0,80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b6c:	91 00 00 f8 	movh.a %a15,32768
80004b70:	d9 ff b8 d4 	lea %a15,[%a15]19320 <80004b78 <IfxAsclin_getFaFrequency+0x1c>>
80004b74:	90 ff       	addsc.a %a15,%a15,%d15,2
80004b76:	dc 0f       	ji %a15
80004b78:	1d 00 20 00 	j 80004bb8 <IfxAsclin_getFaFrequency+0x5c>
80004b7c:	1d 00 20 00 	j 80004bbc <IfxAsclin_getFaFrequency+0x60>
80004b80:	1d 00 26 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b84:	1d 00 1e 00 	j 80004bc0 <IfxAsclin_getFaFrequency+0x64>
80004b88:	1d 00 22 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b8c:	1d 00 20 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b90:	1d 00 1e 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b94:	1d 00 18 00 	j 80004bc4 <IfxAsclin_getFaFrequency+0x68>
80004b98:	1d 00 1a 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004b9c:	1d 00 18 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004ba0:	1d 00 16 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004ba4:	1d 00 14 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004ba8:	1d 00 12 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004bac:	1d 00 10 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004bb0:	1d 00 0e 00 	j 80004bcc <IfxAsclin_getFaFrequency+0x70>
80004bb4:	1d 00 0a 00 	j 80004bc8 <IfxAsclin_getFaFrequency+0x6c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80004bb8:	1d 00 37 0a 	j 80006026 <IfxScuCcu_getSpbFrequency>
        break;
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80004bbc:	1d 00 a6 08 	j 80005d08 <IfxScuCcu_getOsc0Frequency>
        break;
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80004bc0:	1d 00 c3 08 	j 80005d46 <IfxScuCcu_getPllErayFrequency>
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80004bc4:	1d 00 20 0a 	j 80006004 <IfxScuCcu_getBaud2Frequency>
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80004bc8:	1d 00 0e 0a 	j 80005fe4 <IfxScuCcu_getBaud1Frequency>
        frequency = 0.0;
        break;
    }

    return frequency;
}
80004bcc:	82 02       	mov %d2,0
80004bce:	00 90       	ret 

80004bd0 <IfxAsclin_getIndex>:

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004bd0:	91 00 00 38 	movh.a %a3,32768
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004bd4:	82 0f       	mov %d15,0
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80004bd6:	d9 33 a8 d0 	lea %a3,[%a3]2920 <80000b68 <IfxAsclin_cfg_indexMap>>
80004bda:	a0 3f       	mov.a %a15,3
80004bdc:	d0 32       	addsc.a %a2,%a3,%d15,3
80004bde:	d4 25       	ld.a %a5,[%a2]
80004be0:	7d 45 05 80 	jne.a %a5,%a4,80004bea <IfxAsclin_getIndex+0x1a>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80004be4:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80004be8:	00 90       	ret 
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80004bea:	c2 1f       	add %d15,1
80004bec:	fc f8       	loop %a15,80004bdc <IfxAsclin_getIndex+0xc>
IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;
80004bee:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80004bf0:	00 90       	ret 

80004bf2 <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80004bf2:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80004bf4:	6d ff b4 ff 	call 80004b5c <IfxAsclin_getFaFrequency>
80004bf8:	4c f5       	ld.w %d15,[%a15]20
80004bfa:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004bfe:	c2 1f       	add %d15,1
80004c00:	4b 0f 41 f1 	itof %d15,%d15
}
80004c04:	4b f2 51 20 	div.f %d2,%d2,%d15
80004c08:	00 90       	ret 

80004c0a <IfxAsclin_getOvsFrequency>:
    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
80004c0a:	40 4f       	mov.aa %a15,%a4
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
80004c0c:	6d ff f3 ff 	call 80004bf2 <IfxAsclin_getPdFrequency>
80004c10:	48 83       	ld.w %d3,[%a15]32
80004c12:	4c f8       	ld.w %d15,[%a15]32
80004c14:	37 03 6c 38 	extr.u %d3,%d3,16,12
80004c18:	b7 0f 14 f6 	insert %d15,%d15,0,12,20
80004c1c:	4b 03 41 31 	itof %d3,%d3
80004c20:	4b 0f 41 f1 	itof %d15,%d15
80004c24:	4b 32 41 20 	mul.f %d2,%d2,%d3
}
80004c28:	4b f2 51 20 	div.f %d2,%d2,%d15
80004c2c:	00 90       	ret 

80004c2e <IfxAsclin_getShiftFrequency>:
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
80004c2e:	40 4f       	mov.aa %a15,%a4
    return IfxAsclin_getOvsFrequency(asclin) / asclin->BITCON.B.OVERSAMPLING;
80004c30:	6d ff ed ff 	call 80004c0a <IfxAsclin_getOvsFrequency>
80004c34:	4c f5       	ld.w %d15,[%a15]20
80004c36:	37 0f 64 f8 	extr.u %d15,%d15,16,4
80004c3a:	4b 0f 41 f1 	itof %d15,%d15
}
80004c3e:	4b f2 51 20 	div.f %d2,%d2,%d15
80004c42:	00 90       	ret 

80004c44 <IfxAsclin_getSrcPointerEr>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80004c44:	6d ff c6 ff 	call 80004bd0 <IfxAsclin_getIndex>
80004c48:	53 c2 20 f0 	mul %d15,%d2,12
80004c4c:	60 ff       	mov.a %a15,%d15
80004c4e:	d9 f2 08 28 	lea %a2,[%a15]-32632
}
80004c52:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c56:	00 90       	ret 

80004c58 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80004c58:	6d ff bc ff 	call 80004bd0 <IfxAsclin_getIndex>
80004c5c:	53 c2 20 f0 	mul %d15,%d2,12
80004c60:	60 ff       	mov.a %a15,%d15
80004c62:	d9 f2 04 28 	lea %a2,[%a15]-32636
}
80004c66:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c6a:	00 90       	ret 

80004c6c <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80004c6c:	6d ff b2 ff 	call 80004bd0 <IfxAsclin_getIndex>
80004c70:	53 c2 20 f0 	mul %d15,%d2,12
80004c74:	60 ff       	mov.a %a15,%d15
80004c76:	d9 f2 00 28 	lea %a2,[%a15]-32640
}
80004c7a:	11 42 00 2f 	addih.a %a2,%a2,61444
80004c7e:	00 90       	ret 

80004c80 <IfxAsclin_read16>:


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004c80:	9f 04 04 80 	jned %d4,0,80004c88 <IfxAsclin_read16+0x8>
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}
80004c84:	82 02       	mov %d2,0
80004c86:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
80004c88:	19 4f 08 10 	ld.w %d15,[%a4]72
80004c8c:	ac 50       	st.h [%a5]0,%d15
80004c8e:	b0 25       	add.a %a5,2
80004c90:	3c f8       	j 80004c80 <IfxAsclin_read16>

80004c92 <IfxAsclin_read32>:
    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004c92:	9f 04 04 80 	jned %d4,0,80004c9a <IfxAsclin_read32+0x8>
        *data++ = rxData->U;
        count--;
    }

    return count;
}
80004c96:	82 02       	mov %d2,0
80004c98:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
80004c9a:	19 4f 08 10 	ld.w %d15,[%a4]72
80004c9e:	6c 50       	st.w [%a5]0,%d15
80004ca0:	b0 45       	add.a %a5,4
80004ca2:	3c f8       	j 80004c92 <IfxAsclin_read32>

80004ca4 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004ca4:	9f 04 04 80 	jned %d4,0,80004cac <IfxAsclin_read8+0x8>
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}
80004ca8:	82 02       	mov %d2,0
80004caa:	00 90       	ret 
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
80004cac:	19 4f 08 10 	ld.w %d15,[%a4]72
80004cb0:	2c 50       	st.b [%a5]0,%d15
80004cb2:	b0 15       	add.a %a5,1
80004cb4:	3c f8       	j 80004ca4 <IfxAsclin_read8>

80004cb6 <IfxAsclin_resetModule>:
    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
80004cb6:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004cb8:	6d 00 7b 12 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
80004cbc:	02 24       	mov %d4,%d2
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80004cbe:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80004cc0:	6d 00 77 11 	call 80006fae <IfxScuWdt_clearCpuEndinit>

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004cc4:	19 f2 34 30 	ld.w %d2,[%a15]244
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);
80004cc8:	02 f4       	mov %d4,%d15
void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
80004cca:	8f 12 40 21 	or %d2,%d2,1
80004cce:	59 f2 34 30 	st.w [%a15]244,%d2
    asclin->KRST1.B.RST = 1;
80004cd2:	19 f2 30 30 	ld.w %d2,[%a15]240
80004cd6:	8f 12 40 21 	or %d2,%d2,1
80004cda:	59 f2 30 30 	st.w [%a15]240,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80004cde:	6d 00 9d 12 	call 80007218 <IfxScuWdt_setCpuEndinit>

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
80004ce2:	19 f2 34 30 	ld.w %d2,[%a15]244
80004ce6:	6f 12 fe 7f 	jz.t %d2,1,80004ce2 <IfxAsclin_resetModule+0x2c>
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
80004cea:	02 f4       	mov %d4,%d15
80004cec:	6d 00 61 11 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004cf0:	19 f2 2c 30 	ld.w %d2,[%a15]236

    IfxScuWdt_setCpuEndinit(passwd);
80004cf4:	02 f4       	mov %d4,%d15

    while (0 == asclin->KRST0.B.RSTSTAT)    /* Wait until reset is executed */
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
    asclin->KRSTCLR.B.CLR = 1;          /* Clear Kernel reset status bit */
80004cf6:	8f 12 40 21 	or %d2,%d2,1
80004cfa:	59 f2 2c 30 	st.w [%a15]236,%d2

    IfxScuWdt_setCpuEndinit(passwd);
80004cfe:	1d 00 8d 12 	j 80007218 <IfxScuWdt_setCpuEndinit>

80004d02 <IfxAsclin_setClockSource>:
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004d02:	19 4f 0c 10 	ld.w %d15,[%a4]76
80004d06:	37 4f 05 f0 	insert %d15,%d15,%d4,0,5
80004d0a:	59 4f 0c 10 	st.w [%a4]76,%d15

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80004d0e:	f6 46       	jnz %d4,80004d1a <IfxAsclin_setClockSource+0x18>
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004d10:	19 4f 0c 10 	ld.w %d15,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004d14:	bf 0f fe 7f 	jlt %d15,0,80004d10 <IfxAsclin_setClockSource+0xe>
80004d18:	00 90       	ret 
80004d1a:	19 4f 0c 10 	ld.w %d15,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80004d1e:	ff 0f fe 7f 	jge %d15,0,80004d1a <IfxAsclin_setClockSource+0x18>
80004d22:	00 90       	ret 

80004d24 <IfxAsclin_setBaudrateBitFields>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004d24:	19 4f 0c 10 	ld.w %d15,[%a4]76
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004d28:	19 42 0c 10 	ld.w %d2,[%a4]76
80004d2c:	16 1f       	and %d15,31
80004d2e:	8f f2 c1 21 	andn %d2,%d2,31
80004d32:	59 42 0c 10 	st.w [%a4]76,%d2
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004d36:	19 42 0c 10 	ld.w %d2,[%a4]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004d3a:	bf 02 fe 7f 	jlt %d2,0,80004d36 <IfxAsclin_setBaudrateBitFields+0x12>
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80004d3e:	19 42 14 00 	ld.w %d2,[%a4]20
80004d42:	c2 f4       	add %d4,-1
80004d44:	37 42 0c 40 	insert %d4,%d2,%d4,0,12
80004d48:	59 44 14 00 	st.w [%a4]20,%d4
}


IFX_INLINE void IfxAsclin_setNumerator(Ifx_ASCLIN *asclin, uint16 numerator)
{
    asclin->BRG.B.NUMERATOR = numerator;
80004d4c:	19 42 20 00 	ld.w %d2,[%a4]32
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
80004d50:	02 f4       	mov %d4,%d15
80004d52:	37 52 0c 58 	insert %d5,%d2,%d5,16,12
80004d56:	59 45 20 00 	st.w [%a4]32,%d5
}


IFX_INLINE void IfxAsclin_setDenominator(Ifx_ASCLIN *asclin, uint16 denominator)
{
    asclin->BRG.B.DENOMINATOR = denominator;
80004d5a:	19 42 20 00 	ld.w %d2,[%a4]32
80004d5e:	37 62 0c 60 	insert %d6,%d2,%d6,0,12
80004d62:	59 46 20 00 	st.w [%a4]32,%d6
}


IFX_INLINE void IfxAsclin_setOversampling(Ifx_ASCLIN *asclin, IfxAsclin_OversamplingFactor ovsFactor)
{
    asclin->BITCON.B.OVERSAMPLING = ovsFactor;
80004d66:	19 42 14 00 	ld.w %d2,[%a4]20
80004d6a:	37 72 04 78 	insert %d7,%d2,%d7,16,4
80004d6e:	59 47 14 00 	st.w [%a4]20,%d7
80004d72:	1d ff c8 ff 	j 80004d02 <IfxAsclin_setClockSource>

80004d76 <IfxAsclin_setBitTiming>:
}


IFX_INLINE uint8 IfxAsclin_getClockSource(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CLKSEL;
80004d76:	19 42 0c 10 	ld.w %d2,[%a4]76
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
80004d7a:	20 08       	sub.a %sp,8
80004d7c:	8f f2 01 21 	and %d2,%d2,31
80004d80:	02 5f       	mov %d15,%d5
80004d82:	40 4f       	mov.aa %a15,%a4
80004d84:	02 48       	mov %d8,%d4
80004d86:	02 6a       	mov %d10,%d6
80004d88:	60 7d       	mov.a %a13,%d7
80004d8a:	60 2c       	mov.a %a12,%d2
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004d8c:	6d ff 33 ff 	call 80004bf2 <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004d90:	92 15       	add %d5,%d15,1
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80004d92:	02 29       	mov %d9,%d2
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80004d94:	82 4f       	mov %d15,4
80004d96:	0b f5 b0 f1 	max.u %d15,%d5,%d15
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80004d9a:	8f ff 0f 21 	and %d2,%d15,255
80004d9e:	59 a2 04 00 	st.w [%sp]4,%d2
80004da2:	82 16       	mov %d6,1
80004da4:	0b 6a b0 61 	max.u %d6,%d10,%d6
80004da8:	16 ff       	and %d15,255
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
80004daa:	4b 0f 41 31 	itof %d3,%d15
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004dae:	8f f6 0f 61 	and %d6,%d6,255
    fOvs         = baudrate * oversampling;
80004db2:	4b 38 41 f0 	mul.f %d15,%d8,%d3
    float32               f;

    /* Set the PD frequency */
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
80004db6:	60 6e       	mov.a %a14,%d6
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004db8:	02 f4       	mov %d4,%d15
80004dba:	6d 00 8c 36 	call 8000bad2 <__extendsfdf2>
80004dbe:	7b 00 f5 73 	movh %d7,16208
80004dc2:	0b 23 10 48 	mov %e4,%d3,%d2
80004dc6:	7b 20 2f 6d 	movh %d6,54002
80004dca:	1b d7 24 76 	addi %d7,%d7,25165
80004dce:	1b c6 9f 6a 	addi %d6,%d6,-22020
80004dd2:	6d 00 a3 37 	call 8000bd18 <__muldf3>
80004dd6:	0b 23 10 48 	mov %e4,%d3,%d2
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
    nBest          = n;
80004dda:	82 1c       	mov %d12,1
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint  = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    fOvs         = baudrate * oversampling;
    float32               relError   = fOvs;
    float32               limit      = 0.001 * fOvs;                     // save the error limit
80004ddc:	6d 00 2f 39 	call 8000c03a <__truncdfsf2>

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004de0:	4b f9 51 50 	div.f %d5,%d9,%d15
80004de4:	91 00 00 20 	movh.a %a2,0

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);
80004de8:	82 01       	mov %d1,0

    boolean               terminated = FALSE;
    float32               newRelError;                                   //modified by Hassan
    uint32                adder_facL, adder_facH, adder_facL_min, count; //modified by Hassan

    d = (uint32)(fpd / fOvs);
80004dea:	4b 05 71 51 	ftouz %d5,%d5
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
80004dee:	4b 05 61 31 	utof %d3,%d5
80004df2:	4b 39 51 30 	div.f %d3,%d9,%d3
    relError       = __absf(fOvs - f);
80004df6:	6b 03 31 3f 	sub.f %d3,%d15,%d3
80004dfa:	4b 13 01 00 	cmp.f %d0,%d3,%d1
80004dfe:	37 00 61 00 	extr.u %d0,%d0,0,1
80004e02:	9b 03 00 48 	addih %d4,%d3,32768
80004e06:	2b 34 40 30 	sel %d3,%d0,%d4,%d3
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004e0a:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004e0e:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004e12:	df 00 45 80 	jne %d0,0,80004e9c <IfxAsclin_setBitTiming+0x126>
80004e16:	8f 15 00 60 	sh %d6,%d5,1
            /* Increase the value of the oversampling to generate the required baudrate */
            IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, FALSE);
        }
    }

    dBest          = d;
80004e1a:	02 51       	mov %d1,%d5
    nBest          = n;
    adder_facL_min = 0;
80004e1c:	82 0e       	mov %d14,0
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004e1e:	82 28       	mov %d8,2
80004e20:	3b 00 00 71 	mov %d7,4096
80004e24:	7f 76 3b 80 	jge.u %d6,%d7,80004e9a <IfxAsclin_setBitTiming+0x124>
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
80004e28:	a0 13       	mov.a %a3,1

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
80004e2a:	82 1b       	mov %d11,1
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
    {
        if (n == 2)
80004e2c:	df 28 09 00 	jeq %d8,2,80004e3e <IfxAsclin_setBitTiming+0xc8>
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004e30:	73 8e 0a a0 	mul %d10,%d14,%d8
80004e34:	4b ca 11 a2 	div.u %e10,%d10,%d12
            adder_facH = adder_facL + 1;
80004e38:	60 a3       	mov.a %a3,%d10
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
80004e3a:	02 ab       	mov %d11,%d10
            adder_facH = adder_facL + 1;
80004e3c:	b0 13       	add.a %a3,1
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004e3e:	80 34       	mov.d %d4,%a3
80004e40:	3f b4 25 80 	jlt.u %d4,%d11,80004e8a <IfxAsclin_setBitTiming+0x114>
        {
            f           = (fpd * n) / (n * d + count);
80004e44:	4b 08 61 01 	utof %d0,%d8
80004e48:	0b 6b 00 40 	add %d4,%d11,%d6
80004e4c:	4b 04 61 d1 	utof %d13,%d4
80004e50:	4b 09 41 00 	mul.f %d0,%d9,%d0
            newRelError = __absf(fOvs - f);
80004e54:	80 2a       	mov.d %d10,%a2
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
        {
            f           = (fpd * n) / (n * d + count);
80004e56:	4b d0 51 00 	div.f %d0,%d0,%d13
            newRelError = __absf(fOvs - f);
80004e5a:	6b 00 31 0f 	sub.f %d0,%d15,%d0
80004e5e:	4b a0 01 d0 	cmp.f %d13,%d0,%d10
80004e62:	37 0d 61 d0 	extr.u %d13,%d13,0,1
80004e66:	9b 00 00 a8 	addih %d10,%d0,32768
80004e6a:	2b 0a 40 0d 	sel %d0,%d13,%d10,%d0

            if (relError > (newRelError))
80004e6e:	4b 03 01 d0 	cmp.f %d13,%d3,%d0
80004e72:	37 0d 61 d1 	extr.u %d13,%d13,2,1
80004e76:	2b be 50 ed 	seln %d14,%d13,%d14,%d11
80004e7a:	2b 03 50 3d 	seln %d3,%d13,%d3,%d0
80004e7e:	2b 8c 50 cd 	seln %d12,%d13,%d12,%d8
80004e82:	2b 41 50 1d 	seln %d1,%d13,%d1,%d4
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; count <= adder_facH; count++)
80004e86:	c2 1b       	add %d11,1
80004e88:	3c db       	j 80004e3e <IfxAsclin_setBitTiming+0xc8>
                dBest          = (n * d + count);
                adder_facL_min = count;
            }
        }

        if (relError <= limit)
80004e8a:	4b 23 01 00 	cmp.f %d0,%d3,%d2
80004e8e:	87 00 a0 00 	or.t %d0,%d0,0,%d0,1
80004e92:	f6 04       	jnz %d0,80004e9a <IfxAsclin_setBitTiming+0x124>
    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80004e94:	c2 18       	add %d8,1
80004e96:	42 56       	add %d6,%d5
80004e98:	3c c6       	j 80004e24 <IfxAsclin_setBitTiming+0xae>
80004e9a:	02 15       	mov %d5,%d1
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80004e9c:	19 f3 0c 10 	ld.w %d3,[%a15]76
80004ea0:	8f f3 c1 31 	andn %d3,%d3,31
80004ea4:	59 f3 0c 10 	st.w [%a15]76,%d3
}


IFX_INLINE boolean IfxAsclin_getClockStatus(Ifx_ASCLIN *asclin)
{
    return asclin->CSR.B.CON;
80004ea8:	19 ff 0c 10 	ld.w %d15,[%a15]76

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80004eac:	bf 0f fe 7f 	jlt %d15,0,80004ea8 <IfxAsclin_setBitTiming+0x132>
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004eb0:	4c f8       	ld.w %d15,[%a15]32
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004eb2:	19 a2 04 00 	ld.w %d2,[%sp]4
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004eb6:	37 5f 0c 50 	insert %d5,%d15,%d5,0,12
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004eba:	c2 f2       	add %d2,-1
            break;
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
80004ebc:	68 85       	st.w [%a15]32,%d5
    asclin->BRG.B.NUMERATOR   = nBest;
80004ebe:	4c f8       	ld.w %d15,[%a15]32

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ec0:	80 ea       	mov.d %d10,%a14
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80004ec2:	37 cf 0c c8 	insert %d12,%d15,%d12,16,12
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80004ec6:	80 c4       	mov.d %d4,%a12
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;
80004ec8:	68 8c       	st.w [%a15]32,%d12

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004eca:	4c f5       	ld.w %d15,[%a15]20
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);
80004ecc:	40 f4       	mov.aa %a4,%a15
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80004ece:	37 2f 04 28 	insert %d2,%d15,%d2,16,4
80004ed2:	68 52       	st.w [%a15]20,%d2

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ed4:	4c f5       	ld.w %d15,[%a15]20

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004ed6:	80 d2       	mov.d %d2,%a13

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ed8:	37 af 04 6c 	insert %d6,%d15,%d10,24,4

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004edc:	7b 00 00 f8 	movh %d15,32768

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80004ee0:	68 56       	st.w [%a15]20,%d6

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80004ee2:	ab 0f 80 72 	sel %d7,%d2,%d15,0
80004ee6:	4c f5       	ld.w %d15,[%a15]20
80004ee8:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
80004eec:	a6 7f       	or %d15,%d7
80004eee:	68 5f       	st.w [%a15]20,%d15

    IfxAsclin_setClockSource(asclin, source);
80004ef0:	6d ff 09 ff 	call 80004d02 <IfxAsclin_setClockSource>

    return TRUE;
}
80004ef4:	82 12       	mov %d2,1
80004ef6:	00 90       	ret 

80004ef8 <IfxAsclin_write16>:
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
80004ef8:	9f 04 04 80 	jned %d4,0,80004f00 <IfxAsclin_write16+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80004efc:	82 02       	mov %d2,0
80004efe:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80004f00:	b9 5f 00 00 	ld.hu %d15,[%a5]0
80004f04:	b0 25       	add.a %a5,2
80004f06:	59 4f 04 10 	st.w [%a4]68,%d15
80004f0a:	3c f7       	j 80004ef8 <IfxAsclin_write16>

80004f0c <IfxAsclin_write32>:
    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
80004f0c:	9f 04 04 80 	jned %d4,0,80004f14 <IfxAsclin_write32+0x8>
        txData->U = *data++;
        count--;
    }

    return count;
}
80004f10:	82 02       	mov %d2,0
80004f12:	00 90       	ret 
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
80004f14:	4c 50       	ld.w %d15,[%a5]0
80004f16:	b0 45       	add.a %a5,4
80004f18:	59 4f 04 10 	st.w [%a4]68,%d15
80004f1c:	3c f8       	j 80004f0c <IfxAsclin_write32>

80004f1e <IfxAsclin_write8>:
    return count;
}

#include <stdio.h>
uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80004f1e:	9f 04 04 80 	jned %d4,0,80004f26 <IfxAsclin_write8+0x8>
        count--;

    }

    return count;
}
80004f22:	82 02       	mov %d2,0
80004f24:	00 90       	ret 
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {

        txData->U = *data++;
80004f26:	0c 50       	ld.bu %d15,[%a5]0
80004f28:	b0 15       	add.a %a5,1
80004f2a:	59 4f 04 10 	st.w [%a4]68,%d15
80004f2e:	3c f8       	j 80004f1e <IfxAsclin_write8>

80004f30 <IfxAsclin_Asc_getReadCount>:
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80004f30:	cc 42       	ld.a %a15,[%a4]8


sint32 IfxAsclin_Asc_getReadCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_readCount(asclin->rx);
}
80004f32:	88 22       	ld.h %d2,[%a15]4
80004f34:	00 90       	ret 

80004f36 <IfxAsclin_Asc_getReadEvent>:


IfxStdIf_DPipe_ReadEvent IfxAsclin_Asc_getReadEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->rx->eventWriter;
80004f36:	99 42 08 00 	ld.a %a2,[%a4]8
}
80004f3a:	d9 22 1d 00 	lea %a2,[%a2]29
80004f3e:	00 90       	ret 

80004f40 <IfxAsclin_Asc_getSendCount>:


uint32 IfxAsclin_Asc_getSendCount(IfxAsclin_Asc *asclin)
{
    return asclin->sendCount;
80004f40:	19 42 10 00 	ld.w %d2,[%a4]16
}
80004f44:	00 90       	ret 

80004f46 <IfxAsclin_Asc_getTxTimeStamp>:


Ifx_TickTime IfxAsclin_Asc_getTxTimeStamp(IfxAsclin_Asc *asclin)
{
    return asclin->txTimestamp;
80004f46:	09 42 54 09 	ld.d %e2,[%a4]20
}
80004f4a:	00 90       	ret 

80004f4c <IfxAsclin_Asc_getWriteCount>:


sint32 IfxAsclin_Asc_getWriteCount(IfxAsclin_Asc *asclin)
{
    return Ifx_Fifo_writeCount(asclin->tx);
80004f4c:	cc 41       	ld.a %a15,[%a4]4
 *
 * \return Returns the free size in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_writeCount(Ifx_Fifo *fifo)
{
    return (Ifx_SizeT)(fifo->size - Ifx_Fifo_readCount(fifo));
80004f4e:	88 c2       	ld.h %d2,[%a15]24
80004f50:	8c f2       	ld.h %d15,[%a15]4
80004f52:	a2 f2       	sub %d2,%d15
}
80004f54:	37 02 50 20 	extr %d2,%d2,0,16
80004f58:	00 90       	ret 

80004f5a <IfxAsclin_Asc_getWriteEvent>:


IfxStdIf_DPipe_WriteEvent IfxAsclin_Asc_getWriteEvent(IfxAsclin_Asc *asclin)
{
    return &asclin->tx->eventWriter;
80004f5a:	99 42 04 00 	ld.a %a2,[%a4]4
}
80004f5e:	d9 22 1d 00 	lea %a2,[%a2]29
80004f62:	00 90       	ret 

80004f64 <IfxAsclin_Asc_isrError>:
}


void IfxAsclin_Asc_isrError(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin; /* getting the pointer to ASCLIN registers from module handler*/
80004f64:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE boolean IfxAsclin_getParityErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.PE;
80004f66:	4c fd       	ld.w %d15,[%a15]52

    /* store all the flags in the variable */
    if (IfxAsclin_getParityErrorFlagStatus(asclinSFR))
80004f68:	ef 0f 0a 00 	jz.t %d15,16,80004f7c <IfxAsclin_Asc_isrError+0x18>
}


IFX_INLINE void IfxAsclin_clearParityErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.PEC = 1;
80004f6c:	4c ff       	ld.w %d15,[%a15]60
80004f6e:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80004f72:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearParityErrorFlag(asclinSFR);
        asclin->errorFlags.flags.parityError = 1;
80004f74:	0c 4e       	ld.bu %d15,[%a4]14
80004f76:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
80004f7a:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getFrameErrorFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.FE;
80004f7c:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
80004f7e:	ef 2f 0a 00 	jz.t %d15,18,80004f92 <IfxAsclin_Asc_isrError+0x2e>
}


IFX_INLINE void IfxAsclin_clearFrameErrorFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.FEC = 1;
80004f82:	4c ff       	ld.w %d15,[%a15]60
80004f84:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80004f88:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlags.flags.frameError = 1;
80004f8a:	0c 4e       	ld.bu %d15,[%a4]14
80004f8c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
80004f90:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFO;
80004f92:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
80004f94:	ef af 0a 00 	jz.t %d15,26,80004fa8 <IfxAsclin_Asc_isrError+0x44>
}


IFX_INLINE void IfxAsclin_clearRxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFOC = 1;
80004f98:	4c ff       	ld.w %d15,[%a15]60
80004f9a:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80004f9e:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoOverflow = 1;
80004fa0:	0c 4e       	ld.bu %d15,[%a4]14
80004fa2:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
80004fa6:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getRxFifoUnderflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.RFU;
80004fa8:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getRxFifoUnderflowFlagStatus(asclinSFR))
80004faa:	ef bf 0a 00 	jz.t %d15,27,80004fbe <IfxAsclin_Asc_isrError+0x5a>
}


IFX_INLINE void IfxAsclin_clearRxFifoUnderflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.RFUC = 1;
80004fae:	4c ff       	ld.w %d15,[%a15]60
80004fb0:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80004fb4:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearRxFifoUnderflowFlag(asclinSFR);
        asclin->errorFlags.flags.rxFifoUnderflow = 1;
80004fb6:	0c 4e       	ld.bu %d15,[%a4]14
80004fb8:	b7 1f 81 f1 	insert %d15,%d15,1,3,1
80004fbc:	2c 4e       	st.b [%a4]14,%d15
}


IFX_INLINE boolean IfxAsclin_getTxFifoOverflowFlagStatus(Ifx_ASCLIN *asclin)
{
    return asclin->FLAGS.B.TFO;
80004fbe:	4c fd       	ld.w %d15,[%a15]52
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
80004fc0:	ef ef 0a 00 	jz.t %d15,30,80004fd4 <IfxAsclin_Asc_isrError+0x70>
}


IFX_INLINE void IfxAsclin_clearTxFifoOverflowFlag(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.B.TFOC = 1;
80004fc4:	4c ff       	ld.w %d15,[%a15]60
80004fc6:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80004fca:	68 ff       	st.w [%a15]60,%d15
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlags.flags.txFifoOverflow = 1;
80004fcc:	0c 4e       	ld.bu %d15,[%a4]14
80004fce:	b7 1f 01 f2 	insert %d15,%d15,1,4,1
80004fd2:	2c 4e       	st.b [%a4]14,%d15
80004fd4:	00 90       	ret 

80004fd6 <IfxAsclin_Asc_resetSendCount>:
}


void IfxAsclin_Asc_resetSendCount(IfxAsclin_Asc *asclin)
{
    asclin->sendCount = 0;
80004fd6:	82 0f       	mov %d15,0
80004fd8:	6c 44       	st.w [%a4]16,%d15
80004fda:	00 90       	ret 

80004fdc <IfxAsclin_Asc_canReadCount>:
}


boolean IfxAsclin_Asc_canReadCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canReadCount(asclin->rx, count, timeout);
80004fdc:	99 44 08 00 	ld.a %a4,[%a4]8
80004fe0:	1d 00 df 18 	j 8000819e <Ifx_Fifo_canReadCount>

80004fe4 <IfxAsclin_Asc_flushTx>:

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80004fe4:	82 f2       	mov %d2,-1
80004fe6:	06 f2       	sh %d2,-1
80004fe8:	ba f4       	eq %d15,%d4,-1
80004fea:	0b 52 00 f2 	and.eq %d15,%d2,%d5
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
}


boolean IfxAsclin_Asc_flushTx(IfxAsclin_Asc *asclin, Ifx_TickTime timeout)
{
80004fee:	40 4f       	mov.aa %a15,%a4
80004ff0:	02 46       	mov %d6,%d4
    {
        deadLine = TIME_INFINITE;
80004ff2:	82 f9       	mov %d9,-1
80004ff4:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80004ff6:	ee 16       	jnz %d15,80005022 <IfxAsclin_Asc_flushTx+0x3e>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80004ff8:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80004ffc:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005000:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80005004:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005006:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000500a:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000500e:	02 39       	mov %d9,%d3
80005010:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005014:	76 23       	jz %d2,8000501a <IfxAsclin_Asc_flushTx+0x36>
    {
        __enable();
80005016:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
8000501a:	0b 69 40 90 	addx %d9,%d9,%d6
8000501e:	0b 58 50 80 	addc %d8,%d8,%d5
 *
 * \return TRUE if the buffer is emptied.
 */
IFX_INLINE boolean Ifx_Fifo_flush(Ifx_Fifo *fifo, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(fifo, fifo->size, timeout);
80005022:	c8 14       	ld.a %a4,[%a15]4
80005024:	02 57       	mov %d7,%d5
80005026:	c9 44 18 00 	ld.h %d4,[%a4]24
8000502a:	6d 00 fd 19 	call 80008424 <Ifx_Fifo_canWriteCount>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000502e:	82 f4       	mov %d4,-1
80005030:	06 f4       	sh %d4,-1
    boolean      result;

    /* Flush the software FIFO */
    result = Ifx_Fifo_flush(asclin->tx, timeout);

    if (result)
80005032:	f6 23       	jnz %d2,80005038 <IfxAsclin_Asc_flushTx+0x54>
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
80005034:	82 02       	mov %d2,0
80005036:	00 90       	ret 
    {
        /* Flush the hardware FIFO (wait until all bytes have been transmitted) */
        do
        {
            result = IfxAsclin_getTxFifoFillLevel(asclin->asclin) == 0;
80005038:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
8000503a:	4c 23       	ld.w %d15,[%a2]12
8000503c:	37 0f 65 f8 	extr.u %d15,%d15,16,5
        } while (!result && !IfxStm_isDeadLine(deadline));
80005040:	6e 1e       	jz %d15,8000507c <IfxAsclin_Asc_flushTx+0x98>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80005042:	ba f9       	eq %d15,%d9,-1
80005044:	0b 84 00 f2 	and.eq %d15,%d4,%d8
80005048:	ee f9       	jnz %d15,8000503a <IfxAsclin_Asc_flushTx+0x56>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000504a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000504e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005052:	0d 00 40 03 	disable 
80005056:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80005058:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000505c:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005060:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005064:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80005068:	76 23       	jz %d2,8000506e <IfxAsclin_Asc_flushTx+0x8a>
    {
        __enable();
8000506a:	0d 00 00 03 	enable 
8000506e:	0b 8f 00 21 	eq %d2,%d15,%d8
80005072:	0b 93 30 22 	and.lt.u %d2,%d3,%d9
80005076:	0b 8f 90 22 	or.lt %d2,%d15,%d8
8000507a:	3c dc       	j 80005032 <IfxAsclin_Asc_flushTx+0x4e>
8000507c:	82 12       	mov %d2,1
    }

    return result;
}
8000507e:	00 90       	ret 

80005080 <IfxAsclin_Asc_canWriteCount>:
}


boolean IfxAsclin_Asc_canWriteCount(IfxAsclin_Asc *asclin, Ifx_SizeT count, Ifx_TickTime timeout)
{
    return Ifx_Fifo_canWriteCount(asclin->tx, count, timeout);
80005080:	99 44 04 00 	ld.a %a4,[%a4]4
80005084:	1d 00 d0 19 	j 80008424 <Ifx_Fifo_canWriteCount>

80005088 <IfxAsclin_Asc_clearRx>:
}


void IfxAsclin_Asc_clearRx(IfxAsclin_Asc *asclin)
{
    IfxAsclin_flushRxFifo(asclin->asclin);
80005088:	cc 40       	ld.a %a15,[%a4]0
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
8000508a:	4c f4       	ld.w %d15,[%a15]16
8000508c:	96 01       	or %d15,1
8000508e:	68 4f       	st.w [%a15]16,%d15
    Ifx_Fifo_clear(asclin->rx);
80005090:	99 44 08 00 	ld.a %a4,[%a4]8
80005094:	1d 00 ad 19 	j 800083ee <Ifx_Fifo_clear>

80005098 <IfxAsclin_Asc_clearTx>:
}


void IfxAsclin_Asc_clearTx(IfxAsclin_Asc *asclin)
{
80005098:	40 4f       	mov.aa %a15,%a4
    Ifx_Fifo_clear(asclin->tx);
8000509a:	99 44 04 00 	ld.a %a4,[%a4]4
8000509e:	6d 00 a8 19 	call 800083ee <Ifx_Fifo_clear>
    IfxAsclin_flushTxFifo(asclin->asclin);
800050a2:	c8 0f       	ld.a %a15,[%a15]0
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
800050a4:	4c f3       	ld.w %d15,[%a15]12
800050a6:	96 01       	or %d15,1
800050a8:	68 3f       	st.w [%a15]12,%d15
800050aa:	00 90       	ret 

800050ac <IfxAsclin_Asc_read>:
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800050ac:	99 44 08 00 	ld.a %a4,[%a4]8
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800050b0:	0b 45 10 68 	mov %e6,%d5,%d4
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800050b4:	94 64       	ld.h %d4,[%a6]
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800050b6:	40 6f       	mov.aa %a15,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
800050b8:	6d 00 e0 18 	call 80008278 <Ifx_Fifo_read>

    *count -= left;
800050bc:	8c f0       	ld.h %d15,[%a15]0
800050be:	a2 2f       	sub %d15,%d2
800050c0:	a8 0f       	st.h [%a15]0,%d15

    return left == 0;
}
800050c2:	8b 02 00 22 	eq %d2,%d2,0
800050c6:	00 90       	ret 

800050c8 <IfxAsclin_Asc_isrTransmit>:
    }
}

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
800050c8:	20 18       	sub.a %sp,24
800050ca:	40 4f       	mov.aa %a15,%a4
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800050cc:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800050d0:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800050d4:	0d 00 40 03 	disable 
800050d8:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800050da:	85 f5 10 00 	ld.w %d5,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800050de:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800050e2:	02 52       	mov %d2,%d5
800050e4:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800050e8:	76 43       	jz %d4,800050ee <IfxAsclin_Asc_isrTransmit+0x26>
    {
        __enable();
800050ea:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
800050ee:	89 f2 54 09 	st.d [%a15]20,%e2
    asclin->sendCount++;

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800050f2:	c8 14       	ld.a %a4,[%a15]4

#include <stdio.h>
void IfxAsclin_Asc_isrTransmit(IfxAsclin_Asc *asclin)
{
    asclin->txTimestamp = IfxStm_now();
    asclin->sendCount++;
800050f4:	4c f4       	ld.w %d15,[%a15]16
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800050f6:	c9 44 04 00 	ld.h %d4,[%a4]4
800050fa:	c2 1f       	add %d15,1
800050fc:	68 4f       	st.w [%a15]16,%d15

    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800050fe:	df 04 32 00 	jeq %d4,0,80005162 <IfxAsclin_Asc_isrTransmit+0x9a>
    {

        switch (asclin->dataBufferMode)
80005102:	0c ff       	ld.bu %d15,[%a15]15
80005104:	6e 03       	jz %d15,8000510a <IfxAsclin_Asc_isrTransmit+0x42>
80005106:	9e 1d       	jeq %d15,1,80005140 <IfxAsclin_Asc_isrTransmit+0x78>
80005108:	00 90       	ret 
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
8000510a:	c8 02       	ld.a %a2,[%a15]0
        case Ifx_DataBufferMode_normal:
        {

            uint8          ascData[16];
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;
8000510c:	2c a7       	st.b [%sp]7,%d15

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
8000510e:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
80005112:	4c 23       	ld.w %d15,[%a2]12
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80005114:	d2 06       	mov %e6,0
80005116:	37 0f 65 f8 	extr.u %d15,%d15,16,5
8000511a:	d9 a5 08 00 	lea %a5,[%sp]8
            uint16         count            = 0, i_count = 0;
            volatile uint8 hw_tx_fill_level = 0;

            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/

            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
8000511e:	2c a7       	st.b [%sp]7,%d15

            i_count          = (16 - hw_tx_fill_level);
80005120:	0c a7       	ld.bu %d15,[%sp]7
80005122:	8b 0f 01 f1 	rsub %d15,%d15,16
80005126:	37 0f 70 f0 	extr.u %d15,%d15,0,16
8000512a:	0b 4f 90 f1 	min.u %d15,%d15,%d4
            if (i_count > count)
            {
                i_count = count;
            }

            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
8000512e:	37 0f 50 40 	extr %d4,%d15,0,16
80005132:	6d 00 a3 18 	call 80008278 <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
80005136:	c8 04       	ld.a %a4,[%a15]0
80005138:	d9 a5 08 00 	lea %a5,[%sp]8
8000513c:	02 f4       	mov %d4,%d15
8000513e:	3c 10       	j 8000515e <IfxAsclin_Asc_isrTransmit+0x96>
        {

            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005140:	d2 06       	mov %e6,0
80005142:	d9 a5 08 00 	lea %a5,[%sp]8
80005146:	3b c0 00 40 	mov %d4,12
8000514a:	6d 00 97 18 	call 80008278 <Ifx_Fifo_read>

            ascData = packedData.data;
8000514e:	39 af 10 00 	ld.bu %d15,[%sp]16
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005152:	c8 04       	ld.a %a4,[%a15]0
            Ifx_DataBufferMode_TimeStampSingle packedData;
            uint8                              ascData;

            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);

            ascData = packedData.data;
80005154:	d9 a5 18 00 	lea %a5,[%sp]24
80005158:	89 5f 2f f4 	st.b [+%a5]-17,%d15
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
8000515c:	82 14       	mov %d4,1
        }
        break;
8000515e:	1d ff e0 fe 	j 80004f1e <IfxAsclin_write8>
    }
    else
    {

        /* Transmit buffer is empty */
        asclin->txInProgress = FALSE;
80005162:	28 c4       	st.b [%a15]12,%d4
80005164:	00 90       	ret 

80005166 <IfxAsclin_Asc_isrReceive>:

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005166:	0c 4f       	ld.bu %d15,[%a4]15
    }
}


void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
80005168:	20 20       	sub.a %sp,32
8000516a:	40 4f       	mov.aa %a15,%a4
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
8000516c:	6e 34       	jz %d15,800051d4 <IfxAsclin_Asc_isrReceive+0x6e>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
8000516e:	82 18       	mov %d8,1

void IfxAsclin_Asc_isrReceive(IfxAsclin_Asc *asclin)
{
    uint8 ascData[16]; /*FIFO size is 16 bytes*/

    switch (asclin->dataBufferMode)
80005170:	df 1f 45 80 	jne %d15,1,800051fa <IfxAsclin_Asc_isrReceive+0x94>
    }
    case Ifx_DataBufferMode_timeStampSingle:
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
80005174:	c8 02       	ld.a %a2,[%a15]0
}


IFX_INLINE uint8 IfxAsclin_getRxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->RXFIFOCON.B.FILL;
80005176:	4c 24       	ld.w %d15,[%a2]16
80005178:	37 0f 65 f8 	extr.u %d15,%d15,16,5
8000517c:	6e 2b       	jz %d15,800051d2 <IfxAsclin_Asc_isrReceive+0x6c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000517e:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
80005182:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80005186:	0d 00 40 03 	disable 
8000518a:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000518c:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80005190:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80005194:	8f 02 40 21 	or %d2,%d2,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005198:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000519c:	76 33       	jz %d3,800051a2 <IfxAsclin_Asc_isrReceive+0x3c>
    {
        __enable();
8000519e:	0d 00 00 03 	enable 
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
800051a2:	c8 04       	ld.a %a4,[%a15]0
800051a4:	d9 a5 10 00 	lea %a5,[%sp]16
800051a8:	82 14       	mov %d4,1
    {
        Ifx_DataBufferMode_TimeStampSingle packedData;

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
800051aa:	78 02       	st.w [%sp]8,%d15
800051ac:	59 a2 04 00 	st.w [%sp]4,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
800051b0:	6d ff 7a fd 	call 80004ca4 <IfxAsclin_read8>
            packedData.data      = ascData[0];

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800051b4:	c8 24       	ld.a %a4,[%a15]8

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800051b6:	39 af 10 00 	ld.bu %d15,[%sp]16

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800051ba:	d2 06       	mov %e6,0
800051bc:	d9 a5 04 00 	lea %a5,[%sp]4
800051c0:	3b c0 00 40 	mov %d4,12

        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
        {
            packedData.timestamp = IfxStm_now();
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
            packedData.data      = ascData[0];
800051c4:	2c ac       	st.b [%sp]12,%d15

            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
800051c6:	6d 00 a7 19 	call 80008514 <Ifx_Fifo_write>
800051ca:	df 02 d5 7f 	jeq %d2,0,80005174 <IfxAsclin_Asc_isrReceive+0xe>
            {
                /* Receive buffer is full, data is discard */
                asclin->rxSwFifoOverflow = TRUE;
800051ce:	28 d8       	st.b [%a15]13,%d8
800051d0:	3c d2       	j 80005174 <IfxAsclin_Asc_isrReceive+0xe>
800051d2:	00 90       	ret 
    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
    {
        uint8 count;
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
800051d4:	d4 44       	ld.a %a4,[%a4]
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
800051d6:	d9 a5 10 00 	lea %a5,[%sp]16
800051da:	4c 44       	ld.w %d15,[%a4]16
800051dc:	37 0f 65 f8 	extr.u %d15,%d15,16,5
800051e0:	02 f4       	mov %d4,%d15
800051e2:	6d ff 61 fd 	call 80004ca4 <IfxAsclin_read8>

        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
800051e6:	c8 24       	ld.a %a4,[%a15]8
800051e8:	d2 06       	mov %e6,0
800051ea:	d9 a5 10 00 	lea %a5,[%sp]16
800051ee:	02 f4       	mov %d4,%d15
800051f0:	6d 00 92 19 	call 80008514 <Ifx_Fifo_write>
800051f4:	76 23       	jz %d2,800051fa <IfxAsclin_Asc_isrReceive+0x94>
        {
            /* Receive buffer is full, data is discard */
            asclin->rxSwFifoOverflow = TRUE;
800051f6:	82 1f       	mov %d15,1
800051f8:	28 df       	st.b [%a15]13,%d15
800051fa:	00 90       	ret 

800051fc <IfxAsclin_Asc_blockingRead>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
800051fc:	20 08       	sub.a %sp,8
    Ifx_SizeT count = 1;
800051fe:	82 1f       	mov %d15,1
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint8 IfxAsclin_Asc_blockingRead(IfxAsclin_Asc *asclin)
{
80005200:	40 4f       	mov.aa %a15,%a4
    Ifx_SizeT count = 1;
80005202:	ac a3       	st.h [%sp]6,%d15
    uint8     data;

    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
80005204:	82 f4       	mov %d4,-1
80005206:	40 f4       	mov.aa %a4,%a15
80005208:	d9 a5 05 00 	lea %a5,[%sp]5
8000520c:	d9 a6 06 00 	lea %a6,[%sp]6
80005210:	9b 04 00 58 	addih %d5,%d4,32768
80005214:	6d ff 4c ff 	call 800050ac <IfxAsclin_Asc_read>
80005218:	df 12 f6 ff 	jne %d2,1,80005204 <IfxAsclin_Asc_blockingRead+0x8>
    {}

    return data;
}
8000521c:	39 a2 05 00 	ld.bu %d2,[%sp]5
80005220:	00 90       	ret 

80005222 <IfxAsclin_Asc_disableModule>:
}


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
80005222:	cc 40       	ld.a %a15,[%a4]0
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
80005224:	6d 00 c5 0f 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
80005228:	02 24       	mov %d4,%d2


void IfxAsclin_Asc_disableModule(IfxAsclin_Asc *asclin)
{
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       /* getting the pointer to ASCLIN registers from module handler*/
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
8000522a:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(psw);               /* clearing the endinit protection */
8000522c:	6d 00 c1 0e 	call 80006fae <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setDisableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 1;
80005230:	48 02       	ld.w %d2,[%a15]0
    IfxAsclin_setDisableModuleRequest(asclinSFR); /* disabling the module */
    IfxScuWdt_setCpuEndinit(psw);                 /* setting the endinit protection back on */
80005232:	02 f4       	mov %d4,%d15
80005234:	8f 12 40 21 	or %d2,%d2,1
80005238:	68 02       	st.w [%a15]0,%d2
8000523a:	1d 00 ef 0f 	j 80007218 <IfxScuWdt_setCpuEndinit>

8000523e <IfxAsclin_Asc_initModule>:
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
8000523e:	cc 50       	ld.a %a15,[%a5]0
    return &asclin->tx->eventWriter;
}


IfxAsclin_Status IfxAsclin_Asc_initModule(IfxAsclin_Asc *asclin, const IfxAsclin_Asc_Config *config)
{
80005240:	40 4e       	mov.aa %a14,%a4
80005242:	40 5c       	mov.aa %a12,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
80005244:	ec 40       	st.a [%a4]0,%a15

    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
80005246:	40 f4       	mov.aa %a4,%a15
80005248:	6d ff 71 fc 	call 80004b2a <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
8000524c:	40 f4       	mov.aa %a4,%a15
8000524e:	82 04       	mov %d4,0
80005250:	6d ff 59 fd 	call 80004d02 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005254:	4c f6       	ld.w %d15,[%a15]24
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
80005256:	40 f4       	mov.aa %a4,%a15
80005258:	b7 0f 02 f8 	insert %d15,%d15,0,16,2
8000525c:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
8000525e:	8c c4       	ld.h %d15,[%a12]8
80005260:	48 52       	ld.w %d2,[%a15]20
80005262:	c2 ff       	add %d15,-1
80005264:	37 f2 0c f0 	insert %d15,%d2,%d15,0,12
80005268:	68 5f       	st.w [%a15]20,%d15
8000526a:	39 c4 28 00 	ld.bu %d4,[%a12]40
8000526e:	6d ff 4a fd 	call 80004d02 <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005272:	40 f4       	mov.aa %a4,%a15
80005274:	19 c4 04 00 	ld.w %d4,[%a12]4
80005278:	39 c5 0a 00 	ld.bu %d5,[%a12]10
8000527c:	39 c6 0d 00 	ld.bu %d6,[%a12]13
80005280:	39 c7 0c 00 	ld.bu %d7,[%a12]12
80005284:	6d ff 79 fd 	call 80004d76 <IfxAsclin_setBitTiming>
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005288:	40 f4       	mov.aa %a4,%a15
8000528a:	82 04       	mov %d4,0
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    IfxAsclin_setFrameMode(asclinSFR, IfxAsclin_FrameMode_initialise);  /* setting the module in Initialise mode*/
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
8000528c:	02 29       	mov %d9,%d2
        config->baudrate.baudrate,
        config->baudrate.oversampling,
        config->bitTiming.samplePointPosition,
        config->bitTiming.medianFilter);
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
8000528e:	6d ff 3a fd 	call 80004d02 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_enableLoopBackMode(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.LB = enable ? 1 : 0;
80005292:	39 c2 38 00 	ld.bu %d2,[%a12]56
80005296:	7b 00 00 f1 	movh %d15,4096
8000529a:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000529e:	4c f1       	ld.w %d15,[%a15]4
800052a0:	b7 0f 01 fe 	insert %d15,%d15,0,28,1
800052a4:	a6 2f       	or %d15,%d2
800052a6:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxAsclin_enableParity(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
800052a8:	39 c2 14 00 	ld.bu %d2,[%a12]20
800052ac:	7b 00 00 f4 	movh %d15,16384
800052b0:	ab 0f 80 22 	sel %d2,%d2,%d15,0
800052b4:	4c f6       	ld.w %d15,[%a15]24
800052b6:	b7 0f 01 ff 	insert %d15,%d15,0,30,1
800052ba:	a6 2f       	or %d15,%d2
800052bc:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setParityType(Ifx_ASCLIN *asclin, IfxAsclin_ParityType type)
{
    asclin->FRAMECON.B.ODD = type;
800052be:	48 62       	ld.w %d2,[%a15]24
800052c0:	39 cf 12 00 	ld.bu %d15,[%a12]18
800052c4:	37 f2 81 ff 	insert %d15,%d2,%d15,31,1
800052c8:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
800052ca:	48 62       	ld.w %d2,[%a15]24
800052cc:	0c cf       	ld.bu %d15,[%a12]15
800052ce:	37 f2 83 f4 	insert %d15,%d2,%d15,9,3
800052d2:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setShiftDirection(Ifx_ASCLIN *asclin, IfxAsclin_ShiftDirection dir)
{
    asclin->FRAMECON.B.MSB = dir;
800052d4:	48 62       	ld.w %d2,[%a15]24
800052d6:	39 cf 11 00 	ld.bu %d15,[%a12]17
800052da:	67 f2 1c f0 	ins.t %d15,%d2,28,%d15,0
800052de:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setDataLength(Ifx_ASCLIN *asclin, IfxAsclin_DataLength length)
{
    asclin->DATCON.B.DATLEN = length;
800052e0:	48 72       	ld.w %d2,[%a15]28
800052e2:	39 cf 13 00 	ld.bu %d15,[%a12]19
800052e6:	37 f2 04 f0 	insert %d15,%d2,%d15,0,4
800052ea:	68 7f       	st.w [%a15]28,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
800052ec:	48 32       	ld.w %d2,[%a15]12
800052ee:	39 cf 16 00 	ld.bu %d15,[%a12]22
800052f2:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
800052f6:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_setRxFifoOutletWidth(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoOutletWidth width)
{
    asclin->RXFIFOCON.B.OUTW = width;
800052f8:	48 42       	ld.w %d2,[%a15]16
800052fa:	39 cf 17 00 	ld.bu %d15,[%a12]23
800052fe:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80005302:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setIdleDelay(Ifx_ASCLIN *asclin, IfxAsclin_IdleDelay delay)
{
    asclin->FRAMECON.B.IDLE = delay;
80005304:	48 62       	ld.w %d2,[%a15]24
80005306:	0c ce       	ld.bu %d15,[%a12]14
80005308:	37 f2 03 f3 	insert %d15,%d2,%d15,6,3
8000530c:	68 6f       	st.w [%a15]24,%d15
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000530e:	39 c2 18 00 	ld.bu %d2,[%a12]24
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80005312:	da 0f       	mov %d15,15
80005314:	0b f2 90 21 	min.u %d2,%d2,%d15
80005318:	48 33       	ld.w %d3,[%a15]12
8000531a:	37 23 04 24 	insert %d2,%d3,%d2,8,4
8000531e:	68 32       	st.w [%a15]12,%d2
}


IFX_INLINE void IfxAsclin_setRxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_RxFifoInterruptLevel level)
{
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
80005320:	39 c2 19 00 	ld.bu %d2,[%a12]25
80005324:	0b f2 90 f1 	min.u %d15,%d2,%d15
80005328:	48 42       	ld.w %d2,[%a15]16
8000532a:	37 f2 04 f4 	insert %d15,%d2,%d15,8,4
8000532e:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005330:	39 cf 10 00 	ld.bu %d15,[%a12]16
80005334:	48 62       	ld.w %d2,[%a15]24
80005336:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
8000533a:	68 6f       	st.w [%a15]24,%d15
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/

    /* Pin mapping */
    const IfxAsclin_Asc_Pins *pins = config->pins;
8000533c:	99 cd 24 00 	ld.a %a13,[%a12]36

    if (pins != NULL_PTR)
80005340:	bd 0d 81 00 	jz.a %a13,80005442 <IfxAsclin_Asc_initModule+0x204>
    {
        IfxAsclin_Cts_In *cts = pins->cts;
80005344:	4c d0       	ld.w %d15,[%a13]0

        if (cts != NULL_PTR)
80005346:	6e 27       	jz %d15,80005394 <IfxAsclin_Asc_initModule+0x156>
}


IFX_INLINE void IfxAsclin_initCtsPin(const IfxAsclin_Cts_In *cts, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (cts->pin.port != NULL_PTR)
80005348:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
8000534a:	79 d5 04 00 	ld.b %d5,[%a13]4
8000534e:	99 24 04 00 	ld.a %a4,[%a2]4
80005352:	39 d8 1d 00 	ld.bu %d8,[%a13]29
80005356:	bd 04 1f 00 	jz.a %a4,80005394 <IfxAsclin_Asc_initModule+0x156>
8000535a:	39 24 08 00 	ld.bu %d4,[%a2]8
8000535e:	8f f5 0f 51 	and %d5,%d5,255
80005362:	6d 00 ba 03 	call 80005ad6 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
80005366:	60 f3       	mov.a %a3,%d15
80005368:	02 85       	mov %d5,%d8
8000536a:	99 34 04 00 	ld.a %a4,[%a3]4
8000536e:	39 34 08 00 	ld.bu %d4,[%a3]8
80005372:	6d 00 30 04 	call 80005bd2 <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
80005376:	60 f3       	mov.a %a3,%d15
80005378:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_enableCts(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
8000537a:	19 22 04 00 	ld.w %d2,[%a2]4
8000537e:	b7 f2 81 2e 	insert %d2,%d2,15,29,1
80005382:	59 22 04 00 	st.w [%a2]4,%d2
    if (cts->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cts->pin.port, cts->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
        IfxAsclin_enableCts(cts->module, TRUE);
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
80005386:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setCtsInput(Ifx_ASCLIN *asclin, IfxAsclin_CtsInputSelect ctsi)
{
    asclin->IOCR.B.CTS = ctsi;
80005388:	0c 3c       	ld.bu %d15,[%a3]12
8000538a:	19 22 04 00 	ld.w %d2,[%a2]4
8000538e:	37 f2 02 f8 	insert %d15,%d2,%d15,16,2
80005392:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rx_In *rx = pins->rx;
80005394:	4c d2       	ld.w %d15,[%a13]8

        if (rx != NULL_PTR)
80005396:	6e 20       	jz %d15,800053d6 <IfxAsclin_Asc_initModule+0x198>
}


IFX_INLINE void IfxAsclin_initRxPin(const IfxAsclin_Rx_In *rx, IfxPort_InputMode inputMode, IfxPort_PadDriver padDriver)
{
    if (rx->pin.port != NULL_PTR)
80005398:	60 f2       	mov.a %a2,%d15
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
8000539a:	79 d5 0c 00 	ld.b %d5,[%a13]12
8000539e:	99 24 04 00 	ld.a %a4,[%a2]4
800053a2:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800053a6:	bd 04 18 00 	jz.a %a4,800053d6 <IfxAsclin_Asc_initModule+0x198>
800053aa:	39 24 08 00 	ld.bu %d4,[%a2]8
800053ae:	8f f5 0f 51 	and %d5,%d5,255
800053b2:	6d 00 92 03 	call 80005ad6 <IfxPort_setPinMode>
    {
        IfxPort_setPinModeInput(rx->pin.port, rx->pin.pinIndex, inputMode);
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
800053b6:	60 f3       	mov.a %a3,%d15
800053b8:	02 85       	mov %d5,%d8
800053ba:	99 34 04 00 	ld.a %a4,[%a3]4
800053be:	39 34 08 00 	ld.bu %d4,[%a3]8
800053c2:	6d 00 08 04 	call 80005bd2 <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
800053c6:	60 f3       	mov.a %a3,%d15
800053c8:	d4 32       	ld.a %a2,[%a3]
}


IFX_INLINE void IfxAsclin_setRxInput(Ifx_ASCLIN *asclin, IfxAsclin_RxInputSelect alti)
{
    asclin->IOCR.B.ALTI = alti;
800053ca:	0c 3c       	ld.bu %d15,[%a3]12
800053cc:	19 22 04 00 	ld.w %d2,[%a2]4
800053d0:	37 f2 03 f0 	insert %d15,%d2,%d15,0,3
800053d4:	6c 21       	st.w [%a2]4,%d15
        }

        IfxAsclin_Rts_Out *rts = pins->rts;
800053d6:	4c d4       	ld.w %d15,[%a13]16

        if (rts != NULL_PTR)
800053d8:	6e 1a       	jz %d15,8000540c <IfxAsclin_Asc_initModule+0x1ce>
}


IFX_INLINE void IfxPort_setPinModeOutput(Ifx_P *port, uint8 pinIndex, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800053da:	60 f2       	mov.a %a2,%d15
800053dc:	39 d2 14 00 	ld.bu %d2,[%a13]20
800053e0:	39 23 0c 00 	ld.bu %d3,[%a2]12
800053e4:	99 24 04 00 	ld.a %a4,[%a2]4
800053e8:	0f 23 a0 50 	or %d5,%d3,%d2
800053ec:	39 24 08 00 	ld.bu %d4,[%a2]8
800053f0:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
800053f4:	39 d8 1d 00 	ld.bu %d8,[%a13]29
800053f8:	6d 00 6f 03 	call 80005ad6 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initRtsPin(const IfxAsclin_Rts_Out *rts, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
800053fc:	60 f3       	mov.a %a3,%d15
800053fe:	02 85       	mov %d5,%d8
80005400:	99 34 04 00 	ld.a %a4,[%a3]4
80005404:	39 34 08 00 	ld.bu %d4,[%a3]8
80005408:	6d 00 e5 03 	call 80005bd2 <IfxPort_setPinPadDriver>
        }

        IfxAsclin_Tx_Out *tx = pins->tx;
8000540c:	4c d6       	ld.w %d15,[%a13]24

        if (tx != NULL_PTR)
8000540e:	6e 1a       	jz %d15,80005442 <IfxAsclin_Asc_initModule+0x204>
80005410:	60 f2       	mov.a %a2,%d15
80005412:	39 d2 1c 00 	ld.bu %d2,[%a13]28
80005416:	39 23 0c 00 	ld.bu %d3,[%a2]12
8000541a:	99 24 04 00 	ld.a %a4,[%a2]4
8000541e:	0f 23 a0 50 	or %d5,%d3,%d2
80005422:	39 24 08 00 	ld.bu %d4,[%a2]8
80005426:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
8000542a:	39 d8 1d 00 	ld.bu %d8,[%a13]29
8000542e:	6d 00 54 03 	call 80005ad6 <IfxPort_setPinMode>


IFX_INLINE void IfxAsclin_initTxPin(const IfxAsclin_Tx_Out *tx, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
80005432:	60 f3       	mov.a %a3,%d15
80005434:	02 85       	mov %d5,%d8
80005436:	99 34 04 00 	ld.a %a4,[%a3]4
8000543a:	39 34 08 00 	ld.bu %d4,[%a3]8
8000543e:	6d 00 ca 03 	call 80005bd2 <IfxPort_setPinPadDriver>
        }
    }

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
80005442:	40 f4       	mov.aa %a4,%a15
80005444:	39 c4 28 00 	ld.bu %d4,[%a12]40
80005448:	6d ff 5d fc 	call 80004d02 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_disableAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSENABLE.U = 0x00000000;
8000544c:	82 0f       	mov %d15,0
8000544e:	59 ff 00 10 	st.w [%a15]64,%d15
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAsclin_clearAllFlags(Ifx_ASCLIN *asclin)
{
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
80005452:	82 f2       	mov %d2,-1
80005454:	68 f2       	st.w [%a15]60,%d2

    IfxAsclin_disableAllFlags(asclinSFR);                     /* disable all flags */
    IfxAsclin_clearAllFlags(asclinSFR);                       /* clear all flags */

    /* HW error flags */
    asclin->errorFlags.ALL = 0;
80005456:	2c ee       	st.b [%a14]14,%d15

    if (config->errorFlags.flags.parityError)
80005458:	4c ca       	ld.w %d15,[%a12]40
8000545a:	2e 87       	jz.t %d15,8,80005468 <IfxAsclin_Asc_initModule+0x22a>
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000545c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005460:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80005464:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableParityErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.frameError)
80005468:	4c ca       	ld.w %d15,[%a12]40
8000546a:	2e 97       	jz.t %d15,9,80005478 <IfxAsclin_Asc_initModule+0x23a>
}


IFX_INLINE void IfxAsclin_enableFrameErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
8000546c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005470:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
80005474:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableFrameErrorFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoOverflow)
80005478:	4c ca       	ld.w %d15,[%a12]40
8000547a:	2e a7       	jz.t %d15,10,80005488 <IfxAsclin_Asc_initModule+0x24a>
}


IFX_INLINE void IfxAsclin_enableRxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
8000547c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005480:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80005484:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoOverflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.rxFifoUnderflow)
80005488:	4c ca       	ld.w %d15,[%a12]40
8000548a:	2e b7       	jz.t %d15,11,80005498 <IfxAsclin_Asc_initModule+0x25a>
}


IFX_INLINE void IfxAsclin_enableRxFifoUnderflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
8000548c:	19 ff 00 10 	ld.w %d15,[%a15]64
80005490:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80005494:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableRxFifoUnderflowFlag(asclinSFR, TRUE);
    }

    if (config->errorFlags.flags.txFifoOverflow)
80005498:	4c ca       	ld.w %d15,[%a12]40
8000549a:	2e c7       	jz.t %d15,12,800054a8 <IfxAsclin_Asc_initModule+0x26a>
}


IFX_INLINE void IfxAsclin_enableTxFifoOverflowFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
8000549c:	19 ff 00 10 	ld.w %d15,[%a15]64
800054a0:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800054a4:	59 ff 00 10 	st.w [%a15]64,%d15
    {
        IfxAsclin_enableTxFifoOverflowFlag(asclinSFR, TRUE);
    }

    /* transmission flags */
    asclin->rxSwFifoOverflow = FALSE;
800054a8:	82 0f       	mov %d15,0
800054aa:	2c ed       	st.b [%a14]13,%d15
    asclin->txInProgress     = FALSE;
800054ac:	2c ec       	st.b [%a14]12,%d15

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800054ae:	d2 04       	mov %e4,0
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800054b0:	39 c3 39 00 	ld.bu %d3,[%a12]57
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;
800054b4:	82 0f       	mov %d15,0
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
800054b6:	89 e4 54 09 	st.d [%a14]20,%e4
    asclin->sendCount      = 0;
800054ba:	6c e4       	st.w [%a14]16,%d15
    asclin->rxSwFifoOverflow = FALSE;
    asclin->txInProgress     = FALSE;

    /* Buffer mode */
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
800054bc:	e9 e3 0f 00 	st.b [%a14]15,%d3
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
    {
    case Ifx_DataBufferMode_normal:
        elementSize = 1;
800054c0:	82 1f       	mov %d15,1
    Ifx_SizeT elementSize;
    asclin->dataBufferMode = config->dataBufferMode;
    asclin->txTimestamp    = 0;
    asclin->sendCount      = 0;

    switch (asclin->dataBufferMode)
800054c2:	76 34       	jz %d3,800054ca <IfxAsclin_Asc_initModule+0x28c>
        break;
    case Ifx_DataBufferMode_timeStampSingle:
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
        break;
    default:
        elementSize = 0;
800054c4:	ba 13       	eq %d15,%d3,1
800054c6:	ab cf a0 ff 	seln %d15,%d15,%d15,12
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800054ca:	99 c4 2c 00 	ld.a %a4,[%a12]44
800054ce:	c9 c4 2a 00 	ld.h %d4,[%a12]42
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800054d2:	02 f5       	mov %d5,%d15
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    /* SW Fifos */
    if (config->txBuffer != NULL_PTR)
800054d4:	bc 44       	jz.a %a4,800054dc <IfxAsclin_Asc_initModule+0x29e>
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
800054d6:	6d 00 36 16 	call 80008142 <Ifx_Fifo_init>
800054da:	3c 03       	j 800054e0 <IfxAsclin_Asc_initModule+0x2a2>
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800054dc:	6d 00 50 16 	call 8000817c <Ifx_Fifo_create>
    }

    if (config->rxBuffer != NULL_PTR)
800054e0:	99 c4 34 00 	ld.a %a4,[%a12]52
    {
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
    }
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800054e4:	b5 e2 04 00 	st.a [%a14]4,%a2
800054e8:	c9 c4 30 00 	ld.h %d4,[%a12]48
    }

    if (config->rxBuffer != NULL_PTR)
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800054ec:	02 f5       	mov %d5,%d15
    else
    {
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
    }

    if (config->rxBuffer != NULL_PTR)
800054ee:	bc 44       	jz.a %a4,800054f6 <IfxAsclin_Asc_initModule+0x2b8>
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
800054f0:	6d 00 29 16 	call 80008142 <Ifx_Fifo_init>
800054f4:	3c 03       	j 800054fa <IfxAsclin_Asc_initModule+0x2bc>
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
800054f6:	6d 00 43 16 	call 8000817c <Ifx_Fifo_create>
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;
800054fa:	39 cf 22 00 	ld.bu %d15,[%a12]34

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
800054fe:	b9 c2 1e 00 	ld.hu %d2,[%a12]30
80005502:	8b 3f 00 82 	eq %d8,%d15,3
80005506:	02 83       	mov %d3,%d8
    {
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
    }
    else
    {
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80005508:	b5 e2 08 00 	st.a [%a14]8,%a2
    }

    /* initialising the interrupts */
    IfxSrc_Tos tos = config->interrupt.typeOfService;

    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
8000550c:	8b 02 00 35 	or.ne %d3,%d2,0
80005510:	df 03 1e 00 	jeq %d3,0,8000554c <IfxAsclin_Asc_initModule+0x30e>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
80005514:	40 f4       	mov.aa %a4,%a15
80005516:	6d ff a1 fb 	call 80004c58 <IfxAsclin_getSrcPointerRx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000551a:	54 22       	ld.w %d2,[%a2]
8000551c:	39 c3 1e 00 	ld.bu %d3,[%a12]30
80005520:	8f f2 cf 21 	andn %d2,%d2,255
80005524:	a6 32       	or %d2,%d3
80005526:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80005528:	54 22       	ld.w %d2,[%a2]
8000552a:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
8000552e:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005530:	54 22       	ld.w %d2,[%a2]
80005532:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
80005536:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableRxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
80005538:	19 f2 00 10 	ld.w %d2,[%a15]64
8000553c:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80005540:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005544:	54 22       	ld.w %d2,[%a2]
80005546:	b7 f2 01 25 	insert %d2,%d2,15,10,1
8000554a:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.rxPriority);
        IfxAsclin_enableRxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
8000554c:	b9 c2 1c 00 	ld.hu %d2,[%a12]28
80005550:	8b 02 00 85 	or.ne %d8,%d2,0
80005554:	df 08 1e 00 	jeq %d8,0,80005590 <IfxAsclin_Asc_initModule+0x352>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
80005558:	40 f4       	mov.aa %a4,%a15
8000555a:	6d ff 89 fb 	call 80004c6c <IfxAsclin_getSrcPointerTx>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000555e:	54 22       	ld.w %d2,[%a2]
80005560:	39 c3 1c 00 	ld.bu %d3,[%a12]28
80005564:	8f f2 cf 21 	andn %d2,%d2,255
80005568:	a6 32       	or %d2,%d3
8000556a:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
8000556c:	54 22       	ld.w %d2,[%a2]
8000556e:	37 f2 82 25 	insert %d2,%d2,%d15,11,2
80005572:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80005574:	54 22       	ld.w %d2,[%a2]
80005576:	b7 f2 81 2c 	insert %d2,%d2,15,25,1
8000557a:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxAsclin_enableTxFifoFillLevelFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
8000557c:	19 f2 00 10 	ld.w %d2,[%a15]64
80005580:	b7 f2 81 2f 	insert %d2,%d2,15,31,1
80005584:	59 f2 00 10 	st.w [%a15]64,%d2
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80005588:	54 22       	ld.w %d2,[%a2]
8000558a:	b7 f2 01 25 	insert %d2,%d2,15,10,1
8000558e:	74 22       	st.w [%a2],%d2
        IfxSrc_init(src, tos, config->interrupt.txPriority);
        IfxAsclin_enableTxFifoFillLevelFlag(asclinSFR, TRUE);
        IfxSrc_enable(src);
    }

    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
80005590:	b9 c2 20 00 	ld.hu %d2,[%a12]32
80005594:	df 02 1e 00 	jeq %d2,0,800055d0 <IfxAsclin_Asc_initModule+0x392>
    {
        volatile Ifx_SRC_SRCR *src;
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
80005598:	40 f4       	mov.aa %a4,%a15
8000559a:	6d ff 55 fb 	call 80004c44 <IfxAsclin_getSrcPointerEr>
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
8000559e:	54 22       	ld.w %d2,[%a2]
800055a0:	39 c3 20 00 	ld.bu %d3,[%a12]32
800055a4:	8f f2 cf 21 	andn %d2,%d2,255
800055a8:	a6 32       	or %d2,%d3
800055aa:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800055ac:	54 22       	ld.w %d2,[%a2]
800055ae:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
800055b2:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800055b4:	4c 20       	ld.w %d15,[%a2]0
800055b6:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800055ba:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableParityErrorFlag(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800055bc:	19 ff 00 10 	ld.w %d15,[%a15]64
800055c0:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
800055c4:	59 ff 00 10 	st.w [%a15]64,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800055c8:	4c 20       	ld.w %d15,[%a2]0
800055ca:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800055ce:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxAsclin_enableRxFifoInlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
800055d0:	4c f4       	ld.w %d15,[%a15]16

    IfxAsclin_flushRxFifo(asclinSFR);              // flushing Rx FIFO
    IfxAsclin_flushTxFifo(asclinSFR);              // flushing Tx FIFO

    return status;
}
800055d2:	02 92       	mov %d2,%d9
800055d4:	96 02       	or %d15,2
800055d6:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_enableTxFifoOutlet(Ifx_ASCLIN *asclin, boolean enable)
{
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
800055d8:	4c f3       	ld.w %d15,[%a15]12
800055da:	96 02       	or %d15,2
800055dc:	68 3f       	st.w [%a15]12,%d15
}


IFX_INLINE void IfxAsclin_flushRxFifo(Ifx_ASCLIN *asclin)
{
    asclin->RXFIFOCON.B.FLUSH = 1;
800055de:	4c f4       	ld.w %d15,[%a15]16
800055e0:	96 01       	or %d15,1
800055e2:	68 4f       	st.w [%a15]16,%d15
}


IFX_INLINE void IfxAsclin_flushTxFifo(Ifx_ASCLIN *asclin)
{
    asclin->TXFIFOCON.B.FLUSH = 1;
800055e4:	4c f3       	ld.w %d15,[%a15]12
800055e6:	96 01       	or %d15,1
800055e8:	68 3f       	st.w [%a15]12,%d15
800055ea:	00 90       	ret 

800055ec <IfxAsclin_Asc_initModuleConfig>:

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800055ec:	82 12       	mov %d2,1
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800055ee:	7b 10 7e 34 	movh %d3,18401

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
800055f2:	e9 42 28 00 	st.b [%a4]40,%d2
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800055f6:	82 12       	mov %d2,1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
800055f8:	82 0f       	mov %d15,0

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
800055fa:	f9 42 08 00 	st.h [%a4]8,%d2
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
800055fe:	59 43 04 00 	st.w [%a4]4,%d3
    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
80005602:	e9 42 0f 00 	st.b [%a4]15,%d2

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80005606:	82 33       	mov %d3,3
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
80005608:	e9 42 10 00 	st.b [%a4]16,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
8000560c:	e9 42 16 00 	st.b [%a4]22,%d2
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
80005610:	e9 42 17 00 	st.b [%a4]23,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80005614:	82 f2       	mov %d2,-1
void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;

    /* loop back disabled */
    config->loopBack = FALSE;                                                  /* no loop back*/
80005616:	e9 4f 38 00 	st.b [%a4]56,%d15

    /* Default values for baudrate */
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
8000561a:	e9 43 0a 00 	st.b [%a4]10,%d3

    /* Default Values for Bit Timings */
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
8000561e:	2c 4c       	st.b [%a4]12,%d15
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
80005620:	e9 43 0d 00 	st.b [%a4]13,%d3
    /* Default Values for Frame Control */
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
80005624:	2c 4e       	st.b [%a4]14,%d15
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
80005626:	e9 4f 11 00 	st.b [%a4]17,%d15
    config->frame.parityBit               = FALSE;                             /* disable parity*/
8000562a:	e9 4f 14 00 	st.b [%a4]20,%d15
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
8000562e:	e9 4f 12 00 	st.b [%a4]18,%d15
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
80005632:	82 73       	mov %d3,7

    /* Default Values for Fifo Control */
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
80005634:	e9 4f 18 00 	st.b [%a4]24,%d15
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
80005638:	e9 4f 19 00 	st.b [%a4]25,%d15
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
8000563c:	e9 4f 1a 00 	st.b [%a4]26,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80005640:	e9 42 29 00 	st.b [%a4]41,%d2
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80005644:	82 0f       	mov %d15,0

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
80005646:	82 02       	mov %d2,0
}


void IfxAsclin_Asc_initModuleConfig(IfxAsclin_Asc_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin = asclin;
80005648:	f4 45       	st.a [%a4],%a5
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
    config->frame.parityBit               = FALSE;                             /* disable parity*/
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000564a:	e9 43 13 00 	st.b [%a4]19,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
8000564e:	ac 4f       	st.h [%a4]30,%d15
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
80005650:	ac 4e       	st.h [%a4]28,%d15
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
80005652:	f9 4f 20 00 	st.h [%a4]32,%d15
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
80005656:	e9 4f 22 00 	st.b [%a4]34,%d15

    /* Enable error flags */
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/

    /* init pointers */
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
8000565a:	59 42 24 00 	st.w [%a4]36,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
8000565e:	59 42 34 00 	st.w [%a4]52,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
80005662:	59 42 2c 00 	st.w [%a4]44,%d2

    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
80005666:	f9 42 2a 00 	st.h [%a4]42,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
8000566a:	f9 42 30 00 	st.h [%a4]48,%d2

    config->dataBufferMode = Ifx_DataBufferMode_normal;
8000566e:	e9 4f 39 00 	st.b [%a4]57,%d15
80005672:	00 90       	ret 

80005674 <IfxAsclin_Asc_initiateTransmission>:
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
80005674:	0c 4c       	ld.bu %d15,[%a4]12
    config->dataBufferMode = Ifx_DataBufferMode_normal;
}

#include <stdio.h>
void IfxAsclin_Asc_initiateTransmission(IfxAsclin_Asc *asclin)
{
80005676:	20 10       	sub.a %sp,16
80005678:	40 4f       	mov.aa %a15,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
8000567a:	ee 20       	jnz %d15,800056ba <IfxAsclin_Asc_initiateTransmission+0x46>
    {

        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
8000567c:	99 44 04 00 	ld.a %a4,[%a4]4
80005680:	8c 42       	ld.h %d15,[%a4]4
80005682:	6e 1c       	jz %d15,800056ba <IfxAsclin_Asc_initiateTransmission+0x46>
        {
            uint8 data;

            asclin->txInProgress = TRUE;
80005684:	82 1f       	mov %d15,1
80005686:	28 cf       	st.b [%a15]12,%d15

            switch (asclin->dataBufferMode)
80005688:	0c ff       	ld.bu %d15,[%a15]15
8000568a:	6e 0c       	jz %d15,800056a2 <IfxAsclin_Asc_initiateTransmission+0x2e>
8000568c:	de 11       	jne %d15,1,800056ae <IfxAsclin_Asc_initiateTransmission+0x3a>
            break;
            case Ifx_DataBufferMode_timeStampSingle:
            {

                Ifx_DataBufferMode_TimeStampSingle packedData;
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000568e:	d2 06       	mov %e6,0
80005690:	d9 a5 04 00 	lea %a5,[%sp]4
80005694:	3b c0 00 40 	mov %d4,12
80005698:	6d 00 f0 15 	call 80008278 <Ifx_Fifo_read>
                data = packedData.data;
8000569c:	0c ac       	ld.bu %d15,[%sp]12
8000569e:	2c a3       	st.b [%sp]3,%d15
800056a0:	3c 07       	j 800056ae <IfxAsclin_Asc_initiateTransmission+0x3a>
            switch (asclin->dataBufferMode)
            {
            case Ifx_DataBufferMode_normal: // here
            {

                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
800056a2:	d2 06       	mov %e6,0
800056a4:	d9 a5 03 00 	lea %a5,[%sp]3
800056a8:	82 14       	mov %d4,1
800056aa:	6d 00 e7 15 	call 80008278 <Ifx_Fifo_read>
                data = packedData.data;
            }
            break;
            }

            IfxAsclin_write8(asclin->asclin, &data, 1);
800056ae:	c8 04       	ld.a %a4,[%a15]0
800056b0:	d9 a5 03 00 	lea %a5,[%sp]3
800056b4:	82 14       	mov %d4,1
800056b6:	6d ff 34 fc 	call 80004f1e <IfxAsclin_write8>
800056ba:	00 90       	ret 

800056bc <IfxAsclin_Asc_write>:
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800056bc:	40 4f       	mov.aa %a15,%a4

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
800056be:	0c 4c       	ld.bu %d15,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056c0:	99 44 04 00 	ld.a %a4,[%a4]4

    if (*count != 0)
800056c4:	94 63       	ld.h %d3,[%a6]
    return TRUE;
}

#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
800056c6:	0b 45 10 88 	mov %e8,%d5,%d4
800056ca:	40 5d       	mov.aa %a13,%a5

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056cc:	c9 44 18 00 	ld.h %d4,[%a4]24
#include <stdio.h>
boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
800056d0:	82 12       	mov %d2,1
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;

    if (*count != 0)
800056d2:	df 03 25 00 	jeq %d3,0,8000571c <IfxAsclin_Asc_write+0x60>
800056d6:	40 6c       	mov.aa %a12,%a6
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800056d8:	ee 13       	jnz %d15,800056fe <IfxAsclin_Asc_write+0x42>
{

    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
800056da:	37 04 70 f0 	extr.u %d15,%d4,0,16

    if (*count != 0)
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
800056de:	7f 3f 10 00 	jge %d15,%d3,800056fe <IfxAsclin_Asc_write+0x42>
        {


            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
800056e2:	0b 89 10 68 	mov %e6,%d9,%d8
800056e6:	6d 00 17 17 	call 80008514 <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
800056ea:	40 f4       	mov.aa %a4,%a15
800056ec:	6d ff c4 ff 	call 80005674 <IfxAsclin_Asc_initiateTransmission>

            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
800056f0:	94 c4       	ld.h %d4,[%a12]
800056f2:	c8 14       	ld.a %a4,[%a15]4
800056f4:	a2 f4       	sub %d4,%d15
800056f6:	10 d5       	addsc.a %a5,%a13,%d15,0
800056f8:	37 04 50 40 	extr %d4,%d4,0,16
800056fc:	3c 03       	j 80005702 <IfxAsclin_Asc_write+0x46>

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
800056fe:	40 d5       	mov.aa %a5,%a13
80005700:	02 34       	mov %d4,%d3
80005702:	0b 89 10 68 	mov %e6,%d9,%d8
80005706:	6d 00 07 17 	call 80008514 <Ifx_Fifo_write>

            IfxAsclin_Asc_initiateTransmission(asclin);
8000570a:	40 f4       	mov.aa %a4,%a15

        else
        {


            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
8000570c:	02 2f       	mov %d15,%d2

            IfxAsclin_Asc_initiateTransmission(asclin);
8000570e:	6d ff b3 ff 	call 80005674 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
80005712:	94 c2       	ld.h %d2,[%a12]
80005714:	a2 f2       	sub %d2,%d15
80005716:	b4 c2       	st.h [%a12],%d2
        result  = left == 0;
80005718:	8b 0f 00 22 	eq %d2,%d15,0

    }

    return result;
}
8000571c:	00 90       	ret 

8000571e <IfxAsclin_Asc_blockingWrite>:
    return data;
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
8000571e:	20 10       	sub.a %sp,16
80005720:	e9 a4 07 00 	st.b [%sp]7,%d4
    Ifx_SizeT count = 1;

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005724:	82 f4       	mov %d4,-1
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
80005726:	82 1f       	mov %d15,1

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
80005728:	d9 a5 07 00 	lea %a5,[%sp]7
8000572c:	d9 a6 0e 00 	lea %a6,[%sp]14
80005730:	9b 04 00 58 	addih %d5,%d4,32768
}


boolean IfxAsclin_Asc_blockingWrite(IfxAsclin_Asc *asclin, uint8 data)
{
    Ifx_SizeT count = 1;
80005734:	ac a7       	st.h [%sp]14,%d15

    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
}
80005736:	1d ff c3 ff 	j 800056bc <IfxAsclin_Asc_write>

8000573a <IfxAsclin_Asc_stdIfDPipeInit>:


boolean IfxAsclin_Asc_stdIfDPipeInit(IfxStdIf_DPipe *stdif, IfxAsclin_Asc *asclin)
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));
8000573a:	40 42       	mov.aa %a2,%a4
8000573c:	82 0f       	mov %d15,0
8000573e:	c5 0f 0b 10 	lea %a15,4b <_.+0x4a>
80005742:	24 2f       	st.b [%a2+],%d15
80005744:	fc ff       	loop %a15,80005742 <IfxAsclin_Asc_stdIfDPipeInit+0x8>

    /* Set the API link */
    stdif->driver         = asclin;
    stdif->write          = (IfxStdIf_DPipe_Write) & IfxAsclin_Asc_write;
80005746:	7b 00 00 f8 	movh %d15,32768
8000574a:	1b cf 6b f5 	addi %d15,%d15,22204
8000574e:	6c 42       	st.w [%a4]8,%d15
    stdif->read           = (IfxStdIf_DPipe_Read) & IfxAsclin_Asc_read;
80005750:	7b 00 00 f8 	movh %d15,32768
80005754:	1b cf 0a f5 	addi %d15,%d15,20652
80005758:	6c 43       	st.w [%a4]12,%d15
    stdif->getReadCount   = (IfxStdIf_DPipe_GetReadCount) & IfxAsclin_Asc_getReadCount;
8000575a:	7b 00 00 f8 	movh %d15,32768
8000575e:	1b 0f f3 f4 	addi %d15,%d15,20272
80005762:	6c 44       	st.w [%a4]16,%d15
    stdif->getReadEvent   = (IfxStdIf_DPipe_GetReadEvent) & IfxAsclin_Asc_getReadEvent;
80005764:	7b 00 00 f8 	movh %d15,32768
80005768:	1b 6f f3 f4 	addi %d15,%d15,20278
8000576c:	6c 45       	st.w [%a4]20,%d15
    stdif->getWriteCount  = (IfxStdIf_DPipe_GetWriteCount) & IfxAsclin_Asc_getWriteCount;
8000576e:	7b 00 00 f8 	movh %d15,32768
80005772:	1b cf f4 f4 	addi %d15,%d15,20300
80005776:	6c 46       	st.w [%a4]24,%d15
    stdif->getWriteEvent  = (IfxStdIf_DPipe_GetWriteEvent) & IfxAsclin_Asc_getWriteEvent;
80005778:	7b 00 00 f8 	movh %d15,32768
8000577c:	1b af f5 f4 	addi %d15,%d15,20314
80005780:	6c 47       	st.w [%a4]28,%d15
    stdif->canReadCount   = (IfxStdIf_DPipe_CanReadCount) & IfxAsclin_Asc_canReadCount;
80005782:	7b 00 00 f8 	movh %d15,32768
80005786:	1b cf fd f4 	addi %d15,%d15,20444
8000578a:	6c 48       	st.w [%a4]32,%d15
    stdif->canWriteCount  = (IfxStdIf_DPipe_CanWriteCount) & IfxAsclin_Asc_canWriteCount;
8000578c:	7b 00 00 f8 	movh %d15,32768
80005790:	1b 0f 08 f5 	addi %d15,%d15,20608
80005794:	6c 49       	st.w [%a4]36,%d15
    stdif->flushTx        = (IfxStdIf_DPipe_FlushTx) & IfxAsclin_Asc_flushTx;
80005796:	7b 00 00 f8 	movh %d15,32768
8000579a:	1b 4f fe f4 	addi %d15,%d15,20452
8000579e:	6c 4a       	st.w [%a4]40,%d15
    stdif->clearTx        = (IfxStdIf_DPipe_ClearTx) & IfxAsclin_Asc_clearTx;
800057a0:	7b 00 00 f8 	movh %d15,32768
800057a4:	1b 8f 09 f5 	addi %d15,%d15,20632
800057a8:	6c 4b       	st.w [%a4]44,%d15
    stdif->clearRx        = (IfxStdIf_DPipe_ClearRx) & IfxAsclin_Asc_clearRx;
800057aa:	7b 00 00 f8 	movh %d15,32768
800057ae:	1b 8f 08 f5 	addi %d15,%d15,20616
800057b2:	6c 4c       	st.w [%a4]48,%d15
    stdif->onReceive      = (IfxStdIf_DPipe_OnReceive) & IfxAsclin_Asc_isrReceive;
800057b4:	7b 00 00 f8 	movh %d15,32768
800057b8:	1b 6f 16 f5 	addi %d15,%d15,20838
800057bc:	6c 4d       	st.w [%a4]52,%d15
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
800057be:	7b 00 00 f8 	movh %d15,32768
800057c2:	1b 8f 0c f5 	addi %d15,%d15,20680
800057c6:	6c 4e       	st.w [%a4]56,%d15
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
800057c8:	7b 00 00 f8 	movh %d15,32768
800057cc:	1b 4f f6 f4 	addi %d15,%d15,20324
800057d0:	6c 4f       	st.w [%a4]60,%d15
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
800057d2:	7b 00 00 f8 	movh %d15,32768
800057d6:	1b 0f f4 f4 	addi %d15,%d15,20288
800057da:	59 4f 00 10 	st.w [%a4]64,%d15
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
800057de:	7b 00 00 f8 	movh %d15,32768
800057e2:	1b 6f f4 f4 	addi %d15,%d15,20294
800057e6:	59 4f 04 10 	st.w [%a4]68,%d15
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
800057ea:	7b 00 00 f8 	movh %d15,32768
800057ee:	1b 6f fd f4 	addi %d15,%d15,20438
800057f2:	59 4f 08 10 	st.w [%a4]72,%d15
    stdif->txDisabled     = FALSE;
800057f6:	82 0f       	mov %d15,0
{
    /* Ensure the stdif is reset to zeros */
    memset(stdif, 0, sizeof(IfxStdIf_DPipe));

    /* Set the API link */
    stdif->driver         = asclin;
800057f8:	f4 45       	st.a [%a4],%a5
    stdif->onTransmit     = (IfxStdIf_DPipe_OnTransmit) & IfxAsclin_Asc_isrTransmit;
    stdif->onError        = (IfxStdIf_DPipe_OnError) & IfxAsclin_Asc_isrError;
    stdif->getSendCount   = (IfxStdIf_DPipe_GetSendCount) & IfxAsclin_Asc_getSendCount;
    stdif->getTxTimeStamp = (IfxStdIf_DPipe_GetTxTimeStamp) & IfxAsclin_Asc_getTxTimeStamp;
    stdif->resetSendCount = (IfxStdIf_DPipe_ResetSendCount) & IfxAsclin_Asc_resetSendCount;
    stdif->txDisabled     = FALSE;
800057fa:	2c 44       	st.b [%a4]4,%d15
    return TRUE;
}
800057fc:	82 12       	mov %d2,1
800057fe:	00 90       	ret 

80005800 <IfxPort_getAddress>:
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005800:	91 00 00 28 	movh.a %a2,32768
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
80005804:	82 05       	mov %d5,0
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
80005806:	82 02       	mov %d2,0
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
80005808:	d9 22 88 e0 	lea %a2,[%a2]2952 <80000b88 <IfxPort_cfg_indexMap>>
Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
8000580c:	8f f5 0f f1 	and %d15,%d5,255
80005810:	8b 02 00 32 	eq %d3,%d2,0
80005814:	8b 0f 61 34 	and.lt.u %d3,%d15,16
80005818:	76 3a       	jz %d3,8000582c <IfxPort_getAddress+0x2c>
8000581a:	02 5f       	mov %d15,%d5
8000581c:	16 ff       	and %d15,255
    {
        if (IfxPort_cfg_indexMap[i].index == port)
8000581e:	d0 2f       	addsc.a %a15,%a2,%d15,3
80005820:	82 02       	mov %d2,0
80005822:	4c f1       	ld.w %d15,[%a15]4
80005824:	7e 42       	jne %d15,%d4,80005828 <IfxPort_getAddress+0x28>
        {
            module = IfxPort_cfg_indexMap[i].module;
80005826:	48 02       	ld.w %d2,[%a15]0
80005828:	c2 15       	add %d5,1
8000582a:	3c f1       	j 8000580c <IfxPort_getAddress+0xc>

        i++;
    }

    return module;
}
8000582c:	60 22       	mov.a %a2,%d2
8000582e:	00 90       	ret 

80005830 <IfxPort_getIndex>:

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005830:	91 00 00 38 	movh.a %a3,32768
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
80005834:	82 0f       	mov %d15,0
    {
        if (IfxPort_cfg_indexMap[index].module == port)
80005836:	d9 33 88 e0 	lea %a3,[%a3]2952 <80000b88 <IfxPort_cfg_indexMap>>
8000583a:	a0 ff       	mov.a %a15,15
8000583c:	d0 32       	addsc.a %a2,%a3,%d15,3
8000583e:	d4 25       	ld.a %a5,[%a2]
80005840:	7d 45 05 80 	jne.a %a5,%a4,8000584a <IfxPort_getIndex+0x1a>
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
80005844:	79 22 04 00 	ld.b %d2,[%a2]4
            break;
80005848:	00 90       	ret 
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
8000584a:	c2 1f       	add %d15,1
8000584c:	fc f8       	loop %a15,8000583c <IfxPort_getIndex+0xc>
IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;
8000584e:	82 f2       	mov %d2,-1
            break;
        }
    }

    return result;
}
80005850:	00 90       	ret 

80005852 <IfxPort_resetESR>:


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
80005852:	40 4f       	mov.aa %a15,%a4
80005854:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005856:	6d 00 ac 0c 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
8000585a:	02 24       	mov %d4,%d2
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000585c:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
8000585e:	6d 00 a8 0b 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 0);
80005862:	82 12       	mov %d2,1
80005864:	d9 f4 10 10 	lea %a4,[%a15]80
80005868:	0f 82 00 20 	sh %d2,%d2,%d8

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
8000586c:	d2 06       	mov %e6,0
8000586e:	02 27       	mov %d7,%d2
80005870:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
80005874:	02 f4       	mov %d4,%d15
80005876:	1d 00 d1 0c 	j 80007218 <IfxScuWdt_setCpuEndinit>

8000587a <IfxPort_disableEmergencyStop>:
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
8000587a:	91 00 00 38 	movh.a %a3,32768
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
8000587e:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
80005880:	d9 33 c8 00 	lea %a3,[%a3]3080 <80000c08 <IfxPort_cfg_esrMasks>>
80005884:	a0 ff       	mov.a %a15,15
80005886:	d0 32       	addsc.a %a2,%a3,%d15,3
80005888:	d4 25       	ld.a %a5,[%a2]
8000588a:	7d 54 0c 80 	jne.a %a4,%a5,800058a2 <IfxPort_disableEmergencyStop+0x28>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
8000588e:	b9 2f 04 00 	ld.hu %d15,[%a2]4
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
80005892:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
80005894:	57 0f 61 f4 	extr.u %d15,%d15,%d4,1
80005898:	6e 08       	jz %d15,800058a8 <IfxPort_disableEmergencyStop+0x2e>
            {
                IfxPort_resetESR(port, pinIndex);
8000589a:	6d ff dc ff 	call 80005852 <IfxPort_resetESR>
                result = TRUE;
8000589e:	82 12       	mov %d2,1
800058a0:	00 90       	ret 
boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800058a2:	c2 1f       	add %d15,1
800058a4:	fc f1       	loop %a15,80005886 <IfxPort_disableEmergencyStop+0xc>
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;
800058a6:	82 02       	mov %d2,0
            break;
        }
    }

    return result;
}
800058a8:	00 90       	ret 

800058aa <IfxPort_setESR>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
800058aa:	40 4f       	mov.aa %a15,%a4
800058ac:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800058ae:	6d 00 80 0c 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
800058b2:	02 24       	mov %d4,%d2
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
800058b4:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
800058b6:	6d 00 7c 0b 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    __ldmst(&port->ESR.U, 1U << pinIndex, 1U << pinIndex);
800058ba:	82 12       	mov %d2,1
800058bc:	0f 82 00 20 	sh %d2,%d2,%d8
800058c0:	d9 f4 10 10 	lea %a4,[%a15]80
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
800058c4:	53 12 40 60 	mul.u %e6,%d2,1

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
800058c8:	02 27       	mov %d7,%d2
800058ca:	49 46 40 08 	ldmst [%a4]0,%e6
    IfxScuWdt_setCpuEndinit(passwd);
800058ce:	02 f4       	mov %d4,%d15
800058d0:	1d 00 a4 0c 	j 80007218 <IfxScuWdt_setCpuEndinit>

800058d4 <IfxPort_enableEmergencyStop>:
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
800058d4:	82 19       	mov %d9,1
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800058d6:	91 00 00 d8 	movh.a %a13,32768
    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
800058da:	40 4c       	mov.aa %a12,%a4
800058dc:	02 48       	mov %d8,%d4
800058de:	0f 49 00 90 	sh %d9,%d9,%d4
    sint32  portIndex;
    boolean result = FALSE;
800058e2:	82 02       	mov %d2,0

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
800058e4:	82 0f       	mov %d15,0
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
800058e6:	d9 dd c8 00 	lea %a13,[%a13]3080 <80000c08 <IfxPort_cfg_esrMasks>>
800058ea:	d0 df       	addsc.a %a15,%a13,%d15,3
800058ec:	c8 02       	ld.a %a2,[%a15]0
800058ee:	7d 2c 0b 80 	jne.a %a12,%a2,80005904 <IfxPort_enableEmergencyStop+0x30>
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
800058f2:	b9 f3 04 00 	ld.hu %d3,[%a15]4
800058f6:	26 93       	and %d3,%d9
800058f8:	76 36       	jz %d3,80005904 <IfxPort_enableEmergencyStop+0x30>
            {
                IfxPort_setESR(port, pinIndex);
800058fa:	40 c4       	mov.aa %a4,%a12
800058fc:	02 84       	mov %d4,%d8
800058fe:	6d ff d6 ff 	call 800058aa <IfxPort_setESR>
                result = TRUE;
80005902:	82 12       	mov %d2,1
boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
80005904:	c2 1f       	add %d15,1
80005906:	8b 0f 21 32 	ne %d3,%d15,16
8000590a:	df 03 f0 ff 	jne %d3,0,800058ea <IfxPort_enableEmergencyStop+0x16>
            }
        }
    }

    return result;
}
8000590e:	00 90       	ret 

80005910 <IfxPort_setGroupModeInput>:
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005910:	82 0f       	mov %d15,0
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
80005912:	20 20       	sub.a %sp,32
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005914:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
80005916:	78 04       	st.w [%sp]16,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005918:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
8000591a:	78 05       	st.w [%sp]20,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
8000591c:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
8000591e:	78 06       	st.w [%sp]24,%d15
    uint32 iocrMask[4];

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
80005920:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
80005922:	78 07       	st.w [%sp]28,%d15
80005924:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005928:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
8000592c:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005930:	3b 80 0f 70 	mov %d7,248
80005934:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005938:	9f 0f 07 80 	jned %d15,0,80005946 <IfxPort_setGroupModeInput+0x36>
8000593c:	d9 44 10 00 	lea %a4,[%a4]16
80005940:	82 0f       	mov %d15,0
80005942:	a0 3f       	mov.a %a15,3
80005944:	3c 1e       	j 80005980 <IfxPort_setGroupModeInput+0x70>
    {
        if ((imask & (1U << i)) != 0)
80005946:	57 05 61 24 	extr.u %d2,%d5,%d4,1
8000594a:	df 02 19 00 	jeq %d2,0,8000597c <IfxPort_setGroupModeInput+0x6c>
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
8000594e:	8f 34 c0 31 	andn %d3,%d4,3
80005952:	60 32       	mov.a %a2,%d3
80005954:	d9 af 20 00 	lea %a15,[%sp]32
80005958:	30 2f       	add.a %a15,%a2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
8000595a:	8f 34 00 21 	and %d2,%d4,3
8000595e:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
80005960:	19 f0 f0 ff 	ld.w %d0,[%a15]-16
80005964:	0f 27 00 30 	sh %d3,%d7,%d2
80005968:	a6 03       	or %d3,%d0
8000596a:	59 f3 f0 ff 	st.w [%a15]-16,%d3
            iocrVal[index]  |= (mode) << shift;
8000596e:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
80005972:	0f 26 00 20 	sh %d2,%d6,%d2
80005976:	a6 32       	or %d2,%d3
80005978:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
8000597c:	c2 14       	add %d4,1
8000597e:	3c dd       	j 80005938 <IfxPort_setGroupModeInput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005980:	d9 a3 20 00 	lea %a3,[%sp]32
80005984:	90 32       	addsc.a %a2,%a3,%d15,2
80005986:	19 24 f0 ff 	ld.w %d4,[%a2]-16
8000598a:	76 47       	jz %d4,80005998 <IfxPort_setGroupModeInput+0x88>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
8000598c:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005990:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005992:	02 43       	mov %d3,%d4
80005994:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005998:	c2 1f       	add %d15,1
8000599a:	b0 44       	add.a %a4,4
8000599c:	fc f2       	loop %a15,80005980 <IfxPort_setGroupModeInput+0x70>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
8000599e:	00 90       	ret 

800059a0 <IfxPort_setGroupModeOutput>:
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800059a0:	82 0f       	mov %d15,0
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
800059a2:	20 20       	sub.a %sp,32
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800059a4:	78 00       	st.w [%sp]0,%d15
        iocrMask[i] = 0;
800059a6:	78 04       	st.w [%sp]16,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800059a8:	78 01       	st.w [%sp]4,%d15
        iocrMask[i] = 0;
800059aa:	78 05       	st.w [%sp]20,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800059ac:	78 02       	st.w [%sp]8,%d15
        iocrMask[i] = 0;
800059ae:	78 06       	st.w [%sp]24,%d15
    IFX_UNUSED_PARAMETER(index == IfxPort_OutputIdx_general);

    /* initialise */
    for (i = 0; i < 4; i++)
    {
        iocrVal[i]  = 0;
800059b0:	78 03       	st.w [%sp]12,%d15
        iocrMask[i] = 0;
800059b2:	78 07       	st.w [%sp]28,%d15
800059b4:	8b 14 a1 22 	ge.u %d2,%d4,17
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059b8:	8b 04 01 f1 	rsub %d15,%d4,16
        iocrVal[i]  = 0;
        iocrMask[i] = 0;
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;
800059bc:	0f 45 00 50 	sh %d5,%d5,%d4
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059c0:	3b 80 0f 00 	mov %d0,248
800059c4:	ab 0f a0 f2 	seln %d15,%d2,%d15,0
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
800059c8:	9f 0f 07 80 	jned %d15,0,800059d6 <IfxPort_setGroupModeOutput+0x36>
800059cc:	d9 44 10 00 	lea %a4,[%a4]16
800059d0:	82 0f       	mov %d15,0
800059d2:	a0 3f       	mov.a %a15,3
800059d4:	3c 1f       	j 80005a12 <IfxPort_setGroupModeOutput+0x72>
    {
        if ((imask & (1U << i)) != 0)
800059d6:	57 05 61 24 	extr.u %d2,%d5,%d4,1
800059da:	df 02 1a 00 	jeq %d2,0,80005a0e <IfxPort_setGroupModeOutput+0x6e>
        {
            uint32 index = i / 4;
800059de:	8f e4 1f 30 	sh %d3,%d4,-2
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059e2:	d9 a2 20 00 	lea %a2,[%sp]32
800059e6:	01 23 02 f6 	addsc.a %a15,%a2,%d3,2
    for (i = pinIndex; i < 16; i++)
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
800059ea:	8f 34 00 21 	and %d2,%d4,3
800059ee:	06 32       	sh %d2,3
            iocrMask[index] |= (0x1FU << 3) << shift;
            iocrVal[index]  |= (mode | index) << shift;
800059f0:	a6 63       	or %d3,%d6
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
800059f2:	0f 20 00 70 	sh %d7,%d0,%d2
800059f6:	19 f1 f0 ff 	ld.w %d1,[%a15]-16
            iocrVal[index]  |= (mode | index) << shift;
800059fa:	0f 23 00 20 	sh %d2,%d3,%d2
800059fe:	19 f3 e0 ff 	ld.w %d3,[%a15]-32
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a02:	a6 17       	or %d7,%d1
            iocrVal[index]  |= (mode | index) << shift;
80005a04:	a6 32       	or %d2,%d3
    {
        if ((imask & (1U << i)) != 0)
        {
            uint32 index = i / 4;
            uint32 shift = (i & 0x3U) * 8;
            iocrMask[index] |= (0x1FU << 3) << shift;
80005a06:	59 f7 f0 ff 	st.w [%a15]-16,%d7
            iocrVal[index]  |= (mode | index) << shift;
80005a0a:	59 f2 e0 ff 	st.w [%a15]-32,%d2
    }

    /* calculate IOCRx values and masks */
    uint32 imask = (uint32)mask << pinIndex;

    for (i = pinIndex; i < 16; i++)
80005a0e:	c2 14       	add %d4,1
80005a10:	3c dc       	j 800059c8 <IfxPort_setGroupModeOutput+0x28>
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
    {
        if (iocrMask[i] != 0)
80005a12:	d9 a3 20 00 	lea %a3,[%sp]32
80005a16:	90 32       	addsc.a %a2,%a3,%d15,2
80005a18:	19 24 f0 ff 	ld.w %d4,[%a2]-16
80005a1c:	76 47       	jz %d4,80005a2a <IfxPort_setGroupModeOutput+0x8a>
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005a1e:	19 22 e0 ff 	ld.w %d2,[%a2]-32
80005a22:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005a24:	02 43       	mov %d3,%d4
80005a26:	49 42 40 08 	ldmst [%a4]0,%e2
            iocrVal[index]  |= (mode | index) << shift;
        }
    }

    /* write IOCRx */
    for (i = 0; i < 4; i++)
80005a2a:	c2 1f       	add %d15,1
80005a2c:	b0 44       	add.a %a4,4
80005a2e:	fc f2       	loop %a15,80005a12 <IfxPort_setGroupModeOutput+0x72>
        if (iocrMask[i] != 0)
        {
            __ldmst(&((&(port->IOCR0.U))[i]), iocrMask[i], iocrVal[i]);
        }
    }
}
80005a30:	00 90       	ret 

80005a32 <IfxPort_setGroupPadDriver>:


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
80005a32:	20 10       	sub.a %sp,16
80005a34:	02 4f       	mov %d15,%d4
80005a36:	02 5a       	mov %d10,%d5
80005a38:	40 4c       	mov.aa %a12,%a4
80005a3a:	02 69       	mov %d9,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a3c:	6d 00 b9 0b 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005a40:	02 24       	mov %d4,%d2
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005a42:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005a44:	6d 00 b5 0a 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005a48:	82 03       	mov %d3,0
80005a4a:	74 a3       	st.w [%sp],%d3
            pdrMask[i] = 0;
80005a4c:	59 a3 08 00 	st.w [%sp]8,%d3
        uint32 pdrMask[2];

        /* initialise */
        for (i = 0; i < 2; i++)
        {
            pdrVal[i]  = 0;
80005a50:	59 a3 04 00 	st.w [%sp]4,%d3
            pdrMask[i] = 0;
80005a54:	59 a3 0c 00 	st.w [%sp]12,%d3
80005a58:	8b 1f a1 22 	ge.u %d2,%d15,17
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a5c:	8b 0f 01 31 	rsub %d3,%d15,16
            pdrVal[i]  = 0;
            pdrMask[i] = 0;
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;
80005a60:	0f fa 00 50 	sh %d5,%d10,%d15
80005a64:	ab 03 a0 32 	seln %d3,%d2,%d3,0

        for (i = pinIndex; i < 16; i++)
80005a68:	9f 03 03 80 	jned %d3,0,80005a6e <IfxPort_setGroupPadDriver+0x3c>
80005a6c:	3c 1d       	j 80005aa6 <IfxPort_setGroupPadDriver+0x74>
        {
            if ((imask & (1U << i)) != 0)
80005a6e:	57 05 61 2f 	extr.u %d2,%d5,%d15,1
80005a72:	df 02 18 00 	jeq %d2,0,80005aa2 <IfxPort_setGroupPadDriver+0x70>
            {
                uint32 index = i / 8;
80005a76:	8f df 1f 40 	sh %d4,%d15,-3
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a7a:	d9 a2 10 00 	lea %a2,[%sp]16
80005a7e:	01 24 02 f6 	addsc.a %a15,%a2,%d4,2
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005a82:	8f 7f 00 21 	and %d2,%d15,7
                pdrMask[index] |= (0xFUL << shift);
80005a86:	19 f4 f8 ff 	ld.w %d4,[%a15]-8
        for (i = pinIndex; i < 16; i++)
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
80005a8a:	06 22       	sh %d2,2
                pdrMask[index] |= (0xFUL << shift);
80005a8c:	d7 f4 04 42 	insert %d4,%d4,15,%d2,4
                pdrVal[index]  |= (padDriver << shift);
80005a90:	0f 29 00 20 	sh %d2,%d9,%d2
        {
            if ((imask & (1U << i)) != 0)
            {
                uint32 index = i / 8;
                uint32 shift = (i & 0x7U) * 4;
                pdrMask[index] |= (0xFUL << shift);
80005a94:	59 f4 f8 ff 	st.w [%a15]-8,%d4
                pdrVal[index]  |= (padDriver << shift);
80005a98:	19 f4 f0 ff 	ld.w %d4,[%a15]-16
80005a9c:	a6 42       	or %d2,%d4
80005a9e:	59 f2 f0 ff 	st.w [%a15]-16,%d2
        }

        /* calculate PDRx values and masks */
        uint32 imask = (uint32)mask << pinIndex;

        for (i = pinIndex; i < 16; i++)
80005aa2:	c2 1f       	add %d15,1
80005aa4:	3c e2       	j 80005a68 <IfxPort_setGroupPadDriver+0x36>
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005aa6:	58 02       	ld.w %d15,[%sp]8
80005aa8:	6e 08       	jz %d15,80005ab8 <IfxPort_setGroupPadDriver+0x86>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005aaa:	d9 cf 00 10 	lea %a15,[%a12]64
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005aae:	54 a6       	ld.w %d6,[%sp]
80005ab0:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005ab2:	02 f7       	mov %d7,%d15
80005ab4:	49 f6 40 08 	ldmst [%a15]0,%e6
        }

        /* write PDRx */
        for (i = 0; i < 2; i++)
        {
            if (pdrMask[i] != 0)
80005ab8:	58 03       	ld.w %d15,[%sp]12
80005aba:	6e 09       	jz %d15,80005acc <IfxPort_setGroupPadDriver+0x9a>
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
80005abc:	d9 cc 04 10 	lea %a12,[%a12]68
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005ac0:	19 a6 04 00 	ld.w %d6,[%sp]4
80005ac4:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005ac6:	02 f7       	mov %d7,%d15
80005ac8:	49 c6 40 08 	ldmst [%a12]0,%e6
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005acc:	02 84       	mov %d4,%d8
}
80005ace:	d9 aa 10 00 	lea %sp,[%sp]16
            {
                __ldmst(&((&(port->PDR0.U))[i]), pdrMask[i], pdrVal[i]);
            }
        }
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005ad2:	1d 00 a3 0b 	j 80007218 <IfxScuWdt_setCpuEndinit>

80005ad6 <IfxPort_setPinMode>:
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
80005ad6:	91 40 00 2f 	movh.a %a2,61444

void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005ada:	8f 34 00 91 	and %d9,%d4,3

    if (port == &MODULE_P40)
80005ade:	d9 22 00 0e 	lea %a2,[%a2]-8192 <f003e000 <_SMALL_DATA4_+0x40036000>>
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80005ae2:	40 4f       	mov.aa %a15,%a4
80005ae4:	02 4f       	mov %d15,%d4
80005ae6:	02 5a       	mov %d10,%d5
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80005ae8:	d9 4c 10 00 	lea %a12,[%a4]16
    uint8                 iocrIndex = (pinIndex / 4);
80005aec:	8f e4 1f b0 	sh %d11,%d4,-2
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80005af0:	06 39       	sh %d9,3

    if (port == &MODULE_P40)
80005af2:	7d 24 11 80 	jne.a %a4,%a2,80005b14 <IfxPort_setPinMode+0x3e>
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005af6:	6d 00 5c 0b 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
        IfxScuWdt_clearCpuEndinit(passwd);
80005afa:	02 24       	mov %d4,%d2
    uint8                 iocrIndex = (pinIndex / 4);
    uint8                 shift     = (pinIndex & 0x3U) * 8;

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005afc:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80005afe:	6d 00 58 0a 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80005b02:	19 f2 20 10 	ld.w %d2,[%a15]96
        IfxScuWdt_setCpuEndinit(passwd);
80005b06:	02 84       	mov %d4,%d8

    if (port == &MODULE_P40)
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
80005b08:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80005b0c:	59 ff 20 10 	st.w [%a15]96,%d15
        IfxScuWdt_setCpuEndinit(passwd);
80005b10:	6d 00 84 0b 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80005b14:	da ff       	mov %d15,255
80005b16:	01 cb 02 f6 	addsc.a %a15,%a12,%d11,2
80005b1a:	0f 9f 00 f0 	sh %d15,%d15,%d9
80005b1e:	0f 9a 00 20 	sh %d2,%d10,%d9
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005b22:	82 03       	mov %d3,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005b24:	02 f3       	mov %d3,%d15
80005b26:	49 f2 40 08 	ldmst [%a15]0,%e2
80005b2a:	00 90       	ret 

80005b2c <IfxPort_setPinModeLvdsHigh>:
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
80005b2c:	02 5a       	mov %d10,%d5
80005b2e:	40 4f       	mov.aa %a15,%a4
80005b30:	02 49       	mov %d9,%d4
80005b32:	02 6f       	mov %d15,%d6
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b34:	6d 00 3d 0b 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005b38:	02 24       	mov %d4,%d2
}


void IfxPort_setPinModeLvdsHigh(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode, IfxPort_ControlledBy enablePortControlled)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005b3a:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005b3c:	6d 00 39 0a 	call 80006fae <IfxScuWdt_clearCpuEndinit>

    if (mode < IfxPort_Mode_outputPushPullGeneral)
80005b40:	37 0a 48 50 	extr %d5,%d10,0,8
80005b44:	bf 05 11 00 	jlt %d5,0,80005b66 <IfxPort_setPinModeLvdsHigh+0x3a>
    {
        if (pinIndex < 2)
80005b48:	bf 29 21 80 	jlt.u %d9,2,80005b8a <IfxPort_setPinModeLvdsHigh+0x5e>
        {}
        else
        {
            port->LPCR1.B_P21.RDIS_CTRL = enablePortControlled;
80005b4c:	19 f2 24 20 	ld.w %d2,[%a15]164
80005b50:	37 f2 01 f0 	insert %d15,%d2,%d15,0,1
80005b54:	59 ff 24 20 	st.w [%a15]164,%d15
            port->LPCR1.B_P21.RX_DIS    = 0;
80005b58:	19 ff 24 20 	ld.w %d15,[%a15]164
80005b5c:	8f 2f c0 f1 	andn %d15,%d15,2
80005b60:	59 ff 24 20 	st.w [%a15]164,%d15
80005b64:	3c 13       	j 80005b8a <IfxPort_setPinModeLvdsHigh+0x5e>
        }
    }
    else
    {
        port->LPCR2.B.TDIS_CTRL = enablePortControlled;
80005b66:	19 f2 28 20 	ld.w %d2,[%a15]168
80005b6a:	67 f2 0c f0 	ins.t %d15,%d2,12,%d15,0
80005b6e:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_DIS    = 0;
80005b72:	19 ff 28 20 	ld.w %d15,[%a15]168
80005b76:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80005b7a:	59 ff 28 20 	st.w [%a15]168,%d15
        port->LPCR2.B.TX_PD     = 0;
80005b7e:	19 ff 28 20 	ld.w %d15,[%a15]168
80005b82:	b7 0f 01 f7 	insert %d15,%d15,0,14,1
80005b86:	59 ff 28 20 	st.w [%a15]168,%d15
    }

    IfxScuWdt_setCpuEndinit(passwd);
80005b8a:	02 84       	mov %d4,%d8
80005b8c:	1d 00 46 0b 	j 80007218 <IfxScuWdt_setCpuEndinit>

80005b90 <IfxPort_setPinModeLvdsMedium>:
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005b90:	0b 65 10 a8 	mov %e10,%d5,%d6
80005b94:	40 4f       	mov.aa %a15,%a4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005b96:	8f f4 1f 90 	sh %d9,%d4,-1
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
80005b9a:	02 48       	mov %d8,%d4
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005b9c:	6d 00 09 0b 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005ba0:	02 24       	mov %d4,%d2
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();
80005ba2:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005ba4:	6d 00 05 0a 	call 80006fae <IfxScuWdt_clearCpuEndinit>
}


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
80005ba8:	06 d8       	sh %d8,-3
    uint32                shift      = ((pinIndex / 2) * 8);
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
80005baa:	d9 f2 00 10 	lea %a2,[%a15]64
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005bae:	01 28 02 26 	addsc.a %a2,%a2,%d8,2


void IfxPort_setPinModeLvdsMedium(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver lvdsPadDriver, IfxPort_PadSupply padSupply)
{
    uint32                pdrOffset  = (pinIndex / 8);
    uint32                shift      = ((pinIndex / 2) * 8);
80005bb2:	8f 39 00 20 	sh %d2,%d9,3
    uint32                lpcrOffset = (pinIndex / 2);
    volatile Ifx_P_PDR0  *pdr        = &(port->PDR0);
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
80005bb6:	d9 f4 20 20 	lea %a4,[%a15]160
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005bba:	01 49 02 46 	addsc.a %a4,%a4,%d9,2
    volatile Ifx_P_LPCR0 *lpcr       = &(port->LPCR0);
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
80005bbe:	0f 2b 00 50 	sh %d5,%d11,%d2
80005bc2:	74 25       	st.w [%a2],%d5
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005bc4:	54 46       	ld.w %d6,[%a4]
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005bc6:	02 f4       	mov %d4,%d15
    uint16                passwd     = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        pdr[pdrOffset].U       = (lvdsPadDriver << shift); /* configuring LVDS mode */
        lpcr[lpcrOffset].B.PS1 = padSupply;
80005bc8:	67 a6 01 60 	ins.t %d6,%d6,1,%d10,0
80005bcc:	74 46       	st.w [%a4],%d6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005bce:	1d 00 25 0b 	j 80007218 <IfxScuWdt_setCpuEndinit>

80005bd2 <IfxPort_setPinPadDriver>:
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80005bd2:	0b 45 10 88 	mov %e8,%d5,%d4
80005bd6:	40 4f       	mov.aa %a15,%a4
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bd8:	6d 00 eb 0a 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80005bdc:	02 24       	mov %d4,%d2
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80005bde:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80005be0:	6d 00 e7 09 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
80005be4:	8f 78 00 21 	and %d2,%d8,7
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005be8:	06 22       	sh %d2,2
80005bea:	06 d8       	sh %d8,-3
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80005bec:	d9 ff 00 10 	lea %a15,[%a15]64
        uint8            pdrIndex = (pinIndex / 8);
        uint8            shift    = (pinIndex & 0x7U) * 4;
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80005bf0:	3b f0 00 30 	mov %d3,15
80005bf4:	01 f8 02 f6 	addsc.a %a15,%a15,%d8,2
80005bf8:	0f 23 00 30 	sh %d3,%d3,%d2
80005bfc:	0f 29 00 60 	sh %d6,%d9,%d2
                  ldmst [%0]0,%A2"
                     ::"a"(address), "d"(mask), "d"((long long)value));
80005c00:	82 07       	mov %d7,0

/** Insert LDMST instruction. Note that all operands must be word-aligned.
 */
IFX_INLINE void Ifx__ldmst(volatile void* address, uint32 mask, uint32 value)
{
    __asm__ volatile("mov %H2,%1 \n\
80005c02:	02 37       	mov %d7,%d3
80005c04:	49 f6 40 08 	ldmst [%a15]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80005c08:	02 f4       	mov %d4,%d15
80005c0a:	1d 00 07 0b 	j 80007218 <IfxScuWdt_setCpuEndinit>
	...

80005c10 <IfxScuCcu_calculateSysPllDividers>:
        //' K2+1 div should be even for 50% duty cycle
        k2Steps = 2;

        if (fPll > 240000000)
        {
            k2Steps = 1;
80005c10:	7b e0 e4 30 	movh %d3,3662
80005c14:	1b 13 c0 31 	addi %d3,%d3,7169
80005c18:	0b 34 30 c1 	lt.u %d12,%d4,%d3
80005c1c:	82 2f       	mov %d15,2
80005c1e:	ab 1f 80 cc 	sel %d12,%d12,%d15,1
80005c22:	8f 4c 00 80 	sh %d8,%d12,4
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005c26:	7b c0 be 00 	movh %d0,3052

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c2a:	91 40 0f 50 	movh.a %a5,244
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c2e:	7b 80 82 6e 	movh %d6,59432
80005c32:	91 80 7d 61 	movh.a %a6,6104

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
    uint8   deviationAllowed = 2;
    uint32  fOsc             = cfg->xtalFrequency;
80005c36:	19 4e 10 10 	ld.w %d14,[%a4]80
80005c3a:	60 83       	mov.a %a3,%d8
        uint32       bestK2 = 0, bestN = 0, bestP = 0;

        uint64       fRef, fVco;
        uint64       fPllLeastError;

        fPllLeastError = fPllMax;
80005c3c:	1b 00 20 0c 	addi %d0,%d0,-15872

        uint32       p;
        uint32       n;
        uint32       k2;
        uint32       k2Steps;
        uint32       bestK2 = 0, bestN = 0, bestP = 0;
80005c40:	d2 0a       	mov %e10,0
80005c42:	82 09       	mov %d9,0
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005c44:	3b 00 01 50 	mov %d5,16
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c48:	d9 55 41 02 	lea %a5,[%a5]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c4c:	82 f7       	mov %d7,-1
80005c4e:	1b 06 c0 67 	addi %d6,%d6,31744
80005c52:	d9 66 41 08 	lea %a6,[%a6]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
80005c56:	a0 ff       	mov.a %a15,15
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005c58:	4b 5e 11 22 	div.u %e2,%d14,%d5

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c5c:	7b 60 f8 1f 	movh %d1,65414
80005c60:	1b 01 e0 1e 	addi %d1,%d1,-4608
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
        {
            fRef = (fOsc / p);
80005c64:	82 03       	mov %d3,0

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
80005c66:	0b 12 40 10 	addx %d1,%d2,%d1
80005c6a:	8b f3 bf 20 	addc %d2,%d3,-1
80005c6e:	80 53       	mov.d %d3,%a5
80005c70:	ba 02       	eq %d15,%d2,0
80005c72:	0b 31 50 f2 	and.ge.u %d15,%d1,%d3
80005c76:	8b 02 00 f5 	or.ne %d15,%d2,0
80005c7a:	ee 24       	jnz %d15,80005cc2 <IfxScuCcu_calculateSysPllDividers+0xb2>
80005c7c:	02 5d       	mov %d13,%d5
80005c7e:	82 11       	mov %d1,1
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
80005c80:	03 41 68 26 	madd.u %e2,%e6,%d1,%d4
80005c84:	80 68       	mov.d %d8,%a6
80005c86:	ba 03       	eq %d15,%d3,0
80005c88:	0b 82 50 f2 	and.ge.u %d15,%d2,%d8
80005c8c:	8b 03 00 f5 	or.ne %d15,%d3,0
80005c90:	ee 13       	jnz %d15,80005cb6 <IfxScuCcu_calculateSysPllDividers+0xa6>
80005c92:	82 18       	mov %d8,1
80005c94:	c5 02 3f 10 	lea %a2,7f <_.+0x7e>
                    {
                        for (n = nMin; n <= nMax; n++)
                        {
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);
80005c98:	4b d8 11 22 	div.u %e2,%d8,%d13
80005c9c:	e2 e2       	mul %d2,%d14
80005c9e:	a2 42       	sub %d2,%d4

                            if (fPllError == 0)
80005ca0:	df 02 18 00 	jeq %d2,0,80005cd0 <IfxScuCcu_calculateSysPllDividers+0xc0>
                                bestP          = p;

                                goto EXITCALC_LOOP;
                            }

                            if (fPllLeastError > fPllError)
80005ca4:	82 1f       	mov %d15,1
80005ca6:	0b 02 50 f2 	and.ge.u %d15,%d2,%d0
80005caa:	6a 8b       	cmovn %d11,%d15,%d8
80005cac:	6a 20       	cmovn %d0,%d15,%d2
80005cae:	6a 5a       	cmovn %d10,%d15,%d5
80005cb0:	6a 19       	cmovn %d9,%d15,%d1
                {
                    fVco = ((uint64)fPll) * k2;

                    if ((fVco >= fVcoMin) && (fVco <= fVcoMax))
                    {
                        for (n = nMin; n <= nMax; n++)
80005cb2:	c2 18       	add %d8,1
80005cb4:	fc 22       	loop %a2,80005c98 <IfxScuCcu_calculateSysPllDividers+0x88>
80005cb6:	80 3f       	mov.d %d15,%a3
        {
            fRef = (fOsc / p);

            if ((fRef >= fRefMin) && (fRef <= fRefMax))
            {
                for (k2 = k2Min; k2 <= k2Max; k2 += k2Steps)
80005cb8:	42 c1       	add %d1,%d12
80005cba:	42 fd       	add %d13,%d15
80005cbc:	8b 11 68 f2 	lt.u %d15,%d1,129
80005cc0:	ee e0       	jnz %d15,80005c80 <IfxScuCcu_calculateSysPllDividers+0x70>
80005cc2:	60 c2       	mov.a %a2,%d12
        if (fPll > 240000000)
        {
            k2Steps = 1;
        }

        for (p = pMax; p >= pMin; p--)
80005cc4:	c2 f5       	add %d5,-1
80005cc6:	01 23 20 30 	sub.a %a3,%a3,%a2
80005cca:	fd f0 c7 7f 	loop %a15,80005c58 <IfxScuCcu_calculateSysPllDividers+0x48>
80005cce:	3c 05       	j 80005cd8 <IfxScuCcu_calculateSysPllDividers+0xc8>

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
                                bestN          = n;
80005cd0:	0b 58 10 a8 	mov %e10,%d8,%d5
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
                                bestK2         = k2;
80005cd4:	02 19       	mov %d9,%d1
                            uint64 fPllError;
                            fPllError = ((((n) / (p * k2)) * fOsc) - fPll);

                            if (fPllError == 0)
                            {
                                fPllLeastError = fPllError;
80005cd6:	82 00       	mov %d0,0
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005cd8:	da 64       	mov %d15,100
80005cda:	06 14       	sh %d4,1
80005cdc:	4b f4 11 42 	div.u %e4,%d4,%d15
80005ce0:	82 1f       	mov %d15,1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
        }
        else
        {
            retVal = 1;
80005ce2:	82 12       	mov %d2,1
            }
        }

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
80005ce4:	0b 40 50 f2 	and.ge.u %d15,%d0,%d4
80005ce8:	ee 0f       	jnz %d15,80005d06 <IfxScuCcu_calculateSysPllDividers+0xf6>
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005cea:	82 02       	mov %d2,0

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005cec:	c2 fb       	add %d11,-1
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005cee:	c2 fa       	add %d10,-1
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005cf0:	c2 f9       	add %d9,-1
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
80005cf2:	59 42 0c 00 	st.w [%a4]12,%d2

EXITCALC_LOOP:

        if ((fPllLeastError) < ((fPll * deviationAllowed) / 100)) // percent ALLOWED_DEVIATION error allowed
        {
            cfg->sysPll.pllInitialStep.nDivider  = (uint8)(bestN - 1);
80005cf6:	e9 4b 09 00 	st.b [%a4]9,%d11
            cfg->sysPll.pllInitialStep.pDivider  = (uint8)(bestP - 1);
80005cfa:	e9 4a 08 00 	st.b [%a4]8,%d10
            cfg->sysPll.pllInitialStep.k2Initial = (uint8)(bestK2 - 1);
80005cfe:	e9 49 0a 00 	st.b [%a4]10,%d9
            cfg->sysPll.pllInitialStep.waitTime  = 0; // wait time = 0
            cfg->sysPll.numOfPllDividerSteps     = 0; // no step clock incr
80005d02:	2c 40       	st.b [%a4]0,%d15
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxScuCcu_calculateSysPllDividers(IfxScuCcu_Config *cfg, uint32 fPll)
{
    boolean retVal           = 0;
80005d04:	82 02       	mov %d2,0
        {
            retVal = 1;
        }
    }
    return retVal;
}
80005d06:	00 90       	ret 

80005d08 <IfxScuCcu_getOsc0Frequency>:
}


float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IfxScuCcu_xtalFrequency;
80005d08:	91 00 00 f7 	movh.a %a15,28672
80005d0c:	19 f2 20 00 	ld.w %d2,[%a15]32 <70000020 <IfxScuCcu_xtalFrequency>>
}
80005d10:	4b 02 61 21 	utof %d2,%d2
80005d14:	00 90       	ret 

80005d16 <IfxScuCcu_getOscFrequency>:

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005d16:	91 30 00 ff 	movh.a %a15,61443
80005d1a:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005d1e:	4c f0       	ld.w %d15,[%a15]0
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005d20:	7b f0 cb 24 	movh %d2,19647

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005d24:	37 0f 62 fe 	extr.u %d15,%d15,28,2
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80005d28:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80005d2c:	6e 0c       	jz %d15,80005d44 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005d2e:	4c f0       	ld.w %d15,[%a15]0
        freq = (float32)IfxScuCcu_xtalFrequency;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0;
80005d30:	82 02       	mov %d2,0

    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80005d32:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005d36:	5e 17       	jne %d15,1,80005d44 <IfxScuCcu_getOscFrequency+0x2e>
    {
        freq = (float32)IfxScuCcu_xtalFrequency;
80005d38:	91 00 00 f7 	movh.a %a15,28672
80005d3c:	19 f2 20 00 	ld.w %d2,[%a15]32 <70000020 <IfxScuCcu_xtalFrequency>>
80005d40:	4b 02 61 21 	utof %d2,%d2
        /* Reserved values, this */
        freq = 0.0;
    }

    return freq;
}
80005d44:	00 90       	ret 

80005d46 <IfxScuCcu_getPllErayFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005d46:	91 30 00 ff 	movh.a %a15,61443
80005d4a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005d4e:	6d ff e4 ff 	call 80005d16 <IfxScuCcu_getOscFrequency>

    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80005d52:	4c f9       	ld.w %d15,[%a15]36
80005d54:	2e 05       	jz.t %d15,0,80005d5e <IfxScuCcu_getPllErayFrequency+0x18>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80005d56:	4c fb       	ld.w %d15,[%a15]44
80005d58:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005d5c:	3c 21       	j 80005d9e <IfxScuCcu_getPllErayFrequency+0x58>
    }
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80005d5e:	4c f9       	ld.w %d15,[%a15]36
80005d60:	6f 3f 15 00 	jz.t %d15,3,80005d8a <IfxScuCcu_getPllErayFrequency+0x44>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80005d64:	48 b4       	ld.w %d4,[%a15]44
80005d66:	8f f4 07 41 	and %d4,%d4,127
80005d6a:	c2 14       	add %d4,1
80005d6c:	6d 00 34 31 	call 8000bfd4 <__floatsidf>
80005d70:	7b 80 19 54 	movh %d5,16792
80005d74:	0b 23 10 68 	mov %e6,%d3,%d2
80005d78:	82 04       	mov %d4,0
80005d7a:	1b 45 78 5d 	addi %d5,%d5,-10364
80005d7e:	6d 00 9f 30 	call 8000bebc <__divdf3>
80005d82:	0b 23 10 48 	mov %e4,%d3,%d2
80005d86:	1d 00 5a 31 	j 8000c03a <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80005d8a:	48 a3       	ld.w %d3,[%a15]40
80005d8c:	4c fb       	ld.w %d15,[%a15]44
80005d8e:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005d92:	16 7f       	and %d15,127
80005d94:	c2 13       	add %d3,1
80005d96:	4b 03 41 31 	itof %d3,%d3
80005d9a:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005d9e:	c2 1f       	add %d15,1
80005da0:	4b 0f 41 f1 	itof %d15,%d15
80005da4:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005da8:	00 90       	ret 

80005daa <IfxScuCcu_getPllErayVcoFrequency>:

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005daa:	91 30 00 ff 	movh.a %a15,61443
80005dae:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80005db2:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005db4:	7b f0 cb 24 	movh %d2,19647
80005db8:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllErayVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLERAYSTAT.B.FINDIS == 1)
80005dbc:	6f 3f 18 80 	jnz.t %d15,3,80005dec <IfxScuCcu_getPllErayVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLERAYCON0.B.NDIV + 1)) / (SCU_PLLERAYCON0.B.PDIV + 1);
80005dc0:	6d ff ab ff 	call 80005d16 <IfxScuCcu_getOscFrequency>
80005dc4:	91 30 00 ff 	movh.a %a15,61443
80005dc8:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80005dcc:	48 03       	ld.w %d3,[%a15]0
80005dce:	4c f0       	ld.w %d15,[%a15]0
80005dd0:	37 03 e5 34 	extr.u %d3,%d3,9,5
80005dd4:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005dd8:	c2 13       	add %d3,1
80005dda:	4b 03 41 31 	itof %d3,%d3
80005dde:	c2 1f       	add %d15,1
80005de0:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005de4:	4b 0f 41 f1 	itof %d15,%d15
80005de8:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005dec:	00 90       	ret 

80005dee <IfxScuCcu_getPllFrequency>:
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005dee:	91 30 00 ff 	movh.a %a15,61443
80005df2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
{
    Ifx_SCU *scu = &MODULE_SCU;
    float32  oscFreq;
    float32  freq;

    oscFreq = IfxScuCcu_getOscFrequency();
80005df6:	6d ff 90 ff 	call 80005d16 <IfxScuCcu_getOscFrequency>

    if (scu->PLLSTAT.B.VCOBYST == 1)
80005dfa:	4c f5       	ld.w %d15,[%a15]20
80005dfc:	2e 06       	jz.t %d15,0,80005e08 <IfxScuCcu_getPllFrequency+0x1a>
    {
        /* Prescaler mode */
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80005dfe:	4c f7       	ld.w %d15,[%a15]28
80005e00:	37 0f 67 f8 	extr.u %d15,%d15,16,7
80005e04:	c2 1f       	add %d15,1
80005e06:	3c 28       	j 80005e56 <IfxScuCcu_getPllFrequency+0x68>
    }
    else if (scu->PLLSTAT.B.FINDIS == 1)
80005e08:	4c f5       	ld.w %d15,[%a15]20
80005e0a:	6f 3f 15 00 	jz.t %d15,3,80005e34 <IfxScuCcu_getPllFrequency+0x46>
    {
        /* Free running mode */
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80005e0e:	48 74       	ld.w %d4,[%a15]28
80005e10:	8f f4 07 41 	and %d4,%d4,127
80005e14:	c2 14       	add %d4,1
80005e16:	6d 00 df 30 	call 8000bfd4 <__floatsidf>
80005e1a:	7b 80 19 54 	movh %d5,16792
80005e1e:	0b 23 10 68 	mov %e6,%d3,%d2
80005e22:	82 04       	mov %d4,0
80005e24:	1b 45 78 5d 	addi %d5,%d5,-10364
80005e28:	6d 00 4a 30 	call 8000bebc <__divdf3>
80005e2c:	0b 23 10 48 	mov %e4,%d3,%d2
80005e30:	1d 00 05 31 	j 8000c03a <__truncdfsf2>
    }
    else
    {
        /* Normal mode */
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80005e34:	48 64       	ld.w %d4,[%a15]24
80005e36:	4c f7       	ld.w %d15,[%a15]28
80005e38:	37 04 e7 44 	extr.u %d4,%d4,9,7
80005e3c:	8f ff 07 31 	and %d3,%d15,127
80005e40:	4c f6       	ld.w %d15,[%a15]24
80005e42:	c2 14       	add %d4,1
80005e44:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005e48:	4b 04 41 41 	itof %d4,%d4
80005e4c:	c2 1f       	add %d15,1
80005e4e:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
80005e52:	4b 42 41 20 	mul.f %d2,%d2,%d4
80005e56:	4b 0f 41 f1 	itof %d15,%d15
80005e5a:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return freq;
}
80005e5e:	00 90       	ret 

80005e60 <IfxScuCcu_getPllVcoFrequency>:

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005e60:	91 30 00 ff 	movh.a %a15,61443
80005e64:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80005e68:	4c f0       	ld.w %d15,[%a15]0
    {
        /* Free running mode */
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
80005e6a:	7b f0 cb 24 	movh %d2,19647
80005e6e:	1b 02 c2 2b 	addi %d2,%d2,-17376

float32 IfxScuCcu_getPllVcoFrequency(void)
{
    float32 vcoFreq;

    if (SCU_PLLSTAT.B.FINDIS == 1)
80005e72:	6f 3f 18 80 	jnz.t %d15,3,80005ea2 <IfxScuCcu_getPllVcoFrequency+0x42>
        vcoFreq = IFXSCU_VCO_BASE_FREQUENCY;
    }
    else
    {
        /* Normal mode */
        vcoFreq = (IfxScuCcu_getOscFrequency() * (SCU_PLLCON0.B.NDIV + 1)) / (SCU_PLLCON0.B.PDIV + 1);
80005e76:	6d ff 50 ff 	call 80005d16 <IfxScuCcu_getOscFrequency>
80005e7a:	91 30 00 ff 	movh.a %a15,61443
80005e7e:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80005e82:	48 03       	ld.w %d3,[%a15]0
80005e84:	4c f0       	ld.w %d15,[%a15]0
80005e86:	37 03 e7 34 	extr.u %d3,%d3,9,7
80005e8a:	37 0f 64 fc 	extr.u %d15,%d15,24,4
80005e8e:	c2 13       	add %d3,1
80005e90:	4b 03 41 31 	itof %d3,%d3
80005e94:	c2 1f       	add %d15,1
80005e96:	4b 32 41 20 	mul.f %d2,%d2,%d3
80005e9a:	4b 0f 41 f1 	itof %d15,%d15
80005e9e:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return vcoFreq;
}
80005ea2:	00 90       	ret 

80005ea4 <IfxScuCcu_getSourceFrequency>:

float32 IfxScuCcu_getSourceFrequency(void)
{
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
80005ea4:	91 30 00 ff 	movh.a %a15,61443
80005ea8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005eac:	4c f0       	ld.w %d15,[%a15]0
80005eae:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80005eb2:	6e 06       	jz %d15,80005ebe <IfxScuCcu_getSourceFrequency+0x1a>
80005eb4:	1e 13       	jeq %d15,1,80005eba <IfxScuCcu_getSourceFrequency+0x16>
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
        break;
    default:
        sourcefreq = 0;
80005eb6:	82 02       	mov %d2,0
80005eb8:	00 90       	ret 
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
        break;
    case IfxScu_CCUCON0_CLKSEL_fPll:
        sourcefreq = IfxScuCcu_getPllFrequency();
80005eba:	1d ff 9a ff 	j 80005dee <IfxScuCcu_getPllFrequency>
    float32 sourcefreq;

    switch (SCU_CCUCON0.B.CLKSEL)
    {
    case IfxScu_CCUCON0_CLKSEL_fBack:
        sourcefreq = IfxScuCcu_getEvrFrequency();
80005ebe:	7b f0 cb 24 	movh %d2,19647
80005ec2:	1b 02 c2 2b 	addi %d2,%d2,-17376
        sourcefreq = 0;
        break;
    }

    return sourcefreq;
}
80005ec6:	00 90       	ret 

80005ec8 <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80005ec8:	02 4f       	mov %d15,%d4
80005eca:	6d ff ed ff 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
80005ece:	91 30 00 ff 	movh.a %a15,61443
80005ed2:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80005ed6:	48 03       	ld.w %d3,[%a15]0
80005ed8:	37 03 64 34 	extr.u %d3,%d3,8,4
80005edc:	4b 03 41 31 	itof %d3,%d3
80005ee0:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;
80005ee4:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80005ee8:	4b f2 41 20 	mul.f %d2,%d2,%d15
80005eec:	4b 02 71 21 	ftouz %d2,%d2
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80005ef0:	85 ff 10 00 	ld.w %d15,f0000010 <_SMALL_DATA4_+0x3fff8010>
80005ef4:	a2 3f       	sub %d15,%d3
80005ef6:	3f 2f fd ff 	jlt.u %d15,%d2,80005ef0 <IfxScuCcu_wait+0x28>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80005efa:	00 90       	ret 

80005efc <IfxScuCcu_getBbbFrequency>:
float32 IfxScuCcu_getBbbFrequency(void)
{
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80005efc:	6d ff d4 ff 	call 80005ea4 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80005f00:	91 30 00 ff 	movh.a %a15,61443
80005f04:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005f08:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
        break;
    default:
        bbbFrequency = 0.0;
80005f0a:	82 0f       	mov %d15,0
    float32 bbbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80005f0c:	37 03 64 36 	extr.u %d3,%d3,12,4
80005f10:	ff 53 30 80 	jge.u %d3,5,80005f70 <IfxScuCcu_getBbbFrequency+0x74>
80005f14:	91 00 00 f8 	movh.a %a15,32768
80005f18:	d9 ff e4 c5 	lea %a15,[%a15]24356 <80005f24 <IfxScuCcu_getBbbFrequency+0x28>>
80005f1c:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
80005f20:	dc 0f       	ji %a15
80005f22:	00 00       	nop 
80005f24:	1d 00 0a 00 	j 80005f38 <IfxScuCcu_getBbbFrequency+0x3c>
80005f28:	1d 00 17 00 	j 80005f56 <IfxScuCcu_getBbbFrequency+0x5a>
80005f2c:	1d 00 18 00 	j 80005f5c <IfxScuCcu_getBbbFrequency+0x60>
80005f30:	1d 00 19 00 	j 80005f62 <IfxScuCcu_getBbbFrequency+0x66>
80005f34:	1d 00 1a 00 	j 80005f68 <IfxScuCcu_getBbbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80005f38:	91 30 00 ff 	movh.a %a15,61443
80005f3c:	d9 ff 00 16 	lea %a15,[%a15]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80005f40:	48 03       	ld.w %d3,[%a15]0
        {
            bbbFrequency = 0.0;
80005f42:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON2.B.BBBDIV == 0)
80005f44:	8f f3 00 31 	and %d3,%d3,15
80005f48:	df 03 14 00 	jeq %d3,0,80005f70 <IfxScuCcu_getBbbFrequency+0x74>
        {
            bbbFrequency = 0.0;
        }
        else
        {
            bbbFrequency = sourceFrequency / SCU_CCUCON2.B.BBBDIV;
80005f4c:	4c f0       	ld.w %d15,[%a15]0
80005f4e:	16 0f       	and %d15,15
80005f50:	4b 0f 41 f1 	itof %d15,%d15
80005f54:	3c 0c       	j 80005f6c <IfxScuCcu_getBbbFrequency+0x70>
        }

        break;
    case 1:
        bbbFrequency = sourceFrequency / 30;
80005f56:	7b 00 1f f4 	movh %d15,16880
80005f5a:	3c 09       	j 80005f6c <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 2:
        bbbFrequency = sourceFrequency / 60;
80005f5c:	7b 00 27 f4 	movh %d15,17008
80005f60:	3c 06       	j 80005f6c <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 3:
        bbbFrequency = sourceFrequency / 120;
80005f62:	7b 00 2f f4 	movh %d15,17136
80005f66:	3c 03       	j 80005f6c <IfxScuCcu_getBbbFrequency+0x70>
        break;
    case 4:
        bbbFrequency = sourceFrequency / 240;
80005f68:	7b 00 37 f4 	movh %d15,17264
80005f6c:	4b f2 51 f0 	div.f %d15,%d2,%d15
        bbbFrequency = 0.0;
        break;
    }

    return bbbFrequency;
}
80005f70:	02 f2       	mov %d2,%d15
80005f72:	00 90       	ret 

80005f74 <IfxScuCcu_getMaxFrequency>:
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80005f74:	91 30 00 ff 	movh.a %a15,61443
80005f78:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>

float32 IfxScuCcu_getMaxFrequency(void)
{
    float32 maxFrequency;
    float32 sourceFrequency;
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80005f7c:	6d ff 94 ff 	call 80005ea4 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
80005f80:	4c f0       	ld.w %d15,[%a15]0
80005f82:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80005f86:	ff 5f 2d 80 	jge.u %d15,5,80005fe0 <IfxScuCcu_getMaxFrequency+0x6c>
80005f8a:	91 00 00 f8 	movh.a %a15,32768
80005f8e:	d9 ff d8 e5 	lea %a15,[%a15]24472 <80005f98 <IfxScuCcu_getMaxFrequency+0x24>>
80005f92:	90 ff       	addsc.a %a15,%a15,%d15,2
80005f94:	dc 0f       	ji %a15
80005f96:	00 00       	nop 
80005f98:	1d 00 0a 00 	j 80005fac <IfxScuCcu_getMaxFrequency+0x38>
80005f9c:	1d 00 14 00 	j 80005fc4 <IfxScuCcu_getMaxFrequency+0x50>
80005fa0:	1d 00 15 00 	j 80005fca <IfxScuCcu_getMaxFrequency+0x56>
80005fa4:	1d 00 16 00 	j 80005fd0 <IfxScuCcu_getMaxFrequency+0x5c>
80005fa8:	1d 00 17 00 	j 80005fd6 <IfxScuCcu_getMaxFrequency+0x62>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON5.B.MAXDIV == 0)
80005fac:	91 30 00 ff 	movh.a %a15,61443
80005fb0:	d9 ff 0c 16 	lea %a15,[%a15]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80005fb4:	4c f0       	ld.w %d15,[%a15]0
80005fb6:	16 0f       	and %d15,15
80005fb8:	6e 15       	jz %d15,80005fe2 <IfxScuCcu_getMaxFrequency+0x6e>
        {
            maxFrequency = sourceFrequency;
        }
        else
        {
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80005fba:	4c f0       	ld.w %d15,[%a15]0
80005fbc:	16 0f       	and %d15,15
80005fbe:	4b 0f 41 f1 	itof %d15,%d15
80005fc2:	3c 0c       	j 80005fda <IfxScuCcu_getMaxFrequency+0x66>
        }

        break;
    case 1:
        maxFrequency = sourceFrequency / 15;
80005fc4:	7b 00 17 f4 	movh %d15,16752
80005fc8:	3c 09       	j 80005fda <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 2:
        maxFrequency = sourceFrequency / 30;
80005fca:	7b 00 1f f4 	movh %d15,16880
80005fce:	3c 06       	j 80005fda <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 3:
        maxFrequency = sourceFrequency / 60;
80005fd0:	7b 00 27 f4 	movh %d15,17008
80005fd4:	3c 03       	j 80005fda <IfxScuCcu_getMaxFrequency+0x66>
        break;
    case 4:
        maxFrequency = sourceFrequency / 120;
80005fd6:	7b 00 2f f4 	movh %d15,17136
80005fda:	4b f2 51 20 	div.f %d2,%d2,%d15
        break;
80005fde:	00 90       	ret 
    default:
        maxFrequency = 0.0;
80005fe0:	82 02       	mov %d2,0
        break;
    }

    return maxFrequency;
}
80005fe2:	00 90       	ret 

80005fe4 <IfxScuCcu_getBaud1Frequency>:


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005fe4:	91 30 00 ff 	movh.a %a15,61443
80005fe8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80005fec:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD1DIV == 0)
    {
        frequency = 0;
80005fee:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud1Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80005ff0:	8f ff 00 81 	and %d8,%d15,15

    if (ccucon0.B.BAUD1DIV == 0)
80005ff4:	76 87       	jz %d8,80006002 <IfxScuCcu_getBaud1Frequency+0x1e>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80005ff6:	6d ff bf ff 	call 80005f74 <IfxScuCcu_getMaxFrequency>
80005ffa:	4b 08 41 f1 	itof %d15,%d8
80005ffe:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80006002:	00 90       	ret 

80006004 <IfxScuCcu_getBaud2Frequency>:


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006004:	91 30 00 ff 	movh.a %a15,61443
80006008:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000600c:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.BAUD2DIV == 0)
    {
        frequency = 0;
8000600e:	82 02       	mov %d2,0


float32 IfxScuCcu_getBaud2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80006010:	37 0f 64 82 	extr.u %d8,%d15,4,4

    if (ccucon0.B.BAUD2DIV == 0)
80006014:	16 f0       	and %d15,240
80006016:	6e 07       	jz %d15,80006024 <IfxScuCcu_getBaud2Frequency+0x20>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80006018:	6d ff ae ff 	call 80005f74 <IfxScuCcu_getMaxFrequency>
8000601c:	4b 08 41 f1 	itof %d15,%d8
80006020:	4b f2 51 20 	div.f %d2,%d2,%d15
    }

    return frequency;
}
80006024:	00 90       	ret 

80006026 <IfxScuCcu_getSpbFrequency>:
float32 IfxScuCcu_getSpbFrequency(void)
{
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
80006026:	6d ff 3f ff 	call 80005ea4 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
8000602a:	91 30 00 ff 	movh.a %a15,61443
8000602e:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006032:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
        break;
    default:
        spbFrequency = 0.0;
80006034:	82 0f       	mov %d15,0
    float32 spbFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
80006036:	37 03 64 36 	extr.u %d3,%d3,12,4
8000603a:	ff 53 30 80 	jge.u %d3,5,8000609a <IfxScuCcu_getSpbFrequency+0x74>
8000603e:	91 00 00 f8 	movh.a %a15,32768
80006042:	d9 ff 0c 16 	lea %a15,[%a15]24652 <8000604c <IfxScuCcu_getSpbFrequency+0x26>>
80006046:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000604a:	dc 0f       	ji %a15
8000604c:	1d 00 0a 00 	j 80006060 <IfxScuCcu_getSpbFrequency+0x3a>
80006050:	1d 00 18 00 	j 80006080 <IfxScuCcu_getSpbFrequency+0x5a>
80006054:	1d 00 19 00 	j 80006086 <IfxScuCcu_getSpbFrequency+0x60>
80006058:	1d 00 1a 00 	j 8000608c <IfxScuCcu_getSpbFrequency+0x66>
8000605c:	1d 00 1b 00 	j 80006092 <IfxScuCcu_getSpbFrequency+0x6c>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
80006060:	91 30 00 ff 	movh.a %a15,61443
80006064:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006068:	48 03       	ld.w %d3,[%a15]0
        {
            spbFrequency = 0.0;
8000606a:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SPBDIV == 0)
8000606c:	37 03 64 38 	extr.u %d3,%d3,16,4
80006070:	df 03 15 00 	jeq %d3,0,8000609a <IfxScuCcu_getSpbFrequency+0x74>
        {
            spbFrequency = 0.0;
        }
        else
        {
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80006074:	4c f0       	ld.w %d15,[%a15]0
80006076:	37 0f 64 f8 	extr.u %d15,%d15,16,4
8000607a:	4b 0f 41 f1 	itof %d15,%d15
8000607e:	3c 0c       	j 80006096 <IfxScuCcu_getSpbFrequency+0x70>
        }

        break;
    case 1:
        spbFrequency = sourceFrequency / 30;
80006080:	7b 00 1f f4 	movh %d15,16880
80006084:	3c 09       	j 80006096 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 2:
        spbFrequency = sourceFrequency / 60;
80006086:	7b 00 27 f4 	movh %d15,17008
8000608a:	3c 06       	j 80006096 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 3:
        spbFrequency = sourceFrequency / 120;
8000608c:	7b 00 2f f4 	movh %d15,17136
80006090:	3c 03       	j 80006096 <IfxScuCcu_getSpbFrequency+0x70>
        break;
    case 4:
        spbFrequency = sourceFrequency / 240;
80006092:	7b 00 37 f4 	movh %d15,17264
80006096:	4b f2 51 f0 	div.f %d15,%d2,%d15
        spbFrequency = 0.0;
        break;
    }

    return spbFrequency;
}
8000609a:	02 f2       	mov %d2,%d15
8000609c:	00 90       	ret 

8000609e <IfxScuCcu_getModuleFrequency>:
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
8000609e:	91 30 00 ff 	movh.a %a15,61443
800060a2:	d9 ff 38 06 	lea %a15,[%a15]24632 <f0036038 <_SMALL_DATA4_+0x4002e038>>
800060a6:	48 09       	ld.w %d9,[%a15]0
    spbFreq = IfxScuCcu_getSpbFrequency();
800060a8:	6d ff bf ff 	call 80006026 <IfxScuCcu_getSpbFrequency>

    if (scuFdr.B.DM == 1)
800060ac:	bb 00 00 fc 	mov.u %d15,49152
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
    spbFreq = IfxScuCcu_getSpbFrequency();
800060b0:	02 23       	mov %d3,%d2

    if (scuFdr.B.DM == 1)
800060b2:	26 9f       	and %d15,%d9
800060b4:	3b 00 00 24 	mov %d2,16384
float32 IfxScuCcu_getModuleFrequency(void)
{
    float32     spbFreq;
    float32     moduleFreq;
    Ifx_SCU_FDR scuFdr;
    scuFdr  = SCU_FDR;
800060b8:	b7 09 16 85 	insert %d8,%d9,0,10,22
    spbFreq = IfxScuCcu_getSpbFrequency();

    if (scuFdr.B.DM == 1)
800060bc:	7e 29       	jne %d15,%d2,800060ce <IfxScuCcu_getModuleFrequency+0x30>
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
800060be:	3b 00 40 20 	mov %d2,1024
800060c2:	a2 82       	sub %d2,%d8
800060c4:	4b 02 41 21 	itof %d2,%d2
800060c8:	4b 23 51 20 	div.f %d2,%d3,%d2
800060cc:	00 90       	ret 
    }
    else if (scuFdr.B.DM == 2)
800060ce:	bb 00 00 48 	mov.u %d4,32768
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0;
800060d2:	82 02       	mov %d2,0

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
800060d4:	7e 49       	jne %d15,%d4,800060e6 <IfxScuCcu_getModuleFrequency+0x48>
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
800060d6:	4b 08 41 21 	itof %d2,%d8
800060da:	7b 00 a8 f3 	movh %d15,14976
800060de:	4b 23 41 20 	mul.f %d2,%d3,%d2
800060e2:	4b f2 41 20 	mul.f %d2,%d2,%d15
    {
        moduleFreq = 0;
    }

    return moduleFreq;
}
800060e6:	00 90       	ret 

800060e8 <IfxScuCcu_getSriFrequency>:
float32 IfxScuCcu_getSriFrequency(void)
{
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();
800060e8:	6d ff de fe 	call 80005ea4 <IfxScuCcu_getSourceFrequency>

    switch (SCU_CCUCON0.B.LPDIV)
800060ec:	91 30 00 ff 	movh.a %a15,61443
800060f0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800060f4:	48 03       	ld.w %d3,[%a15]0
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
        break;
    default:
        sriFrequency = 0.0;
800060f6:	82 0f       	mov %d15,0
    float32 sriFrequency;
    float32 sourceFrequency;

    sourceFrequency = IfxScuCcu_getSourceFrequency();

    switch (SCU_CCUCON0.B.LPDIV)
800060f8:	37 03 64 36 	extr.u %d3,%d3,12,4
800060fc:	ff 53 31 80 	jge.u %d3,5,8000615e <IfxScuCcu_getSriFrequency+0x76>
80006100:	91 00 00 f8 	movh.a %a15,32768
80006104:	d9 ff 10 46 	lea %a15,[%a15]24848 <80006110 <IfxScuCcu_getSriFrequency+0x28>>
80006108:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000610c:	dc 0f       	ji %a15
8000610e:	00 00       	nop 
80006110:	1d 00 0a 00 	j 80006124 <IfxScuCcu_getSriFrequency+0x3c>
80006114:	1d 00 18 00 	j 80006144 <IfxScuCcu_getSriFrequency+0x5c>
80006118:	1d 00 19 00 	j 8000614a <IfxScuCcu_getSriFrequency+0x62>
8000611c:	1d 00 1a 00 	j 80006150 <IfxScuCcu_getSriFrequency+0x68>
80006120:	1d 00 1b 00 	j 80006156 <IfxScuCcu_getSriFrequency+0x6e>
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006124:	91 30 00 ff 	movh.a %a15,61443
80006128:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000612c:	48 03       	ld.w %d3,[%a15]0
        {
            sriFrequency = 0.0;
8000612e:	82 0f       	mov %d15,0

    switch (SCU_CCUCON0.B.LPDIV)
    {
    case 0:                    /*Not in low power mode */

        if (SCU_CCUCON0.B.SRIDIV == 0)
80006130:	37 03 64 34 	extr.u %d3,%d3,8,4
80006134:	df 03 15 00 	jeq %d3,0,8000615e <IfxScuCcu_getSriFrequency+0x76>
        {
            sriFrequency = 0.0;
        }
        else
        {
            sriFrequency = sourceFrequency / SCU_CCUCON0.B.SRIDIV;
80006138:	4c f0       	ld.w %d15,[%a15]0
8000613a:	37 0f 64 f4 	extr.u %d15,%d15,8,4
8000613e:	4b 0f 41 f1 	itof %d15,%d15
80006142:	3c 0c       	j 8000615a <IfxScuCcu_getSriFrequency+0x72>
        }

        break;
    case 1:
        sriFrequency = sourceFrequency / 30;
80006144:	7b 00 1f f4 	movh %d15,16880
80006148:	3c 09       	j 8000615a <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 2:
        sriFrequency = sourceFrequency / 60;
8000614a:	7b 00 27 f4 	movh %d15,17008
8000614e:	3c 06       	j 8000615a <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 3:
        sriFrequency = sourceFrequency / 120;
80006150:	7b 00 2f f4 	movh %d15,17136
80006154:	3c 03       	j 8000615a <IfxScuCcu_getSriFrequency+0x72>
        break;
    case 4:
        sriFrequency = sourceFrequency / 240;
80006156:	7b 00 37 f4 	movh %d15,17264
8000615a:	4b f2 51 f0 	div.f %d15,%d2,%d15
        sriFrequency = 0.0;
        break;
    }

    return sriFrequency;
}
8000615e:	02 f2       	mov %d2,%d15
80006160:	00 90       	ret 

80006162 <IfxScuCcu_getCpuFrequency>:
    return bbbFrequency;
}


float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu)
{
80006162:	02 4f       	mov %d15,%d4
    float32 frequency = IfxScuCcu_getSriFrequency();
80006164:	6d ff c2 ff 	call 800060e8 <IfxScuCcu_getSriFrequency>
    uint32  cpuDiv    = 0;

    switch (cpu)
80006168:	1e 1d       	jeq %d15,1,80006182 <IfxScuCcu_getCpuFrequency+0x20>
8000616a:	6e 07       	jz %d15,80006178 <IfxScuCcu_getCpuFrequency+0x16>
8000616c:	de 2a       	jne %d15,2,800061a0 <IfxScuCcu_getCpuFrequency+0x3e>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
8000616e:	91 30 00 ff 	movh.a %a15,61443
80006172:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
80006176:	3c 0a       	j 8000618a <IfxScuCcu_getCpuFrequency+0x28>
    uint32  cpuDiv    = 0;

    switch (cpu)
    {
    case IfxCpu_ResourceCpu_0:
        cpuDiv = SCU_CCUCON6.U;
80006178:	91 30 00 ff 	movh.a %a15,61443
8000617c:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
80006180:	3c 05       	j 8000618a <IfxScuCcu_getCpuFrequency+0x28>
        break;
    case IfxCpu_ResourceCpu_1:
        cpuDiv = SCU_CCUCON7.U;
80006182:	91 30 00 ff 	movh.a %a15,61443
80006186:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
8000618a:	4c f0       	ld.w %d15,[%a15]0
    default:
        frequency = 0.0;
        break;
    }

    if (cpuDiv != 0)
8000618c:	6e 0b       	jz %d15,800061a2 <IfxScuCcu_getCpuFrequency+0x40>
    {
        frequency = frequency * (cpuDiv / 64.0f);
8000618e:	4b 0f 61 f1 	utof %d15,%d15
80006192:	7b 00 c8 33 	movh %d3,15488
80006196:	4b 3f 41 f0 	mul.f %d15,%d15,%d3
8000619a:	4b f2 41 20 	mul.f %d2,%d2,%d15
8000619e:	00 90       	ret 
        break;
    case IfxCpu_ResourceCpu_2:
        cpuDiv = SCU_CCUCON8.U;
        break;
    default:
        frequency = 0.0;
800061a0:	82 02       	mov %d2,0
    {
        frequency = frequency * (cpuDiv / 64.0f);
    }

    return frequency;
}
800061a2:	00 90       	ret 

800061a4 <IfxScuCcu_getFsi2Frequency>:


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061a4:	91 30 00 ff 	movh.a %a15,61443
800061a8:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061ac:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSI2DIV == 0)
800061ae:	7b 00 03 30 	movh %d3,48
800061b2:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061b4:	37 0f 62 8a 	extr.u %d8,%d15,20,2

    if (ccucon0.B.FSI2DIV == 0)
    {
        frequency = 0;
800061b8:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsi2Frequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSI2DIV == 0)
800061ba:	76 3f       	jz %d3,800061d8 <IfxScuCcu_getFsi2Frequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800061bc:	6d ff 96 ff 	call 800060e8 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800061c0:	3b 00 f0 30 	mov %d3,3840
800061c4:	26 3f       	and %d15,%d3
800061c6:	1b 0f f0 ff 	addi %d15,%d15,-256
800061ca:	8f 0f d0 f1 	andn %d15,%d15,256
800061ce:	ee 05       	jnz %d15,800061d8 <IfxScuCcu_getFsi2Frequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSI2DIV;
800061d0:	4b 08 41 f1 	itof %d15,%d8
800061d4:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
800061d8:	00 90       	ret 

800061da <IfxScuCcu_getFsiFrequency>:


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061da:	91 30 00 ff 	movh.a %a15,61443
800061de:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800061e2:	4c f0       	ld.w %d15,[%a15]0

    if (ccucon0.B.FSIDIV == 0)
800061e4:	7b 00 30 30 	movh %d3,768
800061e8:	26 f3       	and %d3,%d15


float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800061ea:	37 0f 62 8c 	extr.u %d8,%d15,24,2

    if (ccucon0.B.FSIDIV == 0)
    {
        frequency = 0;
800061ee:	82 02       	mov %d2,0
float32 IfxScuCcu_getFsiFrequency(void)
{
    float32         frequency;
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;

    if (ccucon0.B.FSIDIV == 0)
800061f0:	76 3f       	jz %d3,8000620e <IfxScuCcu_getFsiFrequency+0x34>
    {
        frequency = 0;
    }
    else
    {
        frequency = IfxScuCcu_getSriFrequency();
800061f2:	6d ff 7b ff 	call 800060e8 <IfxScuCcu_getSriFrequency>

        if ((ccucon0.B.SRIDIV == 1) || (ccucon0.B.SRIDIV == 2))
800061f6:	3b 00 f0 30 	mov %d3,3840
800061fa:	26 3f       	and %d15,%d3
800061fc:	1b 0f f0 ff 	addi %d15,%d15,-256
80006200:	8f 0f d0 f1 	andn %d15,%d15,256
80006204:	ee 05       	jnz %d15,8000620e <IfxScuCcu_getFsiFrequency+0x34>
        {
            frequency = frequency / ccucon0.B.FSIDIV;
80006206:	4b 08 41 f1 	itof %d15,%d8
8000620a:	4b f2 51 20 	div.f %d2,%d2,%d15
        }
    }

    return frequency;
}
8000620e:	00 90       	ret 

80006210 <IfxScuCcu_init>:
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80006210:	19 4f 10 10 	ld.w %d15,[%a4]80
80006214:	91 00 00 c7 	movh.a %a12,28672
    return sriFrequency;
}


boolean IfxScuCcu_init(const IfxScuCcu_Config *cfg)
{
80006218:	40 4f       	mov.aa %a15,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
8000621a:	59 cf 20 00 	st.w [%a12]32 <70000020 <IfxScuCcu_xtalFrequency>>,%d15

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
8000621e:	6d 00 c8 07 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
80006222:	02 29       	mov %d9,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80006224:	6d 00 e3 07 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006228:	02 94       	mov %d4,%d9
    boolean status = 0;
    /* Store the crystal frequency */
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;

    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
8000622a:	02 28       	mov %d8,%d2

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000622c:	6d 00 c1 06 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006230:	91 30 00 2f 	movh.a %a2,61443
80006234:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006238:	54 2c       	ld.w %d12,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;
8000623a:	4c 20       	ld.w %d15,[%a2]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000623c:	02 94       	mov %d4,%d9

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
8000623e:	96 08       	or %d15,8
80006240:	6c 20       	st.w [%a2]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006242:	6d 00 eb 07 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006246:	02 84       	mov %d4,%d8
80006248:	6d 00 ce 06 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
8000624c:	37 0c e1 c1 	extr.u %d12,%d12,3,1

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        while (SCU_CCUCON0.B.LCK != 0U)
80006250:	91 30 00 3f 	movh.a %a3,61443
80006254:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006258:	4c 30       	ld.w %d15,[%a3]0
8000625a:	91 30 00 2f 	movh.a %a2,61443
8000625e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006262:	bf 0f fb 7f 	jlt %d15,0,80006258 <IfxScuCcu_init+0x48>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006266:	4c 20       	ld.w %d15,[%a2]0
80006268:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
8000626c:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
8000626e:	4c 20       	ld.w %d15,[%a2]0
80006270:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006274:	6c 20       	st.w [%a2]0,%d15

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006276:	91 30 00 2f 	movh.a %a2,61443
8000627a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000627e:	4c 20       	ld.w %d15,[%a2]0
80006280:	96 10       	or %d15,16
80006282:	6c 20       	st.w [%a2]0,%d15
        /* Now PLL is in free running mode */

        /* Select Clock Source as PLL input clock */
        while (SCU_CCUCON0.B.LCK != 0U)
80006284:	91 30 00 2f 	movh.a %a2,61443
80006288:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
8000628c:	4c 20       	ld.w %d15,[%a2]0
8000628e:	bf 0f ff 7f 	jlt %d15,0,8000628c <IfxScuCcu_init+0x7c>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80006292:	91 30 00 2f 	movh.a %a2,61443
80006296:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000629a:	4c 20       	ld.w %d15,[%a2]0
8000629c:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800062a0:	6c 20       	st.w [%a2]0,%d15
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
800062a2:	4c 20       	ld.w %d15,[%a2]0
800062a4:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
800062a8:	6c 20       	st.w [%a2]0,%d15
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800062aa:	6d 00 82 07 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800062ae:	91 30 00 2f 	movh.a %a2,61443
800062b2:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800062b6:	02 2f       	mov %d15,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800062b8:	54 22       	ld.w %d2,[%a2]

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800062ba:	40 23       	mov.aa %a3,%a2
    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800062bc:	8f 02 c6 21 	andn %d2,%d2,96
800062c0:	74 22       	st.w [%a2],%d2

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
800062c2:	19 c6 20 00 	ld.w %d6,[%a12]32 <70000020 <IfxScuCcu_xtalFrequency>>
800062c6:	7b 60 02 20 	movh %d2,38
800062ca:	1b 02 5a 22 	addi %d2,%d2,9632
800062ce:	4b 26 11 62 	div.u %e6,%d6,%d2
800062d2:	54 22       	ld.w %d2,[%a2]
800062d4:	c2 f6       	add %d6,-1
800062d6:	37 62 05 68 	insert %d6,%d2,%d6,16,5
800062da:	74 26       	st.w [%a2],%d6

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
800062dc:	54 22       	ld.w %d2,[%a2]
800062de:	8f 42 40 21 	or %d2,%d2,4
800062e2:	74 22       	st.w [%a2],%d2

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800062e4:	c5 02 3f 90 	lea %a2,27f <_.+0x27e>
800062e8:	54 32       	ld.w %d2,[%a3]
800062ea:	6f 12 05 80 	jnz.t %d2,1,800062f4 <IfxScuCcu_init+0xe4>
800062ee:	fc 2d       	loop %a2,800062e8 <IfxScuCcu_init+0xd8>
    {
        TimeoutCtr--;

        if (TimeoutCtr == 0)
        {
            status = 1;
800062f0:	82 1b       	mov %d11,1
800062f2:	3c 05       	j 800062fc <IfxScuCcu_init+0xec>

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
800062f4:	54 32       	ld.w %d2,[%a3]
800062f6:	6f 82 fc 7f 	jz.t %d2,8,800062ee <IfxScuCcu_init+0xde>


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;
800062fa:	82 0b       	mov %d11,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
800062fc:	02 f4       	mov %d4,%d15
800062fe:	6d 00 58 06 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80006302:	91 30 00 2f 	movh.a %a2,61443
80006306:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
8000630a:	54 22       	ld.w %d2,[%a2]
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
        IfxScuWdt_setCpuEndinit(endinitPw);
8000630c:	02 f4       	mov %d4,%d15
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
8000630e:	8f 82 40 21 	or %d2,%d2,8
80006312:	74 22       	st.w [%a2],%d2
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80006314:	91 30 00 2f 	movh.a %a2,61443
80006318:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
8000631c:	54 22       	ld.w %d2,[%a2]
8000631e:	8f 82 40 21 	or %d2,%d2,8
80006322:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinitPw);
80006324:	6d 00 7a 07 	call 80007218 <IfxScuWdt_setCpuEndinit>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */

        status             |= IfxScuCcu_isOscillatorStable();

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006328:	02 84       	mov %d4,%d8
8000632a:	6d 00 e3 07 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
    }

    if (status == 0)
8000632e:	df 0b 29 81 	jne %d11,0,80006580 <IfxScuCcu_init+0x370>

        /*Setting up P N and K2 values equate pll to evr osc freq */
        {
            {
                /*Set the K2 divider value for the step corresponding to step count */
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006332:	02 84       	mov %d4,%d8
80006334:	6d 00 58 06 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006338:	91 30 00 2f 	movh.a %a2,61443
8000633c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006340:	4c 20       	ld.w %d15,[%a2]0
80006342:	6f 5f ff 7f 	jz.t %d15,5,80006340 <IfxScuCcu_init+0x130>
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006346:	91 30 00 2f 	movh.a %a2,61443
8000634a:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000634e:	54 22       	ld.w %d2,[%a2]
80006350:	0c fa       	ld.bu %d15,[%a15]10
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80006352:	7b 20 85 43 	movh %d4,14418
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80006356:	37 f2 07 f0 	insert %d15,%d2,%d15,0,7
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000635a:	1b 74 71 4b 	addi %d4,%d4,-18665
                {
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required because Safety Endinit will give a trap */
                }

                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
8000635e:	6c 20       	st.w [%a2]0,%d15

                {
                    /*change P and N divider values */
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80006360:	91 30 00 2f 	movh.a %a2,61443
80006364:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006368:	54 22       	ld.w %d2,[%a2]
8000636a:	0c f8       	ld.bu %d15,[%a15]8
8000636c:	37 f2 04 fc 	insert %d15,%d2,%d15,24,4
80006370:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80006372:	54 22       	ld.w %d2,[%a2]
80006374:	0c f9       	ld.bu %d15,[%a15]9
80006376:	37 f2 87 f4 	insert %d15,%d2,%d15,9,7
8000637a:	6c 20       	st.w [%a2]0,%d15

                    /* Disable oscillator disconnect feature
                     * in case of PLL unlock, PLL stays connected to fref */
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
8000637c:	4c 20       	ld.w %d15,[%a2]0
8000637e:	96 40       	or %d15,64
80006380:	6c 20       	st.w [%a2]0,%d15
                    //                    workaround for Errata: PLL TC 005
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
80006382:	4c 20       	ld.w %d15,[%a2]0
80006384:	b7 0f 01 f8 	insert %d15,%d15,0,16,1
80006388:	6c 20       	st.w [%a2]0,%d15
                    /* Connect PLL to fREF as oscillator clock is connected to PLL   */
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
8000638a:	4c 20       	ld.w %d15,[%a2]0
8000638c:	96 20       	or %d15,32
8000638e:	6c 20       	st.w [%a2]0,%d15
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
80006390:	4c 20       	ld.w %d15,[%a2]0
80006392:	b7 ff 01 f8 	insert %d15,%d15,15,16,1
80006396:	6c 20       	st.w [%a2]0,%d15

                    /* Restart PLL lock detection (RESLD = 1) */
                    SCU_PLLCON0.B.RESLD = 1;
80006398:	4c 20       	ld.w %d15,[%a2]0
8000639a:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000639e:	6c 20       	st.w [%a2]0,%d15

                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800063a0:	6d ff 94 fd 	call 80005ec8 <IfxScuCcu_wait>

                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
800063a4:	91 30 00 2f 	movh.a %a2,61443
800063a8:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800063ac:	4c 20       	ld.w %d15,[%a2]0
800063ae:	6f 2f ff 7f 	jz.t %d15,2,800063ac <IfxScuCcu_init+0x19c>
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800063b2:	91 30 00 2f 	movh.a %a2,61443
800063b6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800063ba:	4c 20       	ld.w %d15,[%a2]0

                    while (SCU_CCUCON0.B.LCK != 0U)
800063bc:	91 30 00 3f 	movh.a %a3,61443
                    {
                        /* Wait for PLL lock */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800063c0:	8f 1f c0 f1 	andn %d15,%d15,1
800063c4:	6c 20       	st.w [%a2]0,%d15

                    while (SCU_CCUCON0.B.LCK != 0U)
800063c6:	d9 33 30 06 	lea %a3,[%a3]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063ca:	4c 30       	ld.w %d15,[%a3]0
800063cc:	91 30 00 2f 	movh.a %a2,61443
800063d0:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063d4:	bf 0f fb 7f 	jlt %d15,0,800063ca <IfxScuCcu_init+0x1ba>
                    {
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    SCU_CCUCON0.B.CLKSEL = 0x01;
800063d8:	4c 20       	ld.w %d15,[%a2]0
800063da:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
800063de:	6c 20       	st.w [%a2]0,%d15

                    /*Configure the clock distribution */
                    while (SCU_CCUCON0.B.LCK != 0U)
800063e0:	4c 20       	ld.w %d15,[%a2]0
800063e2:	91 30 00 cf 	movh.a %a12,61443
800063e6:	d9 cc 30 06 	lea %a12,[%a12]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800063ea:	bf 0f fb 7f 	jlt %d15,0,800063e0 <IfxScuCcu_init+0x1d0>
                        /*Wait till ccucon registers can be written with new value */
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
800063ee:	48 34       	ld.w %d4,[%a15]12
800063f0:	6d ff 6c fd 	call 80005ec8 <IfxScuCcu_wait>

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800063f4:	4c f5       	ld.w %d15,[%a15]20
800063f6:	54 c3       	ld.w %d3,[%a12]
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800063f8:	48 42       	ld.w %d2,[%a15]16
                    /*Wait until the initial clock configurations take in to effect for the PLL*/
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */

                    {                                                    /*Write CCUCON0 configuration */
                        Ifx_SCU_CCUCON0 ccucon0;
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
800063fa:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
800063fe:	26 f2       	and %d2,%d15
80006400:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
80006404:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon0.B.UP     = 1;
80006408:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
8000640c:	91 30 00 3f 	movh.a %a3,61443
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
                        /*update with configured value */
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
                        ccucon0.B.UP     = 1;
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
80006410:	6c c0       	st.w [%a12]0,%d15
                    }

                    while (SCU_CCUCON1.B.LCK != 0U)
80006412:	d9 33 34 06 	lea %a3,[%a3]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006416:	4c 30       	ld.w %d15,[%a3]0
80006418:	91 30 00 2f 	movh.a %a2,61443
8000641c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006420:	bf 0f fb 7f 	jlt %d15,0,80006416 <IfxScuCcu_init+0x206>
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80006424:	4c f7       	ld.w %d15,[%a15]28
80006426:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80006428:	48 62       	ld.w %d2,[%a15]24
                    }

                    {
                        /*Write CCUCON1 configuration */
                        Ifx_SCU_CCUCON1 ccucon1;
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
8000642a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
8000642e:	26 f2       	and %d2,%d15
80006430:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon1.B.INSEL = 1;
80006434:	b7 1f 02 fe 	insert %d15,%d15,1,28,2
                        ccucon1.B.UP    = 1;
80006438:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON1     = ccucon1;
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
8000643c:	91 30 00 3f 	movh.a %a3,61443
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
                        /*update with configured value */
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
                        ccucon1.B.INSEL = 1;
                        ccucon1.B.UP    = 1;
                        SCU_CCUCON1     = ccucon1;
80006440:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON2.B.LCK != 0U)
80006442:	d9 33 00 16 	lea %a3,[%a3]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006446:	4c 30       	ld.w %d15,[%a3]0
80006448:	91 30 00 2f 	movh.a %a2,61443
8000644c:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x4002e040>>
80006450:	bf 0f fb 7f 	jlt %d15,0,80006446 <IfxScuCcu_init+0x236>
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
80006454:	4c f9       	ld.w %d15,[%a15]36
80006456:	54 23       	ld.w %d3,[%a2]
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80006458:	48 82       	ld.w %d2,[%a15]32
                    }

                    {
                        /*Write CCUCON2 configuration */
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
8000645a:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
8000645e:	26 f2       	and %d2,%d15
80006460:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon2.B.UP = 1;
80006464:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
                        SCU_CCUCON2  = ccucon2;
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
80006468:	91 30 00 3f 	movh.a %a3,61443
                        Ifx_SCU_CCUCON2 ccucon2;
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
                        /*update with configured value */
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
                        ccucon2.B.UP = 1;
                        SCU_CCUCON2  = ccucon2;
8000646c:	6c 20       	st.w [%a2]0,%d15
                    }

                    while (SCU_CCUCON5.B.LCK != 0U)
8000646e:	d9 33 0c 16 	lea %a3,[%a3]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
80006472:	4c 30       	ld.w %d15,[%a3]0
80006474:	91 30 00 2f 	movh.a %a2,61443
80006478:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x4002e04c>>
8000647c:	bf 0f fb 7f 	jlt %d15,0,80006472 <IfxScuCcu_init+0x262>
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006480:	54 23       	ld.w %d3,[%a2]
80006482:	4c fb       	ld.w %d15,[%a15]44
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
80006484:	48 a2       	ld.w %d2,[%a15]40
                        /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                    }

                    {           /*Write CCUCON5 configuration */
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80006486:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000648a:	26 f2       	and %d2,%d15
8000648c:	0f 23 a0 f0 	or %d15,%d3,%d2
                        ccucon5.B.UP = 1;
80006490:	b7 1f 01 ff 	insert %d15,%d15,1,30,1

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80006494:	48 c2       	ld.w %d2,[%a15]48
                        Ifx_SCU_CCUCON5 ccucon5;
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
                        /*update with configured value */
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
                        ccucon5.B.UP = 1;
                        SCU_CCUCON5  = ccucon5;
80006496:	6c 20       	st.w [%a2]0,%d15
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
80006498:	91 30 00 2f 	movh.a %a2,61443
8000649c:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800064a0:	54 23       	ld.w %d3,[%a2]
800064a2:	4c fd       	ld.w %d15,[%a15]52
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
                        SCU_CCUCON8 = ccucon8;
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800064a4:	02 84       	mov %d4,%d8
                        SCU_CCUCON5  = ccucon5;
                    }

                    {           /*Write CCUCON6 configuration */
                        Ifx_SCU_CCUCON6 ccucon6;
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
800064a6:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
800064aa:	26 f2       	and %d2,%d15
800064ac:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON6 = ccucon6;
800064b0:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800064b2:	91 30 00 2f 	movh.a %a2,61443
800064b6:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
800064ba:	54 23       	ld.w %d3,[%a2]
800064bc:	4c ff       	ld.w %d15,[%a15]60
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800064be:	48 e2       	ld.w %d2,[%a15]56
                    }

                    {
                        /*Write CCUCON7 configuration */
                        Ifx_SCU_CCUCON7 ccucon7;
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800064c0:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800064c4:	26 f2       	and %d2,%d15
800064c6:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON7 = ccucon7;
800064ca:	6c 20       	st.w [%a2]0,%d15
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800064cc:	91 30 00 2f 	movh.a %a2,61443
800064d0:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800064d4:	54 23       	ld.w %d3,[%a2]
800064d6:	19 ff 04 10 	ld.w %d15,[%a15]68 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800064da:	19 f2 00 10 	ld.w %d2,[%a15]64 <f0036088 <_SMALL_DATA4_+0x4002e088>>
                    }

                    {
                        /*Write CCUCON8 configuration */
                        Ifx_SCU_CCUCON8 ccucon8;
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800064de:	0f f3 e0 30 	andn %d3,%d3,%d15
                        /*update with configured value */
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800064e2:	26 f2       	and %d2,%d15
800064e4:	0f 23 a0 f0 	or %d15,%d3,%d2
                        SCU_CCUCON8 = ccucon8;
800064e8:	6c 20       	st.w [%a2]0,%d15
                    }
                }

                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800064ea:	6d 00 03 07 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
            }
        }

        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
800064ee:	91 00 80 cf 	movh.a %a12,63488
800064f2:	d9 cc 14 02 	lea %a12,[%a12]8212 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800064f6:	19 ff 0c 10 	ld.w %d15,[%a15]76 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
800064fa:	54 c3       	ld.w %d3,[%a12]

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
800064fc:	19 f2 08 10 	ld.w %d2,[%a15]72 <f8002014 <_SMALL_DATA4_+0x47ffa014>>
        {           /*Write Flash waitstate configuration */
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
80006500:	0f f3 e0 30 	andn %d3,%d3,%d15
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006504:	26 f2       	and %d2,%d15
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80006506:	02 94       	mov %d4,%d9
            Ifx_FLASH_FCON fcon;
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;

            /*update with configured value */
            fcon.U &= ~cfg->flashFconWaitStateConfig.mask;
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80006508:	0f 23 a0 f0 	or %d15,%d3,%d2
            {
                IfxScuWdt_clearCpuEndinit(endinit_pw);
8000650c:	6d 00 51 05 	call 80006fae <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
80006510:	6c c0       	st.w [%a12]0,%d15
                IfxScuWdt_setCpuEndinit(endinit_pw);
80006512:	02 94       	mov %d4,%d9
80006514:	6d 00 82 06 	call 80007218 <IfxScuWdt_setCpuEndinit>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006518:	91 30 00 df 	movh.a %a13,61443
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
8000651c:	91 30 00 cf 	movh.a %a12,61443
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80006520:	82 0d       	mov %d13,0
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80006522:	d9 dd 14 06 	lea %a13,[%a13]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006526:	d9 cc 1c 06 	lea %a12,[%a12]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
                IfxScuWdt_setCpuEndinit(endinit_pw);
            }
        }

        /*Start Pll ramp up sequence */
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
8000652a:	0c f0       	ld.bu %d15,[%a15]0
8000652c:	8f fd 0f 21 	and %d2,%d13,255
80006530:	7f f2 28 80 	jge.u %d2,%d15,80006580 <IfxScuCcu_init+0x370>
        {                       /*iterate through number of pll steps */
            {
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006534:	02 84       	mov %d4,%d8
80006536:	6d 00 57 05 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

                /*Configure K2 divider */
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000653a:	4c d0       	ld.w %d15,[%a13]0
8000653c:	6f 5f ff 7f 	jz.t %d15,5,8000653a <IfxScuCcu_init+0x32a>
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006540:	02 df       	mov %d15,%d13
80006542:	16 ff       	and %d15,255
80006544:	53 cf 20 a0 	mul %d10,%d15,12
80006548:	c8 12       	ld.a %a2,[%a15]4
8000654a:	4c c0       	ld.w %d15,[%a12]0
8000654c:	60 a3       	mov.a %a3,%d10
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000654e:	02 84       	mov %d4,%d8
                    /*Wait until K2 divider is ready */
                    /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
                }

                /*Now set the K2 divider value for the step corresponding to step count */
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80006550:	30 32       	add.a %a2,%a3
80006552:	14 22       	ld.bu %d2,[%a2]
80006554:	37 2f 07 20 	insert %d2,%d15,%d2,0,7
80006558:	74 c2       	st.w [%a12],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000655a:	6d 00 cb 06 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
            }

            /*call the hook function if configured */
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
8000655e:	c8 12       	ld.a %a2,[%a15]4
80006560:	60 a3       	mov.a %a3,%d10
80006562:	30 32       	add.a %a2,%a3
80006564:	99 22 08 00 	ld.a %a2,[%a2]8
80006568:	bc 23       	jz.a %a2,8000656e <IfxScuCcu_init+0x35e>
            {
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
8000656a:	2d 02 00 00 	calli %a2
            }

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
8000656e:	c8 12       	ld.a %a2,[%a15]4
80006570:	60 a3       	mov.a %a3,%d10
80006572:	c2 1d       	add %d13,1
80006574:	30 32       	add.a %a2,%a3
80006576:	19 24 04 00 	ld.w %d4,[%a2]4
8000657a:	6d ff a7 fc 	call 80005ec8 <IfxScuCcu_wait>
8000657e:	3c d6       	j 8000652a <IfxScuCcu_init+0x31a>
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006580:	02 84       	mov %d4,%d8
80006582:	6d 00 31 05 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006586:	91 30 00 ff 	movh.a %a15,61443
8000658a:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000658e:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006590:	02 84       	mov %d4,%d8
        }
    }

    {                           /* Enable oscillator disconnect feature */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006592:	8f 0f c4 f1 	andn %d15,%d15,64
80006596:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006598:	6d 00 ac 06 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
8000659c:	91 30 00 ff 	movh.a %a15,61443
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065a0:	02 94       	mov %d4,%d9
        SCU_TRAPCLR.B.SMUT = 1U;
800065a2:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065a6:	6d 00 04 05 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
800065aa:	4c f0       	ld.w %d15,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800065ac:	06 3c       	sh %d12,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
800065ae:	96 08       	or %d15,8
800065b0:	68 0f       	st.w [%a15]0,%d15
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800065b2:	91 30 00 ff 	movh.a %a15,61443
800065b6:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800065ba:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065bc:	02 94       	mov %d4,%d9
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
800065be:	8f 8f c0 f1 	andn %d15,%d15,8
800065c2:	a6 fc       	or %d12,%d15
800065c4:	68 0c       	st.w [%a15]0,%d12
        IfxScuWdt_setCpuEndinit(endinit_pw);
800065c6:	6d 00 29 06 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
800065ca:	02 b2       	mov %d2,%d11
800065cc:	00 90       	ret 

800065ce <IfxScuCcu_initConfig>:


void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg)
{
    *cfg = IfxScuCcu_defaultClockConfig;
800065ce:	91 00 00 f8 	movh.a %a15,32768
800065d2:	d9 ff d0 20 	lea %a15,[%a15]3216 <80000c90 <IfxScuCcu_defaultClockConfig>>
800065d6:	c5 02 14 00 	lea %a2,14 <_.+0x13>
800065da:	44 ff       	ld.w %d15,[%a15+]
800065dc:	64 4f       	st.w [%a4+],%d15
800065de:	fc 2e       	loop %a2,800065da <IfxScuCcu_initConfig+0xc>
800065e0:	00 90       	ret 

800065e2 <IfxScuCcu_initErayPll>:
}


boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
800065e2:	40 4c       	mov.aa %a12,%a4
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
800065e4:	6d 00 e5 05 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
800065e8:	02 2f       	mov %d15,%d2
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800065ea:	6d 00 00 06 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065ee:	02 f4       	mov %d4,%d15
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;

    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800065f0:	02 28       	mov %d8,%d2

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800065f2:	6d 00 de 04 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800065f6:	91 30 00 ff 	movh.a %a15,61443
800065fa:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800065fe:	48 03       	ld.w %d3,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006600:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006602:	02 f4       	mov %d4,%d15
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006604:	8f 82 40 21 	or %d2,%d2,8
80006608:	68 02       	st.w [%a15]0,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    {                           /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
8000660a:	37 03 e1 a1 	extr.u %d10,%d3,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000660e:	6d 00 05 06 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006612:	02 84       	mov %d4,%d8
80006614:	6d 00 e8 04 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    // ensure that PLL enabled
    if (!SCU_PLLERAYCON0.B.PLLPWD || SCU_PLLERAYCON0.B.VCOPWD || SCU_PLLERAYSTAT.B.PWDSTAT)
80006618:	91 30 00 ff 	movh.a %a15,61443
8000661c:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006620:	48 02       	ld.w %d2,[%a15]0
80006622:	ef 02 0c 00 	jz.t %d2,16,8000663a <IfxScuCcu_initErayPll+0x58>
80006626:	48 02       	ld.w %d2,[%a15]0
80006628:	6f 12 09 80 	jnz.t %d2,1,8000663a <IfxScuCcu_initErayPll+0x58>
8000662c:	91 30 00 ff 	movh.a %a15,61443
80006630:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006634:	48 02       	ld.w %d2,[%a15]0
80006636:	6f 12 19 00 	jz.t %d2,1,80006668 <IfxScuCcu_initErayPll+0x86>
    {   // PLLPWD=0 or VCOPWD=1 or PWDSTAT=1?
      // enable PLL and leave power saving mode
        SCU_PLLERAYCON0.B.PLLPWD = 1;
8000663a:	91 30 00 ff 	movh.a %a15,61443
8000663e:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006642:	48 02       	ld.w %d2,[%a15]0
80006644:	b7 f2 01 28 	insert %d2,%d2,15,16,1
80006648:	68 02       	st.w [%a15]0,%d2
        SCU_PLLERAYCON0.B.VCOPWD = 0;
8000664a:	48 02       	ld.w %d2,[%a15]0
8000664c:	8f 22 c0 21 	andn %d2,%d2,2
80006650:	68 02       	st.w [%a15]0,%d2

        while (SCU_PLLERAYSTAT.B.PWDSTAT)  // poll PWDSTAT
80006652:	91 30 00 ff 	movh.a %a15,61443
80006656:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000665a:	48 02       	ld.w %d2,[%a15]0
8000665c:	6f 12 ff ff 	jnz.t %d2,1,8000665a <IfxScuCcu_initErayPll+0x78>
        {}

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(cfg->pllInitialStep.waitTime);
80006660:	19 c4 04 00 	ld.w %d4,[%a12]4
80006664:	6d ff 32 fc 	call 80005ec8 <IfxScuCcu_wait>
    }

    /* Enter Prescalar mode */
    /* Update K and N dividers */
    if (!SCU_PLLERAYSTAT.B.VCOBYST)      // checking PLLERAYBYPST flag
80006668:	91 30 00 ff 	movh.a %a15,61443
8000666c:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006670:	48 02       	ld.w %d2,[%a15]0
80006672:	6f 02 15 80 	jnz.t %d2,0,8000669c <IfxScuCcu_initErayPll+0xba>
    {                                    // select "secure" K1 value - please check @silicon if K1=4 is ok
        while (!SCU_PLLERAYSTAT.B.K1RDY) // poll K1RDY before changing K
80006676:	48 02       	ld.w %d2,[%a15]0
80006678:	6f 42 ff 7f 	jz.t %d2,4,80006676 <IfxScuCcu_initErayPll+0x94>
        {}

        SCU_PLLERAYCON1.B.K1DIV = 3;
8000667c:	91 30 00 ff 	movh.a %a15,61443
80006680:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
80006684:	48 02       	ld.w %d2,[%a15]0
80006686:	b7 32 07 28 	insert %d2,%d2,3,16,7
8000668a:	68 02       	st.w [%a15]0,%d2

        // activate VCO bypass (bit 0: VCOBYP=1)
        SCU_PLLERAYCON0.B.VCOBYP = 1;
8000668c:	91 30 00 ff 	movh.a %a15,61443
80006690:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006694:	48 02       	ld.w %d2,[%a15]0
80006696:	8f 12 40 21 	or %d2,%d2,1
8000669a:	68 02       	st.w [%a15]0,%d2
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
8000669c:	91 30 00 ff 	movh.a %a15,61443
800066a0:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800066a4:	48 02       	ld.w %d2,[%a15]0
800066a6:	6f 52 ff 7f 	jz.t %d2,5,800066a4 <IfxScuCcu_initErayPll+0xc2>
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800066aa:	91 30 00 ff 	movh.a %a15,61443
800066ae:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800066b2:	48 03       	ld.w %d3,[%a15]0
800066b4:	39 c2 02 00 	ld.bu %d2,[%a12]2 <f0030000 <_SMALL_DATA4_+0x40028000>>
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066b8:	02 84       	mov %d4,%d8
    }

    while (!SCU_PLLERAYSTAT.B.K2RDY)     // poll K1RDY before changing K
    {}

    SCU_PLLERAYCON1.B.K2DIV = cfg->pllInitialStep.k2Initial;
800066ba:	37 23 07 20 	insert %d2,%d3,%d2,0,7
800066be:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.PDIV  = cfg->pllInitialStep.pDivider;
800066c0:	91 30 00 ff 	movh.a %a15,61443
800066c4:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
800066c8:	48 03       	ld.w %d3,[%a15]0
800066ca:	14 c2       	ld.bu %d2,[%a12]
800066cc:	37 23 04 2c 	insert %d2,%d3,%d2,24,4
800066d0:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.NDIV  = cfg->pllInitialStep.nDivider;
800066d2:	48 03       	ld.w %d3,[%a15]0
800066d4:	39 c2 01 00 	ld.bu %d2,[%a12]1
800066d8:	37 23 85 24 	insert %d2,%d3,%d2,9,5
800066dc:	68 02       	st.w [%a15]0,%d2
     *  CLRFINDIS = 1 ==> Connect OSC to PLL
     *  PLLPWD = 1    ==> PLL Power Saving Mode : Normal behaviour
     *  NDIV = NDIV
     */

    SCU_PLLERAYCON0.B.RESLD     = 1U;
800066de:	48 02       	ld.w %d2,[%a15]0
800066e0:	b7 f2 01 29 	insert %d2,%d2,15,18,1
800066e4:	68 02       	st.w [%a15]0,%d2
    SCU_PLLERAYCON0.B.CLRFINDIS = 1U;
800066e6:	48 02       	ld.w %d2,[%a15]0
800066e8:	8f 02 42 21 	or %d2,%d2,32
800066ec:	68 02       	st.w [%a15]0,%d2

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800066ee:	6d 00 01 06 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
800066f2:	91 10 00 f0 	movh.a %a15,1
800066f6:	91 30 00 2f 	movh.a %a2,61443
800066fa:	d9 22 24 06 	lea %a2,[%a2]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
800066fe:	d9 ff 0f dc 	lea %a15,[%a15]-15537 <c34f <__TRICORE_DERIVATE_MEMORY_MAP__+0x9c4f>>
80006702:	fd f0 04 00 	loop %a15,8000670a <IfxScuCcu_initErayPll+0x128>
    {}

    // check for timeout, exit immediately (don't disable VCO bypass) of not locked
    if (!time_out_ctr)
    {
        status = TRUE;
80006706:	82 19       	mov %d9,1
80006708:	3c 05       	j 80006712 <IfxScuCcu_initErayPll+0x130>
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    // Wait until VCO LOCK bit is set
    uint32 time_out_ctr = 50000; // higher time out value as for clib_pll, since system is clocked much faster while polling the lock flag

    while (--time_out_ctr && !SCU_PLLERAYSTAT.B.VCOLOCK)
8000670a:	54 22       	ld.w %d2,[%a2]
8000670c:	6f 22 fb 7f 	jz.t %d2,2,80006702 <IfxScuCcu_initErayPll+0x120>

boolean IfxScuCcu_initErayPll(const IfxScuCcu_ErayPllConfig *cfg)
{
    uint8   smuTrapEnable;
    uint16  endinit_pw, endinitSfty_pw;
    boolean status = 0;
80006710:	82 09       	mov %d9,0
    if (!time_out_ctr)
    {
        status = TRUE;
    }

    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006712:	02 84       	mov %d4,%d8
80006714:	6d 00 68 04 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>
    /*Bypass VCO*/
    SCU_PLLERAYCON0.B.VCOBYP = 0U;
80006718:	91 30 00 ff 	movh.a %a15,61443
8000671c:	d9 ff 28 06 	lea %a15,[%a15]24616 <f0036028 <_SMALL_DATA4_+0x4002e028>>
80006720:	48 02       	ld.w %d2,[%a15]0
80006722:	8f 12 c0 21 	andn %d2,%d2,1
80006726:	68 02       	st.w [%a15]0,%d2

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
80006728:	91 30 00 ff 	movh.a %a15,61443
8000672c:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
80006730:	48 02       	ld.w %d2,[%a15]0
80006732:	6f 02 ff ff 	jnz.t %d2,0,80006730 <IfxScuCcu_initErayPll+0x14e>
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80006736:	91 30 00 ff 	movh.a %a15,61443
8000673a:	d9 ff 24 06 	lea %a15,[%a15]24612 <f0036024 <_SMALL_DATA4_+0x4002e024>>
8000673e:	48 02       	ld.w %d2,[%a15]0
    {
        status = TRUE;
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006740:	02 84       	mov %d4,%d8

    // wait until bypass has been deactivated
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
80006742:	37 02 61 21 	extr.u %d2,%d2,2,1

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006746:	91 30 00 ff 	movh.a %a15,61443
    while (SCU_PLLERAYSTAT.B.VCOBYST)         // poll VCOBYST
    {}

    if (!SCU_PLLERAYSTAT.B.VCOLOCK)
    {
        status = TRUE;
8000674a:	ab 19 80 92 	sel %d9,%d2,%d9,1
    }

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000674e:	6d 00 d1 05 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006752:	02 f4       	mov %d4,%d15
80006754:	6d 00 2d 04 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006758:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
8000675c:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
8000675e:	8f 3a 00 30 	sh %d3,%d10,3

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006762:	8f 82 40 21 	or %d2,%d2,8
80006766:	68 02       	st.w [%a15]0,%d2
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006768:	91 30 00 ff 	movh.a %a15,61443
8000676c:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006770:	48 02       	ld.w %d2,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006772:	02 f4       	mov %d4,%d15
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

    {                           /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006774:	8f 82 c0 21 	andn %d2,%d2,8
80006778:	a6 32       	or %d2,%d3
8000677a:	68 02       	st.w [%a15]0,%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
8000677c:	6d 00 4e 05 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }
    return status;
}
80006780:	02 92       	mov %d2,%d9
80006782:	00 90       	ret 

80006784 <IfxScuCcu_initErayPllConfig>:


void IfxScuCcu_initErayPllConfig(IfxScuCcu_ErayPllConfig *cfg)
{
    *cfg = IfxScuCcu_defaultErayPllConfig;
80006784:	91 00 00 f8 	movh.a %a15,32768
80006788:	d9 ff c8 20 	lea %a15,[%a15]3208 <80000c88 <IfxScuCcu_defaultErayPllConfig>>
8000678c:	09 f2 40 09 	ld.d %e2,[%a15]
80006790:	89 42 40 09 	st.d [%a4],%e2
80006794:	00 90       	ret 

80006796 <IfxScuCcu_setCpuFrequency>:
    return status;
}


float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq)
{
80006796:	02 5a       	mov %d10,%d5
80006798:	02 49       	mov %d9,%d4
    uint16  endinitSfty_pw;
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();
8000679a:	6d ff a7 fc 	call 800060e8 <IfxScuCcu_getSriFrequency>
8000679e:	02 2f       	mov %d15,%d2

    if (cpuFreq >= sriFreq)
800067a0:	4b 2a 01 20 	cmp.f %d2,%d10,%d2
800067a4:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
    {
        cpuDiv = 0;
800067a8:	82 08       	mov %d8,0
    float32 sriFreq;
    uint32  cpuDiv;

    sriFreq = IfxScuCcu_getSriFrequency();

    if (cpuFreq >= sriFreq)
800067aa:	f6 29       	jnz %d2,800067bc <IfxScuCcu_setCpuFrequency+0x26>
    {
        cpuDiv = 0;
    }
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
800067ac:	7b 00 28 84 	movh %d8,17024
800067b0:	4b 8a 41 80 	mul.f %d8,%d10,%d8
800067b4:	4b f8 51 80 	div.f %d8,%d8,%d15
800067b8:	4b 08 71 81 	ftouz %d8,%d8
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067bc:	6d 00 17 05 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800067c0:	02 24       	mov %d4,%d2
    else
    {
        cpuDiv = (uint32)((cpuFreq * 64) / sriFreq);
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800067c2:	02 2a       	mov %d10,%d2

    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800067c4:	6d 00 10 04 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

        switch (cpu)
800067c8:	df 19 0f 00 	jeq %d9,1,800067e6 <IfxScuCcu_setCpuFrequency+0x50>
800067cc:	76 98       	jz %d9,800067dc <IfxScuCcu_setCpuFrequency+0x46>
800067ce:	df 29 11 80 	jne %d9,2,800067f0 <IfxScuCcu_setCpuFrequency+0x5a>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800067d2:	91 30 00 ff 	movh.a %a15,61443
800067d6:	d9 ff 08 26 	lea %a15,[%a15]24712 <f0036088 <_SMALL_DATA4_+0x4002e088>>
800067da:	3c 0a       	j 800067ee <IfxScuCcu_setCpuFrequency+0x58>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

        switch (cpu)
        {
        case IfxCpu_ResourceCpu_0:
            SCU_CCUCON6.U = cpuDiv;
800067dc:	91 30 00 ff 	movh.a %a15,61443
800067e0:	d9 ff 00 26 	lea %a15,[%a15]24704 <f0036080 <_SMALL_DATA4_+0x4002e080>>
800067e4:	3c 05       	j 800067ee <IfxScuCcu_setCpuFrequency+0x58>
            break;
        case IfxCpu_ResourceCpu_1:
            SCU_CCUCON7.U = cpuDiv;
800067e6:	91 30 00 ff 	movh.a %a15,61443
800067ea:	d9 ff 04 26 	lea %a15,[%a15]24708 <f0036084 <_SMALL_DATA4_+0x4002e084>>
            break;
        case IfxCpu_ResourceCpu_2:
            SCU_CCUCON8.U = cpuDiv;
800067ee:	68 08       	st.w [%a15]0,%d8

        default:
            break;
        }

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800067f0:	02 a4       	mov %d4,%d10
800067f2:	6d 00 7f 05 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
    }

    if (cpuDiv != 0)
800067f6:	76 89       	jz %d8,80006808 <IfxScuCcu_setCpuFrequency+0x72>
    {
        sriFreq = sriFreq * (cpuDiv / 64.0f);
800067f8:	4b 08 61 81 	utof %d8,%d8
800067fc:	7b 00 c8 23 	movh %d2,15488
80006800:	4b 28 41 80 	mul.f %d8,%d8,%d2
80006804:	4b 8f 41 f0 	mul.f %d15,%d15,%d8
    }

    return sriFreq;
}
80006808:	02 f2       	mov %d2,%d15
8000680a:	00 90       	ret 

8000680c <IfxScuCcu_setGtmFrequency>:


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
8000680c:	91 30 00 ff 	movh.a %a15,61443
80006810:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
    return sriFreq;
}


float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq)
{
80006814:	02 48       	mov %d8,%d4
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON1 ccucon1   = SCU_CCUCON1;
80006816:	4c f0       	ld.w %d15,[%a15]0

    float32         inputFreq = IfxScuCcu_getSourceFrequency();
80006818:	6d ff 46 fb 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
8000681c:	4b 82 51 20 	div.f %d2,%d2,%d8
80006820:	4b 02 31 31 	ftoiz %d3,%d2
80006824:	4b 03 41 41 	itof %d4,%d3
80006828:	6b 04 31 22 	sub.f %d2,%d2,%d4
8000682c:	7b 00 f0 43 	movh %d4,16128
80006830:	4b 42 01 20 	cmp.f %d2,%d2,%d4
80006834:	37 02 61 21 	extr.u %d2,%d2,2,1
80006838:	42 32       	add %d2,%d3
/** Return maximum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__maxu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000683a:	82 13       	mov %d3,1
8000683c:	0b 32 b0 21 	max.u %d2,%d2,%d3
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
80006840:	8b e2 00 52 	eq %d5,%d2,14
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          gtmDiv    = (uint32)__roundf(inputFreq / gtmFreq);
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
80006844:	1b 92 ff 4f 	addi %d4,%d2,-7
        gtmDiv = gtmDiv - 1;
    }

    if (gtmDiv == 14)
    {
        gtmDiv = 12;
80006848:	ab c2 a0 95 	seln %d9,%d5,%d2,12
    gtmDiv = __maxu(gtmDiv, 1);

    /*gtmDiv       = gtmDiv & 0x2U;*//* only even dividers */
    if ((gtmDiv >= 7) && (gtmDiv < 14) && ((gtmDiv & 1) == 1))
    {
        gtmDiv = gtmDiv - 1;
8000684c:	8f 12 c0 31 	andn %d3,%d2,1
80006850:	02 92       	mov %d2,%d9
80006852:	8b 74 a0 92 	ge.u %d9,%d4,7
80006856:	2b 32 40 99 	sel %d9,%d9,%d2,%d3
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
8000685a:	6d 00 c8 04 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
8000685e:	02 24       	mov %d4,%d2
    if (gtmDiv == 14)
    {
        gtmDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006860:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006862:	6d 00 c1 03 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON1.B.LCK != 0U)
80006866:	40 f2       	mov.aa %a2,%a15
80006868:	54 22       	ld.w %d2,[%a2]
8000686a:	91 30 00 ff 	movh.a %a15,61443
8000686e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80006872:	bf 02 fb 7f 	jlt %d2,0,80006868 <IfxScuCcu_setGtmFrequency+0x5c>
    {}

    ccucon1.B.GTMDIV = gtmDiv;
80006876:	37 9f 04 f6 	insert %d15,%d15,%d9,12,4
    ccucon1.B.UP     = 1U;
8000687a:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON1.U    = ccucon1.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
8000687e:	02 84       	mov %d4,%d8
    while (SCU_CCUCON1.B.LCK != 0U)
    {}

    ccucon1.B.GTMDIV = gtmDiv;
    ccucon1.B.UP     = 1U;
    SCU_CCUCON1.U    = ccucon1.U;
80006880:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006882:	6d 00 37 05 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
}


IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80006886:	6d ff 0f fb 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
8000688a:	4c f0       	ld.w %d15,[%a15]0
8000688c:	37 0f 64 f6 	extr.u %d15,%d15,12,4
80006890:	4b 0f 41 f1 	itof %d15,%d15

    return IfxScuCcu_getGtmFrequency();
}
80006894:	4b f2 51 20 	div.f %d2,%d2,%d15
80006898:	00 90       	ret 

8000689a <IfxScuCcu_setPll2ErayFrequency>:


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
8000689a:	02 48       	mov %d8,%d4
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
8000689c:	6d 00 a7 04 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
800068a0:	02 2f       	mov %d15,%d2
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068a2:	6d ff 84 fa 	call 80005daa <IfxScuCcu_getPllErayVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(password);
800068a6:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068a8:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(password);
800068aa:	6d 00 9d 03 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068ae:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
800068b2:	91 30 00 ff 	movh.a %a15,61443
800068b6:	d9 ff 2c 06 	lea %a15,[%a15]24620 <f003602c <_SMALL_DATA4_+0x4002e02c>>
800068ba:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068bc:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(password);
800068c0:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2ErayFrequency(float32 pll2ErayFreq)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div  = (uint32)((IfxScuCcu_getPllErayVcoFrequency() / pll2ErayFreq) - 1);
800068c2:	6b 03 31 88 	sub.f %d8,%d8,%d3
800068c6:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(password);
        SCU_PLLERAYCON1.B.K3DIV = pll2Div;
800068ca:	37 82 04 84 	insert %d8,%d2,%d8,8,4
800068ce:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(password);
800068d0:	6d 00 10 05 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

IFX_INLINE float32 IfxScuCcu_getPll2ErayFrequency(void)
{
    float32 pll2ErayFrequency;

    pll2ErayFrequency = IfxScuCcu_getPllErayVcoFrequency() / (SCU_PLLERAYCON1.B.K3DIV + 1);
800068d4:	6d ff 6b fa 	call 80005daa <IfxScuCcu_getPllErayVcoFrequency>
800068d8:	4c f0       	ld.w %d15,[%a15]0
800068da:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800068de:	c2 1f       	add %d15,1
800068e0:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2ErayFrequency();
}
800068e4:	4b f2 51 20 	div.f %d2,%d2,%d15
800068e8:	00 90       	ret 

800068ea <IfxScuCcu_setPll2Frequency>:


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
800068ea:	02 48       	mov %d8,%d4
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
800068ec:	6d 00 7f 04 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
800068f0:	02 2f       	mov %d15,%d2
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068f2:	6d ff b7 fa 	call 80005e60 <IfxScuCcu_getPllVcoFrequency>
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068f6:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068f8:	02 29       	mov %d9,%d2
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800068fa:	6d 00 75 03 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
800068fe:	4b 89 51 80 	div.f %d8,%d9,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
80006902:	91 30 00 ff 	movh.a %a15,61443
80006906:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000690a:	48 02       	ld.w %d2,[%a15]0


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
8000690c:	7b 00 f8 33 	movh %d3,16256
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006910:	02 f4       	mov %d4,%d15


float32 IfxScuCcu_setPll2Frequency(float32 pll2Freq)
{
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    uint32 pll2Div        = (uint32)((IfxScuCcu_getPllVcoFrequency() / pll2Freq) - 1);
80006912:	6b 03 31 88 	sub.f %d8,%d8,%d3
80006916:	4b 08 71 81 	ftouz %d8,%d8
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        SCU_PLLCON1.B.K3DIV = pll2Div;
8000691a:	37 82 07 84 	insert %d8,%d2,%d8,8,7
8000691e:	68 08       	st.w [%a15]0,%d8
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006920:	6d 00 e8 04 	call 800072f0 <IfxScuWdt_setSafetyEndinit>


IFX_INLINE float32 IfxScuCcu_getPll2Frequency(void)
{
    float32 pll2Frequency;
    pll2Frequency = IfxScuCcu_getPllVcoFrequency() / (SCU_PLLCON1.B.K3DIV + 1);
80006924:	6d ff 9e fa 	call 80005e60 <IfxScuCcu_getPllVcoFrequency>
80006928:	4c f0       	ld.w %d15,[%a15]0
8000692a:	37 0f 67 f4 	extr.u %d15,%d15,8,7
8000692e:	c2 1f       	add %d15,1
80006930:	4b 0f 41 f1 	itof %d15,%d15
    }
    return IfxScuCcu_getPll2Frequency();
}
80006934:	4b f2 51 20 	div.f %d2,%d2,%d15
80006938:	00 90       	ret 

8000693a <IfxScuCcu_setSpbFrequency>:


float32 IfxScuCcu_setSpbFrequency(float32 spbFreq)
{
8000693a:	02 4f       	mov %d15,%d4
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    uint16          l_EndInitPW;
    uint16          l_SEndInitPW;
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
8000693c:	6d ff b4 fa 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
80006940:	4b f2 51 20 	div.f %d2,%d2,%d15
80006944:	82 24       	mov %d4,2
80006946:	4b 02 71 21 	ftouz %d2,%d2
8000694a:	0b 42 b0 41 	max.u %d4,%d2,%d4
    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
    {
        spbDiv = spbDiv - 1;
    }

    if (spbDiv == 14)
8000694e:	8b e4 00 32 	eq %d3,%d4,14
    {
        spbDiv = 12;
80006952:	ab c4 a0 a3 	seln %d10,%d3,%d4,12
    Ifx_SCU_CCUCON0 ccucon0;
    float32         inputFreq = IfxScuCcu_getSourceFrequency();
    uint32          spbDiv    = (uint32)(inputFreq / spbFreq);
    spbDiv = __maxu(spbDiv, 2);

    if ((spbDiv >= 7) && (spbDiv < 14) && ((spbDiv & 1) == 1))
80006956:	1b 94 ff 2f 	addi %d2,%d4,-7
    {
        spbDiv = spbDiv - 1;
8000695a:	8f 14 c0 f1 	andn %d15,%d4,1
8000695e:	02 a4       	mov %d4,%d10
80006960:	8b 72 a0 a2 	ge.u %d10,%d2,7
80006964:	2b f4 40 aa 	sel %d10,%d10,%d4,%d15
    if (spbDiv == 14)
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
80006968:	6d 00 23 04 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
8000696c:	02 28       	mov %d8,%d2
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
8000696e:	6d 00 3e 04 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006972:	02 84       	mov %d4,%d8
    {
        spbDiv = 12;
    }

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006974:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
80006976:	6d 00 1c 03 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
8000697a:	91 30 00 ff 	movh.a %a15,61443
8000697e:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006982:	48 02       	ld.w %d2,[%a15]0
80006984:	3b 00 3e f0 	mov %d15,992
80006988:	a6 2f       	or %d15,%d2
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
8000698a:	02 84       	mov %d4,%d8

    l_EndInitPW  = IfxScuWdt_getCpuWatchdogPassword();
    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U | 0x3E0U;
8000698c:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
8000698e:	6d 00 45 04 	call 80007218 <IfxScuWdt_setCpuEndinit>

    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006992:	02 94       	mov %d4,%d9
80006994:	6d 00 28 03 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006998:	91 30 00 2f 	movh.a %a2,61443
8000699c:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800069a0:	4c 20       	ld.w %d15,[%a2]0
800069a2:	91 30 00 ff 	movh.a %a15,61443
800069a6:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800069aa:	bf 0f fb 7f 	jlt %d15,0,800069a0 <IfxScuCcu_setSpbFrequency+0x66>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
800069ae:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SPBDIV = spbDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800069b0:	02 94       	mov %d4,%d9

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SPBDIV = spbDiv;
800069b2:	37 af 04 f8 	insert %d15,%d15,%d10,16,4
    ccucon0.B.UP     = 1;
800069b6:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
800069ba:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
800069bc:	6d 00 9a 04 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
800069c0:	02 84       	mov %d4,%d8
800069c2:	6d 00 f6 02 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
800069c6:	91 30 00 ff 	movh.a %a15,61443
800069ca:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
800069ce:	4c f0       	ld.w %d15,[%a15]0
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
800069d0:	02 84       	mov %d4,%d8
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;
    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);

    IfxScuWdt_clearCpuEndinit(l_EndInitPW);
    SCU_TRAPDIS.U = SCU_TRAPDIS.U & (uint32)~0x3E0UL;
800069d2:	b7 0f 85 f2 	insert %d15,%d15,0,5,5
800069d6:	68 0f       	st.w [%a15]0,%d15
    IfxScuWdt_setCpuEndinit(l_EndInitPW);
800069d8:	6d 00 20 04 	call 80007218 <IfxScuWdt_setCpuEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
800069dc:	91 30 00 ff 	movh.a %a15,61443
800069e0:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800069e4:	4c f0       	ld.w %d15,[%a15]0
800069e6:	bf 0f ff 7f 	jlt %d15,0,800069e4 <IfxScuCcu_setSpbFrequency+0xaa>
    {}

    return IfxScuCcu_getSpbFrequency();
800069ea:	1d ff 1e fb 	j 80006026 <IfxScuCcu_getSpbFrequency>

800069ee <IfxScuCcu_setSriFrequency>:
}


float32 IfxScuCcu_setSriFrequency(float32 sriFreq)
{
800069ee:	02 4f       	mov %d15,%d4
    float32         freq   = 0;
    float32         source = IfxScuCcu_getSourceFrequency();
800069f0:	6d ff 5a fa 	call 80005ea4 <IfxScuCcu_getSourceFrequency>
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
800069f4:	4b f2 51 20 	div.f %d2,%d2,%d15
800069f8:	4b 02 31 31 	ftoiz %d3,%d2
800069fc:	4b 03 41 f1 	itof %d15,%d3
80006a00:	6b 0f 31 22 	sub.f %d2,%d2,%d15
80006a04:	7b 00 f0 f3 	movh %d15,16128
80006a08:	4b f2 01 f0 	cmp.f %d15,%d2,%d15
80006a0c:	37 0f 61 f1 	extr.u %d15,%d15,2,1
80006a10:	82 12       	mov %d2,1
80006a12:	42 3f       	add %d15,%d3
80006a14:	0b 2f b0 f1 	max.u %d15,%d15,%d2
    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
80006a18:	8b ef 00 42 	eq %d4,%d15,14
    Ifx_SCU_CCUCON0 ccucon0;
    uint16          l_SEndInitPW;
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
80006a1c:	92 93       	add %d3,%d15,-7
        sriDiv = sriDiv - 1;
    }

    if (sriDiv == 14)
    {
        sriDiv = 12;
80006a1e:	ab cf a0 94 	seln %d9,%d4,%d15,12
    uint32          sriDiv = (uint32)__roundf(source / sriFreq);
    sriDiv = __maxu(sriDiv, 1);

    if ((sriDiv >= 7) && (sriDiv < 14) && ((sriDiv & 1) == 1))
    {
        sriDiv = sriDiv - 1;
80006a22:	8f 1f c0 21 	andn %d2,%d15,1
80006a26:	02 9f       	mov %d15,%d9
80006a28:	8b 73 a0 92 	ge.u %d9,%d3,7
80006a2c:	2b 2f 40 99 	sel %d9,%d9,%d15,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a30:	6d 00 dd 03 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a34:	02 24       	mov %d4,%d2
    if (sriDiv == 14)
    {
        sriDiv = 12;
    }

    l_SEndInitPW = IfxScuWdt_getSafetyWatchdogPassword();
80006a36:	02 28       	mov %d8,%d2
    IfxScuWdt_clearSafetyEndinit(l_SEndInitPW);
80006a38:	6d 00 d6 02 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006a3c:	91 30 00 2f 	movh.a %a2,61443
80006a40:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a44:	4c 20       	ld.w %d15,[%a2]0
80006a46:	91 30 00 ff 	movh.a %a15,61443
80006a4a:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a4e:	bf 0f fb 7f 	jlt %d15,0,80006a44 <IfxScuCcu_setSriFrequency+0x56>
    {}

    ccucon0.U        = SCU_CCUCON0.U;
80006a52:	4c f0       	ld.w %d15,[%a15]0
    ccucon0.B.SRIDIV = sriDiv;
    ccucon0.B.UP     = 1;
    SCU_CCUCON0.U    = ccucon0.U;

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a54:	02 84       	mov %d4,%d8

    while (SCU_CCUCON0.B.LCK != 0U)
    {}

    ccucon0.U        = SCU_CCUCON0.U;
    ccucon0.B.SRIDIV = sriDiv;
80006a56:	37 9f 04 f4 	insert %d15,%d15,%d9,8,4
    ccucon0.B.UP     = 1;
80006a5a:	b7 1f 01 ff 	insert %d15,%d15,1,30,1
    SCU_CCUCON0.U    = ccucon0.U;
80006a5e:	68 0f       	st.w [%a15]0,%d15

    IfxScuWdt_setSafetyEndinit(l_SEndInitPW);
80006a60:	6d 00 48 04 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

    while (SCU_CCUCON0.B.LCK != 0U)
80006a64:	4c f0       	ld.w %d15,[%a15]0
80006a66:	bf 0f ff 7f 	jlt %d15,0,80006a64 <IfxScuCcu_setSriFrequency+0x76>
    {}

    freq = IfxScuCcu_getSriFrequency();
80006a6a:	1d ff 3f fb 	j 800060e8 <IfxScuCcu_getSriFrequency>

80006a6e <IfxScuCcu_switchToBackupClock>:
{
    uint16 endinit_pw, endinitSfty_pw;
    int    pllStepsCount;
    uint8  smuTrapEnable;

    if (SCU_CCUCON0.B.CLKSEL == 0) /* Already source is backup clock */
80006a6e:	91 30 00 ff 	movh.a %a15,61443
80006a72:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006a76:	4c f0       	ld.w %d15,[%a15]0
80006a78:	37 0f 62 fe 	extr.u %d15,%d15,28,2
80006a7c:	df 0f 81 00 	jeq %d15,0,80006b7e <IfxScuCcu_switchToBackupClock+0x110>
80006a80:	40 4f       	mov.aa %a15,%a4
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
80006a82:	6d 00 b4 03 	call 800071ea <IfxScuWdt_getSafetyWatchdogPassword>
80006a86:	02 29       	mov %d9,%d2
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006a88:	6d 00 93 03 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006a8c:	0c f0       	ld.bu %d15,[%a15]0
    {
        return;
    }

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();
80006a8e:	02 28       	mov %d8,%d2
80006a90:	53 cf 20 20 	mul %d2,%d15,12
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006a94:	91 30 00 ef 	movh.a %a14,61443
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006a98:	91 30 00 df 	movh.a %a13,61443
80006a9c:	60 22       	mov.a %a2,%d2
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006a9e:	d9 ee 14 06 	lea %a14,[%a14]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80006aa2:	d9 2c f4 ff 	lea %a12,[%a2]-12 <f0036014 <_SMALL_DATA4_+0x4002e014>>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006aa6:	d9 dd 1c 06 	lea %a13,[%a13]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006aaa:	6e 1b       	jz %d15,80006ae0 <IfxScuCcu_switchToBackupClock+0x72>
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006aac:	02 94       	mov %d4,%d9
80006aae:	6d 00 9b 02 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

            /*Configure K2 divider */
            while (SCU_PLLSTAT.B.K2RDY == 0U)
80006ab2:	54 e2       	ld.w %d2,[%a14]
80006ab4:	6f 52 ff 7f 	jz.t %d2,5,80006ab2 <IfxScuCcu_switchToBackupClock+0x44>
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006ab8:	c8 12       	ld.a %a2,[%a15]4
80006aba:	54 d3       	ld.w %d3,[%a13]

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006abc:	02 94       	mov %d4,%d9
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006abe:	30 c2       	add.a %a2,%a12
80006ac0:	14 22       	ld.bu %d2,[%a2]

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
    endinit_pw     = IfxScuWdt_getCpuWatchdogPassword();

    /*Start Pll ramp down sequence */
    for (pllStepsCount = cfg->sysPll.numOfPllDividerSteps; pllStepsCount > 0; pllStepsCount--)
80006ac2:	c2 ff       	add %d15,-1
                /*Wait until K2 divider is ready */
                /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount - 1].k2Step;
80006ac4:	37 23 07 20 	insert %d2,%d3,%d2,0,7
80006ac8:	74 d2       	st.w [%a13],%d2

            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006aca:	6d 00 13 04 	call 800072f0 <IfxScuWdt_setSafetyEndinit>

            /*Wait for waitCounter corresponding to the pll step */
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount - 1].waitTime);
80006ace:	c8 12       	ld.a %a2,[%a15]4
80006ad0:	30 c2       	add.a %a2,%a12
80006ad2:	19 24 04 00 	ld.w %d4,[%a2]4
80006ad6:	6d ff f9 f9 	call 80005ec8 <IfxScuCcu_wait>
80006ada:	d9 cc f4 ff 	lea %a12,[%a12]-12
80006ade:	3c e6       	j 80006aaa <IfxScuCcu_switchToBackupClock+0x3c>
        }
    }

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006ae0:	02 84       	mov %d4,%d8
80006ae2:	6d 00 66 02 	call 80006fae <IfxScuWdt_clearCpuEndinit>

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006ae6:	91 30 00 ff 	movh.a %a15,61443
80006aea:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006aee:	48 02       	ld.w %d2,[%a15]0
        SCU_TRAPDIS.B.SMUT = 1U;
80006af0:	4c f0       	ld.w %d15,[%a15]0

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006af2:	02 84       	mov %d4,%d8
    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
        SCU_TRAPDIS.B.SMUT = 1U;
80006af4:	96 08       	or %d15,8
80006af6:	68 0f       	st.w [%a15]0,%d15

    {
        /* Disable TRAP for SMU (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinit_pw);

        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80006af8:	37 02 e1 a1 	extr.u %d10,%d2,3,1
        SCU_TRAPDIS.B.SMUT = 1U;

        IfxScuWdt_setCpuEndinit(endinit_pw);
80006afc:	6d 00 8e 03 	call 80007218 <IfxScuWdt_setCpuEndinit>
    }

    {
        /* Select fback (fosc-evr) as CCU input clock */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80006b00:	02 94       	mov %d4,%d9
80006b02:	6d 00 71 02 	call 80006fe4 <IfxScuWdt_clearSafetyEndinit>

        while (SCU_CCUCON0.B.LCK != 0U)
80006b06:	91 30 00 2f 	movh.a %a2,61443
80006b0a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b0e:	4c 20       	ld.w %d15,[%a2]0
80006b10:	91 30 00 ff 	movh.a %a15,61443
80006b14:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80006b18:	bf 0f fb 7f 	jlt %d15,0,80006b0e <IfxScuCcu_switchToBackupClock+0xa0>
        {
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80006b1c:	4c f0       	ld.w %d15,[%a15]0
80006b1e:	b7 0f 02 fe 	insert %d15,%d15,0,28,2
80006b22:	68 0f       	st.w [%a15]0,%d15
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80006b24:	4c f0       	ld.w %d15,[%a15]0
80006b26:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
80006b2a:	68 0f       	st.w [%a15]0,%d15

        while (SCU_CCUCON0.B.LCK != 0U)
80006b2c:	4c f0       	ld.w %d15,[%a15]0
80006b2e:	bf 0f ff 7f 	jlt %d15,0,80006b2c <IfxScuCcu_switchToBackupClock+0xbe>
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006b32:	91 30 00 ff 	movh.a %a15,61443
80006b36:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80006b3a:	4c f0       	ld.w %d15,[%a15]0

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b3c:	02 94       	mov %d4,%d9
            /*Wait till ccucon0 lock is set */
            /*No "timeout" required, because if it hangs, Safety Endinit will give a trap */
        }

        /* Disconnet PLL (SETFINDIS=1): oscillator clock is disconnected from PLL */
        SCU_PLLCON0.B.SETFINDIS = 1;
80006b3e:	96 10       	or %d15,16
80006b40:	68 0f       	st.w [%a15]0,%d15

        /* Enable oscillator disconnect feature */
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80006b42:	4c f0       	ld.w %d15,[%a15]0
80006b44:	8f 0f c4 f1 	andn %d15,%d15,64
80006b48:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80006b4a:	6d 00 d3 03 	call 800072f0 <IfxScuWdt_setSafetyEndinit>
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006b4e:	91 30 00 ff 	movh.a %a15,61443
80006b52:	d9 ff 2c 46 	lea %a15,[%a15]24876 <f003612c <_SMALL_DATA4_+0x4002e12c>>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80006b56:	02 84       	mov %d4,%d8
80006b58:	6d 00 2b 02 	call 80006fae <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80006b5c:	4c f0       	ld.w %d15,[%a15]0

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b5e:	8f 3a 00 20 	sh %d2,%d10,3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
    }
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;
80006b62:	96 08       	or %d15,8
80006b64:	68 0f       	st.w [%a15]0,%d15

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b66:	91 30 00 ff 	movh.a %a15,61443
80006b6a:	d9 ff 30 46 	lea %a15,[%a15]24880 <f0036130 <_SMALL_DATA4_+0x4002e130>>
80006b6e:	4c f0       	ld.w %d15,[%a15]0
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006b70:	02 84       	mov %d4,%d8
    {
        /* Enable VCO unlock Trap if it was disabled before */
        IfxScuWdt_clearCpuEndinit(endinit_pw);
        SCU_TRAPCLR.B.SMUT = 1U;

        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80006b72:	8f 8f c0 f1 	andn %d15,%d15,8
80006b76:	a6 2f       	or %d15,%d2
80006b78:	68 0f       	st.w [%a15]0,%d15
        IfxScuWdt_setCpuEndinit(endinit_pw);
80006b7a:	1d 00 4f 03 	j 80007218 <IfxScuWdt_setCpuEndinit>
80006b7e:	00 90       	ret 

80006b80 <IfxScuEru_clearAllEventFlags>:
/******************************************************************************/

void IfxScuEru_clearAllEventFlags(void)
{
    uint32 mask = (0xFF << 16);
    MODULE_SCU.FMR.U = mask;
80006b80:	91 30 00 ff 	movh.a %a15,61443
80006b84:	7b f0 0f f0 	movh %d15,255
80006b88:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006b8c:	59 ff 24 80 	st.w [%a15]548 <f0030224 <_SMALL_DATA4_+0x40028224>>,%d15
80006b90:	00 90       	ret 

80006b92 <IfxScuEru_clearEventFlag>:
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006b92:	1b 04 01 40 	addi %d4,%d4,16
80006b96:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006b98:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_clearEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << (inputChannel + 16);
80006b9c:	0f 4f 00 f0 	sh %d15,%d15,%d4
    SCU_FMR.U = mask;
80006ba0:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006ba4:	68 0f       	st.w [%a15]0,%d15
80006ba6:	00 90       	ret 

80006ba8 <IfxScuEru_clearInputChannelConfiguration>:


void IfxScuEru_clearInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ba8:	8f f4 1f f0 	sh %d15,%d4,-1
80006bac:	06 2f       	sh %d15,2
80006bae:	60 ff       	mov.a %a15,%d15
80006bb0:	d9 ff 00 06 	lea %a15,[%a15]24576
80006bb4:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006bb8:	19 ff 10 80 	ld.w %d15,[%a15]528
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006bbc:	6f 04 05 00 	jz.t %d4,0,80006bc6 <IfxScuEru_clearInputChannelConfiguration+0x1e>
    {
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006bc0:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006bc4:	3c 03       	j 80006bca <IfxScuEru_clearInputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.EICR[index].U = (MODULE_SCU.EICR[index].U & mask);
80006bc6:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006bca:	59 ff 10 80 	st.w [%a15]528,%d15
80006bce:	00 90       	ret 

80006bd0 <IfxScuEru_clearOutputChannelConfiguration>:


void IfxScuEru_clearOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006bd0:	8f f4 1f f0 	sh %d15,%d4,-1
80006bd4:	06 2f       	sh %d15,2
80006bd6:	60 ff       	mov.a %a15,%d15
80006bd8:	d9 ff 00 06 	lea %a15,[%a15]24576
80006bdc:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006be0:	19 ff 2c 80 	ld.w %d15,[%a15]556
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 mask  = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006be4:	6f 04 05 00 	jz.t %d4,0,80006bee <IfxScuEru_clearOutputChannelConfiguration+0x1e>
    {
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006be8:	b7 0f 10 f8 	insert %d15,%d15,0,16,16
80006bec:	3c 03       	j 80006bf2 <IfxScuEru_clearOutputChannelConfiguration+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        mask                     = (mask << 16);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & mask);
80006bee:	b7 0f 10 f0 	insert %d15,%d15,0,0,16
80006bf2:	59 ff 2c 80 	st.w [%a15]556,%d15
80006bf6:	00 90       	ret 

80006bf8 <IfxScuEru_connectTrigger>:


void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006bf8:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006bfc:	91 30 00 ff 	movh.a %a15,61443
80006c00:	1b 4f 08 f0 	addi %d15,%d15,132
80006c04:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c08:	8f 75 00 51 	and %d5,%d5,7
80006c0c:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_connectTrigger(IfxScuEru_InputChannel inputChannel, IfxScuEru_InputNodePointer triggerSelect)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c0e:	6f 04 08 00 	jz.t %d4,0,80006c1e <IfxScuEru_connectTrigger+0x26>
    {
        MODULE_SCU.EICR[index].B.INP1 = triggerSelect;
80006c12:	4c f0       	ld.w %d15,[%a15]0
80006c14:	8f c5 01 50 	sh %d5,%d5,28
80006c18:	b7 0f 03 fe 	insert %d15,%d15,0,28,3
80006c1c:	3c 06       	j 80006c28 <IfxScuEru_connectTrigger+0x30>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.INP0 = triggerSelect;
80006c1e:	4c f0       	ld.w %d15,[%a15]0
80006c20:	8f c5 00 50 	sh %d5,%d5,12
80006c24:	b7 0f 03 f6 	insert %d15,%d15,0,12,3
80006c28:	a6 f5       	or %d5,%d15
80006c2a:	68 05       	st.w [%a15]0,%d5
80006c2c:	00 90       	ret 

80006c2e <IfxScuEru_disableAutoClear>:


void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c2e:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006c32:	91 30 00 ff 	movh.a %a15,61443
80006c36:	1b 4f 08 f0 	addi %d15,%d15,132
80006c3a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c3e:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c40:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c42:	6f 04 05 00 	jz.t %d4,0,80006c4c <IfxScuEru_disableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = FALSE;
80006c46:	b7 0f 01 fd 	insert %d15,%d15,0,26,1
80006c4a:	3c 03       	j 80006c50 <IfxScuEru_disableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = FALSE;
80006c4c:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80006c50:	68 0f       	st.w [%a15]0,%d15
80006c52:	00 90       	ret 

80006c54 <IfxScuEru_disableFallingEdgeDetection>:


void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c54:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006c58:	91 30 00 ff 	movh.a %a15,61443
80006c5c:	1b 4f 08 f0 	addi %d15,%d15,132
80006c60:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c64:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c66:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006c68:	6f 04 05 00 	jz.t %d4,0,80006c72 <IfxScuEru_disableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = FALSE;
80006c6c:	b7 0f 01 fc 	insert %d15,%d15,0,24,1
80006c70:	3c 03       	j 80006c76 <IfxScuEru_disableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = FALSE;
80006c72:	8f 0f d0 f1 	andn %d15,%d15,256
80006c76:	68 0f       	st.w [%a15]0,%d15
80006c78:	00 90       	ret 

80006c7a <IfxScuEru_disablePatternDetectionTrigger>:


void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006c7a:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006c7e:	91 30 00 ff 	movh.a %a15,61443
80006c82:	1b bf 08 f0 	addi %d15,%d15,139
80006c86:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006c8a:	90 ff       	addsc.a %a15,%a15,%d15,2
80006c8c:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006c8e:	6f 04 05 00 	jz.t %d4,0,80006c98 <IfxScuEru_disablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = FALSE;
80006c92:	b7 0f 81 fe 	insert %d15,%d15,0,29,1
80006c96:	3c 03       	j 80006c9c <IfxScuEru_disablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = FALSE;
80006c98:	b7 0f 81 f6 	insert %d15,%d15,0,13,1
80006c9c:	68 0f       	st.w [%a15]0,%d15
80006c9e:	00 90       	ret 

80006ca0 <IfxScuEru_disableRisingEdgeDetection>:


void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ca0:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006ca4:	91 30 00 ff 	movh.a %a15,61443
80006ca8:	1b 4f 08 f0 	addi %d15,%d15,132
80006cac:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006cb0:	90 ff       	addsc.a %a15,%a15,%d15,2
80006cb2:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006cb4:	6f 04 05 00 	jz.t %d4,0,80006cbe <IfxScuEru_disableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = FALSE;
80006cb8:	b7 0f 81 fc 	insert %d15,%d15,0,25,1
80006cbc:	3c 03       	j 80006cc2 <IfxScuEru_disableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = FALSE;
80006cbe:	b7 0f 81 f4 	insert %d15,%d15,0,9,1
80006cc2:	68 0f       	st.w [%a15]0,%d15
80006cc4:	00 90       	ret 

80006cc6 <IfxScuEru_disableTriggerPulse>:


void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006cc6:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006cca:	91 30 00 ff 	movh.a %a15,61443
80006cce:	1b 4f 08 f0 	addi %d15,%d15,132
80006cd2:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006cd6:	90 ff       	addsc.a %a15,%a15,%d15,2
80006cd8:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_disableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006cda:	6f 04 05 00 	jz.t %d4,0,80006ce4 <IfxScuEru_disableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = FALSE;
80006cde:	b7 0f 81 fd 	insert %d15,%d15,0,27,1
80006ce2:	3c 03       	j 80006ce8 <IfxScuEru_disableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = FALSE;
80006ce4:	b7 0f 81 f5 	insert %d15,%d15,0,11,1
80006ce8:	68 0f       	st.w [%a15]0,%d15
80006cea:	00 90       	ret 

80006cec <IfxScuEru_enableAutoClear>:


void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006cec:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006cf0:	91 30 00 ff 	movh.a %a15,61443
80006cf4:	1b 4f 08 f0 	addi %d15,%d15,132
80006cf8:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006cfc:	90 ff       	addsc.a %a15,%a15,%d15,2
80006cfe:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableAutoClear(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d00:	6f 04 05 00 	jz.t %d4,0,80006d0a <IfxScuEru_enableAutoClear+0x1e>
    {
        MODULE_SCU.EICR[index].B.LDEN1 = TRUE;
80006d04:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
80006d08:	3c 03       	j 80006d0e <IfxScuEru_enableAutoClear+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.LDEN0 = TRUE;
80006d0a:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80006d0e:	68 0f       	st.w [%a15]0,%d15
80006d10:	00 90       	ret 

80006d12 <IfxScuEru_enableFallingEdgeDetection>:


void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d12:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006d16:	91 30 00 ff 	movh.a %a15,61443
80006d1a:	1b 4f 08 f0 	addi %d15,%d15,132
80006d1e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d22:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d24:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableFallingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d26:	6f 04 05 00 	jz.t %d4,0,80006d30 <IfxScuEru_enableFallingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.FEN1 = TRUE;
80006d2a:	b7 ff 01 fc 	insert %d15,%d15,15,24,1
80006d2e:	3c 03       	j 80006d34 <IfxScuEru_enableFallingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.FEN0 = TRUE;
80006d30:	8f 0f 50 f1 	or %d15,%d15,256
80006d34:	68 0f       	st.w [%a15]0,%d15
80006d36:	00 90       	ret 

80006d38 <IfxScuEru_enablePatternDetectionTrigger>:


void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d38:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006d3c:	91 30 00 ff 	movh.a %a15,61443
80006d40:	1b bf 08 f0 	addi %d15,%d15,139
80006d44:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d48:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d4a:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enablePatternDetectionTrigger(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006d4c:	6f 04 05 00 	jz.t %d4,0,80006d56 <IfxScuEru_enablePatternDetectionTrigger+0x1e>
    {
        MODULE_SCU.IGCR[index].B.GEEN1 = TRUE;
80006d50:	b7 ff 81 fe 	insert %d15,%d15,15,29,1
80006d54:	3c 03       	j 80006d5a <IfxScuEru_enablePatternDetectionTrigger+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.GEEN0 = TRUE;
80006d56:	b7 ff 81 f6 	insert %d15,%d15,15,13,1
80006d5a:	68 0f       	st.w [%a15]0,%d15
80006d5c:	00 90       	ret 

80006d5e <IfxScuEru_enableRisingEdgeDetection>:


void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d5e:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006d62:	91 30 00 ff 	movh.a %a15,61443
80006d66:	1b 4f 08 f0 	addi %d15,%d15,132
80006d6a:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d6e:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d70:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableRisingEdgeDetection(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d72:	6f 04 05 00 	jz.t %d4,0,80006d7c <IfxScuEru_enableRisingEdgeDetection+0x1e>
    {
        MODULE_SCU.EICR[index].B.REN1 = TRUE;
80006d76:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
80006d7a:	3c 03       	j 80006d80 <IfxScuEru_enableRisingEdgeDetection+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.REN0 = TRUE;
80006d7c:	b7 ff 81 f4 	insert %d15,%d15,15,9,1
80006d80:	68 0f       	st.w [%a15]0,%d15
80006d82:	00 90       	ret 

80006d84 <IfxScuEru_enableTriggerPulse>:


void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006d84:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006d88:	91 30 00 ff 	movh.a %a15,61443
80006d8c:	1b 4f 08 f0 	addi %d15,%d15,132
80006d90:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006d94:	90 ff       	addsc.a %a15,%a15,%d15,2
80006d96:	4c f0       	ld.w %d15,[%a15]0
void IfxScuEru_enableTriggerPulse(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)     // for channels 1, 3 ,5 and 7
80006d98:	6f 04 05 00 	jz.t %d4,0,80006da2 <IfxScuEru_enableTriggerPulse+0x1e>
    {
        MODULE_SCU.EICR[index].B.EIEN1 = TRUE;
80006d9c:	b7 ff 81 fd 	insert %d15,%d15,15,27,1
80006da0:	3c 03       	j 80006da6 <IfxScuEru_enableTriggerPulse+0x22>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EIEN0 = TRUE;
80006da2:	b7 ff 81 f5 	insert %d15,%d15,15,11,1
80006da6:	68 0f       	st.w [%a15]0,%d15
80006da8:	00 90       	ret 

80006daa <IfxScuEru_getAllEventFlagsStatus>:
}


uint32 IfxScuEru_getAllEventFlagsStatus(void)
{
    return MODULE_SCU.EIFR.U;
80006daa:	91 30 00 ff 	movh.a %a15,61443
80006dae:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006db2:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006db6:	00 90       	ret 

80006db8 <IfxScuEru_getEventFlagStatus>:


boolean IfxScuEru_getEventFlagStatus(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = (1U << inputChannel);
    return (MODULE_SCU.EIFR.U & mask) ? TRUE : FALSE;
80006db8:	91 30 00 ff 	movh.a %a15,61443
80006dbc:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dc0:	19 f2 20 80 	ld.w %d2,[%a15]544 <f0030220 <_SMALL_DATA4_+0x40028220>>
}
80006dc4:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006dc8:	00 90       	ret 

80006dca <IfxScuEru_getInputChannelConfiguration>:


uint32 IfxScuEru_getInputChannelConfiguration(IfxScuEru_InputChannel inputChannel)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dca:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006dce:	91 30 00 ff 	movh.a %a15,61443
80006dd2:	1b 4f 08 f0 	addi %d15,%d15,132
80006dd6:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dda:	90 ff       	addsc.a %a15,%a15,%d15,2
80006ddc:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006dde:	6f 04 05 00 	jz.t %d4,0,80006de8 <IfxScuEru_getInputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.EICR[index].U & mask);
80006de2:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006de6:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.EICR[index].U & mask);
80006de8:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006dec:	00 90       	ret 

80006dee <IfxScuEru_getOutputChannelConfiguration>:


uint32 IfxScuEru_getOutputChannelConfiguration(IfxScuEru_OutputChannel outputChannel)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006dee:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006df2:	91 30 00 ff 	movh.a %a15,61443
80006df6:	1b bf 08 f0 	addi %d15,%d15,139
80006dfa:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006dfe:	90 ff       	addsc.a %a15,%a15,%d15,2
80006e00:	48 02       	ld.w %d2,[%a15]0
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
    uint32 status, mask = 0xFFFF;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e02:	6f 04 05 00 	jz.t %d4,0,80006e0c <IfxScuEru_getOutputChannelConfiguration+0x1e>
    {
        mask   = (mask << 16);
        status = (MODULE_SCU.IGCR[index].U & mask);
80006e06:	b7 02 10 20 	insert %d2,%d2,0,0,16
80006e0a:	00 90       	ret 
    }
    else    // for channels 0, 2, 4 and 6
    {
        status = (MODULE_SCU.IGCR[index].U & mask);
80006e0c:	b7 02 10 28 	insert %d2,%d2,0,16,16
    }

    return status;
}
80006e10:	00 90       	ret 

80006e12 <IfxScuEru_getPatternDetectionResult>:


boolean IfxScuEru_getPatternDetectionResult(IfxScuEru_OutputChannel outputChannel)
{
    uint32 mask = (1U << outputChannel);
    return (MODULE_SCU.PDRR.U & mask) ? TRUE : FALSE;
80006e12:	91 30 00 ff 	movh.a %a15,61443
80006e16:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e1a:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006e1e:	57 02 61 24 	extr.u %d2,%d2,%d4,1
80006e22:	00 90       	ret 

80006e24 <IfxScuEru_getWholePatternDetectionResult>:


uint32 IfxScuEru_getWholePatternDetectionResult(void)
{
    return MODULE_SCU.PDRR.U;
80006e24:	91 30 00 ff 	movh.a %a15,61443
80006e28:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e2c:	19 f2 28 80 	ld.w %d2,[%a15]552 <f0030228 <_SMALL_DATA4_+0x40028228>>
}
80006e30:	00 90       	ret 

80006e32 <IfxScuEru_selectExternalInput>:


void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006e32:	8f f4 1f f0 	sh %d15,%d4,-1

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006e36:	91 30 00 ff 	movh.a %a15,61443
80006e3a:	1b 4f 08 f0 	addi %d15,%d15,132
80006e3e:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006e42:	8f 75 00 51 	and %d5,%d5,7
80006e46:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_selectExternalInput(IfxScuEru_InputChannel inputChannel, IfxScuEru_ExternalInputSelection inputSignal)
{
    // select appropriate EICRi register for the given input channel X ( i = 0,1,2,3 and X = 0 to 7 )
    uint32 index = (inputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (inputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006e48:	6f 04 08 00 	jz.t %d4,0,80006e58 <IfxScuEru_selectExternalInput+0x26>
    {
        MODULE_SCU.EICR[index].B.EXIS1 = inputSignal;
80006e4c:	4c f0       	ld.w %d15,[%a15]0
80006e4e:	8f 45 01 50 	sh %d5,%d5,20
80006e52:	b7 0f 03 fa 	insert %d15,%d15,0,20,3
80006e56:	3c 05       	j 80006e60 <IfxScuEru_selectExternalInput+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.EICR[index].B.EXIS0 = inputSignal;
80006e58:	4c f0       	ld.w %d15,[%a15]0
80006e5a:	06 45       	sh %d5,4
80006e5c:	8f 0f c7 f1 	andn %d15,%d15,112
80006e60:	a6 f5       	or %d5,%d15
80006e62:	68 05       	st.w [%a15]0,%d5
80006e64:	00 90       	ret 

80006e66 <IfxScuEru_setEventFlag>:
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006e66:	82 1f       	mov %d15,1
    SCU_FMR.U = mask;
80006e68:	91 30 00 ff 	movh.a %a15,61443
}


void IfxScuEru_setEventFlag(IfxScuEru_InputChannel inputChannel)
{
    uint32 mask = 1 << inputChannel;
80006e6c:	0f 4f 00 40 	sh %d4,%d15,%d4
    SCU_FMR.U = mask;
80006e70:	d9 ff 24 86 	lea %a15,[%a15]25124 <f0036224 <_SMALL_DATA4_+0x4002e224>>
80006e74:	68 04       	st.w [%a15]0,%d4
80006e76:	00 90       	ret 

80006e78 <IfxScuEru_setFlagPatternDetection>:
}


void IfxScuEru_setFlagPatternDetection(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InputChannel inputChannel, boolean state)
{
80006e78:	8f f4 1f f0 	sh %d15,%d4,-1
    uint32 shift, mask;

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD) // for channels 1, 3 ,5 and 7
80006e7c:	6f 04 04 00 	jz.t %d4,0,80006e84 <IfxScuEru_setFlagPatternDetection+0xc>
    {
        shift = (inputChannel + 16);                  // offset at location IPEN10
80006e80:	1b 05 01 50 	addi %d5,%d5,16
80006e84:	06 2f       	sh %d15,2
80006e86:	60 f2       	mov.a %a2,%d15
80006e88:	d9 2f 00 06 	lea %a15,[%a2]24576
80006e8c:	11 3f 00 ff 	addih.a %a15,%a15,61443
    {
        shift = inputChannel;
        mask  = (1 << shift);
        // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
        uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
        MODULE_SCU.IGCR[index].U = (MODULE_SCU.IGCR[index].U & ~mask) | ((uint32)state << shift);
80006e90:	19 ff 2c 80 	ld.w %d15,[%a15]556
80006e94:	d7 0f 01 f5 	insert %d15,%d15,0,%d5,1
80006e98:	0f 56 00 50 	sh %d5,%d6,%d5
80006e9c:	a6 f5       	or %d5,%d15
80006e9e:	59 f5 2c 80 	st.w [%a15]556,%d5
80006ea2:	00 90       	ret 

80006ea4 <IfxScuEru_setInterruptGatingPattern>:


void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);
80006ea4:	8f f4 1f f0 	sh %d15,%d4,-1

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006ea8:	91 30 00 ff 	movh.a %a15,61443
80006eac:	1b bf 08 f0 	addi %d15,%d15,139
80006eb0:	d9 ff 00 06 	lea %a15,[%a15]24576 <f0036000 <_SMALL_DATA4_+0x4002e000>>
80006eb4:	8f 35 00 51 	and %d5,%d5,3
80006eb8:	90 ff       	addsc.a %a15,%a15,%d15,2
void IfxScuEru_setInterruptGatingPattern(IfxScuEru_OutputChannel outputChannel, IfxScuEru_InterruptGatingPattern gatingPattern)
{
    // select appropriate IGCRj register for the given output channel Y ( j = 0,1,2,3 and Y = 0 to 7 )
    uint32 index = (outputChannel >> IFXSCUERU_TO_REGISTER_BASE);

    if (outputChannel & IFXSCUERU_CHANNEL_NUMBER_ODD)    // for channels 1, 3 ,5 and 7
80006eba:	6f 04 06 00 	jz.t %d4,0,80006ec6 <IfxScuEru_setInterruptGatingPattern+0x22>
    {
        MODULE_SCU.IGCR[index].B.IGP1 = gatingPattern;
80006ebe:	4c f0       	ld.w %d15,[%a15]0
80006ec0:	37 5f 02 5f 	insert %d5,%d15,%d5,30,2
80006ec4:	3c 07       	j 80006ed2 <IfxScuEru_setInterruptGatingPattern+0x2e>
    }
    else    // for channels 0, 2, 4 and 6
    {
        MODULE_SCU.IGCR[index].B.IGP0 = gatingPattern;
80006ec6:	4c f0       	ld.w %d15,[%a15]0
80006ec8:	8f e5 00 50 	sh %d5,%d5,14
80006ecc:	b7 0f 02 f7 	insert %d15,%d15,0,14,2
80006ed0:	a6 f5       	or %d5,%d15
80006ed2:	68 05       	st.w [%a15]0,%d5
80006ed4:	00 90       	ret 

80006ed6 <IfxScuWdt_changeCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006ed6:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006eda:	16 07       	and %d15,7
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScuWdt_changeCpuWatchdogPassword(uint16 password, uint16 newPassword)
{
    Ifx_SCU_WDTCPU     *watchdog = &MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()];
80006edc:	53 cf 20 f0 	mul %d15,%d15,12
80006ee0:	60 f2       	mov.a %a2,%d15
80006ee2:	d9 2f 00 46 	lea %a15,[%a2]24832
80006ee6:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80006eea:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006eec:	2e 16       	jz.t %d15,1,80006ef8 <IfxScuWdt_changeCpuWatchdogPassword+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006eee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006ef2:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80006ef6:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006ef8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006efc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
80006f00:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80006f04:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80006f06:	4c f0       	ld.w %d15,[%a15]0
80006f08:	6f 0f ff 7f 	jz.t %d15,0,80006f06 <IfxScuWdt_changeCpuWatchdogPassword+0x30>
    {}
}
80006f0c:	00 90       	ret 

80006f0e <IfxScuWdt_changeCpuWatchdogReload>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006f0e:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006f12:	16 07       	and %d15,7

void IfxScuWdt_changeCpuWatchdogReload(uint16 password, uint16 reload)
{
    /* Select CPU Watchdog based on Core Id */
    uint32              coreId = IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU     *wdt    = &MODULE_SCU.WDTCPU[coreId];
80006f14:	53 cf 20 f0 	mul %d15,%d15,12
80006f18:	60 f2       	mov.a %a2,%d15
80006f1a:	d9 2f 00 46 	lea %a15,[%a2]24832
80006f1e:	11 3f 00 ff 	addih.a %a15,%a15,61443

    /* Read Config_0 register */
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80006f22:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f24:	2e 16       	jz.t %d15,1,80006f30 <IfxScuWdt_changeCpuWatchdogReload+0x22>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f26:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f2a:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80006f2e:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f30:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f34:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80006f38:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80006f3c:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80006f3e:	4c f0       	ld.w %d15,[%a15]0
80006f40:	6f 0f ff 7f 	jz.t %d15,0,80006f3e <IfxScuWdt_changeCpuWatchdogReload+0x30>
    {}
}
80006f44:	00 90       	ret 

80006f46 <IfxScuWdt_changeSafetyWatchdogPassword>:
{
    Ifx_SCU_WDTS     *watchdog = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = watchdog->CON0.U;
80006f46:	91 30 00 ff 	movh.a %a15,61443
80006f4a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f4e:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f50:	2e 16       	jz.t %d15,1,80006f5c <IfxScuWdt_changeSafetyWatchdogPassword+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f52:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f56:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        watchdog->CON0.U = wdt_con0.U;
80006f5a:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Password, ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f5c:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f60:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.PW      = newPassword;
80006f64:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14
    watchdog->CON0.U   = wdt_con0.U;
80006f68:	91 30 00 ff 	movh.a %a15,61443
80006f6c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f70:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80006f72:	4c f0       	ld.w %d15,[%a15]0
80006f74:	6f 0f ff 7f 	jz.t %d15,0,80006f72 <IfxScuWdt_changeSafetyWatchdogPassword+0x2c>
    {}
}
80006f78:	00 90       	ret 

80006f7a <IfxScuWdt_changeSafetyWatchdogReload>:
    /* Initialize pointer to Safety Watchdog */
    Ifx_SCU_WDTS     *wdt = &MODULE_SCU.WDTS;

    /* Read Config_0 register */
    Ifx_SCU_WDTS_CON0 wdt_con0;
    wdt_con0.U = wdt->CON0.U;
80006f7a:	91 30 00 ff 	movh.a %a15,61443
80006f7e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006f82:	4c f0       	ld.w %d15,[%a15]0

    if (wdt_con0.B.LCK)
80006f84:	2e 16       	jz.t %d15,1,80006f90 <IfxScuWdt_changeSafetyWatchdogReload+0x16>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80006f86:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
        wdt_con0.B.PW      = password;
80006f8a:	37 4f 0e f1 	insert %d15,%d15,%d4,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80006f8e:	68 0f       	st.w [%a15]0,%d15
    }

    /* Set new Reload value, set ENDINT and LCK bit in Config_0 register */
    wdt_con0.B.ENDINIT = 1;
80006f90:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
    wdt_con0.B.LCK     = 1;
80006f94:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
    wdt_con0.B.REL     = reload;
80006f98:	37 5f 10 f8 	insert %d15,%d15,%d5,16,16
    wdt->CON0.U        = wdt_con0.U;
80006f9c:	91 30 00 ff 	movh.a %a15,61443
80006fa0:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006fa4:	68 0f       	st.w [%a15]0,%d15

    /* read back ENDINIT and wait until it has been set */
    while (wdt->CON0.B.ENDINIT == 0)
80006fa6:	4c f0       	ld.w %d15,[%a15]0
80006fa8:	6f 0f ff 7f 	jz.t %d15,0,80006fa6 <IfxScuWdt_changeSafetyWatchdogReload+0x2c>
    {}
}
80006fac:	00 90       	ret 

80006fae <IfxScuWdt_clearCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80006fae:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80006fb2:	16 07       	and %d15,7


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80006fb4:	53 cf 20 f0 	mul %d15,%d15,12
80006fb8:	06 24       	sh %d4,2
80006fba:	60 f2       	mov.a %a2,%d15
80006fbc:	d9 2f 00 46 	lea %a15,[%a2]24832
80006fc0:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80006fc4:	4c f0       	ld.w %d15,[%a15]0
80006fc6:	2e 16       	jz.t %d15,1,80006fd2 <IfxScuWdt_clearCpuEndinit+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80006fc8:	4c f0       	ld.w %d15,[%a15]0
80006fca:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80006fce:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80006fd0:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80006fd2:	4c f0       	ld.w %d15,[%a15]0
80006fd4:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80006fd8:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80006fda:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80006fdc:	4c f0       	ld.w %d15,[%a15]0
80006fde:	6f 0f ff ff 	jnz.t %d15,0,80006fdc <IfxScuWdt_clearCpuEndinit+0x2e>
}
80006fe2:	00 90       	ret 

80006fe4 <IfxScuWdt_clearSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80006fe4:	91 30 00 ff 	movh.a %a15,61443
80006fe8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80006fec:	4c f0       	ld.w %d15,[%a15]0
80006fee:	06 24       	sh %d4,2
80006ff0:	2e 16       	jz.t %d15,1,80006ffc <IfxScuWdt_clearSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80006ff2:	4c f0       	ld.w %d15,[%a15]0
80006ff4:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80006ff8:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80006ffa:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80006ffc:	91 30 00 ff 	movh.a %a15,61443
80007000:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007004:	4c f0       	ld.w %d15,[%a15]0
80007006:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000700a:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000700c:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000700e:	4c f0       	ld.w %d15,[%a15]0
80007010:	6f 0f ff ff 	jnz.t %d15,0,8000700e <IfxScuWdt_clearSafetyEndinit+0x2a>


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80007014:	00 90       	ret 

80007016 <IfxScuWdt_disableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007016:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000701a:	16 07       	and %d15,7

void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000701c:	53 cf 20 f0 	mul %d15,%d15,12
80007020:	06 24       	sh %d4,2
80007022:	60 f2       	mov.a %a2,%d15
80007024:	d9 2f 00 46 	lea %a15,[%a2]24832
80007028:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000702c:	4c f0       	ld.w %d15,[%a15]0
8000702e:	2e 16       	jz.t %d15,1,8000703a <IfxScuWdt_disableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007030:	4c f0       	ld.w %d15,[%a15]0
80007032:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007036:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007038:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000703a:	4c f0       	ld.w %d15,[%a15]0
8000703c:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007040:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007042:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80007044:	4c f0       	ld.w %d15,[%a15]0
80007046:	6f 0f ff ff 	jnz.t %d15,0,80007044 <IfxScuWdt_disableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
8000704a:	4c f1       	ld.w %d15,[%a15]4
8000704c:	96 08       	or %d15,8
8000704e:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80007050:	4c f0       	ld.w %d15,[%a15]0
80007052:	2e 16       	jz.t %d15,1,8000705e <IfxScuWdt_disableCpuWatchdog+0x48>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007054:	4c f0       	ld.w %d15,[%a15]0
80007056:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000705a:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000705c:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000705e:	4c f0       	ld.w %d15,[%a15]0
80007060:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007064:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007066:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007068:	4c f0       	ld.w %d15,[%a15]0
8000706a:	6f 0f ff 7f 	jz.t %d15,0,80007068 <IfxScuWdt_disableCpuWatchdog+0x52>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000706e:	00 90       	ret 

80007070 <IfxScuWdt_disableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007070:	91 30 00 ff 	movh.a %a15,61443
80007074:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007078:	4c f0       	ld.w %d15,[%a15]0
8000707a:	06 24       	sh %d4,2
8000707c:	2e 16       	jz.t %d15,1,80007088 <IfxScuWdt_disableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000707e:	4c f0       	ld.w %d15,[%a15]0
80007080:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007084:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007086:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007088:	91 30 00 ff 	movh.a %a15,61443
8000708c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007090:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007092:	40 f2       	mov.aa %a2,%a15
80007094:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007098:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000709a:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000709c:	4c 20       	ld.w %d15,[%a2]0
8000709e:	91 30 00 ff 	movh.a %a15,61443
800070a2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070a6:	6f 0f fb ff 	jnz.t %d15,0,8000709c <IfxScuWdt_disableSafetyWatchdog+0x2c>


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
800070aa:	91 30 00 2f 	movh.a %a2,61443
800070ae:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
800070b2:	4c 20       	ld.w %d15,[%a2]0
800070b4:	96 08       	or %d15,8
800070b6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800070b8:	4c f0       	ld.w %d15,[%a15]0
800070ba:	2e 16       	jz.t %d15,1,800070c6 <IfxScuWdt_disableSafetyWatchdog+0x56>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800070bc:	4c f0       	ld.w %d15,[%a15]0
800070be:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800070c2:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800070c4:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800070c6:	91 30 00 ff 	movh.a %a15,61443
800070ca:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800070ce:	4c f0       	ld.w %d15,[%a15]0
800070d0:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800070d4:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800070d6:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800070d8:	4c f0       	ld.w %d15,[%a15]0
800070da:	6f 0f ff 7f 	jz.t %d15,0,800070d8 <IfxScuWdt_disableSafetyWatchdog+0x68>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800070de:	00 90       	ret 

800070e0 <IfxScuWdt_enableCpuWatchdog>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800070e0:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800070e4:	16 07       	and %d15,7

void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800070e6:	53 cf 20 f0 	mul %d15,%d15,12
800070ea:	06 24       	sh %d4,2
800070ec:	60 f2       	mov.a %a2,%d15
800070ee:	d9 2f 00 46 	lea %a15,[%a2]24832
800070f2:	11 3f 00 ff 	addih.a %a15,%a15,61443
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800070f6:	4c f0       	ld.w %d15,[%a15]0
800070f8:	2e 16       	jz.t %d15,1,80007104 <IfxScuWdt_enableCpuWatchdog+0x24>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800070fa:	4c f0       	ld.w %d15,[%a15]0
800070fc:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007100:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007102:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007104:	4c f0       	ld.w %d15,[%a15]0
80007106:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000710a:	a6 4f       	or %d15,%d4
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000710c:	68 0f       	st.w [%a15]0,%d15
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
8000710e:	4c f0       	ld.w %d15,[%a15]0
80007110:	6f 0f ff ff 	jnz.t %d15,0,8000710e <IfxScuWdt_enableCpuWatchdog+0x2e>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
80007114:	4c f1       	ld.w %d15,[%a15]4
80007116:	8f 8f c0 f1 	andn %d15,%d15,8
8000711a:	68 1f       	st.w [%a15]4,%d15
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000711c:	4c f0       	ld.w %d15,[%a15]0
8000711e:	2e 16       	jz.t %d15,1,8000712a <IfxScuWdt_enableCpuWatchdog+0x4a>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007120:	4c f0       	ld.w %d15,[%a15]0
80007122:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007126:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007128:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000712a:	4c f0       	ld.w %d15,[%a15]0
8000712c:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007130:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007132:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007134:	4c f0       	ld.w %d15,[%a15]0
80007136:	6f 0f ff 7f 	jz.t %d15,0,80007134 <IfxScuWdt_enableCpuWatchdog+0x54>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
8000713a:	00 90       	ret 

8000713c <IfxScuWdt_enableSafetyWatchdog>:
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000713c:	91 30 00 ff 	movh.a %a15,61443
80007140:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007144:	4c f0       	ld.w %d15,[%a15]0
80007146:	06 24       	sh %d4,2
80007148:	2e 16       	jz.t %d15,1,80007154 <IfxScuWdt_enableSafetyWatchdog+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000714a:	4c f0       	ld.w %d15,[%a15]0
8000714c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007150:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007152:	68 0f       	st.w [%a15]0,%d15

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007154:	91 30 00 ff 	movh.a %a15,61443
80007158:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000715c:	4c f0       	ld.w %d15,[%a15]0

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000715e:	40 f2       	mov.aa %a2,%a15
80007160:	b7 2f 10 f0 	insert %d15,%d15,2,0,16
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007164:	a6 4f       	or %d15,%d4
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007166:	68 0f       	st.w [%a15]0,%d15
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80007168:	4c 20       	ld.w %d15,[%a2]0
8000716a:	91 30 00 ff 	movh.a %a15,61443
8000716e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007172:	6f 0f fb ff 	jnz.t %d15,0,80007168 <IfxScuWdt_enableSafetyWatchdog+0x2c>


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80007176:	91 30 00 2f 	movh.a %a2,61443
8000717a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x4002e0f4>>
8000717e:	4c 20       	ld.w %d15,[%a2]0
80007180:	8f 8f c0 f1 	andn %d15,%d15,8
80007184:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80007186:	4c f0       	ld.w %d15,[%a15]0
80007188:	2e 16       	jz.t %d15,1,80007194 <IfxScuWdt_enableSafetyWatchdog+0x58>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000718a:	4c f0       	ld.w %d15,[%a15]0
8000718c:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007190:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007192:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007194:	91 30 00 ff 	movh.a %a15,61443
80007198:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000719c:	4c f0       	ld.w %d15,[%a15]0
8000719e:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800071a2:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800071a4:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800071a6:	4c f0       	ld.w %d15,[%a15]0
800071a8:	6f 0f ff 7f 	jz.t %d15,0,800071a6 <IfxScuWdt_enableSafetyWatchdog+0x6a>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800071ac:	00 90       	ret 

800071ae <IfxScuWdt_getCpuWatchdogPassword>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071ae:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800071b2:	16 07       	and %d15,7


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800071b4:	53 cf 20 f0 	mul %d15,%d15,12
800071b8:	60 f2       	mov.a %a2,%d15
800071ba:	d9 2f 00 46 	lea %a15,[%a2]24832
800071be:	11 3f 00 ff 	addih.a %a15,%a15,61443
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800071c2:	48 02       	ld.w %d2,[%a15]0
800071c4:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
800071c8:	8f f2 83 21 	xor %d2,%d2,63
800071cc:	00 90       	ret 

800071ce <IfxScuWdt_getCpuWatchdogEndInit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
800071ce:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800071d2:	16 07       	and %d15,7


boolean IfxScuWdt_getCpuWatchdogEndInit(void)
{
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800071d4:	53 cf 20 f0 	mul %d15,%d15,12
800071d8:	60 f2       	mov.a %a2,%d15
800071da:	d9 2f 00 46 	lea %a15,[%a2]24832
800071de:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE boolean IfxScuWdt_getCpuWatchdogEndInitInline(Ifx_SCU_WDTCPU *watchdog)
{
    return (boolean)watchdog->CON0.B.ENDINIT;
800071e2:	48 02       	ld.w %d2,[%a15]0
}
800071e4:	8f 12 00 21 	and %d2,%d2,1
800071e8:	00 90       	ret 

800071ea <IfxScuWdt_getSafetyWatchdogPassword>:
    Ifx_SCU_WDTS *watchdog = &MODULE_SCU.WDTS;

    /* Read Password from Safety WDT CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800071ea:	91 30 00 ff 	movh.a %a15,61443
800071ee:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800071f2:	48 02       	ld.w %d2,[%a15]0
800071f4:	37 02 6e 21 	extr.u %d2,%d2,2,14


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
800071f8:	8f f2 83 21 	xor %d2,%d2,63
800071fc:	00 90       	ret 

800071fe <IfxScuWdt_initConfig>:


void IfxScuWdt_initConfig(IfxScuWdt_Config *config)
{
    config->password                      = IFXSCUWDT_RESET_PASSWORD;
800071fe:	da 3c       	mov %d15,60
80007200:	ac 40       	st.h [%a4]0,%d15
    config->reload                        = 0xFFFC;
80007202:	82 cf       	mov %d15,-4
80007204:	ac 41       	st.h [%a4]2,%d15
    config->inputFrequency                = IfxScu_WDTCON1_IR_divBy16384;
80007206:	82 0f       	mov %d15,0
80007208:	2c 44       	st.b [%a4]4,%d15
    config->disableWatchdog               = FALSE;
8000720a:	2c 45       	st.b [%a4]5,%d15
    config->enableSmuRestriction          = FALSE;
8000720c:	2c 46       	st.b [%a4]6,%d15
    config->enableAutomaticPasswordChange = FALSE;
8000720e:	2c 47       	st.b [%a4]7,%d15
    config->enableTimerCheck              = FALSE;
80007210:	2c 48       	st.b [%a4]8,%d15
    config->enableTimerCheckTolerance     = FALSE;
80007212:	2c 49       	st.b [%a4]9,%d15
    config->clrInternalResetFlag          = FALSE;
80007214:	2c 4a       	st.b [%a4]10,%d15
80007216:	00 90       	ret 

80007218 <IfxScuWdt_setCpuEndinit>:


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80007218:	4d c0 e1 ff 	mfcr %d15,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000721c:	16 07       	and %d15,7
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000721e:	53 cf 20 f0 	mul %d15,%d15,12
80007222:	06 24       	sh %d4,2
80007224:	60 f2       	mov.a %a2,%d15
80007226:	d9 2f 00 46 	lea %a15,[%a2]24832
8000722a:	11 3f 00 ff 	addih.a %a15,%a15,61443
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000722e:	4c f0       	ld.w %d15,[%a15]0
80007230:	2e 16       	jz.t %d15,1,8000723c <IfxScuWdt_setCpuEndinit+0x24>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80007232:	4c f0       	ld.w %d15,[%a15]0
80007234:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007238:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000723a:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000723c:	4c f0       	ld.w %d15,[%a15]0
8000723e:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80007242:	a6 f4       	or %d4,%d15
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80007244:	68 04       	st.w [%a15]0,%d4
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80007246:	4c f0       	ld.w %d15,[%a15]0
80007248:	6f 0f ff 7f 	jz.t %d15,0,80007246 <IfxScuWdt_setCpuEndinit+0x2e>
}
8000724c:	00 90       	ret 

8000724e <IfxScuWdt_initCpuWatchdog>:
{
    Ifx_SCU_WDTCPU_CON0 wdt_con0;
    Ifx_SCU_WDTCPU_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
8000724e:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007250:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
80007252:	6f 12 0b 00 	jz.t %d2,1,80007268 <IfxScuWdt_initCpuWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
80007256:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000725a:	37 02 6e 31 	extr.u %d3,%d2,2,14
8000725e:	8f f3 83 31 	xor %d3,%d3,63
80007262:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
80007266:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
80007268:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000726a:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
8000726e:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
80007272:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
80007276:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000727a:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
8000727e:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007280:	54 42       	ld.w %d2,[%a4]
80007282:	6f 02 ff ff 	jnz.t %d2,0,80007280 <IfxScuWdt_initCpuWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
80007286:	39 52 04 00 	ld.bu %d2,[%a5]4
8000728a:	df 12 0a 00 	jeq %d2,1,8000729e <IfxScuWdt_initCpuWatchdog+0x50>
8000728e:	76 26       	jz %d2,8000729a <IfxScuWdt_initCpuWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007290:	8b 22 20 22 	ne %d2,%d2,2
80007294:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
80007298:	3c 07       	j 800072a6 <IfxScuWdt_initCpuWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000729a:	82 0f       	mov %d15,0
        break;
8000729c:	3c 05       	j 800072a6 <IfxScuWdt_initCpuWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
8000729e:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
800072a2:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR   = config->disableWatchdog ? 1 : 0;
800072a6:	39 52 05 00 	ld.bu %d2,[%a5]5
800072aa:	8b 02 20 22 	ne %d2,%d2,0
800072ae:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR   = config->enableSmuRestriction ? 1 : 0;
800072b2:	39 52 06 00 	ld.bu %d2,[%a5]6
800072b6:	8b 02 20 22 	ne %d2,%d2,0
800072ba:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR  = config->enableAutomaticPasswordChange ? 1 : 0;
800072be:	39 52 07 00 	ld.bu %d2,[%a5]7
800072c2:	8b 02 20 22 	ne %d2,%d2,0
800072c6:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR  = config->enableTimerCheck ? 1 : 0;
800072ca:	39 52 08 00 	ld.bu %d2,[%a5]8
800072ce:	8b 02 20 22 	ne %d2,%d2,0
800072d2:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR = config->enableTimerCheckTolerance ? 1 : 0;
800072d6:	39 52 09 00 	ld.bu %d2,[%a5]9
800072da:	8b 02 20 22 	ne %d2,%d2,0
800072de:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800072e2:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set CPU ENDINIT protection */
    IfxScuWdt_setCpuEndinit(config->password);
800072e4:	b9 54 00 00 	ld.hu %d4,[%a5]0
800072e8:	1d ff 98 ff 	j 80007218 <IfxScuWdt_setCpuEndinit>

800072ec <IfxScuWdt_serviceCpuWatchdog>:
}


void IfxScuWdt_serviceCpuWatchdog(uint16 password)
{
    IfxScuWdt_setCpuEndinit(password);
800072ec:	1d ff 96 ff 	j 80007218 <IfxScuWdt_setCpuEndinit>

800072f0 <IfxScuWdt_setSafetyEndinit>:
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
800072f0:	91 30 00 ff 	movh.a %a15,61443
800072f4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800072f8:	4c f0       	ld.w %d15,[%a15]0
800072fa:	06 24       	sh %d4,2
800072fc:	2e 16       	jz.t %d15,1,80007308 <IfxScuWdt_setSafetyEndinit+0x18>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800072fe:	4c f0       	ld.w %d15,[%a15]0
80007300:	b7 1f 10 f0 	insert %d15,%d15,1,0,16
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007304:	a6 4f       	or %d15,%d4
IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007306:	68 0f       	st.w [%a15]0,%d15

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80007308:	91 30 00 ff 	movh.a %a15,61443
8000730c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80007310:	4c f0       	ld.w %d15,[%a15]0
80007312:	b7 3f 10 f0 	insert %d15,%d15,3,0,16
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80007316:	a6 f4       	or %d4,%d15
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80007318:	68 04       	st.w [%a15]0,%d4
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000731a:	4c f0       	ld.w %d15,[%a15]0
8000731c:	6f 0f ff 7f 	jz.t %d15,0,8000731a <IfxScuWdt_setSafetyEndinit+0x2a>


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
    IfxScuWdt_setSafetyEndinitInline(password);
}
80007320:	00 90       	ret 

80007322 <IfxScuWdt_initSafetyWatchdog>:
{
    Ifx_SCU_WDTS_CON0 wdt_con0;
    Ifx_SCU_WDTS_CON1 wdt_con1;

    /* Read Config_0 register and clear wdt_con1 variable */
    wdt_con0.U = wdt->CON0.U;
80007322:	54 42       	ld.w %d2,[%a4]
    wdt_con1.U = 0;
80007324:	82 0f       	mov %d15,0

    if (wdt_con0.B.LCK)
80007326:	6f 12 0b 00 	jz.t %d2,1,8000733c <IfxScuWdt_initSafetyWatchdog+0x1a>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wdt_con0.B.ENDINIT = 1;
        wdt_con0.B.LCK     = 0;
8000732a:	b7 12 02 20 	insert %d2,%d2,1,0,2
        wdt_con0.B.PW     ^= 0x003F;
8000732e:	37 02 6e 31 	extr.u %d3,%d2,2,14
80007332:	8f f3 83 31 	xor %d3,%d3,63
80007336:	37 32 0e 21 	insert %d2,%d2,%d3,2,14

        /* Password ready. Store it to WDT_CON0 to unprotect the register */
        wdt->CON0.U = wdt_con0.U;
8000733a:	74 42       	st.w [%a4],%d2
    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
    wdt_con0.B.LCK     = 1;
    wdt_con0.B.PW      = config->password; //user defined password
8000733c:	94 53       	ld.h %d3,[%a5]
    }

    /* Initialize CON0 register, with modify access, with user defined parameters
     * Clear ENDINT bit to unprotect CON1 register for initialization
     * see Table 3 (Modify Access Bit Pattern Requirements) */
    wdt_con0.B.ENDINIT = 0;
8000733e:	8f 12 c0 21 	andn %d2,%d2,1
    wdt_con0.B.LCK     = 1;
80007342:	b7 12 81 20 	insert %d2,%d2,1,1,1
    wdt_con0.B.PW      = config->password; //user defined password
80007346:	37 32 0e 21 	insert %d2,%d2,%d3,2,14
    wdt_con0.B.REL     = config->reload;   //user defined reload value
8000734a:	b9 53 02 00 	ld.hu %d3,[%a5]2
8000734e:	37 32 10 28 	insert %d2,%d2,%d3,16,16

    /* Modify access ready - write WDT_CON0 register */
    wdt->CON0.U = wdt_con0.U;
80007352:	74 42       	st.w [%a4],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (wdt->CON0.B.ENDINIT == 1)
80007354:	54 42       	ld.w %d2,[%a4]
80007356:	6f 02 ff ff 	jnz.t %d2,0,80007354 <IfxScuWdt_initSafetyWatchdog+0x32>
    {}

    /* Initialize CON1 register */
    switch (config->inputFrequency)
8000735a:	39 52 04 00 	ld.bu %d2,[%a5]4
8000735e:	df 12 0a 00 	jeq %d2,1,80007372 <IfxScuWdt_initSafetyWatchdog+0x50>
80007362:	76 26       	jz %d2,8000736e <IfxScuWdt_initSafetyWatchdog+0x4c>
        wdt_con1.B.IR0 = 1;
        wdt_con1.B.IR1 = 0;
        break;
    case IfxScu_WDTCON1_IR_divBy64:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
80007364:	8b 22 20 22 	ne %d2,%d2,2
80007368:	ab 0f 82 f2 	sel %d15,%d2,%d15,32
8000736c:	3c 07       	j 8000737a <IfxScuWdt_initSafetyWatchdog+0x58>
    /* Initialize CON1 register */
    switch (config->inputFrequency)
    {
    case IfxScu_WDTCON1_IR_divBy16384:
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 0;
8000736e:	82 0f       	mov %d15,0
        break;
80007370:	3c 05       	j 8000737a <IfxScuWdt_initSafetyWatchdog+0x58>
    case IfxScu_WDTCON1_IR_divBy256:
        wdt_con1.B.IR0 = 1;
80007372:	b7 1f 01 f1 	insert %d15,%d15,1,2,1
        wdt_con1.B.IR1 = 0;
80007376:	8f 0f c2 f1 	andn %d15,%d15,32
        wdt_con1.B.IR0 = 0;
        wdt_con1.B.IR1 = 1;
        break;
    }

    wdt_con1.B.DR     = config->disableWatchdog ? 1 : 0;
8000737a:	39 52 05 00 	ld.bu %d2,[%a5]5
8000737e:	8b 02 20 22 	ne %d2,%d2,0
80007382:	67 2f 03 f0 	ins.t %d15,%d15,3,%d2,0
    wdt_con1.B.UR     = config->enableSmuRestriction ? 1 : 0;
80007386:	39 52 06 00 	ld.bu %d2,[%a5]6
8000738a:	8b 02 20 22 	ne %d2,%d2,0
8000738e:	67 2f 06 f0 	ins.t %d15,%d15,6,%d2,0
    wdt_con1.B.PAR    = config->enableAutomaticPasswordChange ? 1 : 0;
80007392:	39 52 07 00 	ld.bu %d2,[%a5]7
80007396:	8b 02 20 22 	ne %d2,%d2,0
8000739a:	67 2f 07 f0 	ins.t %d15,%d15,7,%d2,0
    wdt_con1.B.TCR    = config->enableTimerCheck ? 1 : 0;
8000739e:	39 52 08 00 	ld.bu %d2,[%a5]8
800073a2:	8b 02 20 22 	ne %d2,%d2,0
800073a6:	67 2f 08 f0 	ins.t %d15,%d15,8,%d2,0
    wdt_con1.B.TCTR   = config->enableTimerCheckTolerance ? 1 : 0;
800073aa:	39 52 09 00 	ld.bu %d2,[%a5]9
800073ae:	8b 02 20 22 	ne %d2,%d2,0
800073b2:	37 2f 87 f4 	insert %d15,%d15,%d2,9,7
    wdt_con1.B.CLRIRF = config->clrInternalResetFlag ? 0 : 1;
800073b6:	39 52 0a 00 	ld.bu %d2,[%a5]10
800073ba:	8b 02 00 22 	eq %d2,%d2,0
800073be:	67 2f 00 f0 	ins.t %d15,%d15,0,%d2,0

    /* Finally write CON1 with user defined configuration */
    wdt->CON1.U = wdt_con1.U;
800073c2:	6c 41       	st.w [%a4]4,%d15

    /* Initialization finished - set Safety ENDINIT protection */
    IfxScuWdt_setSafetyEndinit(config->password);
800073c4:	b9 54 00 00 	ld.hu %d4,[%a5]0
800073c8:	1d ff 94 ff 	j 800072f0 <IfxScuWdt_setSafetyEndinit>

800073cc <IfxScuWdt_serviceSafetyWatchdog>:
}


void IfxScuWdt_serviceSafetyWatchdog(uint16 password)
{
    IfxScuWdt_setSafetyEndinit(password);
800073cc:	1d ff 92 ff 	j 800072f0 <IfxScuWdt_setSafetyEndinit>

800073d0 <IfxScuWdt_enableWatchdogWithDebugger>:
    volatile uint32 *oecPtr    = (volatile uint32 *)0xF0000478;
    volatile uint32 *ostatePtr = (volatile uint32 *)0xF0000480;
    volatile uint32 *ocntrlPtr = (volatile uint32 *)0xF000047C;

    /* read OSTATE.OEN */
    ostateValue = *ostatePtr;
800073d0:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
    oenEnabled  = (ostateValue & 0x00000001);

    if (!oenEnabled)
800073d4:	2e 07       	jz.t %d15,0,800073e2 <IfxScuWdt_enableWatchdogWithDebugger+0x12>
    }

    if (oenEnabled)
    {
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
800073d6:	3b 00 00 f3 	mov %d15,12288
800073da:	a5 ff 7c 10 	st.w f000047c <_SMALL_DATA4_+0x3fff847c>,%d15
}


boolean IfxScuWdt_enableWatchdogWithDebugger(void)
{
    boolean          status = 0, oenEnabled = 0, watchdogEnabled = 0;
800073de:	82 0f       	mov %d15,0
800073e0:	3c 11       	j 80007402 <IfxScuWdt_enableWatchdogWithDebugger+0x32>

    if (!oenEnabled)
    {
        /* enable the debug interface (OSTATE.OEN )if it is not already enabled */
        /* pattern for enabling OSTATE.OEN */
        *oecPtr = 0xA1;
800073e2:	3b 10 0a 20 	mov %d2,161
800073e6:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800073ea:	da 5e       	mov %d15,94
800073ec:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15
        *oecPtr = 0xA1;
800073f0:	a5 f2 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d2
        *oecPtr = 0x5E;
800073f4:	a5 ff 78 10 	st.w f0000478 <_SMALL_DATA4_+0x3fff8478>,%d15

        /* read OSTATE.OEN again*/
        ostateValue = *ostatePtr;
800073f8:	85 ff 40 20 	ld.w %d15,f0000480 <_SMALL_DATA4_+0x3fff8480>
        oenEnabled  = (ostateValue & 0x00000001);
    }

    if (oenEnabled)
800073fc:	6f 0f ed ff 	jnz.t %d15,0,800073d6 <IfxScuWdt_enableWatchdogWithDebugger+0x6>
        /* set watchdog suspend bit in OSTATE reg, by writing OCNTRL.WDTSUS and OCNTRL.WDTSUS_P together */
        *ocntrlPtr = 0x00003000;
    }
    else
    {
        status = 1;
80007400:	82 1f       	mov %d15,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, oenEnabled == 1);

    /* read OSTATE.WDTSUS */
    ostateValue     = *ostatePtr;
80007402:	85 f2 40 20 	ld.w %d2,f0000480 <_SMALL_DATA4_+0x3fff8480>
    watchdogEnabled = (ostateValue & 0x00000080);

    if (!watchdogEnabled)
80007406:	37 02 e1 23 	extr.u %d2,%d2,7,1
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, watchdogEnabled == 1);

    return status;
}
8000740a:	ab 1f 80 22 	sel %d2,%d2,%d15,1
8000740e:	00 90       	ret 

80007410 <IfxVadc_Adc_deInitGroup>:
    Ifx_VADC_G     *vadcG      = IfxVadc_Adc_getGroupRegsFromGroup(group);
    /* Get group index */
    IfxVadc_GroupId groupIndex = group->groupId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007410:	0c 48       	ld.bu %d15,[%a4]8
80007412:	d4 4c       	ld.a %a12,[%a4]
80007414:	1b 0f 01 f0 	addi %d15,%d15,16
80007418:	16 ff       	and %d15,255
8000741a:	99 4d 04 00 	ld.a %a13,[%a4]4
8000741e:	02 f4       	mov %d4,%d15
80007420:	40 c4       	mov.aa %a4,%a12
80007422:	6d ff 91 e8 	call 80004544 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_resetGroup(Ifx_VADC_G *vadcG)
{
    vadcG->ARBCFG.B.ANONC = IfxVadc_AnalogConverterMode_off;   /* turn off group */
80007426:	54 d2       	ld.w %d2,[%a13]
    IfxVadc_resetGroup(vadcG);
    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007428:	40 c4       	mov.aa %a4,%a12
8000742a:	8f 32 c0 21 	andn %d2,%d2,3
8000742e:	74 d2       	st.w [%a13],%d2
80007430:	02 f4       	mov %d4,%d15
80007432:	1d ff 6d e8 	j 8000450c <IfxVadc_disableAccess>

80007436 <IfxVadc_Adc_disableModule>:
}


void IfxVadc_Adc_disableModule(Ifx_VADC *vadc)
{
80007436:	40 4f       	mov.aa %a15,%a4
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007438:	6d ff bb fe 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>
    IfxScuWdt_clearCpuEndinit(passwd);
8000743c:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
8000743e:	02 2f       	mov %d15,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
80007440:	6d ff b7 fd 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.B.DISR = 1;
80007444:	48 02       	ld.w %d2,[%a15]0
    IfxScuWdt_setCpuEndinit(passwd);
80007446:	02 f4       	mov %d4,%d15

IFX_INLINE void IfxVadc_disableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    vadc->CLC.B.DISR = 1;
80007448:	8f 12 40 21 	or %d2,%d2,1
8000744c:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
8000744e:	1d ff e5 fe 	j 80007218 <IfxScuWdt_setCpuEndinit>

80007452 <IfxVadc_Adc_getChannelConfig>:
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
80007452:	99 42 04 00 	ld.a %a2,[%a4]4
80007456:	99 2d 04 00 	ld.a %a13,[%a2]4
    IfxVadc_ChannelId channelIndex = channel->channel;
8000745a:	79 42 00 00 	ld.b %d2,[%a4]0

    config->channelId = channel->channel;
    config->group     = channel->group;
8000745e:	b5 52 14 00 	st.a [%a5]20,%a2


IFX_INLINE Ifx_VADC_CHCTR IfxVadc_getChannelControlConfig(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U = vadcG->CHCTR[channelIndex].U;
80007462:	1b 02 06 f0 	addi %d15,%d2,96
80007466:	90 d2       	addsc.a %a2,%a13,%d15,2
void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
    Ifx_VADC_G       *vadcG        = IfxVadc_Adc_getGroupRegsFromGroup(channel->group);
    IfxVadc_ChannelId channelIndex = channel->channel;

    config->channelId = channel->channel;
80007468:	e9 52 0c 00 	st.b [%a5]12,%d2
8000746c:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
8000746e:	40 4c       	mov.aa %a12,%a4

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007470:	37 0f 62 30 	extr.u %d3,%d15,0,2
    IfxVadc_disableModule(vadc);
}


void IfxVadc_Adc_getChannelConfig(IfxVadc_Adc_Channel *channel, IfxVadc_Adc_ChannelConfig *config)
{
80007474:	40 5f       	mov.aa %a15,%a5

    Ifx_VADC_CHCTR tempChctr;
    tempChctr.U                 = 0;
    tempChctr                   = IfxVadc_getChannelControlConfig(vadcG, channelIndex);

    config->inputClass          = (IfxVadc_InputClasses)tempChctr.B.ICLSEL;
80007476:	e9 53 0d 00 	st.b [%a5]13,%d3
    config->reference           = (IfxVadc_ChannelReference)tempChctr.B.REFSEL;
8000747a:	37 0f e1 35 	extr.u %d3,%d15,11,1
8000747e:	e9 53 0e 00 	st.b [%a5]14,%d3
    config->resultRegister      = (IfxVadc_ChannelResult)tempChctr.B.RESREG;
80007482:	37 0f 64 38 	extr.u %d3,%d15,16,4
80007486:	e9 53 0f 00 	st.b [%a5]15,%d3
    config->globalResultUsage   = tempChctr.B.RESTBS;
8000748a:	37 0f 61 3a 	extr.u %d3,%d15,20,1
8000748e:	34 53       	st.b [%a5],%d3
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
80007490:	37 0f 62 32 	extr.u %d3,%d15,4,2
80007494:	e9 53 10 00 	st.b [%a5]16,%d3
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
80007498:	37 0f 62 33 	extr.u %d3,%d15,6,2
8000749c:	e9 53 11 00 	st.b [%a5]17,%d3
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
800074a0:	37 0f 64 36 	extr.u %d3,%d15,12,4
800074a4:	e9 53 12 00 	st.b [%a5]18,%d3
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
800074a8:	37 0f 62 34 	extr.u %d3,%d15,8,2
800074ac:	e9 53 13 00 	st.b [%a5]19,%d3
    config->synchonize          = tempChctr.B.SYNC;
800074b0:	37 0f 61 35 	extr.u %d3,%d15,10,1
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800074b4:	37 0f e1 fa 	extr.u %d15,%d15,21,1
    config->globalResultUsage   = tempChctr.B.RESTBS;
    config->lowerBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELL;
    config->upperBoundary       = (IfxVadc_BoundarySelection)tempChctr.B.BNDSELU;
    config->boundaryMode        = (IfxVadc_BoundaryExtension)tempChctr.B.BNDSELX;
    config->limitCheck          = (IfxVadc_LimitCheck)tempChctr.B.CHEVMODE;
    config->synchonize          = tempChctr.B.SYNC;
800074b8:	e9 53 01 00 	st.b [%a5]1,%d3
    config->rightAlignedStorage = tempChctr.B.RESPOS;
800074bc:	2c 53       	st.b [%a5]3,%d15


IFX_INLINE Ifx_VADC_G_CHASS IfxVadc_getAssignedChannels(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CHASS assignChannels;
    assignChannels.U = vadcG->CHASS.U;
800074be:	4c d2       	ld.w %d15,[%a13]8

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
800074c0:	57 0f 61 22 	extr.u %d2,%d15,%d2,1
800074c4:	8f 12 80 21 	xor %d2,%d2,1
800074c8:	e9 52 02 00 	st.b [%a5]2,%d2
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800074cc:	99 42 04 00 	ld.a %a2,[%a4]4
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
800074d0:	79 4f 00 00 	ld.b %d15,[%a4]0


IFX_INLINE Ifx_VADC_G_CEVNP0 IfxVadc_getChannelServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = vadcG->CEVNP0.U;
800074d4:	19 d2 20 40 	ld.w %d2,[%a13]288
800074d8:	06 2f       	sh %d15,2
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800074da:	57 02 64 ff 	extr.u %d15,%d2,%d15,4
    config->rightAlignedStorage = tempChctr.B.RESPOS;

    config->backgroundChannel   = ((IfxVadc_getAssignedChannels(vadcG)).U & (1 << channelIndex)) ? FALSE : TRUE;
    uint32                 channelServiceRequestNodePtr;
    /* Get Channel index */
    IfxVadc_GroupId        groupIndex = channel->group->groupId;
800074de:	39 28 08 00 	ld.bu %d8,[%a2]8
    channelServiceRequestNodePtr = ((IfxVadc_getChannelServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
    volatile Ifx_SRC_SRCR *src        = IfxVadc_getSrcAddress(groupIndex, (IfxVadc_SrcNr)channelServiceRequestNodePtr);
800074e2:	0b 8f 10 48 	mov %e4,%d15,%d8
800074e6:	6d ff 60 e9 	call 800047a6 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
800074ea:	54 22       	ld.w %d2,[%a2]
800074ec:	6f a2 0a 00 	jz.t %d2,10,80007500 <IfxVadc_Adc_getChannelConfig+0xae>
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)channelServiceRequestNodePtr;
800074f0:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)src->B.SRPN;
800074f2:	4c 20       	ld.w %d15,[%a2]0
800074f4:	16 ff       	and %d15,255
800074f6:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)src->B.TOS;
800074f8:	4c 20       	ld.w %d15,[%a2]0
800074fa:	37 0f e2 f5 	extr.u %d15,%d15,11,2
800074fe:	3c 05       	j 80007508 <IfxVadc_Adc_getChannelConfig+0xb6>
    }
    else
    {
        config->channelSrcNr        = (IfxVadc_SrcNr)0;
80007500:	82 0f       	mov %d15,0
80007502:	28 bf       	st.b [%a15]11,%d15
        config->channelPriority     = (Ifx_Priority)0;
80007504:	82 0f       	mov %d15,0
80007506:	a8 3f       	st.h [%a15]6,%d15
        config->channelServProvider = (IfxSrc_Tos)0;
80007508:	28 9f       	st.b [%a15]9,%d15
    }

    uint32 resultServiceRequestNodePtr;

    if (config->resultRegister < IfxVadc_ChannelResult_8)
8000750a:	0c ff       	ld.bu %d15,[%a15]15
8000750c:	79 c2 00 00 	ld.b %d2,[%a12]0
80007510:	ff 8f 08 80 	jge.u %d15,8,80007520 <IfxVadc_Adc_getChannelConfig+0xce>


IFX_INLINE Ifx_VADC_G_REVNP0 IfxVadc_getChannelResultServiceRequestNodePointer0(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = vadcG->REVNP0.U;
80007514:	19 df 30 40 	ld.w %d15,[%a13]304
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer0(vadcG)).U >> (channel->channel * 4)) & 0xF;
80007518:	06 22       	sh %d2,2
8000751a:	57 0f 64 f2 	extr.u %d15,%d15,%d2,4
8000751e:	3c 08       	j 8000752e <IfxVadc_Adc_getChannelConfig+0xdc>
    }
    else
    {
        resultServiceRequestNodePtr = ((IfxVadc_getChannelResultServiceRequestNodePointer1(vadcG)).U >> ((channel->channel - IfxVadc_ChannelResult_8) * 4)) & 0xF;
80007520:	9a 82       	add %d15,%d2,-8


IFX_INLINE Ifx_VADC_G_REVNP1 IfxVadc_getChannelResultServiceRequestNodePointer1(Ifx_VADC_G *vadcG)
{
    Ifx_VADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = vadcG->REVNP1.U;
80007522:	19 d3 34 40 	ld.w %d3,[%a13]308
80007526:	8f 2f 00 20 	sh %d2,%d15,2
8000752a:	57 03 64 f2 	extr.u %d15,%d3,%d2,4
    }

    src = IfxVadc_getSrcAddress(groupIndex, resultServiceRequestNodePtr);
8000752e:	16 ff       	and %d15,255
80007530:	0b 8f 10 48 	mov %e4,%d15,%d8
80007534:	6d ff 39 e9 	call 800047a6 <IfxVadc_getSrcAddress>

    if (src->B.SRE == 1)
80007538:	54 22       	ld.w %d2,[%a2]
8000753a:	6f a2 0a 00 	jz.t %d2,10,8000754e <IfxVadc_Adc_getChannelConfig+0xfc>
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)resultServiceRequestNodePtr;
8000753e:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)src->B.SRPN;
80007540:	4c 20       	ld.w %d15,[%a2]0
80007542:	16 ff       	and %d15,255
80007544:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)src->B.TOS;
80007546:	4c 20       	ld.w %d15,[%a2]0
80007548:	37 0f e2 f5 	extr.u %d15,%d15,11,2
8000754c:	3c 05       	j 80007556 <IfxVadc_Adc_getChannelConfig+0x104>
    }
    else
    {
        config->resultSrcNr        = (IfxVadc_SrcNr)0;
8000754e:	82 0f       	mov %d15,0
80007550:	28 af       	st.b [%a15]10,%d15
        config->resultPriority     = (Ifx_Priority)0;
80007552:	82 0f       	mov %d15,0
80007554:	a8 2f       	st.h [%a15]4,%d15
        config->resultServProvider = (IfxSrc_Tos)0;
80007556:	28 8f       	st.b [%a15]8,%d15
80007558:	00 90       	ret 

8000755a <IfxVadc_Adc_getChannelConversionTime>:
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
8000755a:	cc 41       	ld.a %a15,[%a4]4
8000755c:	c8 12       	ld.a %a2,[%a15]4
}


IFX_INLINE IfxVadc_InputClasses IfxVadc_getChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    return (IfxVadc_InputClasses)vadcG->CHCTR[channelIndex].B.ICLSEL;
8000755e:	79 4f 00 00 	ld.b %d15,[%a4]0
80007562:	08 8a       	ld.bu %d10,[%a15]8
80007564:	c8 0f       	ld.a %a15,[%a15]0
80007566:	1b 0f 06 f0 	addi %d15,%d15,96
8000756a:	90 22       	addsc.a %a2,%a2,%d15,2
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
8000756c:	20 08       	sub.a %sp,8
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
8000756e:	40 f4       	mov.aa %a4,%a15
    }
}


float32 IfxVadc_Adc_getChannelConversionTime(IfxVadc_Adc_Channel *channel, IfxVadc_ConversionType conversionMode)
{
80007570:	02 49       	mov %d9,%d4
80007572:	54 28       	ld.w %d8,[%a2]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
80007574:	6d ff 9a e8 	call 800046a8 <IfxVadc_getAdcAnalogFrequency>
80007578:	02 2f       	mov %d15,%d2
8000757a:	6d ff b0 e8 	call 800046da <IfxVadc_getAdcModuleFrequency>
8000757e:	8f 38 00 81 	and %d8,%d8,3
80007582:	74 a9       	st.w [%sp],%d9
80007584:	40 f4       	mov.aa %a4,%a15
80007586:	0b a8 10 48 	mov %e4,%d8,%d10
8000758a:	0b f2 10 68 	mov %e6,%d2,%d15
}
8000758e:	1d ff c1 e9 	j 80004910 <IfxVadc_getChannelConversionTime>

80007592 <IfxVadc_Adc_getGroupConfig>:

void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
80007592:	d4 4d       	ld.a %a13,[%a4]
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
80007594:	40 4e       	mov.aa %a14,%a4
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
80007596:	99 4c 04 00 	ld.a %a12,[%a4]4
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
8000759a:	40 d4       	mov.aa %a4,%a13
    return IfxVadc_getChannelConversionTime(channel->group->module.vadc, channel->group->groupId, IfxVadc_getChannelInputClass(channel->group->group, channel->channel), IfxVadc_getAdcAnalogFrequency(channel->group->module.vadc), IfxVadc_getAdcModuleFrequency(), conversionMode);
}


void IfxVadc_Adc_getGroupConfig(IfxVadc_Adc_Group *group, IfxVadc_Adc_GroupConfig *config)
{
8000759c:	40 5f       	mov.aa %a15,%a5
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
8000759e:	6d ff 85 e8 	call 800046a8 <IfxVadc_getAdcAnalogFrequency>

    config->groupId                    = group->groupId;
800075a2:	0c e8       	ld.bu %d15,[%a14]8
    config->module                     = &group->module;
800075a4:	e8 0e       	st.a [%a15]0,%a14
    uint8       inputClassNum;
    Ifx_VADC_G *vadcG           = group->group;
    Ifx_VADC   *vadc            = group->module.vadc;
    float32     analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);

    config->groupId                    = group->groupId;
800075a6:	28 4f       	st.b [%a15]4,%d15
}


IFX_INLINE IfxVadc_ArbitrationRounds IfxVadc_getArbiterRoundLength(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_ArbitrationRounds)vadcG->ARBCFG.B.ARBRND;
800075a8:	4c c0       	ld.w %d15,[%a12]0
800075aa:	37 0f 62 f2 	extr.u %d15,%d15,4,2
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);
800075ae:	e9 ff 32 00 	st.b [%a15]50,%d15
800075b2:	82 0f       	mov %d15,0
}


IFX_INLINE IfxVadc_ChannelResolution IfxVadc_getGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum)
{
    return (IfxVadc_ChannelResolution)vadcG->ICLASS[inputClassNum].B.CMS;
800075b4:	1b 8f 00 30 	addi %d3,%d15,8
800075b8:	01 c3 02 26 	addsc.a %a2,%a12,%d3,2

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
800075bc:	d0 f3       	addsc.a %a3,%a15,%d15,3
800075be:	54 23       	ld.w %d3,[%a2]
800075c0:	37 03 63 34 	extr.u %d3,%d3,8,3
800075c4:	e9 33 0c 00 	st.b [%a3]12,%d3
}


IFX_INLINE float32 IfxVadc_getGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = vadcG->ICLASS[inputClassNum].B.STCS;
800075c8:	54 23       	ld.w %d3,[%a2]
800075ca:	8f f3 01 31 	and %d3,%d3,31

    if (sampleTime > 16)
800075ce:	8b 13 61 42 	lt.u %d4,%d3,17
800075d2:	f6 44       	jnz %d4,800075da <IfxVadc_Adc_getGroupConfig+0x48>
    {
        sampleTime = (sampleTime - 15) * 16;
800075d4:	1b 13 ff 3f 	addi %d3,%d3,-15
800075d8:	06 43       	sh %d3,4
    }

    return (float32)(IFXVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
800075da:	c2 23       	add %d3,2
800075dc:	4b 03 41 31 	itof %d3,%d3
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
800075e0:	92 14       	add %d4,%d15,1
800075e2:	4b 23 51 30 	div.f %d3,%d3,%d2
800075e6:	01 f4 03 26 	addsc.a %a2,%a15,%d4,3
800075ea:	74 23       	st.w [%a2],%d3
    config->groupId                    = group->groupId;
    config->module                     = &group->module;

    config->arbiter.arbiterRoundLength = IfxVadc_getArbiterRoundLength(vadcG);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
800075ec:	1e 13       	jeq %d15,1,800075f2 <IfxVadc_Adc_getGroupConfig+0x60>
800075ee:	82 1f       	mov %d15,1
800075f0:	3c e2       	j 800075b4 <IfxVadc_Adc_getGroupConfig+0x22>
}


IFX_INLINE boolean IfxVadc_isRequestScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN1;
800075f2:	19 c2 04 00 	ld.w %d2,[%a12]4
    {
        config->inputClass[inputClassNum].resolution = IfxVadc_getGroupResolution(vadcG, inputClassNum);
        config->inputClass[inputClassNum].sampleTime = IfxVadc_getGroupSampleTime(vadcG, inputClassNum, analogFrequency);
    }

    if (IfxVadc_isRequestScanSlotEnabled(vadcG) == TRUE)
800075f6:	ef 92 33 00 	jz.t %d2,25,8000765c <IfxVadc_Adc_getGroupConfig+0xca>
    {
        config->arbiter.requestSlotScanEnabled          = TRUE;
800075fa:	e9 ff 34 00 	st.b [%a15]52,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO1;
800075fe:	19 c2 04 00 	ld.w %d2,[%a12]4
80007602:	37 02 62 22 	extr.u %d2,%d2,4,2
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
80007606:	e9 f2 1e 00 	st.b [%a15]30,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM1;
8000760a:	19 c2 04 00 	ld.w %d2,[%a12]4
8000760e:	37 02 e1 23 	extr.u %d2,%d2,7,1
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);
80007612:	e9 f2 1f 00 	st.b [%a15]31,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getScanSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->ASCTRL.B.XTSEL;
80007616:	19 c3 20 20 	ld.w %d3,[%a12]160
8000761a:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
8000761e:	e9 f3 1b 00 	st.b [%a15]27,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getScanSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->ASCTRL.B.XTMODE;
80007622:	19 c2 20 20 	ld.w %d2,[%a12]160
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007626:	8b f3 00 32 	eq %d3,%d3,15
8000762a:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotScanEnabled          = TRUE;
        config->scanRequest.requestSlotPrio             = IfxVadc_getScanSlotPriority(vadcG);
        config->scanRequest.requestSlotStartMode        = IfxVadc_getScanSlotStartMode(vadcG);

        config->scanRequest.triggerConfig.triggerSource = IfxVadc_getScanSlotTriggerInput(vadcG);
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_getScanSlotTriggerMode(vadcG);
8000762e:	e9 f2 1d 00 	st.b [%a15]29,%d2

        if (config->scanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007632:	f6 35       	jnz %d3,8000763c <IfxVadc_Adc_getGroupConfig+0xaa>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getScanSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->ASMR.B.ENGT;
80007634:	19 cf 24 20 	ld.w %d15,[%a12]164
80007638:	16 03       	and %d15,3
8000763a:	3c 02       	j 8000763e <IfxVadc_Adc_getGroupConfig+0xac>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_getScanSlotGatingMode(vadcG);
        }
        else if (config->scanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
8000763c:	76 23       	jz %d2,80007642 <IfxVadc_Adc_getGroupConfig+0xb0>
        {
            config->scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
8000763e:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getScanSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->ASCTRL.B.GTSEL;
80007642:	19 cf 20 20 	ld.w %d15,[%a12]160
80007646:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->scanRequest.triggerConfig.gatingSource = IfxVadc_getScanSlotGatingSource(vadcG);
8000764a:	e9 ff 1a 00 	st.b [%a15]26,%d15
}


IFX_INLINE boolean IfxVadc_isAutoScanEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ASMR.B.SCAN;
8000764e:	19 cf 24 20 	ld.w %d15,[%a12]164
80007652:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->scanRequest.autoscanEnabled            = IfxVadc_isAutoScanEnabled(vadcG);
80007656:	e9 ff 18 00 	st.b [%a15]24,%d15
8000765a:	3c 0c       	j 80007672 <IfxVadc_Adc_getGroupConfig+0xe0>
    }
    else
    {
        config->scanRequest.autoscanEnabled             = FALSE;
8000765c:	82 0f       	mov %d15,0
8000765e:	e9 ff 18 00 	st.b [%a15]24,%d15
        config->scanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
80007662:	e9 ff 1c 00 	st.b [%a15]28,%d15
        config->scanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;    /* Use CCU6061 TRIG0 */
80007666:	e9 ff 1a 00 	st.b [%a15]26,%d15
        config->scanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
8000766a:	e9 ff 1d 00 	st.b [%a15]29,%d15
        config->scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;   /* Trigger source taken from Gating Input */
8000766e:	e9 ff 1b 00 	st.b [%a15]27,%d15
}


IFX_INLINE boolean IfxVadc_isRequestQueueSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN0;
80007672:	4c c1       	ld.w %d15,[%a12]4
80007674:	37 0f 61 fc 	extr.u %d15,%d15,24,1
    }

    if (IfxVadc_isRequestQueueSlotEnabled(vadcG) == TRUE)
80007678:	df 1f 30 80 	jne %d15,1,800076d8 <IfxVadc_Adc_getGroupConfig+0x146>
    {
        config->arbiter.requestSlotQueueEnabled          = TRUE;
8000767c:	e9 ff 33 00 	st.b [%a15]51,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getQueueSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO0;
80007680:	19 c2 04 00 	ld.w %d2,[%a12]4
80007684:	8f 32 00 21 	and %d2,%d2,3
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
80007688:	e9 f2 26 00 	st.b [%a15]38,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getQueueSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM0;
8000768c:	19 c2 04 00 	ld.w %d2,[%a12]4
80007690:	37 02 e1 21 	extr.u %d2,%d2,3,1
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);
80007694:	e9 f2 27 00 	st.b [%a15]39,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getQueueSlotTriggerInput(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerSource)vadcG->QCTRL0.B.XTSEL;
80007698:	19 c3 00 20 	ld.w %d3,[%a12]128
8000769c:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
800076a0:	e9 f3 23 00 	st.b [%a15]35,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getQueueSlotTriggerMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_TriggerMode)vadcG->QCTRL0.B.XTMODE;
800076a4:	19 c2 00 20 	ld.w %d2,[%a12]128
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800076a8:	8b f3 00 32 	eq %d3,%d3,15
800076ac:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotQueueEnabled          = TRUE;
        config->queueRequest.requestSlotPrio             = IfxVadc_getQueueSlotPriority(vadcG);
        config->queueRequest.requestSlotStartMode        = IfxVadc_getQueueSlotStartMode(vadcG);

        config->queueRequest.triggerConfig.triggerSource = IfxVadc_getQueueSlotTriggerInput(vadcG);
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_getQueueSlotTriggerMode(vadcG);
800076b0:	e9 f2 25 00 	st.b [%a15]37,%d2

        if (config->queueRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
800076b4:	f6 35       	jnz %d3,800076be <IfxVadc_Adc_getGroupConfig+0x12c>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getQueueSlotGatingMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingMode)vadcG->QMR0.B.ENGT;
800076b6:	19 cf 04 20 	ld.w %d15,[%a12]132
800076ba:	16 03       	and %d15,3
800076bc:	3c 02       	j 800076c0 <IfxVadc_Adc_getGroupConfig+0x12e>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_getQueueSlotGatingMode(vadcG);
        }
        else if (config->queueRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800076be:	76 23       	jz %d2,800076c4 <IfxVadc_Adc_getGroupConfig+0x132>
        {
            config->queueRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
800076c0:	e9 ff 24 00 	st.b [%a15]36,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getQueueSlotGatingSource(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_GatingSource)vadcG->QCTRL0.B.GTSEL;
800076c4:	19 cf 00 20 	ld.w %d15,[%a12]128
800076c8:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->queueRequest.triggerConfig.gatingSource = IfxVadc_getQueueSlotGatingSource(vadcG);
800076cc:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.flushQueueAfterInit        = FALSE;
800076d0:	82 0f       	mov %d15,0
800076d2:	e9 ff 20 00 	st.b [%a15]32,%d15
800076d6:	3c 0c       	j 800076ee <IfxVadc_Adc_getGroupConfig+0x15c>
    }
    else
    {
        config->queueRequest.flushQueueAfterInit         = FALSE;
800076d8:	82 0f       	mov %d15,0
800076da:	e9 ff 20 00 	st.b [%a15]32,%d15
        config->queueRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
800076de:	e9 ff 24 00 	st.b [%a15]36,%d15
        config->queueRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;        /* Use CCU6061 TRIG0 */
800076e2:	e9 ff 22 00 	st.b [%a15]34,%d15
        config->queueRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
800076e6:	e9 ff 25 00 	st.b [%a15]37,%d15
        config->queueRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;       /* Trigger source taken from Gating Input */
800076ea:	e9 ff 23 00 	st.b [%a15]35,%d15
}


IFX_INLINE boolean IfxVadc_isRequestBackgroundScanSlotEnabled(Ifx_VADC_G *vadcG)
{
    return (boolean)vadcG->ARBPR.B.ASEN2;
800076ee:	4c c1       	ld.w %d15,[%a12]4
800076f0:	37 0f 61 fd 	extr.u %d15,%d15,26,1
    }

    if (IfxVadc_isRequestBackgroundScanSlotEnabled(vadcG) == TRUE)
800076f4:	df 1f 33 80 	jne %d15,1,8000775a <IfxVadc_Adc_getGroupConfig+0x1c8>
    {
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
800076f8:	e9 ff 35 00 	st.b [%a15]53,%d15
}


IFX_INLINE IfxVadc_RequestSlotPriority IfxVadc_getBackgroundScanSlotPriority(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotPriority)vadcG->ARBPR.B.PRIO2;
800076fc:	19 c2 04 00 	ld.w %d2,[%a12]4
80007700:	37 02 62 24 	extr.u %d2,%d2,8,2
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
80007704:	e9 f2 2e 00 	st.b [%a15]46,%d2
}


IFX_INLINE IfxVadc_RequestSlotStartMode IfxVadc_getBackgroundScanSlotStartMode(Ifx_VADC_G *vadcG)
{
    return (IfxVadc_RequestSlotStartMode)vadcG->ARBPR.B.CSM2;
80007708:	19 c2 04 00 	ld.w %d2,[%a12]4
8000770c:	37 02 e1 25 	extr.u %d2,%d2,11,1
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);
80007710:	e9 f2 2f 00 	st.b [%a15]47,%d2
}


IFX_INLINE IfxVadc_TriggerSource IfxVadc_getBackgroundScanTriggerInput(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerSource)vadc->BRSCTRL.B.XTSEL;
80007714:	19 d3 00 80 	ld.w %d3,[%a13]512
80007718:	37 03 64 34 	extr.u %d3,%d3,8,4

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
8000771c:	e9 f3 2b 00 	st.b [%a15]43,%d3
}


IFX_INLINE IfxVadc_TriggerMode IfxVadc_getBackgroundScanTriggerMode(Ifx_VADC *vadc)
{
    return (IfxVadc_TriggerMode)vadc->BRSCTRL.B.XTMODE;
80007720:	19 d2 00 80 	ld.w %d2,[%a13]512
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007724:	8b f3 00 32 	eq %d3,%d3,15
80007728:	37 02 e2 26 	extr.u %d2,%d2,13,2
        config->arbiter.requestSlotBackgroundScanEnabled          = TRUE;
        config->backgroundScanRequest.requestSlotPrio             = IfxVadc_getBackgroundScanSlotPriority(vadcG);
        config->backgroundScanRequest.requestSlotStartMode        = IfxVadc_getBackgroundScanSlotStartMode(vadcG);

        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_getBackgroundScanTriggerInput(vadc);
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_getBackgroundScanTriggerMode(vadc);
8000772c:	e9 f2 2d 00 	st.b [%a15]45,%d2

        if (config->backgroundScanRequest.triggerConfig.triggerSource != IfxVadc_TriggerSource_15)
80007730:	f6 35       	jnz %d3,8000773a <IfxVadc_Adc_getGroupConfig+0x1a8>
}


IFX_INLINE IfxVadc_GatingMode IfxVadc_getBackgroundScanGatingMode(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingMode)vadc->BRSMR.B.ENGT;
80007732:	19 df 04 80 	ld.w %d15,[%a13]516
80007736:	16 03       	and %d15,3
80007738:	3c 02       	j 8000773c <IfxVadc_Adc_getGroupConfig+0x1aa>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_getBackgroundScanGatingMode(vadc);
        }
        else if (config->backgroundScanRequest.triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
8000773a:	76 23       	jz %d2,80007740 <IfxVadc_Adc_getGroupConfig+0x1ae>
        {
            config->backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
8000773c:	e9 ff 2c 00 	st.b [%a15]44,%d15
}


IFX_INLINE IfxVadc_GatingSource IfxVadc_getBackgroundScanGatingSource(Ifx_VADC *vadc)
{
    return (IfxVadc_GatingSource)vadc->BRSCTRL.B.GTSEL;
80007740:	19 df 00 80 	ld.w %d15,[%a13]512
80007744:	37 0f 64 f8 	extr.u %d15,%d15,16,4
        }

        config->backgroundScanRequest.triggerConfig.gatingSource = IfxVadc_getBackgroundScanGatingSource(vadc);
80007748:	e9 ff 2a 00 	st.b [%a15]42,%d15
}


IFX_INLINE boolean IfxVadc_isAutoBackgroundScanEnabled(Ifx_VADC *vadc)
{
    return (boolean)vadc->BRSMR.B.SCAN;
8000774c:	19 df 04 80 	ld.w %d15,[%a13]516
80007750:	37 0f 61 f2 	extr.u %d15,%d15,4,1
        config->backgroundScanRequest.autoBackgroundScanEnabled  = IfxVadc_isAutoBackgroundScanEnabled(vadc);
80007754:	e9 ff 28 00 	st.b [%a15]40,%d15
80007758:	3c 0c       	j 80007770 <IfxVadc_Adc_getGroupConfig+0x1de>
    }
    else
    {
        config->backgroundScanRequest.autoBackgroundScanEnabled   = FALSE;
8000775a:	82 0f       	mov %d15,0
8000775c:	e9 ff 28 00 	st.b [%a15]40,%d15
        config->backgroundScanRequest.triggerConfig.gatingMode    = IfxVadc_GatingMode_disabled;
80007760:	e9 ff 2c 00 	st.b [%a15]44,%d15
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
80007764:	e9 ff 2a 00 	st.b [%a15]42,%d15
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
80007768:	e9 ff 2d 00 	st.b [%a15]45,%d15
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
8000776c:	e9 ff 2b 00 	st.b [%a15]43,%d15


IFX_INLINE uint8 IfxVadc_getMasterIndex(Ifx_VADC_G *vadcG)
{
    uint8 masterIndex = 0;
    masterIndex = vadcG->SYNCTR.B.STSEL;
80007770:	19 c3 00 10 	ld.w %d3,[%a12]64
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
80007774:	39 e7 08 00 	ld.bu %d7,[%a14]8
80007778:	8f 33 00 31 	and %d3,%d3,3
8000777c:	02 72       	mov %d2,%d7
IFX_INLINE IfxVadc_GroupId IfxVadc_Adc_getMasterId(IfxVadc_GroupId slave, IfxVadc_Adc_SYNCTR_STSEL masterIndex)
{
    uint8           i, idxOffset;
    IfxVadc_GroupId masterId = slave;

    if (masterIndex == 0)
8000777e:	df 03 1f 00 	jeq %d3,0,800077bc <IfxVadc_Adc_getGroupConfig+0x22a>
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007782:	7b 00 00 58 	movh %d5,32768
80007786:	1b 05 f8 50 	addi %d5,%d5,3968
8000778a:	13 87 20 55 	madd %d5,%d5,%d7,8
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
8000778e:	8b 47 60 42 	lt.u %d4,%d7,4
80007792:	82 02       	mov %d2,0
80007794:	ab 42 80 24 	sel %d2,%d4,%d2,4

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
80007798:	1a 25       	add %d15,%d5,%d2
8000779a:	60 f4       	mov.a %a4,%d15
    {
        masterId = slave;
    }
    else
    {
        idxOffset = (slave < 4) ? 0 : 4;    /* 4 is the index in the above IfxVadc_Adc_masterIndex about which symmetry is observed */
8000779c:	82 04       	mov %d4,0

        for (i = 0; i < 4; i++)
        {
            if (IfxVadc_Adc_masterIndex[slave][i + idxOffset] == masterIndex)
8000779e:	a0 32       	mov.a %a2,3
800077a0:	01 44 00 36 	addsc.a %a3,%a4,%d4,0
800077a4:	8f f4 0f 61 	and %d6,%d4,255
800077a8:	14 35       	ld.bu %d5,[%a3]
800077aa:	5f 35 06 80 	jne %d5,%d3,800077b6 <IfxVadc_Adc_getGroupConfig+0x224>
            {
                return (IfxVadc_GroupId)(i + idxOffset);
800077ae:	42 62       	add %d2,%d6
800077b0:	8f f2 0f 21 	and %d2,%d2,255
800077b4:	3c 04       	j 800077bc <IfxVadc_Adc_getGroupConfig+0x22a>
800077b6:	c2 14       	add %d4,1
800077b8:	fc 24       	loop %a2,800077a0 <IfxVadc_Adc_getGroupConfig+0x20e>
        config->backgroundScanRequest.triggerConfig.gatingSource  = IfxVadc_GatingSource_0;  /* Use CCU6061 TRIG0 */
        config->backgroundScanRequest.triggerConfig.triggerMode   = IfxVadc_TriggerMode_noExternalTrigger;
        config->backgroundScanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0; /* Trigger source taken from Gating Input */
    }

    config->master                 = IfxVadc_Adc_getMasterId(group->groupId, IfxVadc_getMasterIndex(vadcG));
800077ba:	02 72       	mov %d2,%d7
800077bc:	28 52       	st.b [%a15]5,%d2


IFX_INLINE Ifx_VADC_GLOBCFG IfxVadc_getGlobalConfigValue(Ifx_VADC *vadc)
{
    Ifx_VADC_GLOBCFG globCfg;
    globCfg.U = vadc->GLOBCFG.U;
800077be:	19 d2 00 20 	ld.w %d2,[%a13]128

    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
800077c2:	1b 07 01 f0 	addi %d15,%d7,16
800077c6:	57 02 61 ff 	extr.u %d15,%d2,%d15,1
800077ca:	e9 ff 30 00 	st.b [%a15]48,%d15
800077ce:	00 90       	ret 

800077d0 <IfxVadc_Adc_initChannel>:


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
800077d0:	99 52 14 00 	ld.a %a2,[%a5]20
800077d4:	d4 2e       	ld.a %a14,[%a2]
800077d6:	99 2c 04 00 	ld.a %a12,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
800077da:	39 28 08 00 	ld.bu %d8,[%a2]8
{
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
800077de:	b5 42 04 00 	st.a [%a4]4,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077e2:	02 84       	mov %d4,%d8
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800077e4:	40 4d       	mov.aa %a13,%a4
    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077e6:	40 e4       	mov.aa %a4,%a14
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
800077e8:	40 5f       	mov.aa %a15,%a5
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
    IfxVadc_ChannelId channelIndex = config->channelId;
800077ea:	79 59 0c 00 	ld.b %d9,[%a5]12

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800077ee:	6d ff ab e6 	call 80004544 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
800077f2:	1b 09 06 20 	addi %d2,%d9,96
800077f6:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
800077fa:	0c fe       	ld.bu %d15,[%a15]14
800077fc:	54 22       	ld.w %d2,[%a2]
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800077fe:	40 e4       	mov.aa %a4,%a14
80007800:	67 f2 0b f0 	ins.t %d15,%d2,11,%d15,0
80007804:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80007806:	54 22       	ld.w %d2,[%a2]
80007808:	0c ff       	ld.bu %d15,[%a15]15
8000780a:	37 f2 04 f8 	insert %d15,%d2,%d15,16,4
8000780e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setLowerBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection lowerBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
80007810:	54 22       	ld.w %d2,[%a2]
80007812:	39 ff 10 00 	ld.bu %d15,[%a15]16
80007816:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
8000781a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setUpperBoundary(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundarySelection upperBoundary)
{
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
8000781c:	54 22       	ld.w %d2,[%a2]
8000781e:	39 ff 11 00 	ld.bu %d15,[%a15]17
80007822:	37 f2 02 f3 	insert %d15,%d2,%d15,6,2
80007826:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setSyncRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean synchonize)
{
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
80007828:	54 22       	ld.w %d2,[%a2]
8000782a:	0c f1       	ld.bu %d15,[%a15]1
8000782c:	67 f2 0a f0 	ins.t %d15,%d2,10,%d15,0
80007830:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelInputClass(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_InputClasses inputClass)
{
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80007832:	54 22       	ld.w %d2,[%a2]
80007834:	0c fd       	ld.bu %d15,[%a15]13
80007836:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
8000783a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setChannelLimitCheckMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_LimitCheck limitCheck)
{
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
8000783c:	54 22       	ld.w %d2,[%a2]
8000783e:	39 ff 13 00 	ld.bu %d15,[%a15]19
80007842:	37 f2 02 f4 	insert %d15,%d2,%d15,8,2
80007846:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setResultPosition(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
80007848:	54 22       	ld.w %d2,[%a2]
8000784a:	0c f3       	ld.bu %d15,[%a15]3
8000784c:	67 f2 15 f0 	ins.t %d15,%d2,21,%d15,0
80007850:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBackgroundResultTarget(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, boolean globalResultUsage)
{
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
80007852:	54 22       	ld.w %d2,[%a2]
80007854:	0c f0       	ld.bu %d15,[%a15]0
80007856:	67 f2 14 f0 	ins.t %d15,%d2,20,%d15,0
8000785a:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxVadc_setBoundaryMode(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_BoundaryExtension boundaryMode)
{
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
8000785c:	54 22       	ld.w %d2,[%a2]
8000785e:	39 ff 12 00 	ld.bu %d15,[%a15]18
80007862:	37 f2 04 f6 	insert %d15,%d2,%d15,12,4
80007866:	6c 20       	st.w [%a2]0,%d15
80007868:	1b 08 01 f0 	addi %d15,%d8,16
8000786c:	16 ff       	and %d15,255
8000786e:	02 f4       	mov %d4,%d15
80007870:	6d ff 6a e6 	call 80004544 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80007874:	08 23       	ld.bu %d3,[%a15]2
80007876:	82 12       	mov %d2,1
80007878:	0f 92 00 20 	sh %d2,%d2,%d9
8000787c:	f6 35       	jnz %d3,80007886 <IfxVadc_Adc_initChannel+0xb6>
}


IFX_INLINE void IfxVadc_setGroupPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U |= (1 << channelIndex);
8000787e:	19 c3 08 00 	ld.w %d3,[%a12]8
80007882:	a6 32       	or %d2,%d3
80007884:	3c 05       	j 8000788e <IfxVadc_Adc_initChannel+0xbe>
}


IFX_INLINE void IfxVadc_setBackgroundPriorityChannel(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex)
{
    vadcG->CHASS.U &= ~(1 << channelIndex);
80007886:	19 c3 08 00 	ld.w %d3,[%a12]8
8000788a:	0f 23 e0 20 	andn %d2,%d3,%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000788e:	02 f4       	mov %d4,%d15
80007890:	59 c2 08 00 	st.w [%a12]8,%d2
80007894:	40 e4       	mov.aa %a4,%a14
80007896:	6d ff 3b e6 	call 8000450c <IfxVadc_disableAccess>
}


IFX_INLINE void IfxVadc_setChannelEventNodePointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr channelSrcNr, IfxVadc_ChannelId channel)
{
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
8000789a:	79 d3 00 00 	ld.b %d3,[%a13]0
8000789e:	19 c5 20 40 	ld.w %d5,[%a12]288
800078a2:	8f 23 00 f0 	sh %d15,%d3,2
800078a6:	3b f0 00 20 	mov %d2,15
800078aa:	0f f2 00 20 	sh %d2,%d2,%d15
800078ae:	0f 25 e0 20 	andn %d2,%d5,%d2

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
800078b2:	08 b4       	ld.bu %d4,[%a15]11
800078b4:	59 c2 20 40 	st.w [%a12]288,%d2
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
800078b8:	19 c2 20 40 	ld.w %d2,[%a12]288
800078bc:	0f f4 00 f0 	sh %d15,%d4,%d15
800078c0:	a6 2f       	or %d15,%d2
800078c2:	59 cf 20 40 	st.w [%a12]288,%d15

    if (config->channelPriority > 0)
800078c6:	b9 ff 06 00 	ld.hu %d15,[%a15]6
800078ca:	6e 1f       	jz %d15,80007908 <IfxVadc_Adc_initChannel+0x138>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
800078cc:	02 84       	mov %d4,%d8
800078ce:	08 b5       	ld.bu %d5,[%a15]11
800078d0:	6d ff 6b e7 	call 800047a6 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_clearChannelRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelId)
{
    vadcG->CEFCLR.U = 1 << channelId;
800078d4:	79 f2 0c 00 	ld.b %d2,[%a15]12
800078d8:	82 1f       	mov %d15,1
800078da:	0f 2f 00 f0 	sh %d15,%d15,%d2
800078de:	59 cf 10 40 	st.w [%a12]272,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800078e2:	54 22       	ld.w %d2,[%a2]
800078e4:	08 63       	ld.bu %d3,[%a15]6
800078e6:	8f f2 cf 21 	andn %d2,%d2,255
800078ea:	a6 32       	or %d2,%d3

        IfxVadc_clearChannelRequest(vadcG, config->channelId);
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
800078ec:	0c f9       	ld.bu %d15,[%a15]9
800078ee:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800078f0:	54 22       	ld.w %d2,[%a2]
800078f2:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
800078f6:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
800078f8:	4c 20       	ld.w %d15,[%a2]0
800078fa:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
800078fe:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
80007900:	4c 20       	ld.w %d15,[%a2]0
80007902:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
80007906:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80007908:	0c ff       	ld.bu %d15,[%a15]15
8000790a:	08 a2       	ld.bu %d2,[%a15]10
8000790c:	ff 8f 15 80 	jge.u %d15,8,80007936 <IfxVadc_Adc_initChannel+0x166>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer0(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80007910:	19 c4 30 40 	ld.w %d4,[%a12]304
80007914:	06 2f       	sh %d15,2
80007916:	3b f0 00 30 	mov %d3,15
8000791a:	0f f3 00 30 	sh %d3,%d3,%d15
8000791e:	0f 34 e0 30 	andn %d3,%d4,%d3
80007922:	59 c3 30 40 	st.w [%a12]304,%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80007926:	19 c3 30 40 	ld.w %d3,[%a12]304
8000792a:	0f f2 00 f0 	sh %d15,%d2,%d15
8000792e:	a6 3f       	or %d15,%d3
80007930:	59 cf 30 40 	st.w [%a12]304,%d15
80007934:	3c 14       	j 8000795c <IfxVadc_Adc_initChannel+0x18c>
}


IFX_INLINE void IfxVadc_setResultNodeEventPointer1(Ifx_VADC_G *vadcG, IfxVadc_SrcNr resultSrcNr, IfxVadc_ChannelResult resultRegister)
{
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80007936:	c2 8f       	add %d15,-8
80007938:	19 c4 34 40 	ld.w %d4,[%a12]308
8000793c:	06 2f       	sh %d15,2
8000793e:	3b f0 00 30 	mov %d3,15
80007942:	0f f3 00 30 	sh %d3,%d3,%d15
80007946:	0f 34 e0 30 	andn %d3,%d4,%d3
8000794a:	59 c3 34 40 	st.w [%a12]308,%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
8000794e:	19 c3 34 40 	ld.w %d3,[%a12]308
80007952:	0f f2 00 f0 	sh %d15,%d2,%d15
80007956:	a6 3f       	or %d15,%d3
80007958:	59 cf 34 40 	st.w [%a12]308,%d15
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
8000795c:	b9 ff 04 00 	ld.hu %d15,[%a15]4
80007960:	6e 24       	jz %d15,800079a8 <IfxVadc_Adc_initChannel+0x1d8>
    {
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80007962:	02 84       	mov %d4,%d8
80007964:	08 a5       	ld.bu %d5,[%a15]10
80007966:	6d ff 20 e7 	call 800047a6 <IfxVadc_getSrcAddress>
}


IFX_INLINE void IfxVadc_enableServiceRequest(Ifx_VADC_G *vadcG, IfxVadc_ChannelResult resultRegister)
{
    vadcG->RCR[resultRegister].B.SRGEN = 1;
8000796a:	0c ff       	ld.bu %d15,[%a15]15
8000796c:	1b 0f 08 f0 	addi %d15,%d15,128
80007970:	90 c3       	addsc.a %a3,%a12,%d15,2
80007972:	4c 30       	ld.w %d15,[%a3]0
80007974:	b7 ff 81 ff 	insert %d15,%d15,15,31,1
80007978:	6c 30       	st.w [%a3]0,%d15
}


IFX_INLINE void IfxVadc_clearAllResultRequests(Ifx_VADC_G *vadcG)
{
    vadcG->REFCLR.U = 0x0000FFFFu;
8000797a:	bb f0 ff ff 	mov.u %d15,65535
8000797e:	59 cf 14 40 	st.w [%a12]276,%d15
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80007982:	54 22       	ld.w %d2,[%a2]
80007984:	08 43       	ld.bu %d3,[%a15]4
80007986:	8f f2 cf 21 	andn %d2,%d2,255
8000798a:	a6 32       	or %d2,%d3

        IfxVadc_enableServiceRequest(vadcG, config->resultRegister);
        IfxVadc_clearAllResultRequests(vadcG);
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
8000798c:	0c f8       	ld.bu %d15,[%a15]8
8000798e:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80007990:	54 22       	ld.w %d2,[%a2]
80007992:	37 f2 82 f5 	insert %d15,%d2,%d15,11,2
80007996:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
80007998:	4c 20       	ld.w %d15,[%a2]0
8000799a:	b7 ff 81 fc 	insert %d15,%d15,15,25,1
8000799e:	6c 20       	st.w [%a2]0,%d15
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
800079a0:	4c 20       	ld.w %d15,[%a2]0
800079a2:	b7 ff 01 f5 	insert %d15,%d15,15,10,1
800079a6:	6c 20       	st.w [%a2]0,%d15
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
800079a8:	40 e4       	mov.aa %a4,%a14
800079aa:	02 84       	mov %d4,%d8
800079ac:	6d ff b0 e5 	call 8000450c <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
800079b0:	0c ff       	ld.bu %d15,[%a15]15
    channel->channel   = config->channelId;

    return Status;
}
800079b2:	82 02       	mov %d2,0
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
    /* Software initialization */
    channel->resultreg = config->resultRegister;
800079b4:	2c d1       	st.b [%a13]1,%d15
    channel->channel   = config->channelId;
800079b6:	0c fc       	ld.bu %d15,[%a15]12
800079b8:	2c d0       	st.b [%a13]0,%d15

    return Status;
}
800079ba:	00 90       	ret 

800079bc <IfxVadc_Adc_initChannelConfig>:
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
800079bc:	40 42       	mov.aa %a2,%a4
800079be:	d2 02       	mov %e2,0
800079c0:	89 22 48 01 	st.d [%a2+]8,%e2
800079c4:	89 22 48 01 	st.d [%a2+]8,%e2
800079c8:	89 22 48 01 	st.d [%a2+]8,%e2
    config->group = group;
800079cc:	b5 45 14 00 	st.a [%a4]20,%a5
800079d0:	00 90       	ret 

800079d2 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
800079d2:	d4 52       	ld.a %a2,[%a5]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
800079d4:	39 58 04 00 	ld.bu %d8,[%a5]4


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
800079d8:	d4 2c       	ld.a %a12,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
800079da:	8f a8 00 90 	sh %d9,%d8,10
800079de:	1b 09 48 f0 	addi %d15,%d9,1152
800079e2:	10 cd       	addsc.a %a13,%a12,%d15,0

    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
800079e4:	4c 20       	ld.w %d15,[%a2]0
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];

    /* check for write access */
    group->group   = vadcG;
800079e6:	b5 4d 04 00 	st.a [%a4]4,%a13
    group->module  = *config->module;
800079ea:	6c 40       	st.w [%a4]0,%d15
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
800079ec:	e9 48 08 00 	st.b [%a4]8,%d8
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800079f0:	40 c4       	mov.aa %a4,%a12
    config->group = group;
}


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
800079f2:	40 5f       	mov.aa %a15,%a5
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
800079f4:	6d ff 5a e6 	call 800046a8 <IfxVadc_getAdcAnalogFrequency>

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800079f8:	1b 08 01 f0 	addi %d15,%d8,16
800079fc:	8f ff 0f a1 	and %d10,%d15,255
80007a00:	40 c4       	mov.aa %a4,%a12
80007a02:	02 a4       	mov %d4,%d10
    /* check for write access */
    group->group   = vadcG;
    group->module  = *config->module;
    IfxVadc_GroupId groupIndex      = config->groupId;
    group->groupId = groupIndex;
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80007a04:	02 2b       	mov %d11,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007a06:	6d ff 9f e5 	call 80004544 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007a0a:	39 ff 33 00 	ld.bu %d15,[%a15]51
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007a0e:	40 d4       	mov.aa %a4,%a13
    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007a10:	5e 17       	jne %d15,1,80007a1e <IfxVadc_Adc_initGroup+0x4c>
    {
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80007a12:	82 14       	mov %d4,1
80007a14:	39 f5 26 00 	ld.bu %d5,[%a15]38
80007a18:	39 f6 27 00 	ld.bu %d6,[%a15]39
80007a1c:	3c 03       	j 80007a22 <IfxVadc_Adc_initGroup+0x50>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80007a1e:	d2 04       	mov %e4,0
80007a20:	82 06       	mov %d6,0
80007a22:	82 07       	mov %d7,0
80007a24:	6d ff 06 e8 	call 80004a30 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007a28:	39 ff 34 00 	ld.bu %d15,[%a15]52
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007a2c:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007a2e:	5e 17       	jne %d15,1,80007a3c <IfxVadc_Adc_initGroup+0x6a>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80007a30:	82 14       	mov %d4,1
80007a32:	39 f5 1e 00 	ld.bu %d5,[%a15]30
80007a36:	39 f6 1f 00 	ld.bu %d6,[%a15]31
80007a3a:	3c 03       	j 80007a40 <IfxVadc_Adc_initGroup+0x6e>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80007a3c:	d2 04       	mov %e4,0
80007a3e:	82 06       	mov %d6,0
80007a40:	82 17       	mov %d7,1
80007a42:	6d ff f7 e7 	call 80004a30 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007a46:	39 ff 35 00 	ld.bu %d15,[%a15]53
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007a4a:	40 d4       	mov.aa %a4,%a13
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007a4c:	5e 17       	jne %d15,1,80007a5a <IfxVadc_Adc_initGroup+0x88>
    {
        /* Setup Arbitration priority and turn on enabled slot */
        /* Enable Arbiter slot, set Priority and start mode */
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80007a4e:	82 14       	mov %d4,1
80007a50:	39 f5 2e 00 	ld.bu %d5,[%a15]46
80007a54:	39 f6 2f 00 	ld.bu %d6,[%a15]47
80007a58:	3c 03       	j 80007a5e <IfxVadc_Adc_initGroup+0x8c>
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80007a5a:	d2 04       	mov %e4,0
80007a5c:	82 06       	mov %d6,0
80007a5e:	82 27       	mov %d7,2
80007a60:	6d ff e8 e7 	call 80004a30 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80007a64:	0c f5       	ld.bu %d15,[%a15]5
80007a66:	be 8b       	jeq %d15,%d8,80007a9c <IfxVadc_Adc_initGroup+0xca>
}


IFX_INLINE IfxVadc_Adc_SYNCTR_STSEL IfxVadc_Adc_getMasterKernelIndex(IfxVadc_GroupId slave, IfxVadc_GroupId master)
{
    return IfxVadc_Adc_masterIndex[slave][master];
80007a68:	13 88 20 ff 	madd %d15,%d15,%d8,8
80007a6c:	91 00 00 28 	movh.a %a2,32768
80007a70:	d9 22 c0 e0 	lea %a2,[%a2]3968 <80000f80 <IfxVadc_Adc_masterIndex>>
80007a74:	10 22       	addsc.a %a2,%a2,%d15,0
80007a76:	0c 20       	ld.bu %d15,[%a2]0
}


IFX_INLINE void IfxVadc_setMasterIndex(Ifx_VADC_G *vadcG, uint8 masterIndex)
{
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80007a78:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007a7c:	8f 3f 00 21 	and %d2,%d15,3
80007a80:	19 23 40 30 	ld.w %d3,[%a2]1216
80007a84:	37 f3 02 f0 	insert %d15,%d3,%d15,0,2
80007a88:	59 2f 40 30 	st.w [%a2]1216,%d15
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80007a8c:	19 23 40 30 	ld.w %d3,[%a2]1216
80007a90:	da 08       	mov %d15,8
80007a92:	0f 2f 00 f0 	sh %d15,%d15,%d2
80007a96:	a6 3f       	or %d15,%d3
80007a98:	59 2f 40 30 	st.w [%a2]1216,%d15
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007a9c:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007aa0:	19 2f 40 20 	ld.w %d15,[%a2]1152
80007aa4:	8f 3f c0 f1 	andn %d15,%d15,3
80007aa8:	59 2f 40 20 	st.w [%a2]1152,%d15
}


IFX_INLINE void IfxVadc_setArbitrationRoundLength(Ifx_VADC_G *vadcG, IfxVadc_ArbitrationRounds arbiterRoundLength)
{
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80007aac:	39 ff 32 00 	ld.bu %d15,[%a15]50
80007ab0:	19 22 40 20 	ld.w %d2,[%a2]1152
80007ab4:	37 f2 02 f2 	insert %d15,%d2,%d15,4,2
80007ab8:	59 2f 40 20 	st.w [%a2]1152,%d15
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80007abc:	39 ff 33 00 	ld.bu %d15,[%a15]51
80007ac0:	df 1f 5a 80 	jne %d15,1,80007b74 <IfxVadc_Adc_initGroup+0x1a2>
    {
        const IfxVadc_Adc_QueueConfig *queueSlot = &config->queueRequest;

        /* configure external Trigger if enabled */
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007ac4:	39 ff 25 00 	ld.bu %d15,[%a15]37
80007ac8:	6e 28       	jz %d15,80007b18 <IfxVadc_Adc_initGroup+0x146>
}


IFX_INLINE void IfxVadc_enableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80007aca:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007ace:	96 04       	or %d15,4
80007ad0:	59 2f 44 40 	st.w [%a2]1284,%d15


IFX_INLINE void IfxVadc_setQueueSlotTriggerOperatingConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U        = vadcG->QCTRL0.U;
80007ad4:	19 23 40 40 	ld.w %d3,[%a2]1280
        {
            /* enable external trigger */
            IfxVadc_enableQueueSlotExternalTrigger(vadcG);
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80007ad8:	39 f2 25 00 	ld.bu %d2,[%a15]37
80007adc:	39 ff 23 00 	ld.bu %d15,[%a15]35
    qctrl0.B.XTWC   = 1;
80007ae0:	b7 13 81 37 	insert %d3,%d3,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80007ae4:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    qctrl0.B.XTSEL  = triggerSource;
80007ae8:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80007aec:	59 23 40 40 	st.w [%a2]1280,%d3

            /* if last input is used the trigger input selection is extend by Gating inputs */
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80007af0:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007af4:	8b ff 20 f2 	ne %d15,%d15,15
80007af8:	ee 16       	jnz %d15,80007b24 <IfxVadc_Adc_initGroup+0x152>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007afa:	19 23 40 40 	ld.w %d3,[%a2]1280
            {
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007afe:	39 ff 22 00 	ld.bu %d15,[%a15]34
    qctrl0.B.GTWC      = 1;
80007b02:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007b06:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007b0a:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007b0e:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007b12:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007b16:	3c 05       	j 80007b20 <IfxVadc_Adc_initGroup+0x14e>
}


IFX_INLINE void IfxVadc_disableQueueSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80007b18:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007b1c:	8f 4f c0 f1 	andn %d15,%d15,4
80007b20:	59 2f 44 40 	st.w [%a2]1284,%d15
            /* disable external trigger */
            IfxVadc_disableQueueSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007b24:	39 ff 23 00 	ld.bu %d15,[%a15]35
80007b28:	8b ff 00 f2 	eq %d15,%d15,15
80007b2c:	ee 15       	jnz %d15,80007b56 <IfxVadc_Adc_initGroup+0x184>


IFX_INLINE void IfxVadc_setQueueSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_QCTRL0 qctrl0;
    qctrl0.U           = vadcG->QCTRL0.U;
80007b2e:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80007b32:	39 f2 22 00 	ld.bu %d2,[%a15]34
80007b36:	19 23 40 40 	ld.w %d3,[%a2]1280
80007b3a:	39 ff 24 00 	ld.bu %d15,[%a15]36
    qctrl0.B.GTWC      = 1;
80007b3e:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80007b42:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80007b46:	59 23 40 40 	st.w [%a2]1280,%d3
    vadcG->QMR0.B.ENGT = gatingMode;
80007b4a:	19 22 44 40 	ld.w %d2,[%a2]1284
80007b4e:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007b52:	59 2f 44 40 	st.w [%a2]1284,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80007b56:	39 f2 20 00 	ld.bu %d2,[%a15]32
}


IFX_INLINE void IfxVadc_clearQueue(Ifx_VADC_G *vadcG, boolean flushQueue)
{
    vadcG->QMR0.B.FLUSH = flushQueue;
80007b5a:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007b5e:	3b 00 40 f0 	mov %d15,1024
80007b62:	ab 0f 80 22 	sel %d2,%d2,%d15,0
80007b66:	19 2f 44 40 	ld.w %d15,[%a2]1284
80007b6a:	b7 0f 01 f5 	insert %d15,%d15,0,10,1
80007b6e:	a6 2f       	or %d15,%d2
80007b70:	59 2f 44 40 	st.w [%a2]1284,%d15
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80007b74:	39 ff 34 00 	ld.bu %d15,[%a15]52
80007b78:	df 1f 5a 80 	jne %d15,1,80007c2c <IfxVadc_Adc_initGroup+0x25a>
    {
        const IfxVadc_Adc_ScanConfig *scanSlot = &config->scanRequest;

        /* configure external Trigger if enabled */
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007b7c:	39 ff 1d 00 	ld.bu %d15,[%a15]29
}


IFX_INLINE void IfxVadc_enableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80007b80:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007b84:	6e 28       	jz %d15,80007bd4 <IfxVadc_Adc_initGroup+0x202>
80007b86:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007b8a:	96 04       	or %d15,4
80007b8c:	59 2f 64 40 	st.w [%a2]1316,%d15


IFX_INLINE void IfxVadc_setScanSlotTriggerConfig(Ifx_VADC_G *vadcG, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U        = vadcG->ASCTRL.U;
80007b90:	19 23 60 40 	ld.w %d3,[%a2]1312
        {
            /* enable external trigger */
            IfxVadc_enableScanSlotExternalTrigger(vadcG);

            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80007b94:	39 f2 1d 00 	ld.bu %d2,[%a15]29
80007b98:	39 ff 1b 00 	ld.bu %d15,[%a15]27
    asctrl.B.XTWC   = 1;
80007b9c:	b7 13 81 37 	insert %d3,%d3,1,15,1
    asctrl.B.XTMODE = triggerMode;
80007ba0:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    asctrl.B.XTSEL  = triggerSource;
80007ba4:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadcG->ASCTRL.U = asctrl.U;
80007ba8:	59 23 60 40 	st.w [%a2]1312,%d3

            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007bac:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007bb0:	8b ff 20 f2 	ne %d15,%d15,15
80007bb4:	ee 16       	jnz %d15,80007be0 <IfxVadc_Adc_initGroup+0x20e>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007bb6:	19 23 60 40 	ld.w %d3,[%a2]1312
            {
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007bba:	39 ff 1a 00 	ld.bu %d15,[%a15]26
    asctrl.B.GTWC      = 1;
80007bbe:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007bc2:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007bc6:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007bca:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007bce:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007bd2:	3c 05       	j 80007bdc <IfxVadc_Adc_initGroup+0x20a>
}


IFX_INLINE void IfxVadc_disableScanSlotExternalTrigger(Ifx_VADC_G *vadcG)
{
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80007bd4:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007bd8:	8f 4f c0 f1 	andn %d15,%d15,4
80007bdc:	59 2f 64 40 	st.w [%a2]1316,%d15
        {
            IfxVadc_disableScanSlotExternalTrigger(vadcG);
        }

        /* configure Gating if enabled */
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007be0:	39 ff 1b 00 	ld.bu %d15,[%a15]27
80007be4:	8b ff 00 f2 	eq %d15,%d15,15
80007be8:	ee 15       	jnz %d15,80007c12 <IfxVadc_Adc_initGroup+0x240>


IFX_INLINE void IfxVadc_setScanSlotGatingConfig(Ifx_VADC_G *vadcG, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_G_ASCTRL asctrl;
    asctrl.U           = vadcG->ASCTRL.U;
80007bea:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
        {
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80007bee:	39 f2 1a 00 	ld.bu %d2,[%a15]26
80007bf2:	19 23 60 40 	ld.w %d3,[%a2]1312
80007bf6:	39 ff 1c 00 	ld.bu %d15,[%a15]28
    asctrl.B.GTWC      = 1;
80007bfa:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80007bfe:	37 23 04 38 	insert %d3,%d3,%d2,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80007c02:	59 23 60 40 	st.w [%a2]1312,%d3
    vadcG->ASMR.B.ENGT = gatingMode;
80007c06:	19 22 64 40 	ld.w %d2,[%a2]1316
80007c0a:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007c0e:	59 2f 64 40 	st.w [%a2]1316,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80007c12:	39 ff 18 00 	ld.bu %d15,[%a15]24
}


IFX_INLINE void IfxVadc_setAutoScan(Ifx_VADC_G *vadcG, boolean autoscanEnable)
{
    vadcG->ASMR.B.SCAN = autoscanEnable;
80007c16:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007c1a:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007c1e:	19 2f 64 40 	ld.w %d15,[%a2]1316
80007c22:	8f 0f c1 f1 	andn %d15,%d15,16
80007c26:	a6 2f       	or %d15,%d2
80007c28:	59 2f 64 40 	st.w [%a2]1316,%d15
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80007c2c:	39 ff 35 00 	ld.bu %d15,[%a15]53
80007c30:	df 1f 4f 80 	jne %d15,1,80007cce <IfxVadc_Adc_initGroup+0x2fc>
    {
        const IfxVadc_Adc_BackgroundScanConfig *backgroundScanSlot = &config->backgroundScanRequest;

        /* configure external Trigger if enabled */
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80007c34:	39 ff 2d 00 	ld.bu %d15,[%a15]45
80007c38:	6e 29       	jz %d15,80007c8a <IfxVadc_Adc_initGroup+0x2b8>
}


IFX_INLINE void IfxVadc_enableBackgroundScanSlotExternalTrigger(Ifx_VADC *vadc)
{
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80007c3a:	19 cf 04 80 	ld.w %d15,[%a12]516
80007c3e:	96 04       	or %d15,4
80007c40:	59 cf 04 80 	st.w [%a12]516,%d15


IFX_INLINE void IfxVadc_setBackgroundScanSlotTriggerConfig(Ifx_VADC *vadc, IfxVadc_TriggerMode triggerMode, IfxVadc_TriggerSource triggerSource)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U        = vadc->BRSCTRL.U;
80007c44:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_enableBackgroundScanSlotExternalTrigger(vadc);

            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80007c48:	39 f2 2d 00 	ld.bu %d2,[%a15]45
80007c4c:	39 ff 2b 00 	ld.bu %d15,[%a15]43
    brsctrl.B.XTWC   = 1;
80007c50:	b7 13 81 37 	insert %d3,%d3,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80007c54:	37 23 82 36 	insert %d3,%d3,%d2,13,2
    brsctrl.B.XTSEL  = triggerSource;
80007c58:	37 f3 04 34 	insert %d3,%d3,%d15,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
80007c5c:	59 c3 00 80 	st.w [%a12]512,%d3

            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80007c60:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007c64:	8b ff 20 f2 	ne %d15,%d15,15
80007c68:	ee 11       	jnz %d15,80007c8a <IfxVadc_Adc_initGroup+0x2b8>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007c6a:	19 c3 00 80 	ld.w %d3,[%a12]512
            {
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80007c6e:	39 ff 2a 00 	ld.bu %d15,[%a15]42
    brsctrl.B.GTWC     = 1;
80007c72:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007c76:	37 f3 04 38 	insert %d3,%d3,%d15,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
80007c7a:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007c7e:	19 cf 04 80 	ld.w %d15,[%a12]516
80007c82:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
80007c86:	59 cf 04 80 	st.w [%a12]516,%d15
        {
            /* do nothing */
        }

        /* configure Gating if enabled */
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80007c8a:	39 ff 2b 00 	ld.bu %d15,[%a15]43
80007c8e:	8b ff 00 f2 	eq %d15,%d15,15
80007c92:	ee 13       	jnz %d15,80007cb8 <IfxVadc_Adc_initGroup+0x2e6>


IFX_INLINE void IfxVadc_setBackgroundScanSlotGatingConfig(Ifx_VADC *vadc, IfxVadc_GatingSource gatingSource, IfxVadc_GatingMode gatingMode)
{
    Ifx_VADC_BRSCTRL brsctrl;
    brsctrl.U          = vadc->BRSCTRL.U;
80007c94:	19 c3 00 80 	ld.w %d3,[%a12]512
        {
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80007c98:	39 f2 2a 00 	ld.bu %d2,[%a15]42
    brsctrl.B.GTWC     = 1;
80007c9c:	b7 13 81 3b 	insert %d3,%d3,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80007ca0:	37 23 04 38 	insert %d3,%d3,%d2,16,4
80007ca4:	39 ff 2c 00 	ld.bu %d15,[%a15]44
    vadc->BRSCTRL.U    = brsctrl.U;
80007ca8:	59 c3 00 80 	st.w [%a12]512,%d3
    vadc->BRSMR.B.ENGT = gatingMode;
80007cac:	19 c2 04 80 	ld.w %d2,[%a12]516
80007cb0:	37 f2 02 f0 	insert %d15,%d2,%d15,0,2
80007cb4:	59 cf 04 80 	st.w [%a12]516,%d15
        else
        {
            /* do nothing, handled by trigger settings */
        }

        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
80007cb8:	39 ff 28 00 	ld.bu %d15,[%a15]40
}


IFX_INLINE void IfxVadc_setAutoBackgroundScan(Ifx_VADC *vadc, boolean autoBackgroundScanEnable)
{
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80007cbc:	ab 0f a1 2f 	seln %d2,%d15,%d15,16
80007cc0:	19 cf 04 80 	ld.w %d15,[%a12]516
80007cc4:	8f 0f c1 f1 	andn %d15,%d15,16
80007cc8:	a6 2f       	or %d15,%d2
80007cca:	59 cf 04 80 	st.w [%a12]516,%d15
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80007cce:	0c f5       	ld.bu %d15,[%a15]5
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007cd0:	01 c9 00 26 	addsc.a %a2,%a12,%d9,0
80007cd4:	3a 8f       	eq %d15,%d15,%d8
80007cd6:	ab 3f a0 2f 	seln %d2,%d15,%d15,3
80007cda:	19 2f 40 20 	ld.w %d15,[%a2]1152
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80007cde:	02 84       	mov %d4,%d8
80007ce0:	8f 3f c0 f1 	andn %d15,%d15,3
80007ce4:	a6 2f       	or %d15,%d2
80007ce6:	59 2f 40 20 	st.w [%a2]1152,%d15
80007cea:	39 f5 30 00 	ld.bu %d5,[%a15]48
80007cee:	40 c4       	mov.aa %a4,%a12
80007cf0:	6d ff 69 e4 	call 800045c2 <IfxVadc_disablePostCalibration>
}


IFX_INLINE void IfxVadc_setGroupResolution(Ifx_VADC_G *vadcG, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
80007cf4:	8f 88 00 80 	sh %d8,%d8,8
80007cf8:	82 05       	mov %d5,0
/** Return minimum of two unsigned integers
 */
IFX_INLINE uint32 Ifx__minu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80007cfa:	3b f0 0f 40 	mov %d4,255

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
80007cfe:	01 f5 03 26 	addsc.a %a2,%a15,%d5,3
80007d02:	0b 58 00 20 	add %d2,%d8,%d5
80007d06:	1b 82 12 20 	addi %d2,%d2,296
80007d0a:	0c 2c       	ld.bu %d15,[%a2]12
80007d0c:	01 c2 02 26 	addsc.a %a2,%a12,%d2,2
80007d10:	54 22       	ld.w %d2,[%a2]
80007d12:	37 f2 03 f4 	insert %d15,%d2,%d15,8,3
80007d16:	6c 20       	st.w [%a2]0,%d15
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
80007d18:	9a 15       	add %d15,%d5,1
80007d1a:	d0 f2       	addsc.a %a2,%a15,%d15,3

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007d1c:	54 23       	ld.w %d3,[%a2]
80007d1e:	4b 3b 41 30 	mul.f %d3,%d11,%d3
80007d22:	4b 03 71 31 	ftouz %d3,%d3
80007d26:	c2 e3       	add %d3,-2

    if (ticks > 31)
80007d28:	8b 03 62 f2 	lt.u %d15,%d3,32
80007d2c:	ee 04       	jnz %d15,80007d34 <IfxVadc_Adc_initGroup+0x362>
    {
        ticks = (ticks / 16) + 15;
80007d2e:	06 c3       	sh %d3,-4
80007d30:	1b f3 00 30 	addi %d3,%d3,15
80007d34:	0b 43 90 31 	min.u %d3,%d3,%d4
}


IFX_INLINE void IfxVadc_setGroupSampleTime(Ifx_VADC_G *vadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007d38:	1a 58       	add %d15,%d8,%d5
80007d3a:	1b 8f 12 f0 	addi %d15,%d15,296
80007d3e:	90 c2       	addsc.a %a2,%a12,%d15,2
80007d40:	4c 20       	ld.w %d15,[%a2]0
80007d42:	37 3f 05 30 	insert %d3,%d15,%d3,0,5
80007d46:	74 23       	st.w [%a2],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80007d48:	df 15 04 00 	jeq %d5,1,80007d50 <IfxVadc_Adc_initGroup+0x37e>
80007d4c:	82 15       	mov %d5,1
80007d4e:	3c d8       	j 80007cfe <IfxVadc_Adc_initGroup+0x32c>
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80007d50:	40 c4       	mov.aa %a4,%a12
80007d52:	02 a4       	mov %d4,%d10
80007d54:	6d ff dc e3 	call 8000450c <IfxVadc_disableAccess>

    return status;
}
80007d58:	82 02       	mov %d2,0
80007d5a:	00 90       	ret 

80007d5c <IfxVadc_Adc_initGroupConfig>:
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80007d5c:	40 42       	mov.aa %a2,%a4
80007d5e:	7b 60 58 f3 	movh %d15,13702
80007d62:	d2 02       	mov %e2,0
80007d64:	a0 6f       	mov.a %a15,6
80007d66:	89 22 48 01 	st.d [%a2+]8,%e2
80007d6a:	fc fe       	loop %a15,80007d66 <IfxVadc_Adc_initGroupConfig+0xa>
80007d6c:	1b df 7b f3 	addi %d15,%d15,14269
80007d70:	6c 42       	st.w [%a4]8,%d15
80007d72:	6c 44       	st.w [%a4]16,%d15
80007d74:	82 1f       	mov %d15,1
80007d76:	e9 4f 1e 00 	st.b [%a4]30,%d15
80007d7a:	e9 4f 20 00 	st.b [%a4]32,%d15
80007d7e:	e9 4f 26 00 	st.b [%a4]38,%d15
80007d82:	e9 4f 2e 00 	st.b [%a4]46,%d15
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
80007d86:	f4 45       	st.a [%a4],%a5
80007d88:	00 90       	ret 

80007d8a <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80007d8a:	cc 50       	ld.a %a15,[%a5]0
    config->disablePostCalibration = FALSE;
}


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80007d8c:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
    vadc->vadc = vadcSFR;
80007d8e:	ec 40       	st.a [%a4]0,%a15
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d90:	6d ff 0f fa 	call 800071ae <IfxScuWdt_getCpuWatchdogPassword>

    IfxScuWdt_clearCpuEndinit(passwd);
80007d94:	02 24       	mov %d4,%d2
}


IFX_INLINE void IfxVadc_enableModule(Ifx_VADC *vadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80007d96:	02 2f       	mov %d15,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80007d98:	6d ff 0b f9 	call 80006fae <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80007d9c:	82 02       	mov %d2,0
80007d9e:	68 02       	st.w [%a15]0,%d2
    IfxScuWdt_setCpuEndinit(passwd);
80007da0:	02 f4       	mov %d4,%d15
80007da2:	6d ff 3b fa 	call 80007218 <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
80007da6:	40 f4       	mov.aa %a4,%a15
80007da8:	39 c4 21 00 	ld.bu %d4,[%a12]33
80007dac:	6d ff 30 e6 	call 80004a0c <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007db0:	19 c4 18 00 	ld.w %d4,[%a12]24
80007db4:	40 f4       	mov.aa %a4,%a15
80007db6:	4b 04 71 41 	ftouz %d4,%d4
    {
        return IfxVadc_Status_notInitialised;
80007dba:	82 1f       	mov %d15,1
    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80007dbc:	6d ff 42 e5 	call 80004840 <IfxVadc_initializeFAdcI>
80007dc0:	df 02 57 00 	jeq %d2,0,80007e6e <IfxVadc_Adc_initModule+0xe4>
    {
        /* do nothing */
    }

    /* Set digital Frequency */
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
80007dc4:	19 c4 14 00 	ld.w %d4,[%a12]20
80007dc8:	40 f4       	mov.aa %a4,%a15
80007dca:	4b 04 71 41 	ftouz %d4,%d4
80007dce:	6d ff 24 e5 	call 80004816 <IfxVadc_initializeFAdcD>

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
80007dd2:	40 f4       	mov.aa %a4,%a15
80007dd4:	6d ff 6a e4 	call 800046a8 <IfxVadc_getAdcAnalogFrequency>
80007dd8:	82 03       	mov %d3,0
80007dda:	3b f0 0f 60 	mov %d6,255

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
    {
        /* configure ADC channel resolution ( conversion mode ) */
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
80007dde:	9a 13       	add %d15,%d3,1
}


IFX_INLINE void IfxVadc_setGlobalResolution(Ifx_VADC *vadc, uint8 inputClassNum, IfxVadc_ChannelResolution resolution)
{
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
80007de0:	1b 83 02 40 	addi %d4,%d3,40
80007de4:	d0 c2       	addsc.a %a2,%a12,%d15,3
80007de6:	01 f4 02 36 	addsc.a %a3,%a15,%d4,2
80007dea:	0c 20       	ld.bu %d15,[%a2]0
80007dec:	54 35       	ld.w %d5,[%a3]
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
80007dee:	01 c3 03 26 	addsc.a %a2,%a12,%d3,3
80007df2:	37 f5 03 f4 	insert %d15,%d5,%d15,8,3
80007df6:	6c 30       	st.w [%a3]0,%d15

IFX_INLINE uint32 IfxVadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;
80007df8:	4c 21       	ld.w %d15,[%a2]4
80007dfa:	4b f2 41 f0 	mul.f %d15,%d2,%d15
80007dfe:	4b 0f 71 f1 	ftouz %d15,%d15
80007e02:	c2 ef       	add %d15,-2

    if (ticks > 31)
80007e04:	8b 0f 62 52 	lt.u %d5,%d15,32
80007e08:	f6 54       	jnz %d5,80007e10 <IfxVadc_Adc_initModule+0x86>
    {
        ticks = (ticks / 16) + 15;
80007e0a:	06 cf       	sh %d15,-4
80007e0c:	1b ff 00 f0 	addi %d15,%d15,15
80007e10:	0b 6f 90 f1 	min.u %d15,%d15,%d6
}


IFX_INLINE void IfxVadc_setGlobalSampleTime(Ifx_VADC *vadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
80007e14:	01 f4 02 26 	addsc.a %a2,%a15,%d4,2
80007e18:	54 24       	ld.w %d4,[%a2]
80007e1a:	37 f4 05 f0 	insert %d15,%d4,%d15,0,5
80007e1e:	6c 20       	st.w [%a2]0,%d15
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);

    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);

    /* configure Global input class registers */
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80007e20:	df 13 04 00 	jeq %d3,1,80007e28 <IfxVadc_Adc_initModule+0x9e>
80007e24:	82 13       	mov %d3,1
80007e26:	3c dc       	j 80007dde <IfxVadc_Adc_initModule+0x54>
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007e28:	39 c2 20 00 	ld.bu %d2,[%a12]32

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
80007e2c:	82 0f       	mov %d15,0
        /* configure Sample time ticks */
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
    }

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
80007e2e:	df 12 20 80 	jne %d2,1,80007e6e <IfxVadc_Adc_initModule+0xe4>
80007e32:	82 08       	mov %d8,0
80007e34:	1b 08 01 f0 	addi %d15,%d8,16
80007e38:	16 ff       	and %d15,255
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e3a:	02 f4       	mov %d4,%d15
80007e3c:	40 f4       	mov.aa %a4,%a15
80007e3e:	6d ff 83 e3 	call 80004544 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_setAnalogConvertControl(Ifx_VADC_G *vadcG, IfxVadc_AnalogConverterMode analogConverterMode)
{
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80007e42:	8f a8 00 20 	sh %d2,%d8,10
80007e46:	01 f2 00 26 	addsc.a %a2,%a15,%d2,0
80007e4a:	c2 18       	add %d8,1
80007e4c:	19 22 40 20 	ld.w %d2,[%a2]1152
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e50:	02 f4       	mov %d4,%d15
80007e52:	8f 32 40 21 	or %d2,%d2,3
80007e56:	59 22 40 20 	st.w [%a2]1152,%d2
80007e5a:	40 f4       	mov.aa %a4,%a15

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007e5c:	8b 88 20 f2 	ne %d15,%d8,8
        {
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80007e60:	6d ff 56 e3 	call 8000450c <IfxVadc_disableAccess>

    /* Start up calibration is requested */
    if (config->startupCalibration == TRUE)
    {
        /* Ensure that all groups are enabled */
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80007e64:	ee e8       	jnz %d15,80007e34 <IfxVadc_Adc_initModule+0xaa>
            IfxVadc_setAnalogConvertControl(&vadcSFR->G[groupNum], IfxVadc_AnalogConverterMode_normalOperation);
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
        }

        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
80007e66:	40 f4       	mov.aa %a4,%a15
80007e68:	6d ff 19 e6 	call 80004a9a <IfxVadc_startupCalibration>
    }

    return status;
80007e6c:	82 0f       	mov %d15,0
}
80007e6e:	02 f2       	mov %d2,%d15
80007e70:	00 90       	ret 

80007e72 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e72:	7b 90 b9 f4 	movh %d15,19353
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007e76:	40 4f       	mov.aa %a15,%a4
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e78:	1b 0f 68 f9 	addi %d15,%d15,-27008
    return status;
}


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80007e7c:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
80007e7e:	e8 05       	st.a [%a15]0,%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
80007e80:	68 6f       	st.w [%a15]24,%d15

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80007e82:	6d ff 1f e4 	call 800046c0 <IfxVadc_getAdcDigitalFrequency>
80007e86:	68 52       	st.w [%a15]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80007e88:	6d ff cf f0 	call 80006026 <IfxScuCcu_getSpbFrequency>
80007e8c:	68 72       	st.w [%a15]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e8e:	7b 60 58 23 	movh %d2,13702
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007e92:	82 0f       	mov %d15,0
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e94:	1b d2 7b 23 	addi %d2,%d2,14269
    config->vadc                           = vadc;
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80007e98:	28 8f       	st.b [%a15]8,%d15
    config->globalInputClass[0].sampleTime = 1.0e-6;
80007e9a:	68 12       	st.w [%a15]4,%d2
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
80007e9c:	e9 ff 10 00 	st.b [%a15]16,%d15
    config->globalInputClass[1].sampleTime = 1.0e-6;
80007ea0:	68 32       	st.w [%a15]12,%d2
    config->startupCalibration             = FALSE;
80007ea2:	e9 ff 20 00 	st.b [%a15]32,%d15
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80007ea6:	e9 ff 21 00 	st.b [%a15]33,%d15
80007eaa:	00 90       	ret 

80007eac <IfxVadc_Adc_initExternalMultiplexerModeConfig>:
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
80007eac:	20 10       	sub.a %sp,16
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007eae:	82 0f       	mov %d15,0
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007eb0:	40 a2       	mov.aa %a2,%sp


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
    emuxConfig->channels              = 0;
80007eb2:	2c 49       	st.b [%a4]9,%d15
    emuxConfig->groupId               = IfxVadc_GroupId_0;
80007eb4:	2c 48       	st.b [%a4]8,%d15
    emuxConfig->emuxInterface         = IfxVadc_EmuxInterface_0;
80007eb6:	2c 4a       	st.b [%a4]10,%d15
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
80007eb8:	2c 45       	st.b [%a4]5,%d15
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
80007eba:	2c 46       	st.b [%a4]6,%d15
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
80007ebc:	2c 47       	st.b [%a4]7,%d15
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
80007ebe:	2c 44       	st.b [%a4]4,%d15
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
80007ec0:	e9 4f 1c 00 	st.b [%a4]28,%d15
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007ec4:	d2 02       	mov %e2,0
80007ec6:	89 22 48 01 	st.d [%a2+]8,%e2
80007eca:	89 22 48 01 	st.d [%a2+]8,%e2
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80007ece:	3b 00 f8 ff 	mov %d15,-128
}


void IfxVadc_Adc_initExternalMultiplexerModeConfig(IfxVadc_Adc_EmuxControl *emuxConfig, Ifx_VADC *vadc)
{
    emuxConfig->vadc                  = vadc;
80007ed2:	f4 45       	st.a [%a4],%a5
    emuxConfig->startChannel          = IfxVadc_EmuxSelectValue_0;
    emuxConfig->code                  = IfxVadc_EmuxCodingScheme_binary;
    emuxConfig->sampleTimeControl     = IfxVadc_EmuxSampleTimeControl_settingChanges;
    emuxConfig->mode                  = IfxVadc_ExternalMultiplexerMode_softwareControl;
    emuxConfig->channelSelectionStyle = IfxVadc_ChannelSelectionStyle_channelNumber;
    IfxVadc_Adc_EmuxPinConfig defaultConfig = {
80007ed4:	40 af       	mov.aa %a15,%sp
        .pins       = {NULL_PTR},
        .outputMode = IfxPort_OutputMode_pushPull,
        .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
    };

    emuxConfig->emuxOutPinConfig = defaultConfig;
80007ed6:	2c ac       	st.b [%sp]12,%d15
80007ed8:	d9 44 0c 00 	lea %a4,[%a4]12
80007edc:	09 f2 48 01 	ld.d %e2,[%a15+]8
80007ee0:	89 42 48 01 	st.d [%a4+]8,%e2
80007ee4:	09 f2 48 01 	ld.d %e2,[%a15+]8
80007ee8:	89 42 48 01 	st.d [%a4+]8,%e2
80007eec:	00 90       	ret 

80007eee <IfxVadc_Adc_initExternalMultiplexerMode>:


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
80007eee:	0c 58       	ld.bu %d15,[%a5]8
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80007ef0:	20 08       	sub.a %sp,8
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
80007ef2:	8f af 00 20 	sh %d2,%d15,10
80007ef6:	1b 02 48 20 	addi %d2,%d2,1152
80007efa:	01 42 00 e6 	addsc.a %a14,%a4,%d2,0
}


IFX_INLINE void IfxVadc_setEmuxInterfaceForGroup(Ifx_VADC *vadc, IfxVadc_EmuxInterface emuxInterface, IfxVadc_GroupId group)
{
    if (emuxInterface == IfxVadc_EmuxInterface_0)
80007efe:	39 52 0a 00 	ld.bu %d2,[%a5]10
    emuxConfig->emuxOutPinConfig = defaultConfig;
}


void IfxVadc_Adc_initExternalMultiplexerMode(Ifx_VADC *vadc, const IfxVadc_Adc_EmuxControl *emuxControl)
{
80007f02:	40 4c       	mov.aa %a12,%a4
80007f04:	40 5f       	mov.aa %a15,%a5
80007f06:	16 0f       	and %d15,15
80007f08:	f6 2a       	jnz %d2,80007f1c <IfxVadc_Adc_initExternalMultiplexerMode+0x2e>
    {
        vadc->EMUXSEL.B.EMUXGRP0 = group;
80007f0a:	19 42 30 f0 	ld.w %d2,[%a4]1008
80007f0e:	8f f2 c0 21 	andn %d2,%d2,15
80007f12:	a6 2f       	or %d15,%d2
80007f14:	59 cf 30 f0 	st.w [%a12]1008,%d15
80007f18:	82 0f       	mov %d15,0
80007f1a:	3c 07       	j 80007f28 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
    }
    else
    {
        vadc->EMUXSEL.B.EMUXGRP1 = group;
80007f1c:	19 42 30 f0 	ld.w %d2,[%a4]1008
80007f20:	06 4f       	sh %d15,4
80007f22:	8f 02 cf 21 	andn %d2,%d2,240
80007f26:	3c f6       	j 80007f12 <IfxVadc_Adc_initExternalMultiplexerMode+0x24>
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
    {
        if (emuxControl->emuxOutPinConfig.pins[count] != NULL_PTR)
80007f28:	90 f2       	addsc.a %a2,%a15,%d15,2
80007f2a:	99 2d 0c 00 	ld.a %a13,[%a2]12
80007f2e:	bd 0d 19 00 	jz.a %a13,80007f60 <IfxVadc_Adc_initExternalMultiplexerMode+0x72>
80007f32:	39 d3 0c 00 	ld.bu %d3,[%a13]12
80007f36:	39 f2 18 00 	ld.bu %d2,[%a15]24
80007f3a:	99 d4 04 00 	ld.a %a4,[%a13]4
80007f3e:	0f 23 a0 50 	or %d5,%d3,%d2
80007f42:	39 d4 08 00 	ld.bu %d4,[%a13]8
80007f46:	8f f5 0f 51 	and %d5,%d5,255
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
80007f4a:	39 f8 19 00 	ld.bu %d8,[%a15]25
80007f4e:	6d ff c4 ed 	call 80005ad6 <IfxPort_setPinMode>


IFX_INLINE void IfxVadc_initEmuxPin(const IfxVadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
80007f52:	99 d4 04 00 	ld.a %a4,[%a13]4
80007f56:	39 d4 08 00 	ld.bu %d4,[%a13]8
80007f5a:	02 85       	mov %d5,%d8
80007f5c:	6d ff 3b ee 	call 80005bd2 <IfxPort_setPinPadDriver>
80007f60:	c2 1f       	add %d15,1
{
    uint8       count = 0;
    Ifx_VADC_G *vadcG = &vadc->G[emuxControl->groupId];
    IfxVadc_setEmuxInterfaceForGroup(vadc, emuxControl->emuxInterface, emuxControl->groupId);

    for (count = 0; count < 3; count++)
80007f62:	df 3f e3 ff 	jne %d15,3,80007f28 <IfxVadc_Adc_initExternalMultiplexerMode+0x3a>
        {
            IfxVadc_initEmuxPin(emuxControl->emuxOutPinConfig.pins[count], emuxControl->emuxOutPinConfig.outputMode, emuxControl->emuxOutPinConfig.padDriver);
        }
    }

    IfxVadc_configExternalMultiplexerMode(vadc, vadcG, emuxControl->mode, emuxControl->channels, emuxControl->startChannel, emuxControl->code, emuxControl->sampleTimeControl, emuxControl->channelSelectionStyle);
80007f66:	0c f7       	ld.bu %d15,[%a15]7
80007f68:	08 44       	ld.bu %d4,[%a15]4
80007f6a:	78 00       	st.w [%sp]0,%d15
80007f6c:	39 ff 1c 00 	ld.bu %d15,[%a15]28
80007f70:	08 95       	ld.bu %d5,[%a15]9
80007f72:	08 56       	ld.bu %d6,[%a15]5
80007f74:	08 67       	ld.bu %d7,[%a15]6
80007f76:	78 01       	st.w [%sp]4,%d15
80007f78:	40 c4       	mov.aa %a4,%a12
80007f7a:	40 e5       	mov.aa %a5,%a14
80007f7c:	1d ff 00 e3 	j 8000457c <IfxVadc_configExternalMultiplexerMode>

80007f80 <Ifx_CircularBuffer_get32>:

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f80:	cc 40       	ld.a %a15,[%a4]0
80007f82:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 4;

    if (buffer->index >= buffer->length)
80007f86:	b9 43 06 00 	ld.hu %d3,[%a4]6

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f8a:	90 ff       	addsc.a %a15,%a15,%d15,2

    buffer->index += 4;
80007f8c:	c2 4f       	add %d15,4
80007f8e:	37 0f 70 f0 	extr.u %d15,%d15,0,16

#if (IFX_CFG_CIRCULARBUFFER_C)

uint32 Ifx_CircularBuffer_get32(Ifx_CircularBuffer *buffer)
{
    uint32 data = ((uint32 *)buffer->base)[buffer->index];
80007f92:	48 02       	ld.w %d2,[%a15]0

    buffer->index += 4;
80007f94:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007f96:	3f 3f 04 80 	jlt.u %d15,%d3,80007f9e <Ifx_CircularBuffer_get32+0x1e>
    {
        buffer->index = 0;
80007f9a:	82 0f       	mov %d15,0
80007f9c:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80007f9e:	00 90       	ret 

80007fa0 <Ifx_CircularBuffer_get16>:


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007fa0:	cc 40       	ld.a %a15,[%a4]0
80007fa2:	b9 4f 04 00 	ld.hu %d15,[%a4]4

    buffer->index += 2;

    if (buffer->index >= buffer->length)
80007fa6:	b9 43 06 00 	ld.hu %d3,[%a4]6
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007faa:	50 ff       	addsc.a %a15,%a15,%d15,1

    buffer->index += 2;
80007fac:	c2 2f       	add %d15,2
80007fae:	37 0f 70 f0 	extr.u %d15,%d15,0,16
}


uint16 Ifx_CircularBuffer_get16(Ifx_CircularBuffer *buffer)
{
    uint16 data = ((uint16 *)buffer->base)[buffer->index];
80007fb2:	b9 f2 00 00 	ld.hu %d2,[%a15]0

    buffer->index += 2;
80007fb6:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007fb8:	3f 3f 04 80 	jlt.u %d15,%d3,80007fc0 <Ifx_CircularBuffer_get16+0x20>
    {
        buffer->index = 0;
80007fbc:	82 0f       	mov %d15,0
80007fbe:	ac 42       	st.h [%a4]4,%d15
    }

    return data;
}
80007fc0:	00 90       	ret 

80007fc2 <Ifx_CircularBuffer_addDataIncr>:
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fc2:	cc 40       	ld.a %a15,[%a4]0
80007fc4:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    buffer->index                          += 4;

    if (buffer->index >= buffer->length)
80007fc8:	b9 42 06 00 	ld.hu %d2,[%a4]6
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fcc:	90 ff       	addsc.a %a15,%a15,%d15,2
    buffer->index                          += 4;
80007fce:	c2 4f       	add %d15,4
80007fd0:	37 0f 70 f0 	extr.u %d15,%d15,0,16
 *
 * \return None.
 */
void Ifx_CircularBuffer_addDataIncr(Ifx_CircularBuffer *buffer, uint32 data)
{
    ((uint32 *)buffer->base)[buffer->index] = data;
80007fd4:	68 04       	st.w [%a15]0,%d4
    buffer->index                          += 4;
80007fd6:	ac 42       	st.h [%a4]4,%d15

    if (buffer->index >= buffer->length)
80007fd8:	3f 2f 04 80 	jlt.u %d15,%d2,80007fe0 <Ifx_CircularBuffer_addDataIncr+0x1e>
    {
        buffer->index = 0;
80007fdc:	82 0f       	mov %d15,0
80007fde:	ac 42       	st.h [%a4]4,%d15
80007fe0:	00 90       	ret 

80007fe2 <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80007fe2:	80 52       	mov.d %d2,%a5
80007fe4:	37 04 70 40 	extr.u %d4,%d4,0,16
80007fe8:	8f 02 60 31 	nor %d3,%d2,0
80007fec:	1a 42       	add %d15,%d2,%d4
80007fee:	42 3f       	add %d15,%d3
80007ff0:	42 23       	add %d3,%d2
80007ff2:	42 43       	add %d3,%d4
    uint8 *Dest = (uint8 *)data;
80007ff4:	40 5f       	mov.aa %a15,%a5
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80007ff6:	82 06       	mov %d6,0
80007ff8:	37 0f 70 f0 	extr.u %d15,%d15,0,16
80007ffc:	6f f3 03 00 	jz.t %d3,15,80008002 <_SMALL_DATA2_+0x2>
80008000:	82 0f       	mov %d15,0
    uint8 *Dest = (uint8 *)data;

    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
80008002:	b9 43 04 00 	ld.hu %d3,[%a4]4
80008006:	d4 42       	ld.a %a2,[%a4]
80008008:	60 33       	mov.a %a3,%d3
8000800a:	30 32       	add.a %a2,%a3
8000800c:	14 23       	ld.bu %d3,[%a2]
8000800e:	24 f3       	st.b [%a15+],%d3
        Dest  = &Dest[1];
        buffer->index++;
80008010:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
80008014:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        *Dest = ((uint8 *)buffer->base)[buffer->index];
        Dest  = &Dest[1];
        buffer->index++;
80008018:	c2 13       	add %d3,1
8000801a:	37 03 70 30 	extr.u %d3,%d3,0,16
8000801e:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
80008022:	3f 53 04 80 	jlt.u %d3,%d5,8000802a <_SMALL_DATA2_+0x2a>
        {
            buffer->index = 0;
80008026:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
8000802a:	9f 0f ec ff 	jned %d15,0,80008002 <_SMALL_DATA2_+0x2>
8000802e:	c2 f4       	add %d4,-1
80008030:	37 04 50 40 	extr %d4,%d4,0,16
80008034:	8b 04 40 43 	max %d4,%d4,0
80008038:	c2 14       	add %d4,1

    return Dest;
}
8000803a:	1a 42       	add %d15,%d2,%d4
8000803c:	60 f2       	mov.a %a2,%d15
8000803e:	00 90       	ret 

80008040 <Ifx_CircularBuffer_read32>:


void *Ifx_CircularBuffer_read32(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
80008040:	37 04 70 40 	extr.u %d4,%d4,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;
80008044:	d4 42       	ld.a %a2,[%a4]
80008046:	1b f4 ff 5f 	addi %d5,%d4,-1
8000804a:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
8000804e:	b9 46 06 00 	ld.hu %d6,[%a4]6
80008052:	82 03       	mov %d3,0
80008054:	37 05 70 20 	extr.u %d2,%d5,0,16
80008058:	6f f5 03 00 	jz.t %d5,15,8000805e <Ifx_CircularBuffer_read32+0x1e>
8000805c:	82 02       	mov %d2,0
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
8000805e:	10 2f       	addsc.a %a15,%a2,%d15,0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
80008060:	c2 4f       	add %d15,4
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008062:	48 05       	ld.w %d5,[%a15]0
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;
80008064:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    uint32 *Dest = (uint32 *)data;
    uint8  *base = buffer->base;

    do
    {
        *Dest         = *((uint32 *)(&base[buffer->index]));
80008068:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
8000806c:	c2 13       	add %d3,1
8000806e:	68 05       	st.w [%a15]0,%d5
        Dest          = &Dest[1];
        buffer->index = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80008070:	0b 6f 30 51 	lt.u %d5,%d15,%d6
80008074:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
80008078:	9f 02 f3 ff 	jned %d2,0,8000805e <Ifx_CircularBuffer_read32+0x1e>
8000807c:	c2 f4       	add %d4,-1
8000807e:	37 04 50 40 	extr %d4,%d4,0,16
80008082:	ac 42       	st.h [%a4]4,%d15
80008084:	8b 04 40 43 	max %d4,%d4,0
80008088:	c2 14       	add %d4,1

    return Dest;
}
8000808a:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
8000808e:	00 90       	ret 

80008090 <Ifx_CircularBuffer_write8>:


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80008090:	80 52       	mov.d %d2,%a5
80008092:	37 04 70 40 	extr.u %d4,%d4,0,16
80008096:	8f 02 60 31 	nor %d3,%d2,0
8000809a:	1a 42       	add %d15,%d2,%d4
8000809c:	42 3f       	add %d15,%d3
8000809e:	42 23       	add %d3,%d2
800080a0:	42 43       	add %d3,%d4
    const uint8 *source = (const uint8 *)data;
800080a2:	40 5f       	mov.aa %a15,%a5
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800080a4:	82 06       	mov %d6,0
800080a6:	37 0f 70 f0 	extr.u %d15,%d15,0,16
800080aa:	6f f3 03 00 	jz.t %d3,15,800080b0 <Ifx_CircularBuffer_write8+0x20>
800080ae:	82 0f       	mov %d15,0
    const uint8 *source = (const uint8 *)data;

    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
800080b0:	b9 43 04 00 	ld.hu %d3,[%a4]4
800080b4:	d4 42       	ld.a %a2,[%a4]
800080b6:	60 33       	mov.a %a3,%d3
800080b8:	04 f5       	ld.bu %d5,[%a15+]
800080ba:	30 32       	add.a %a2,%a3
800080bc:	34 25       	st.b [%a2],%d5
        source                                 = &source[1];
        buffer->index++;
800080be:	c9 43 04 00 	ld.h %d3,[%a4]4

        if (buffer->index >= buffer->length)
800080c2:	b9 45 06 00 	ld.hu %d5,[%a4]6
    do
    {
        count--;
        ((uint8 *)buffer->base)[buffer->index] = *source;
        source                                 = &source[1];
        buffer->index++;
800080c6:	c2 13       	add %d3,1
800080c8:	37 03 70 30 	extr.u %d3,%d3,0,16
800080cc:	f9 43 04 00 	st.h [%a4]4,%d3

        if (buffer->index >= buffer->length)
800080d0:	3f 53 04 80 	jlt.u %d3,%d5,800080d8 <Ifx_CircularBuffer_write8+0x48>
        {
            buffer->index = 0;
800080d4:	f9 46 04 00 	st.h [%a4]4,%d6
        }
    } while (count > 0);
800080d8:	9f 0f ec ff 	jned %d15,0,800080b0 <Ifx_CircularBuffer_write8+0x20>
800080dc:	c2 f4       	add %d4,-1
800080de:	37 04 50 40 	extr %d4,%d4,0,16
800080e2:	8b 04 40 43 	max %d4,%d4,0
800080e6:	c2 14       	add %d4,1

    return source;
}
800080e8:	1a 42       	add %d15,%d2,%d4
800080ea:	60 f2       	mov.a %a2,%d15
800080ec:	00 90       	ret 

800080ee <Ifx_CircularBuffer_write32>:


const void *Ifx_CircularBuffer_write32(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
800080ee:	37 04 70 40 	extr.u %d4,%d4,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;
800080f2:	d4 42       	ld.a %a2,[%a4]
800080f4:	1b f4 ff 5f 	addi %d5,%d4,-1
800080f8:	b9 4f 04 00 	ld.hu %d15,[%a4]4
    {
        *((uint32 *)(&base[buffer->index])) = *source;
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
800080fc:	b9 46 06 00 	ld.hu %d6,[%a4]6
80008100:	82 03       	mov %d3,0
80008102:	37 05 70 20 	extr.u %d2,%d5,0,16
80008106:	6f f5 03 00 	jz.t %d5,15,8000810c <Ifx_CircularBuffer_write32+0x1e>
8000810a:	82 02       	mov %d2,0
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
8000810c:	01 53 02 f6 	addsc.a %a15,%a5,%d3,2
80008110:	c2 13       	add %d3,1
80008112:	48 05       	ld.w %d5,[%a15]0
80008114:	10 2f       	addsc.a %a15,%a2,%d15,0
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;
80008116:	c2 4f       	add %d15,4
80008118:	37 0f 70 f0 	extr.u %d15,%d15,0,16
    const uint32 *source = (const uint32 *)data;
    uint8        *base   = buffer->base;

    do
    {
        *((uint32 *)(&base[buffer->index])) = *source;
8000811c:	68 05       	st.w [%a15]0,%d5
        source                              = &source[1];
        buffer->index                       = buffer->index + 4;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
8000811e:	0b 6f 30 51 	lt.u %d5,%d15,%d6
80008122:	ab 0f 80 f5 	sel %d15,%d5,%d15,0
        }

        count--;
    } while (count > 0);
80008126:	9f 02 f3 ff 	jned %d2,0,8000810c <Ifx_CircularBuffer_write32+0x1e>
8000812a:	c2 f4       	add %d4,-1
8000812c:	37 04 50 40 	extr %d4,%d4,0,16
80008130:	ac 42       	st.h [%a4]4,%d15
80008132:	8b 04 40 43 	max %d4,%d4,0
80008136:	c2 14       	add %d4,1

    return source;
}
80008138:	01 54 02 26 	addsc.a %a2,%a5,%d4,2
8000813c:	00 90       	ret 

8000813e <Ifx_Fifo_destroy>:
}


void Ifx_Fifo_destroy(Ifx_Fifo *fifo)
{
    free(fifo);
8000813e:	1d 00 52 21 	j 8000c3e2 <free>

80008142 <Ifx_Fifo_init>:
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
80008142:	82 0f       	mov %d15,0
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008144:	80 42       	mov.d %d2,%a4
    /* Check size over maximum FIFO size */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (size <= IFX_SIZET_MAX)); 

    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
80008146:	e9 4f 1c 00 	st.b [%a4]28,%d15
        fifo->eventWriter        = TRUE;
8000814a:	82 1f       	mov %d15,1
8000814c:	e9 4f 1d 00 	st.b [%a4]29,%d15
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80008150:	1b 72 02 f0 	addi %d15,%d2,39
80008154:	8f 7f c0 f1 	andn %d15,%d15,7
80008158:	6c 40       	st.w [%a4]0,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
8000815a:	c2 34       	add %d4,3
    {
        fifo                     = (Ifx_Fifo *)buffer;
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
8000815c:	82 0f       	mov %d15,0
8000815e:	ac 42       	st.h [%a4]4,%d15
        fifo->shared.maxcount    = 0;
80008160:	ac 48       	st.h [%a4]16,%d15

Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
80008162:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
80008166:	82 0f       	mov %d15,0
    free(fifo);
}


Ifx_Fifo *Ifx_Fifo_init(void *buffer, Ifx_SizeT size, Ifx_SizeT elementSize)
{
80008168:	40 42       	mov.aa %a2,%a4
        fifo->eventReader        = FALSE;
        fifo->eventWriter        = TRUE;
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
        fifo->shared.count       = 0;
        fifo->shared.maxcount    = 0;
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
8000816a:	6c 43       	st.w [%a4]12,%d15
8000816c:	6c 42       	st.w [%a4]8,%d15
        fifo->startIndex         = fifo->endIndex = 0;
8000816e:	ac 4b       	st.h [%a4]22,%d15
80008170:	ac 4a       	st.h [%a4]20,%d15
        fifo->size               = size;
80008172:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
80008176:	f9 45 1a 00 	st.h [%a4]26,%d5
    }

    return fifo;
}
8000817a:	00 90       	ret 

8000817c <Ifx_Fifo_create>:
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
8000817c:	c2 34       	add %d4,3
8000817e:	37 04 50 f0 	extr %d15,%d4,0,16
 * This is valid is an OS is used.
 *
 */
//------------------------------------------------------------------------------
Ifx_Fifo *Ifx_Fifo_create(Ifx_SizeT size, Ifx_SizeT elementSize)
{
80008182:	02 58       	mov %d8,%d5
    Ifx_Fifo *fifo = NULL_PTR;

    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80008184:	8f 3f c0 f1 	andn %d15,%d15,3

    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
80008188:	1b 8f 02 40 	addi %d4,%d15,40
8000818c:	6d 00 25 21 	call 8000c3d6 <malloc>
80008190:	40 24       	mov.aa %a4,%a2

    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
80008192:	bc 25       	jz.a %a2,8000819c <Ifx_Fifo_create+0x20>
    {
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
80008194:	0b f8 10 48 	mov %e4,%d8,%d15
80008198:	1d ff d5 ff 	j 80008142 <Ifx_Fifo_init>
    }

    return fifo;
}
8000819c:	00 90       	ret 

8000819e <Ifx_Fifo_canReadCount>:
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
8000819e:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be read from the buffer */
        result = FALSE;
800081a0:	82 02       	mov %d2,0
{
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);

    if ((count < fifo->elementSize) || (count > fifo->size))
800081a2:	3f f4 6a 00 	jlt %d4,%d15,80008276 <Ifx_Fifo_canReadCount+0xd8>
800081a6:	8c 4c       	ld.h %d15,[%a4]24
800081a8:	3f 4f 67 00 	jlt %d15,%d4,80008276 <Ifx_Fifo_canReadCount+0xd8>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800081ac:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
800081b0:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800081b4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800081b8:	00 00       	nop 
    else
    {
        boolean interruptState;
        sint32  waitCount;
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);
800081ba:	8c 42       	ld.h %d15,[%a4]4
800081bc:	a2 f4       	sub %d4,%d15

        if (waitCount <= 0)
800081be:	4e 4c       	jgtz %d4,800081d6 <Ifx_Fifo_canReadCount+0x38>
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE;
800081c0:	82 1f       	mov %d15,1
        interruptState = IfxCpu_disableInterrupts();
        waitCount      = count - Ifx_Fifo_readCount(fifo);

        if (waitCount <= 0)
        {
            fifo->shared.readerWaitx = 0;
800081c2:	59 42 08 00 	st.w [%a4]8,%d2
            fifo->eventReader        = TRUE;
800081c6:	e9 4f 1c 00 	st.b [%a4]28,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
800081ca:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800081cc:	df 00 55 00 	jeq %d0,0,80008276 <Ifx_Fifo_canReadCount+0xd8>
    {
        __enable();
800081d0:	0d 00 00 03 	enable 
800081d4:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800081d6:	82 f2       	mov %d2,-1
800081d8:	06 f2       	sh %d2,-1
800081da:	ba f6       	eq %d15,%d6,-1
800081dc:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
800081e0:	82 f5       	mov %d5,-1
800081e2:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
800081e4:	ee 16       	jnz %d15,80008210 <Ifx_Fifo_canReadCount+0x72>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800081e6:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800081ea:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800081ee:	0d 00 40 03 	disable 
800081f2:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800081f4:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800081f8:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800081fc:	02 15       	mov %d5,%d1
800081fe:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008202:	76 23       	jz %d2,80008208 <Ifx_Fifo_canReadCount+0x6a>
    {
        __enable();
80008204:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008208:	0b 65 40 50 	addx %d5,%d5,%d6
8000820c:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
80008210:	82 0f       	mov %d15,0
80008212:	e9 4f 1c 00 	st.b [%a4]28,%d15
            fifo->shared.readerWaitx = waitCount;
80008216:	59 44 08 00 	st.w [%a4]8,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000821a:	76 03       	jz %d0,80008220 <Ifx_Fifo_canReadCount+0x82>
    {
        __enable();
8000821c:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008220:	82 f6       	mov %d6,-1
80008222:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008224:	39 4f 1c 00 	ld.bu %d15,[%a4]28
80008228:	6e 08       	jz %d15,80008238 <Ifx_Fifo_canReadCount+0x9a>
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
            result = fifo->eventReader == TRUE;
8000822a:	39 42 1c 00 	ld.bu %d2,[%a4]28
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the reader is not waiting for any data */
            fifo->shared.readerWaitx = 0;
8000822e:	82 0f       	mov %d15,0
80008230:	6c 42       	st.w [%a4]8,%d15
            result = fifo->eventReader == TRUE;
80008232:	8b 12 00 22 	eq %d2,%d2,1
80008236:	00 90       	ret 
80008238:	ba f5       	eq %d15,%d5,-1
8000823a:	0b 36 00 f2 	and.eq %d15,%d6,%d3
8000823e:	ee f3       	jnz %d15,80008224 <Ifx_Fifo_canReadCount+0x86>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008240:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008244:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008248:	0d 00 40 03 	disable 
8000824c:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000824e:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008252:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008256:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000825a:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000825e:	76 23       	jz %d2,80008264 <Ifx_Fifo_canReadCount+0xc6>
    {
        __enable();
80008260:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventReader        = FALSE;
            fifo->shared.readerWaitx = waitCount;
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008264:	0b 3f 00 21 	eq %d2,%d15,%d3
80008268:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
8000826c:	0b 3f 90 22 	or.lt %d2,%d15,%d3
80008270:	df 02 da ff 	jne %d2,0,80008224 <Ifx_Fifo_canReadCount+0x86>
80008274:	3c db       	j 8000822a <Ifx_Fifo_canReadCount+0x8c>
            result = fifo->eventReader == TRUE;
        }
    }

    return result;
}
80008276:	00 90       	ret 

80008278 <Ifx_Fifo_read>:
    return count - blockSize;
}

#include <stdio.h>
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80008278:	20 08       	sub.a %sp,8
8000827a:	40 4f       	mov.aa %a15,%a4
8000827c:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
8000827e:	df 04 b6 00 	jeq %d4,0,800083ea <Ifx_Fifo_read+0x172>
    {

        buffer.base   = fifo->buffer;
80008282:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008284:	82 f2       	mov %d2,-1
80008286:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80008288:	8c 4c       	ld.h %d15,[%a4]24
8000828a:	06 f2       	sh %d2,-1
8000828c:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
8000828e:	8c 4a       	ld.h %d15,[%a4]20
    {
        deadLine = TIME_INFINITE;
80008290:	82 fa       	mov %d10,-1
80008292:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008294:	ba f6       	eq %d15,%d6,-1
80008296:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000829a:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
8000829c:	ee 16       	jnz %d15,800082c8 <Ifx_Fifo_read+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000829e:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800082a2:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800082a6:	0d 00 40 03 	disable 
800082aa:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800082ac:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800082b0:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800082b4:	02 3a       	mov %d10,%d3
800082b6:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800082ba:	76 23       	jz %d2,800082c0 <Ifx_Fifo_read+0x48>
    {
        __enable();
800082bc:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
800082c0:	0b 6a 40 a0 	addx %d10,%d10,%d6
800082c4:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800082c8:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_read(Ifx_Fifo *fifo, void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
800082ca:	82 0d       	mov %d13,0
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventReader        = FALSE;
800082cc:	82 0e       	mov %d14,0
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
800082ce:	a0 0c       	mov.a %a12,0
800082d0:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800082d2:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
800082d6:	37 04 e1 47 	extr.u %d4,%d4,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800082da:	0d 00 40 03 	disable 
800082de:	00 00       	nop 
{
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
800082e0:	88 2b       	ld.h %d11,[%a15]4
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800082e2:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
800082e6:	8c fd       	ld.h %d15,[%a15]26
800082e8:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventReader        = FALSE;
800082ec:	e9 fe 1c 00 	st.b [%a15]28,%d14
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800082f0:	4b f2 01 22 	div %e2,%d2,%d15
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800082f4:	88 c2       	ld.h %d2,[%a15]24
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
800082f6:	a2 3b       	sub %d11,%d3
800082f8:	37 0b 70 b0 	extr.u %d11,%d11,0,16
800082fc:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventReader        = FALSE;
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80008300:	0b f9 80 30 	sub %d3,%d9,%d15
80008304:	0b 23 80 21 	min %d2,%d3,%d2
80008308:	68 22       	st.w [%a15]8,%d2
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000830a:	76 43       	jz %d4,80008310 <Ifx_Fifo_read+0x98>
    {
        __enable();
8000830c:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginRead(fifo, count);

            if (blockSize != 0)
80008310:	6e 20       	jz %d15,80008350 <Ifx_Fifo_read+0xd8>
            {
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
80008312:	40 a4       	mov.aa %a4,%sp
80008314:	02 f4       	mov %d4,%d15
80008316:	6d ff 66 fe 	call 80007fe2 <Ifx_CircularBuffer_read8>
8000831a:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000831c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008320:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008324:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008328:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
8000832a:	88 23       	ld.h %d3,[%a15]4
8000832c:	a2 b3       	sub %d3,%d11
8000832e:	a8 23       	st.h [%a15]4,%d3

    if (fifo->shared.writerWaitx != 0)
80008330:	48 33       	ld.w %d3,[%a15]12
80008332:	76 39       	jz %d3,80008344 <Ifx_Fifo_read+0xcc>
    {
        fifo->shared.writerWaitx -= blockSize;
80008334:	5a f3       	sub %d15,%d3,%d15

        if (fifo->shared.writerWaitx <= 0)
80008336:	8e f3       	jlez %d15,8000833c <Ifx_Fifo_read+0xc4>

    fifo->shared.count -= blockSize;

    if (fifo->shared.writerWaitx != 0)
    {
        fifo->shared.writerWaitx -= blockSize;
80008338:	68 3f       	st.w [%a15]12,%d15
8000833a:	3c 05       	j 80008344 <Ifx_Fifo_read+0xcc>

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE; /* Signal the writer */
8000833c:	82 1f       	mov %d15,1
    {
        fifo->shared.writerWaitx -= blockSize;

        if (fifo->shared.writerWaitx <= 0)
        {
            fifo->shared.writerWaitx = 0;
8000833e:	e8 3c       	st.a [%a15]12,%a12
            fifo->eventWriter        = TRUE; /* Signal the writer */
80008340:	e9 ff 1d 00 	st.b [%a15]29,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008344:	76 23       	jz %d2,8000834a <Ifx_Fifo_read+0xd2>
    {
        __enable();
80008346:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
8000834a:	a2 b9       	sub %d9,%d11
8000834c:	37 09 50 90 	extr %d9,%d9,0,16
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008350:	76 d4       	jz %d13,80008358 <Ifx_Fifo_read+0xe0>
            {
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
80008352:	82 0f       	mov %d15,0
80008354:	68 2f       	st.w [%a15]8,%d15
                break;
80008356:	3c 48       	j 800083e6 <Ifx_Fifo_read+0x16e>
80008358:	ba fa       	eq %d15,%d10,-1
8000835a:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000835e:	ee 1b       	jnz %d15,80008394 <Ifx_Fifo_read+0x11c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008360:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008364:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008368:	0d 00 40 03 	disable 
8000836c:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000836e:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008372:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008376:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000837a:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000837e:	76 23       	jz %d2,80008384 <Ifx_Fifo_read+0x10c>
    {
        __enable();
80008380:	0d 00 00 03 	enable 
                /* read element from the buffer */
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008384:	0b 8f 00 21 	eq %d2,%d15,%d8
80008388:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
8000838c:	0b f8 90 22 	or.lt %d2,%d8,%d15
80008390:	df 02 e1 ff 	jne %d2,0,80008352 <Ifx_Fifo_read+0xda>
                /*When exiting, the reader is not waiting for any data */
                fifo->shared.readerWaitx = 0;
                break;
            }

            if (count != 0)
80008394:	df 09 29 00 	jeq %d9,0,800083e6 <Ifx_Fifo_read+0x16e>
            {
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008398:	39 ff 1c 00 	ld.bu %d15,[%a15]28
8000839c:	ee 1f       	jnz %d15,800083da <Ifx_Fifo_read+0x162>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000839e:	ba fa       	eq %d15,%d10,-1
800083a0:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
800083a4:	ee fa       	jnz %d15,80008398 <Ifx_Fifo_read+0x120>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083a6:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083aa:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083ae:	0d 00 40 03 	disable 
800083b2:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800083b4:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800083b8:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800083bc:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800083c0:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800083c4:	76 23       	jz %d2,800083ca <Ifx_Fifo_read+0x152>
    {
        __enable();
800083c6:	0d 00 00 03 	enable 
800083ca:	0b 8f 00 21 	eq %d2,%d15,%d8
800083ce:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
800083d2:	0b 8f 90 22 	or.lt %d2,%d15,%d8
800083d6:	df 02 e1 ff 	jne %d2,0,80008398 <Ifx_Fifo_read+0x120>
                {}

                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
800083da:	39 fd 1c 00 	ld.bu %d13,[%a15]28
800083de:	8b 0d 00 d2 	eq %d13,%d13,0
800083e2:	1d ff 78 ff 	j 800082d2 <Ifx_Fifo_read+0x5a>
            }
        } while (count != 0);

        fifo->startIndex = buffer.index;
800083e6:	8c a2       	ld.h %d15,[%sp]4
800083e8:	a8 af       	st.h [%a15]20,%d15
    }

    return count;
}
800083ea:	02 92       	mov %d2,%d9
800083ec:	00 90       	ret 

800083ee <Ifx_Fifo_clear>:
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800083ee:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800083f2:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800083f6:	0d 00 40 03 	disable 
800083fa:	00 00       	nop 
{
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();

    if (fifo->shared.writerWaitx != 0)
800083fc:	4c 43       	ld.w %d15,[%a4]12
800083fe:	6e 06       	jz %d15,8000840a <Ifx_Fifo_clear+0x1c>
    {
        fifo->shared.writerWaitx = 0;
80008400:	82 0f       	mov %d15,0
80008402:	6c 43       	st.w [%a4]12,%d15
        fifo->eventWriter        = TRUE; /* Signal the writer */
80008404:	82 1f       	mov %d15,1
80008406:	e9 4f 1d 00 	st.b [%a4]29,%d15
    }

    fifo->eventReader        = FALSE;
8000840a:	82 0f       	mov %d15,0
8000840c:	e9 4f 1c 00 	st.b [%a4]28,%d15
    fifo->shared.readerWaitx = 0;
80008410:	82 0f       	mov %d15,0
80008412:	6c 42       	st.w [%a4]8,%d15
    fifo->shared.count       = 0;
80008414:	ac 42       	st.h [%a4]4,%d15
    fifo->shared.maxcount    = 0;
80008416:	ac 48       	st.h [%a4]16,%d15
    fifo->startIndex         = fifo->endIndex;
80008418:	8c 4b       	ld.h %d15,[%a4]22
8000841a:	ac 4a       	st.h [%a4]20,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000841c:	76 23       	jz %d2,80008422 <Ifx_Fifo_clear+0x34>
    {
        __enable();
8000841e:	0d 00 00 03 	enable 
80008422:	00 90       	ret 

80008424 <Ifx_Fifo_canWriteCount>:
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008424:	8c 4d       	ld.h %d15,[%a4]26
    {                           /* Only complete elements can be written to the buffer */
        result = FALSE;
80008426:	82 02       	mov %d2,0
    boolean result;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);


    if ((count < fifo->elementSize) || (count > fifo->size))
80008428:	3f f4 75 00 	jlt %d4,%d15,80008512 <Ifx_Fifo_canWriteCount+0xee>
8000842c:	8c 4c       	ld.h %d15,[%a4]24
8000842e:	3f 4f 72 00 	jlt %d15,%d4,80008512 <Ifx_Fifo_canWriteCount+0xee>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008432:	4d c0 e2 0f 	mfcr %d0,$icr
    return reg.B.IE != 0;
80008436:	37 00 e1 07 	extr.u %d0,%d0,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000843a:	0d 00 40 03 	disable 
8000843e:	00 00       	nop 
    else
    {
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
80008440:	c9 43 18 00 	ld.h %d3,[%a4]24
80008444:	8c 42       	ld.h %d15,[%a4]4
80008446:	5a f3       	sub %d15,%d3,%d15
80008448:	3f 4f 0d 00 	jlt %d15,%d4,80008462 <Ifx_Fifo_canWriteCount+0x3e>
        {
            fifo->shared.writerWaitx = 0;
            fifo->eventWriter        = TRUE;
8000844c:	82 1f       	mov %d15,1
        boolean interruptState;
        interruptState = IfxCpu_disableInterrupts();

        if ((fifo->size - Ifx_Fifo_readCount(fifo)) >= count)
        {
            fifo->shared.writerWaitx = 0;
8000844e:	59 42 0c 00 	st.w [%a4]12,%d2
            fifo->eventWriter        = TRUE;
80008452:	e9 4f 1d 00 	st.b [%a4]29,%d15
            IfxCpu_restoreInterrupts(interruptState);
            result                   = TRUE;
80008456:	82 12       	mov %d2,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008458:	df 00 5d 00 	jeq %d0,0,80008512 <Ifx_Fifo_canWriteCount+0xee>
    {
        __enable();
8000845c:	0d 00 00 03 	enable 
80008460:	00 90       	ret 

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008462:	82 f2       	mov %d2,-1
80008464:	06 f2       	sh %d2,-1
80008466:	ba f6       	eq %d15,%d6,-1
80008468:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
8000846c:	82 f5       	mov %d5,-1
8000846e:	02 23       	mov %d3,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008470:	ee 16       	jnz %d15,8000849c <Ifx_Fifo_canWriteCount+0x78>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008472:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008476:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000847a:	0d 00 40 03 	disable 
8000847e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008480:	85 f1 10 00 	ld.w %d1,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008484:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008488:	02 15       	mov %d5,%d1
8000848a:	b7 0f 81 3f 	insert %d3,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000848e:	76 23       	jz %d2,80008494 <Ifx_Fifo_canWriteCount+0x70>
    {
        __enable();
80008490:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80008494:	0b 65 40 50 	addx %d5,%d5,%d6
80008498:	0b 73 50 30 	addc %d3,%d3,%d7
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
8000849c:	82 0f       	mov %d15,0
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
8000849e:	c9 42 04 00 	ld.h %d2,[%a4]4
            result                   = TRUE;
        }
        else
        {
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
800084a2:	e9 4f 1d 00 	st.b [%a4]29,%d15
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
800084a6:	8c 4c       	ld.h %d15,[%a4]24
800084a8:	5a f2       	sub %d15,%d2,%d15
800084aa:	42 f4       	add %d4,%d15
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800084ac:	82 02       	mov %d2,0
800084ae:	0b 42 a0 41 	max %d4,%d2,%d4
800084b2:	59 44 0c 00 	st.w [%a4]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084b6:	76 03       	jz %d0,800084bc <Ifx_Fifo_canWriteCount+0x98>
    {
        __enable();
800084b8:	0d 00 00 03 	enable 

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
800084bc:	82 f6       	mov %d6,-1
800084be:	06 f6       	sh %d6,-1
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
800084c0:	39 4f 1d 00 	ld.bu %d15,[%a4]29
800084c4:	6e 08       	jz %d15,800084d4 <Ifx_Fifo_canWriteCount+0xb0>
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
            result = fifo->eventWriter == TRUE;
800084c6:	39 42 1d 00 	ld.bu %d2,[%a4]29
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
            {}
            /* After the timeout, the writer is not waiting for any space */
            fifo->shared.writerWaitx = 0;
800084ca:	82 0f       	mov %d15,0
800084cc:	6c 43       	st.w [%a4]12,%d15
            result = fifo->eventWriter == TRUE;
800084ce:	8b 12 00 22 	eq %d2,%d2,1
800084d2:	00 90       	ret 
800084d4:	ba f5       	eq %d15,%d5,-1
800084d6:	0b 36 00 f2 	and.eq %d15,%d6,%d3
800084da:	ee f3       	jnz %d15,800084c0 <Ifx_Fifo_canWriteCount+0x9c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800084dc:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
800084e0:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800084e4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800084e8:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800084ea:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
800084ee:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
800084f2:	8f 04 40 41 	or %d4,%d4,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
800084f6:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800084fa:	76 23       	jz %d2,80008500 <Ifx_Fifo_canWriteCount+0xdc>
    {
        __enable();
800084fc:	0d 00 00 03 	enable 
            Ifx_TickTime DeadLine = IfxStm_getDeadLine(timeout);
            fifo->eventWriter        = FALSE;
            fifo->shared.writerWaitx = __max(0, count - (fifo->size - Ifx_Fifo_readCount(fifo)));
            IfxCpu_restoreInterrupts(interruptState);

            while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008500:	0b 3f 00 21 	eq %d2,%d15,%d3
80008504:	0b 54 30 22 	and.lt.u %d2,%d4,%d5
80008508:	0b 3f 90 22 	or.lt %d2,%d15,%d3
8000850c:	df 02 da ff 	jne %d2,0,800084c0 <Ifx_Fifo_canWriteCount+0x9c>
80008510:	3c db       	j 800084c6 <Ifx_Fifo_canWriteCount+0xa2>
            result = fifo->eventWriter == TRUE;
        }
    }

    return result;
}
80008512:	00 90       	ret 

80008514 <Ifx_Fifo_write>:
}


#include <stdio.h>
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80008514:	20 08       	sub.a %sp,8
80008516:	40 4f       	mov.aa %a15,%a4
80008518:	02 49       	mov %d9,%d4
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
8000851a:	df 04 be 00 	jeq %d4,0,80008696 <Ifx_Fifo_write+0x182>
    {
        buffer.base   = fifo->buffer;
8000851e:	4c 40       	ld.w %d15,[%a4]0

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008520:	82 f2       	mov %d2,-1
80008522:	78 00       	st.w [%sp]0,%d15
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80008524:	8c 4c       	ld.h %d15,[%a4]24
80008526:	06 f2       	sh %d2,-1
80008528:	ac a3       	st.h [%sp]6,%d15
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
8000852a:	8c 4b       	ld.h %d15,[%a4]22
    {
        deadLine = TIME_INFINITE;
8000852c:	82 fa       	mov %d10,-1
8000852e:	ac a2       	st.h [%sp]4,%d15

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008530:	ba f6       	eq %d15,%d6,-1
80008532:	0b 72 00 f2 	and.eq %d15,%d2,%d7
    {
        deadLine = TIME_INFINITE;
80008536:	02 28       	mov %d8,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80008538:	ee 16       	jnz %d15,80008564 <Ifx_Fifo_write+0x50>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000853a:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
8000853e:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008542:	0d 00 40 03 	disable 
80008546:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008548:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000854c:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008550:	02 3a       	mov %d10,%d3
80008552:	b7 0f 81 8f 	insert %d8,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008556:	76 23       	jz %d2,8000855c <Ifx_Fifo_write+0x48>
    {
        __enable();
80008558:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
8000855c:	0b 6a 40 a0 	addx %d10,%d10,%d6
80008560:	0b 78 50 80 	addc %d8,%d8,%d7

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
80008564:	82 fc       	mov %d12,-1
Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
    Ifx_TickTime       DeadLine;
    Ifx_SizeT          blockSize;
    Ifx_CircularBuffer buffer;
    boolean            Stop = FALSE;
80008566:	82 0d       	mov %d13,0
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
    fifo->eventWriter        = FALSE;
80008568:	82 0e       	mov %d14,0
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
8000856a:	a0 0c       	mov.a %a12,0
8000856c:	06 fc       	sh %d12,-1
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000856e:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80008572:	37 05 e1 57 	extr.u %d5,%d5,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008576:	0d 00 40 03 	disable 
8000857a:	00 00       	nop 
{
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
8000857c:	88 c4       	ld.h %d4,[%a15]24
8000857e:	88 2b       	ld.h %d11,[%a15]4
80008580:	0b b4 80 b0 	sub %d11,%d4,%d11
/** Return minimum of two integers
 */
IFX_INLINE sint32 Ifx__min(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80008584:	0b b9 80 b1 	min %d11,%d9,%d11
    blockSize               -= blockSize % fifo->elementSize;
80008588:	8c fd       	ld.h %d15,[%a15]26
8000858a:	37 0b 50 20 	extr %d2,%d11,0,16
    fifo->eventWriter        = FALSE;
8000858e:	e9 fe 1d 00 	st.b [%a15]29,%d14
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
    blockSize               -= blockSize % fifo->elementSize;
80008592:	4b f2 01 22 	div %e2,%d2,%d15
80008596:	a2 3b       	sub %d11,%d3
80008598:	37 0b 70 b0 	extr.u %d11,%d11,0,16
8000859c:	37 0b 50 f0 	extr %d15,%d11,0,16
    fifo->eventWriter        = FALSE;
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
800085a0:	0b f9 80 20 	sub %d2,%d9,%d15
800085a4:	0b 42 80 41 	min %d4,%d2,%d4
800085a8:	68 34       	st.w [%a15]12,%d4
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085aa:	76 53       	jz %d5,800085b0 <Ifx_Fifo_write+0x9c>
    {
        __enable();
800085ac:	0d 00 00 03 	enable 

        do
        {
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
800085b0:	6e 26       	jz %d15,800085fc <Ifx_Fifo_write+0xe8>
            {

                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
800085b2:	40 a4       	mov.aa %a4,%sp
800085b4:	02 f4       	mov %d4,%d15
800085b6:	6d ff 6d fd 	call 80008090 <Ifx_CircularBuffer_write8>
800085ba:	40 25       	mov.aa %a5,%a2
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800085bc:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800085c0:	37 03 e1 37 	extr.u %d3,%d3,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800085c4:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800085c8:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800085ca:	88 22       	ld.h %d2,[%a15]4
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800085cc:	88 84       	ld.h %d4,[%a15]16
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800085ce:	42 b2       	add %d2,%d11
800085d0:	37 02 50 20 	extr %d2,%d2,0,16
800085d4:	a8 22       	st.h [%a15]4,%d2
/** Return maximum of two integers
 */
IFX_INLINE sint32 Ifx__max(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800085d6:	0b 24 a0 21 	max %d2,%d4,%d2
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800085da:	a8 82       	st.h [%a15]16,%d2

    if (fifo->shared.readerWaitx != 0)
800085dc:	48 22       	ld.w %d2,[%a15]8
800085de:	76 29       	jz %d2,800085f0 <Ifx_Fifo_write+0xdc>
    {
        fifo->shared.readerWaitx -= blockSize;
800085e0:	5a f2       	sub %d15,%d2,%d15

        if (fifo->shared.readerWaitx <= 0)
800085e2:	8e f3       	jlez %d15,800085e8 <Ifx_Fifo_write+0xd4>
    fifo->shared.count   += blockSize;
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */

    if (fifo->shared.readerWaitx != 0)
    {
        fifo->shared.readerWaitx -= blockSize;
800085e4:	68 2f       	st.w [%a15]8,%d15
800085e6:	3c 05       	j 800085f0 <Ifx_Fifo_write+0xdc>

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800085e8:	82 1f       	mov %d15,1
    {
        fifo->shared.readerWaitx -= blockSize;

        if (fifo->shared.readerWaitx <= 0)
        {
            fifo->shared.readerWaitx = 0;
800085ea:	e8 2c       	st.a [%a15]8,%a12
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800085ec:	e9 ff 1c 00 	st.b [%a15]28,%d15
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800085f0:	76 33       	jz %d3,800085f6 <Ifx_Fifo_write+0xe2>
    {
        __enable();
800085f2:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800085f6:	a2 b9       	sub %d9,%d11
800085f8:	37 09 50 90 	extr %d9,%d9,0,16
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
800085fc:	76 d4       	jz %d13,80008604 <Ifx_Fifo_write+0xf0>
            {
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
800085fe:	82 0f       	mov %d15,0
80008600:	68 3f       	st.w [%a15]12,%d15
                break;
80008602:	3c 48       	j 80008692 <Ifx_Fifo_write+0x17e>
80008604:	ba fa       	eq %d15,%d10,-1
80008606:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
8000860a:	ee 1b       	jnz %d15,80008640 <Ifx_Fifo_write+0x12c>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000860c:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008610:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80008614:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80008618:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
8000861a:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
8000861e:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008622:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80008626:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000862a:	76 23       	jz %d2,80008630 <Ifx_Fifo_write+0x11c>
    {
        __enable();
8000862c:	0d 00 00 03 	enable 
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80008630:	0b 8f 00 21 	eq %d2,%d15,%d8
80008634:	0b a3 50 22 	and.ge.u %d2,%d3,%d10
80008638:	0b f8 90 22 	or.lt %d2,%d8,%d15
8000863c:	df 02 e1 ff 	jne %d2,0,800085fe <Ifx_Fifo_write+0xea>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
80008640:	df 09 29 00 	jeq %d9,0,80008692 <Ifx_Fifo_write+0x17e>
            {
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80008644:	39 ff 1d 00 	ld.bu %d15,[%a15]29
80008648:	ee 1f       	jnz %d15,80008686 <Ifx_Fifo_write+0x172>

IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
8000864a:	ba fa       	eq %d15,%d10,-1
8000864c:	0b 8c 00 f2 	and.eq %d15,%d12,%d8
80008650:	ee fa       	jnz %d15,80008644 <Ifx_Fifo_write+0x130>
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80008652:	4d c0 e2 2f 	mfcr %d2,$icr
    return reg.B.IE != 0;
80008656:	37 02 e1 27 	extr.u %d2,%d2,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000865a:	0d 00 40 03 	disable 
8000865e:	00 00       	nop 

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80008660:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x3fff8010>
    result |= ((uint64)stm->CAP.U) << 32;
80008664:	85 ff 2c 00 	ld.w %d15,f000002c <_SMALL_DATA4_+0x3fff802c>
80008668:	8f 03 40 31 	or %d3,%d3,0
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
8000866c:	b7 0f 81 ff 	insert %d15,%d15,0,31,1
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80008670:	76 23       	jz %d2,80008676 <Ifx_Fifo_write+0x162>
    {
        __enable();
80008672:	0d 00 00 03 	enable 
80008676:	0b 8f 00 21 	eq %d2,%d15,%d8
8000867a:	0b a3 30 22 	and.lt.u %d2,%d3,%d10
8000867e:	0b 8f 90 22 	or.lt %d2,%d15,%d8
80008682:	df 02 e1 ff 	jne %d2,0,80008644 <Ifx_Fifo_write+0x130>
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
80008686:	39 fd 1d 00 	ld.bu %d13,[%a15]29
8000868a:	8b 0d 00 d2 	eq %d13,%d13,0
8000868e:	1d ff 70 ff 	j 8000856e <Ifx_Fifo_write+0x5a>
            }
        } while (count != 0);

        fifo->endIndex = buffer.index;
80008692:	8c a2       	ld.h %d15,[%sp]4
80008694:	a8 bf       	st.h [%a15]22,%d15
    }

    return count;
}
80008696:	02 92       	mov %d2,%d9
80008698:	00 90       	ret 

8000869a <osEE_tc_core0_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000869a:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
8000869e:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086a2:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800086a6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086aa:	54 25       	ld.w %d5,[%a2]
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800086ac:	48 08       	ld.w %d8,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086ae:	37 05 6e 51 	extr.u %d5,%d5,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
800086b2:	37 08 6e 81 	extr.u %d8,%d8,2,14
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
800086b6:	91 20 00 f7 	movh.a %a15,28674
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800086ba:	8f f5 83 51 	xor %d5,%d5,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
800086be:	8f f8 83 81 	xor %d8,%d8,63
800086c2:	d9 ff 40 89 	lea %a15,[%a15]-27136 <70019600 <__USTACK0>>
800086c6:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
800086c8:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
800086cc:	3b 00 b8 f0 	mov %d15,2944
800086d0:	cd 4f e0 0f 	mtcr $psw,%d15
800086d4:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
800086d8:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
800086dc:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
800086e0:	cd 0f e0 0f 	mtcr $pcxi,%d15
800086e4:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800086e8:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800086ec:	82 12       	mov %d2,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
800086ee:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
800086f2:	cd 42 20 09 	mtcr $pcon1,%d2
800086f6:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
800086fa:	53 cf 20 f0 	mul %d15,%d15,12
800086fe:	10 22       	addsc.a %a2,%a2,%d15,0
80008700:	54 22       	ld.w %d2,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008702:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008704:	37 02 6e 21 	extr.u %d2,%d2,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008708:	d9 2f 00 46 	lea %a15,[%a2]24832
8000870c:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008710:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008712:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008716:	2e 16       	jz.t %d15,1,80008722 <osEE_tc_core0_start+0x88>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008718:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000871c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008720:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008722:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008726:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000872a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000872c:	4c f0       	ld.w %d15,[%a15]0
8000872e:	6f 0f ff ff 	jnz.t %d15,0,8000872c <osEE_tc_core0_start+0x92>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008732:	82 0f       	mov %d15,0
80008734:	cd cf 20 09 	mtcr $pcon0,%d15
80008738:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
8000873c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
8000873e:	2e 16       	jz.t %d15,1,8000874a <osEE_tc_core0_start+0xb0>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008740:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008744:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008748:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000874a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
8000874e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008752:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008754:	4c f0       	ld.w %d15,[%a15]0
80008756:	6f 0f ff 7f 	jz.t %d15,0,80008754 <osEE_tc_core0_start+0xba>
8000875a:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
8000875e:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008762:	91 30 00 ff 	movh.a %a15,61443
80008766:	53 cf 20 f0 	mul %d15,%d15,12
8000876a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000876e:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008770:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008772:	48 02       	ld.w %d2,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008774:	d9 2f 00 46 	lea %a15,[%a2]24832
80008778:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
8000877c:	37 02 6e 21 	extr.u %d2,%d2,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008780:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008782:	8f f2 83 21 	xor %d2,%d2,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008786:	2e 16       	jz.t %d15,1,80008792 <osEE_tc_core0_start+0xf8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008788:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000878c:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008790:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008792:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008796:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000879a:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000879c:	4c f0       	ld.w %d15,[%a15]0
8000879e:	6f 0f ff ff 	jnz.t %d15,0,8000879c <osEE_tc_core0_start+0x102>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
800087a2:	82 0f       	mov %d15,0
800087a4:	cd 0f 04 09 	mtcr $dcon0,%d15
800087a8:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800087ac:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800087ae:	2e 16       	jz.t %d15,1,800087ba <osEE_tc_core0_start+0x120>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800087b0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800087b4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800087b8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800087ba:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800087be:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800087c2:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800087c4:	4c f0       	ld.w %d15,[%a15]0
800087c6:	6f 0f ff 7f 	jz.t %d15,0,800087c4 <osEE_tc_core0_start+0x12a>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800087ca:	91 30 00 ff 	movh.a %a15,61443
800087ce:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087d2:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800087d4:	2e 16       	jz.t %d15,1,800087e0 <osEE_tc_core0_start+0x146>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800087d6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800087da:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800087de:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800087e0:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800087e4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800087e8:	91 30 00 ff 	movh.a %a15,61443
800087ec:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087f0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800087f2:	4c f0       	ld.w %d15,[%a15]0
800087f4:	91 30 00 2f 	movh.a %a2,61443
800087f8:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800087fc:	6f 0f fb ff 	jnz.t %d15,0,800087f2 <osEE_tc_core0_start+0x158>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(0U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB0);
80008800:	7b 00 00 f8 	movh %d15,32768
80008804:	1b 0f 30 f1 	addi %d15,%d15,4864
80008808:	cd 4f e2 0f 	mtcr $btv,%d15
8000880c:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB0);
80008810:	7b 00 00 f8 	movh %d15,32768
80008814:	1b 0f 00 f2 	addi %d15,%d15,8192
80008818:	cd 0f e2 0f 	mtcr $biv,%d15
8000881c:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK0);
80008820:	7b 20 00 f7 	movh %d15,28674
80008824:	1b 0f b0 f9 	addi %d15,%d15,-25856
80008828:	cd 8f e2 0f 	mtcr $isp,%d15
8000882c:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008830:	4c 20       	ld.w %d15,[%a2]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008832:	2e 16       	jz.t %d15,1,8000883e <osEE_tc_core0_start+0x1a4>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008834:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008838:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000883c:	6c 20       	st.w [%a2]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
8000883e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008842:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008846:	91 30 00 ff 	movh.a %a15,61443
8000884a:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
8000884e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008850:	4c f0       	ld.w %d15,[%a15]0
80008852:	6f 0f ff 7f 	jz.t %d15,0,80008850 <osEE_tc_core0_start+0x1b6>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(0U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80008856:	91 10 00 f7 	movh.a %a15,28673
8000885a:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
8000885e:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80008860:	91 10 00 f8 	movh.a %a15,32769
80008864:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008868:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000886a:	91 10 00 f8 	movh.a %a15,32769
8000886e:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008872:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_SINGLECORE)) || (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core0);
80008874:	91 00 00 f8 	movh.a %a15,32768
80008878:	d9 ff 1c 70 	lea %a15,[%a15]476 <800001dc <osEE_cdb_var_core0>>
8000887c:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
8000887e:	7b 20 00 f7 	movh %d15,28674
80008882:	7b 20 00 47 	movh %d4,28674
80008886:	1b 0f c0 69 	addi %d6,%d15,-25600
8000888a:	1b 04 c0 4b 	addi %d4,%d4,-17408
8000888e:	a2 64       	sub %d4,%d6
80008890:	86 a4       	sha %d4,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80008892:	82 02       	mov %d2,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80008894:	df 04 16 00 	jeq %d4,0,800088c0 <osEE_tc_core0_start+0x226>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80008898:	9a f4       	add %d15,%d4,-1
8000889a:	06 6f       	sh %d15,6
8000889c:	12 63       	add %d3,%d15,%d6

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000889e:	60 3f       	mov.a %a15,%d3
800088a0:	82 00       	mov %d0,0
800088a2:	68 00       	st.w [%a15]0,%d0
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
800088a4:	60 4f       	mov.a %a15,%d4
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
800088a6:	8f 43 1e 20 	sh %d2,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
800088aa:	37 03 70 73 	extr.u %d7,%d3,6,16
800088ae:	1b 0f fc ff 	addi %d15,%d15,-64

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
800088b2:	b0 ff       	add.a %a15,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
800088b4:	37 27 10 28 	insert %d2,%d7,%d2,16,16
800088b8:	42 6f       	add %d15,%d6

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
800088ba:	82 53       	mov %d3,5
800088bc:	fd f0 11 01 	loop %a15,80008ade <osEE_tc_core0_start+0x444>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
800088c0:	cd 82 e3 0f 	mtcr $fcx,%d2
800088c4:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800088c8:	91 30 00 ff 	movh.a %a15,61443
800088cc:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088d0:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800088d2:	2e 16       	jz.t %d15,1,800088de <osEE_tc_core0_start+0x244>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800088d4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800088d8:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800088dc:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
800088de:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
800088e2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800088e6:	91 30 00 ff 	movh.a %a15,61443
800088ea:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088ee:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
800088f0:	40 f2       	mov.aa %a2,%a15
800088f2:	4c 20       	ld.w %d15,[%a2]0
800088f4:	91 30 00 ff 	movh.a %a15,61443
800088f8:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800088fc:	6f 0f fb ff 	jnz.t %d15,0,800088f2 <osEE_tc_core0_start+0x258>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
80008900:	4c f1       	ld.w %d15,[%a15]4
80008902:	96 08       	or %d15,8
80008904:	68 1f       	st.w [%a15]4,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008906:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008908:	2e 16       	jz.t %d15,1,80008914 <osEE_tc_core0_start+0x27a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
8000890a:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
8000890e:	37 5f 0e f1 	insert %d15,%d15,%d5,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008912:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008914:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008918:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
8000891c:	91 30 00 ff 	movh.a %a15,61443
80008920:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008924:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008926:	4c f0       	ld.w %d15,[%a15]0
80008928:	6f 0f ff 7f 	jz.t %d15,0,80008926 <osEE_tc_core0_start+0x28c>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000892c:	91 30 00 ff 	movh.a %a15,61443
80008930:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008934:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008936:	2e 16       	jz.t %d15,1,80008942 <osEE_tc_core0_start+0x2a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008938:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
8000893c:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008940:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008942:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008946:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
8000894a:	91 30 00 ff 	movh.a %a15,61443
8000894e:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008952:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008954:	40 f2       	mov.aa %a2,%a15
80008956:	4c 20       	ld.w %d15,[%a2]0
80008958:	91 30 00 ff 	movh.a %a15,61443
8000895c:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008960:	6f 0f fb ff 	jnz.t %d15,0,80008956 <osEE_tc_core0_start+0x2bc>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80008964:	4c f1       	ld.w %d15,[%a15]4
80008966:	96 08       	or %d15,8
80008968:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
8000896a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
8000896c:	2e 16       	jz.t %d15,1,80008978 <osEE_tc_core0_start+0x2de>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
8000896e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008972:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008976:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008978:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
8000897c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008980:	91 30 00 ff 	movh.a %a15,61443
80008984:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008988:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
8000898a:	4c f0       	ld.w %d15,[%a15]0
8000898c:	6f 0f ff 7f 	jz.t %d15,0,8000898a <osEE_tc_core0_start+0x2f0>
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80008990:	91 00 00 48 	movh.a %a4,32768
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
        *block_to_clear.p_ull = 0ULL;
80008994:	d2 02       	mov %e2,0
static void osEE_tc_apply_clear_table
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
80008996:	d9 44 28 61 	lea %a4,[%a4]4520 <800011a8 <__clear_table>>
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
        *block_to_clear.p_ui = 0x0U;
8000899a:	82 07       	mov %d7,0
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
        *block_to_clear.p_us = 0x0U;
8000899c:	82 06       	mov %d6,0
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
        *block_to_clear.p_uc = 0x0U;
8000899e:	82 05       	mov %d5,0

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
800089a0:	4c 41       	ld.w %d15,[%a4]4
  while (p_clear_table != NULL) {
    OsEE_tc_init_table_entry_ptr  block_to_clear;
    MemSize                       table_entry_length;

/* Get pointer to the block to be cleared */
    block_to_clear = p_clear_table->block_to_clear;
800089a2:	d4 43       	ld.a %a3,[%a4]

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_clear_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
800089a4:	9e f6       	jeq %d15,-1,800089d0 <osEE_tc_core0_start+0x336>
/* Prepare to clear as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
800089a6:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
800089aa:	76 49       	jz %d4,800089bc <osEE_tc_core0_start+0x322>
        *block_to_clear.p_ull = 0ULL;
800089ac:	60 4f       	mov.a %a15,%d4
800089ae:	40 32       	mov.aa %a2,%a3
800089b0:	b0 ff       	add.a %a15,-1
800089b2:	89 22 48 01 	st.d [%a2+]8,%e2
800089b6:	fc fe       	loop %a15,800089b2 <osEE_tc_core0_start+0x318>
800089b8:	01 34 03 36 	addsc.a %a3,%a3,%d4,3
        ++block_to_clear.p_ull;
        --ull_cnt;
      }

/*  Clear the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
800089bc:	2e 22       	jz.t %d15,2,800089c0 <osEE_tc_core0_start+0x326>
        *block_to_clear.p_ui = 0x0U;
800089be:	64 37       	st.w [%a3+],%d7
        ++block_to_clear.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
800089c0:	2e 12       	jz.t %d15,1,800089c4 <osEE_tc_core0_start+0x32a>
        *block_to_clear.p_us = 0x0U;
800089c2:	a4 36       	st.h [%a3+],%d6
        ++block_to_clear.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
800089c4:	2e 02       	jz.t %d15,0,800089c8 <osEE_tc_core0_start+0x32e>
        *block_to_clear.p_uc = 0x0U;
800089c6:	34 35       	st.b [%a3],%d5
      }

/* Prepare the table pointer for the next iteration */
      ++p_clear_table;
800089c8:	d9 44 08 00 	lea %a4,[%a4]8 <80000008 <BootModeHeader0+0x8>>
(
    const OsEE_tc_clear_table * p_clear_table_param
)
{
  const OsEE_tc_clear_table * p_clear_table = p_clear_table_param;
  while (p_clear_table != NULL) {
800089cc:	bd 04 ea ff 	jnz.a %a4,800089a0 <osEE_tc_core0_start+0x306>
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);

      while (ull_cnt != 0U) {
800089d0:	91 00 00 68 	movh.a %a6,32768
800089d4:	d9 66 10 81 	lea %a6,[%a6]4624 <80001210 <__copy_table>>

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
800089d8:	4c 62       	ld.w %d15,[%a6]8
    OsEE_tc_init_table_entry_ptr  block_src;
    OsEE_tc_init_table_entry_ptr  block_dest;
    MemSize                       table_entry_length;

/* Get pointer to the data source block */
    block_src = p_copy_table->block_src;
800089da:	d4 65       	ld.a %a5,[%a6]

/* Get pointer to the data destination block */
    block_dest = p_copy_table->block_dest;
800089dc:	99 64 04 00 	ld.a %a4,[%a6]4 <80000004 <BootModeHeader0+0x4>>

/* Get the lenght of the table entry (in bytes) */
    table_entry_length = p_copy_table->table_entry_length;
    
/* We have finished when length == -1 */
    if (table_entry_length != 0xFFFFFFFFU) {
800089e0:	df ff 21 00 	jeq %d15,-1,80008a22 <osEE_tc_core0_start+0x388>
/* Prepare to copy as much unsigned long long as you can... */
      MemSize ull_cnt = table_entry_length / sizeof(uint64_t);
800089e4:	8f df 1f 40 	sh %d4,%d15,-3

      while (ull_cnt != 0U) {
800089e8:	76 4f       	jz %d4,80008a06 <osEE_tc_core0_start+0x36c>
800089ea:	60 4f       	mov.a %a15,%d4
800089ec:	40 43       	mov.aa %a3,%a4
800089ee:	40 52       	mov.aa %a2,%a5
800089f0:	b0 ff       	add.a %a15,-1
        *block_dest.p_ull = *block_src.p_ull;
800089f2:	09 22 48 01 	ld.d %e2,[%a2+]8
800089f6:	89 32 48 01 	st.d [%a3+]8,%e2
800089fa:	fc fc       	loop %a15,800089f2 <osEE_tc_core0_start+0x358>
800089fc:	06 34       	sh %d4,3
800089fe:	01 54 00 56 	addsc.a %a5,%a5,%d4,0
80008a02:	01 44 00 46 	addsc.a %a4,%a4,%d4,0
        ++block_dest.p_ull;
        --ull_cnt;
      }

/* Copy the remaning bytes */
      if (((table_entry_length) & 0x4U) != 0U) {
80008a06:	2e 23       	jz.t %d15,2,80008a0c <osEE_tc_core0_start+0x372>
        *block_dest.p_ui = *block_src.p_ui;
80008a08:	44 52       	ld.w %d2,[%a5+]
80008a0a:	64 42       	st.w [%a4+],%d2
        ++block_src.p_ui;
        ++block_dest.p_ui;
      }

      if (((table_entry_length) & 0x2U) != 0U) {
80008a0c:	2e 14       	jz.t %d15,1,80008a14 <osEE_tc_core0_start+0x37a>
        *block_dest.p_us = *block_src.p_us;
80008a0e:	09 52 c2 00 	ld.hu %d2,[%a5+]2
80008a12:	a4 42       	st.h [%a4+],%d2
        ++block_src.p_us;
        ++block_dest.p_us;
      }

      if (((table_entry_length) & 0x1U) != 0U) {
80008a14:	2e 03       	jz.t %d15,0,80008a1a <osEE_tc_core0_start+0x380>
        *block_dest.p_uc = *block_src.p_uc;
80008a16:	0c 50       	ld.bu %d15,[%a5]0
80008a18:	2c 40       	st.b [%a4]0,%d15
      }

/* Prepare the table pointer for the next iteration */
      ++p_copy_table;
80008a1a:	d9 66 0c 00 	lea %a6,[%a6]12 <8000000c <BootModeHeader0+0xc>>
(
  const OsEE_tc_copy_table * p_copy_table_param
)
{
  const OsEE_tc_copy_table * p_copy_table = p_copy_table_param;
  while (p_copy_table != NULL) {
80008a1e:	bd 06 dd ff 	jnz.a %a6,800089d8 <osEE_tc_core0_start+0x33e>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008a22:	91 30 00 ff 	movh.a %a15,61443
80008a26:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008a2a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008a2c:	2e 16       	jz.t %d15,1,80008a38 <osEE_tc_core0_start+0x39e>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008a2e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008a32:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008a36:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008a38:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008a3c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008a40:	91 30 00 ff 	movh.a %a15,61443
80008a44:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008a48:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008a4a:	4c f0       	ld.w %d15,[%a15]0
80008a4c:	6f 0f ff ff 	jnz.t %d15,0,80008a4a <osEE_tc_core0_start+0x3b0>
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON8_OFF) = OSEE_TC_SCU_CCUCON8_INIT;
#endif /* OSEE_TC_SCU_CCUCON8_INIT */

/* BUS Divisors */
/* Configure CCUCON0 */
  OSEE_TC_SCU_CCUCON0.reg = OSEE_TC_SCU_CCUCON0_INIT;
80008a50:	7b 20 22 f1 	movh %d15,4642
80008a54:	91 30 00 ff 	movh.a %a15,61443
80008a58:	1b 1f 10 f0 	addi %d15,%d15,257
80008a5c:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
80008a60:	68 0f       	st.w [%a15]0,%d15
#if (defined(OSEE_TC_SCU_CCUCON5_INIT))
  OSEE_TC_SCU_REG(OSEE_TC_SCU_CCUCON5_OFF) = OSEE_TC_SCU_CCUCON5_INIT;
#endif /* OSEE_TC_SCU_CCUCON5_INIT */
/* Configure CCUCON1 and Update CCU 0, 1 & 5. Forced INSEL to 1 even for
   external configuration, otherwise PLL initialization won't work. */
  OSEE_TC_SCU_CCUCON1.reg = OSEE_TC_SCU_CCUCON1_INIT |
80008a62:	7b 00 00 f5 	movh %d15,20480
80008a66:	91 30 00 ff 	movh.a %a15,61443
80008a6a:	1b 0f 10 f1 	addi %d15,%d15,4352
80008a6e:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
80008a72:	68 0f       	st.w [%a15]0,%d15
{
  /*
   * Default System Oscillator Configuration
   * MODE:    0   -> External Crystal
   */
  OSEE_TC_SCU_OSCCON.reg = OSEE_TC_SCU_OSCCON_OSCRES |
80008a74:	7b 70 00 f0 	movh %d15,7
80008a78:	91 30 00 ff 	movh.a %a15,61443
80008a7c:	1b cf 01 f0 	addi %d15,%d15,28
80008a80:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008a84:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_OSCCON_GAINSEL | OSEE_TC_SCU_OSCCON_MODE(0U) |
    OSEE_TC_SCU_OSCCON_OSCVAL((OSEE_TC_BOARD_FOSC / 2500000U) - 1U);

  while (OSEE_TC_SCU_OSCCON.bits.plllv == 0U) {
80008a86:	4c f0       	ld.w %d15,[%a15]0
80008a88:	6f 1f ff 7f 	jz.t %d15,1,80008a86 <osEE_tc_core0_start+0x3ec>
    ; /* Oscillator not too low */
  }

  while (OSEE_TC_SCU_OSCCON.bits.pllhv == 0U) {
80008a8c:	91 30 00 ff 	movh.a %a15,61443
80008a90:	d9 ff 10 06 	lea %a15,[%a15]24592 <f0036010 <_SMALL_DATA4_+0x4002e010>>
80008a94:	4c f0       	ld.w %d15,[%a15]0
80008a96:	6f 8f ff 7f 	jz.t %d15,8,80008a94 <osEE_tc_core0_start+0x3fa>
/*===================== Configure CCU Clock Control =========================*/
  osEE_tc_conf_clock_ctrl();
/*===================== Configure Oscillator Control ========================*/
  osEE_tc_conf_osc_ctrl();
/*============================ Configure PLL ================================*/
  osEE_tc_set_pll_fsource(OSEE_CPU_CLOCK);
80008a9a:	7b c0 be 40 	movh %d4,3052
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008a9e:	91 30 00 ff 	movh.a %a15,61443
80008aa2:	1b 04 20 4c 	addi %d4,%d4,-15872
80008aa6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008aaa:	6d 00 88 03 	call 800091ba <osEE_tc_set_pll_fsource>
80008aae:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008ab0:	2e 16       	jz.t %d15,1,80008abc <osEE_tc_core0_start+0x422>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008ab2:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008ab6:	37 8f 0e f1 	insert %d15,%d15,%d8,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008aba:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008abc:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008ac0:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008ac4:	91 30 00 ff 	movh.a %a15,61443
80008ac8:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008acc:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80008ace:	4c f0       	ld.w %d15,[%a15]0
80008ad0:	6f 0f ff 7f 	jz.t %d15,0,80008ace <osEE_tc_core0_start+0x434>
  osEE_tc_set_safety_endinit(safety_wdt_pw);
#endif /* OSEE_CPU_CLOCK */
#endif /* !OSEE_BYPASS_CLOCK_CONFIGURATION */
#endif /* !OSEE_TRICORE_ILLD && !OSEE_TC_2G */

  OSEE_EXIT(main());
80008ad4:	6d ff dc dc 	call 8000448c <main>
80008ad8:	02 24       	mov %d4,%d2
80008ada:	6d 00 05 36 	call 8000f6e4 <_exit>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008ade:	60 f2       	mov.a %a2,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008ae0:	8f 4f 1e 40 	sh %d4,%d15,-28
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008ae4:	74 22       	st.w [%a2],%d2
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008ae6:	c2 f3       	add %d3,-1
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008ae8:	37 0f 70 23 	extr.u %d2,%d15,6,16
80008aec:	37 42 10 28 	insert %d2,%d2,%d4,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80008af0:	76 36       	jz %d3,80008afc <osEE_tc_core0_start+0x462>
80008af2:	1b 0f fc ff 	addi %d15,%d15,-64
80008af6:	fc f4       	loop %a15,80008ade <osEE_tc_core0_start+0x444>
80008af8:	1d ff e4 fe 	j 800088c0 <osEE_tc_core0_start+0x226>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80008afc:	cd c2 e3 0f 	mtcr $lcx,%d2
80008b00:	0d 00 c0 04 	isync 
80008b04:	3c f7       	j 80008af2 <osEE_tc_core0_start+0x458>

80008b06 <osEE_tc_core1_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b06:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008b0a:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b0e:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008b12:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b16:	19 22 0c 00 	ld.w %d2,[%a2]12 <f003000c <_SMALL_DATA4_+0x4002800c>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008b1a:	48 06       	ld.w %d6,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b1c:	37 02 6e 21 	extr.u %d2,%d2,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008b20:	37 06 6e 61 	extr.u %d6,%d6,2,14
80008b24:	91 20 00 f6 	movh.a %a15,24578
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008b28:	8f f2 83 21 	xor %d2,%d2,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008b2c:	8f f6 83 61 	xor %d6,%d6,63
80008b30:	d9 ff 40 8b 	lea %a15,[%a15]-18944 <6001b600 <__USTACK1>>
80008b34:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80008b36:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80008b3a:	3b 00 b8 f0 	mov %d15,2944
80008b3e:	cd 4f e0 0f 	mtcr $psw,%d15
80008b42:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008b46:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80008b4a:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80008b4e:	cd 0f e0 0f 	mtcr $pcxi,%d15
80008b52:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008b56:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008b5a:	82 13       	mov %d3,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008b5c:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008b60:	cd 43 20 09 	mtcr $pcon1,%d3
80008b64:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b68:	53 cf 20 f0 	mul %d15,%d15,12
80008b6c:	10 22       	addsc.a %a2,%a2,%d15,0
80008b6e:	54 23       	ld.w %d3,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008b70:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008b72:	37 03 6e 31 	extr.u %d3,%d3,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008b76:	d9 2f 00 46 	lea %a15,[%a2]24832
80008b7a:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008b7e:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008b80:	8f f3 83 31 	xor %d3,%d3,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008b84:	2e 16       	jz.t %d15,1,80008b90 <osEE_tc_core1_start+0x8a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008b86:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008b8a:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008b8e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008b90:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008b94:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008b98:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008b9a:	4c f0       	ld.w %d15,[%a15]0
80008b9c:	6f 0f ff ff 	jnz.t %d15,0,80008b9a <osEE_tc_core1_start+0x94>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008ba0:	82 0f       	mov %d15,0
80008ba2:	cd cf 20 09 	mtcr $pcon0,%d15
80008ba6:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008baa:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008bac:	2e 16       	jz.t %d15,1,80008bb8 <osEE_tc_core1_start+0xb2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008bae:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008bb2:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008bb6:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008bb8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008bbc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008bc0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008bc2:	4c f0       	ld.w %d15,[%a15]0
80008bc4:	6f 0f ff 7f 	jz.t %d15,0,80008bc2 <osEE_tc_core1_start+0xbc>
80008bc8:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008bcc:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008bd0:	91 30 00 ff 	movh.a %a15,61443
80008bd4:	53 cf 20 f0 	mul %d15,%d15,12
80008bd8:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008bdc:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008bde:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008be0:	48 03       	ld.w %d3,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008be2:	d9 2f 00 46 	lea %a15,[%a2]24832
80008be6:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008bea:	37 03 6e 31 	extr.u %d3,%d3,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008bee:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008bf0:	8f f3 83 31 	xor %d3,%d3,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008bf4:	2e 16       	jz.t %d15,1,80008c00 <osEE_tc_core1_start+0xfa>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008bf6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008bfa:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008bfe:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008c00:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008c04:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008c08:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008c0a:	4c f0       	ld.w %d15,[%a15]0
80008c0c:	6f 0f ff ff 	jnz.t %d15,0,80008c0a <osEE_tc_core1_start+0x104>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80008c10:	82 0f       	mov %d15,0
80008c12:	cd 0f 04 09 	mtcr $dcon0,%d15
80008c16:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008c1a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008c1c:	2e 16       	jz.t %d15,1,80008c28 <osEE_tc_core1_start+0x122>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008c1e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008c22:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008c26:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008c28:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008c2c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008c30:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008c32:	4c f0       	ld.w %d15,[%a15]0
80008c34:	6f 0f ff 7f 	jz.t %d15,0,80008c32 <osEE_tc_core1_start+0x12c>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008c38:	91 30 00 ff 	movh.a %a15,61443
80008c3c:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008c40:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008c42:	2e 16       	jz.t %d15,1,80008c4e <osEE_tc_core1_start+0x148>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008c44:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008c48:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008c4c:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008c4e:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008c52:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008c56:	91 30 00 ff 	movh.a %a15,61443
80008c5a:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008c5e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008c60:	40 f2       	mov.aa %a2,%a15
80008c62:	4c 20       	ld.w %d15,[%a2]0
80008c64:	91 30 00 ff 	movh.a %a15,61443
80008c68:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008c6c:	6f 0f fb ff 	jnz.t %d15,0,80008c62 <osEE_tc_core1_start+0x15c>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(1U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB1);
80008c70:	7b 00 00 f8 	movh %d15,32768
80008c74:	1b 0f 30 f1 	addi %d15,%d15,4864
80008c78:	cd 4f e2 0f 	mtcr $btv,%d15
80008c7c:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB1);
80008c80:	7b 10 00 f8 	movh %d15,32769
80008c84:	1b 0f 00 f0 	addi %d15,%d15,0
80008c88:	cd 0f e2 0f 	mtcr $biv,%d15
80008c8c:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK1);
80008c90:	7b 20 00 f6 	movh %d15,24578
80008c94:	1b 0f b0 fb 	addi %d15,%d15,-17664
80008c98:	cd 8f e2 0f 	mtcr $isp,%d15
80008c9c:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008ca0:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008ca2:	2e 16       	jz.t %d15,1,80008cae <osEE_tc_core1_start+0x1a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008ca4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008ca8:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008cac:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008cae:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008cb2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008cb6:	91 30 00 ff 	movh.a %a15,61443
80008cba:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008cbe:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008cc0:	4c f0       	ld.w %d15,[%a15]0
80008cc2:	6f 0f ff 7f 	jz.t %d15,0,80008cc0 <osEE_tc_core1_start+0x1ba>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(1U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80008cc6:	91 10 00 f7 	movh.a %a15,28673
80008cca:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80008cce:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80008cd0:	91 10 00 f8 	movh.a %a15,32769
80008cd4:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008cd8:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
80008cda:	91 10 00 f8 	movh.a %a15,32769
80008cde:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80008ce2:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core1);
80008ce4:	91 00 00 f8 	movh.a %a15,32768
80008ce8:	d9 ff 38 60 	lea %a15,[%a15]440 <800001b8 <osEE_cdb_var_core1>>
80008cec:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
80008cee:	7b 20 00 36 	movh %d3,24578
80008cf2:	7b 20 00 56 	movh %d5,24578
80008cf6:	1b 03 c0 7b 	addi %d7,%d3,-17408
80008cfa:	1b 05 c0 5d 	addi %d5,%d5,-9216
80008cfe:	a2 75       	sub %d5,%d7
80008d00:	86 a5       	sha %d5,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80008d02:	82 0f       	mov %d15,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80008d04:	df 05 1d 00 	jeq %d5,0,80008d3e <osEE_tc_core1_start+0x238>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80008d08:	1b f5 ff 3f 	addi %d3,%d5,-1
80008d0c:	06 63       	sh %d3,6
80008d0e:	0b 73 00 40 	add %d4,%d3,%d7

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008d12:	60 4f       	mov.a %a15,%d4
80008d14:	82 01       	mov %d1,0
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008d16:	8f 44 1e f0 	sh %d15,%d4,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008d1a:	37 04 70 03 	extr.u %d0,%d4,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008d1e:	68 01       	st.w [%a15]0,%d1
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008d20:	60 5f       	mov.a %a15,%d5
80008d22:	1b 03 fc 3f 	addi %d3,%d3,-64
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008d26:	37 f0 10 f8 	insert %d15,%d0,%d15,16,16
80008d2a:	42 73       	add %d3,%d7

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008d2c:	82 54       	mov %d4,5
80008d2e:	b0 ff       	add.a %a15,-1
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80008d30:	8f 43 1e 70 	sh %d7,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008d34:	37 03 70 53 	extr.u %d5,%d3,6,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80008d38:	c2 f4       	add %d4,-1
80008d3a:	fd f0 71 00 	loop %a15,80008e1c <osEE_tc_core1_start+0x316>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
80008d3e:	cd 8f e3 0f 	mtcr $fcx,%d15
80008d42:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008d46:	91 30 00 ff 	movh.a %a15,61443
80008d4a:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008d4e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008d50:	2e 16       	jz.t %d15,1,80008d5c <osEE_tc_core1_start+0x256>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008d52:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008d56:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008d5a:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008d5c:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008d60:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008d64:	91 30 00 ff 	movh.a %a15,61443
80008d68:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008d6c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008d6e:	40 f2       	mov.aa %a2,%a15
80008d70:	4c 20       	ld.w %d15,[%a2]0
80008d72:	91 30 00 ff 	movh.a %a15,61443
80008d76:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008d7a:	6f 0f fb ff 	jnz.t %d15,0,80008d70 <osEE_tc_core1_start+0x26a>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
80008d7e:	91 30 00 2f 	movh.a %a2,61443
80008d82:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008d86:	4c 24       	ld.w %d15,[%a2]16
80008d88:	96 08       	or %d15,8
80008d8a:	6c 24       	st.w [%a2]16,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008d8c:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008d8e:	2e 16       	jz.t %d15,1,80008d9a <osEE_tc_core1_start+0x294>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008d90:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008d94:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008d98:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008d9a:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008d9e:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008da2:	91 30 00 ff 	movh.a %a15,61443
80008da6:	d9 ff 0c 46 	lea %a15,[%a15]24844 <f003610c <_SMALL_DATA4_+0x4002e10c>>
80008daa:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008dac:	4c f0       	ld.w %d15,[%a15]0
80008dae:	6f 0f ff 7f 	jz.t %d15,0,80008dac <osEE_tc_core1_start+0x2a6>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008db2:	91 30 00 ff 	movh.a %a15,61443
80008db6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008dba:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008dbc:	2e 16       	jz.t %d15,1,80008dc8 <osEE_tc_core1_start+0x2c2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008dbe:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008dc2:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008dc6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
80008dc8:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
80008dcc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80008dd0:	91 30 00 ff 	movh.a %a15,61443
80008dd4:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008dd8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
80008dda:	40 f2       	mov.aa %a2,%a15
80008ddc:	4c 20       	ld.w %d15,[%a2]0
80008dde:	91 30 00 ff 	movh.a %a15,61443
80008de2:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008de6:	6f 0f fb ff 	jnz.t %d15,0,80008ddc <osEE_tc_core1_start+0x2d6>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
80008dea:	4c f1       	ld.w %d15,[%a15]4
80008dec:	96 08       	or %d15,8
80008dee:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80008df0:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80008df2:	2e 16       	jz.t %d15,1,80008dfe <osEE_tc_core1_start+0x2f8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80008df4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80008df8:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
80008dfc:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
80008dfe:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80008e02:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80008e06:	91 30 00 ff 	movh.a %a15,61443
80008e0a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80008e0e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80008e10:	4c f0       	ld.w %d15,[%a15]0
80008e12:	6f 0f ff 7f 	jz.t %d15,0,80008e10 <osEE_tc_core1_start+0x30a>
/* C core 1 private initialization */
  _c_init_tc1();
#endif /* __TASKING__ */

/* Call main function */
  (void)main();
80008e16:	6d ff 3b db 	call 8000448c <main>

/* TODO: handle main return */
  for (;;) {
    ;
  }
80008e1a:	3c 00       	j 80008e1a <osEE_tc_core1_start+0x314>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80008e1c:	60 32       	mov.a %a2,%d3
80008e1e:	6c 20       	st.w [%a2]0,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80008e20:	37 75 10 f8 	insert %d15,%d5,%d7,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80008e24:	76 44       	jz %d4,80008e2c <osEE_tc_core1_start+0x326>
80008e26:	1b 03 fc 3f 	addi %d3,%d3,-64
80008e2a:	3c 83       	j 80008d30 <osEE_tc_core1_start+0x22a>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
80008e2c:	cd cf e3 0f 	mtcr $lcx,%d15
80008e30:	0d 00 c0 04 	isync 
80008e34:	3c f9       	j 80008e26 <osEE_tc_core1_start+0x320>

80008e36 <osEE_tc_core2_start>:
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008e36:	91 30 00 2f 	movh.a %a2,61443
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008e3a:	91 30 00 ff 	movh.a %a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008e3e:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008e42:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008e46:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x40028018>>
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008e4a:	48 06       	ld.w %d6,[%a15]0
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008e4c:	37 02 6e 21 	extr.u %d2,%d2,2,14
  osEE_tc_get_safety_wdt_pw(void)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
80008e50:	37 06 6e 61 	extr.u %d6,%d6,2,14
80008e54:	91 20 00 f5 	movh.a %a15,20482
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008e58:	8f f2 83 21 	xor %d2,%d2,63
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTS.con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008e5c:	8f f6 83 61 	xor %d6,%d6,63
80008e60:	d9 ff 40 8b 	lea %a15,[%a15]-18944 <5001b600 <__USTACK2>>
80008e64:	40 fa       	mov.aa %sp,%a15
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80008e66:	0d 00 80 04 	dsync 
  osEE_tc_dsync();

/* Set the PSW to its reset value in case of a warm start, set PSW.IS.
   Global Stack is needed since ERIKA's use the stack to save context for the
   current TASK */
  osEE_tc_set_csfr(OSEE_CSFR_PSW, OSEE_TC_START_PSW);
80008e6a:	3b 00 b8 f0 	mov %d15,2944
80008e6e:	cd 4f e0 0f 	mtcr $psw,%d15
80008e72:	0d 00 c0 04 	isync 

/* Set the PCXS and PCXO to its reset value in case of a warm start */
  pcxi  = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
80008e76:	4d 00 e0 ff 	mfcr %d15,$pcxi
  pcxi &= 0xFFF00000U;
80008e7a:	b7 0f 14 f0 	insert %d15,%d15,0,0,20
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, pcxi);
80008e7e:	cd 0f e0 0f 	mtcr $pcxi,%d15
80008e82:	0d 00 c0 04 	isync 
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80008e86:	4d c0 e1 ff 	mfcr %d15,$core_id
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008e8a:	82 13       	mov %d3,1
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008e8c:	37 0f 48 f0 	extr %d15,%d15,0,8
   PCBYP is the only not reserved bit in PCON0. */
  OsEE_reg const pcon0 = (enable)? 0x0U: 0x2U;
  if (enable) {
    /* Step 1: Initiate invalidation of current pcache contents if any.
       (i.e. PCON1[0:0](.PCINV) = 1 Program Cache Invalidate */
    osEE_tc_set_csfr(OSEE_CSFR_PCON1, 0x1U);
80008e90:	cd 43 20 09 	mtcr $pcon1,%d3
80008e94:	0d 00 c0 04 	isync 
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008e98:	53 cf 20 f0 	mul %d15,%d15,12
80008e9c:	10 22       	addsc.a %a2,%a2,%d15,0
80008e9e:	54 23       	ld.w %d3,[%a2]
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008ea0:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008ea2:	37 03 6e 31 	extr.u %d3,%d3,2,14
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008ea6:	d9 2f 00 46 	lea %a15,[%a2]24832
80008eaa:	11 3f 00 ff 	addih.a %a15,%a15,61443

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008eae:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008eb0:	8f f3 83 31 	xor %d3,%d3,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008eb4:	2e 16       	jz.t %d15,1,80008ec0 <osEE_tc_core2_start+0x8a>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008eb6:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008eba:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008ebe:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008ec0:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008ec4:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008ec8:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008eca:	4c f0       	ld.w %d15,[%a15]0
80008ecc:	6f 0f ff ff 	jnz.t %d15,0,80008eca <osEE_tc_core2_start+0x94>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* PCACHE enable steps */
/* Step 2: Set PCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_PCON0, pcon0);
80008ed0:	82 0f       	mov %d15,0
80008ed2:	cd cf 20 09 	mtcr $pcon0,%d15
80008ed6:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008eda:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008edc:	2e 16       	jz.t %d15,1,80008ee8 <osEE_tc_core2_start+0xb2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008ede:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008ee2:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008ee6:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008ee8:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008eec:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008ef0:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008ef2:	4c f0       	ld.w %d15,[%a15]0
80008ef4:	6f 0f ff 7f 	jz.t %d15,0,80008ef2 <osEE_tc_core2_start+0xbc>
80008ef8:	4d c0 e1 ff 	mfcr %d15,$core_id
  OsEE_core_id  const core_id = osEE_get_curr_core_id();
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x40U)
  OsEE_reg      const core_index = (core_id != OS_CORE_ID_6)?
    (OsEE_reg)core_id: 5U;
#else
  OsEE_reg      const core_index = (OsEE_reg)core_id;
80008efc:	37 0f 48 f0 	extr %d15,%d15,0,8
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008f00:	91 30 00 ff 	movh.a %a15,61443
80008f04:	53 cf 20 f0 	mul %d15,%d15,12
80008f08:	d9 ff 00 46 	lea %a15,[%a15]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
80008f0c:	10 ff       	addsc.a %a15,%a15,%d15,0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008f0e:	60 f2       	mov.a %a2,%d15
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008f10:	48 03       	ld.w %d3,[%a15]0
 osEE_tc_clear_cpu_endinit(OsEE_reg core_index, uint16_t pw)
{
  OsEE_tc_SCU_WDTCPU_CON0 cpu_wdt_con0;
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];
80008f12:	d9 2f 00 46 	lea %a15,[%a2]24832
80008f16:	11 3f 00 ff 	addih.a %a15,%a15,61443
  osEE_tc_get_cpu_wdt_pw(OsEE_reg core_index)
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
80008f1a:	37 03 6e 31 	extr.u %d3,%d3,2,14
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008f1e:	4c f0       	ld.w %d15,[%a15]0
{
  /* Read Password from CON0 register
   * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
   * to toggle them before returning password */
  uint16_t pw = OSEE_TC_SCU_WDTCPU[core_index].con0.bits.pw;
  uint16_t pw_toggled = pw ^ ((uint16_t)0x003FU);
80008f20:	8f f3 83 31 	xor %d3,%d3,63

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008f24:	2e 16       	jz.t %d15,1,80008f30 <osEE_tc_core2_start+0xfa>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008f26:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008f2a:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008f2e:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008f30:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008f34:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008f38:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008f3a:	4c f0       	ld.w %d15,[%a15]0
80008f3c:	6f 0f ff ff 	jnz.t %d15,0,80008f3a <osEE_tc_core2_start+0x104>
  cpu_wdt_pw = osEE_tc_get_cpu_wdt_pw(core_index);

/* DCACHE enable steps */
/* Step 2: Set DCBYP to 0 if cache is enabled */
  osEE_tc_clear_cpu_endinit(core_index, cpu_wdt_pw);
  osEE_tc_set_csfr(OSEE_CSFR_DCON0, dcon0);
80008f40:	82 0f       	mov %d15,0
80008f42:	cd 0f 04 09 	mtcr $dcon0,%d15
80008f46:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008f4a:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008f4c:	2e 16       	jz.t %d15,1,80008f58 <osEE_tc_core2_start+0x122>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008f4e:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008f52:	37 3f 0e f1 	insert %d15,%d15,%d3,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008f56:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008f58:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008f5c:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008f60:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008f62:	4c f0       	ld.w %d15,[%a15]0
80008f64:	6f 0f ff 7f 	jz.t %d15,0,80008f62 <osEE_tc_core2_start+0x12c>
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008f68:	91 30 00 ff 	movh.a %a15,61443
80008f6c:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80008f70:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008f72:	2e 16       	jz.t %d15,1,80008f7e <osEE_tc_core2_start+0x148>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008f74:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008f78:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008f7c:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
80008f7e:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80008f82:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008f86:	91 30 00 ff 	movh.a %a15,61443
80008f8a:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80008f8e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
80008f90:	40 f2       	mov.aa %a2,%a15
80008f92:	4c 20       	ld.w %d15,[%a2]0
80008f94:	91 30 00 ff 	movh.a %a15,61443
80008f98:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80008f9c:	6f 0f fb ff 	jnz.t %d15,0,80008f92 <osEE_tc_core2_start+0x15c>

/* Clear the ENDINIT bit in the WDT_CON0 register */
  osEE_tc_clear_cpu_endinit(2U, cpu_wdt_pw);

/* Load Base Address of Trap Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BTV, (OsEE_reg)__TRAPTAB2);
80008fa0:	7b 00 00 f8 	movh %d15,32768
80008fa4:	1b 0f 30 f1 	addi %d15,%d15,4864
80008fa8:	cd 4f e2 0f 	mtcr $btv,%d15
80008fac:	0d 00 c0 04 	isync 

/* Load Base Address of Interrupt Vector Table. */
  osEE_tc_set_csfr(OSEE_CSFR_BIV, (OsEE_reg)__INTTAB2);
80008fb0:	7b 10 00 f8 	movh %d15,32769
80008fb4:	1b 0f 00 f2 	addi %d15,%d15,8192
80008fb8:	cd 0f e2 0f 	mtcr $biv,%d15
80008fbc:	0d 00 c0 04 	isync 

/* Load Interrupt Stack Pointer. (Not Used) */
  osEE_tc_set_csfr(OSEE_CSFR_ISP, (OsEE_reg)__ISTACK2);
80008fc0:	7b 20 00 f5 	movh %d15,20482
80008fc4:	1b 0f b0 fb 	addi %d15,%d15,-17664
80008fc8:	cd 8f e2 0f 	mtcr $isp,%d15
80008fcc:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80008fd0:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80008fd2:	2e 16       	jz.t %d15,1,80008fde <osEE_tc_core2_start+0x1a8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80008fd4:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80008fd8:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
80008fdc:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
80008fde:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
80008fe2:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80008fe6:	91 30 00 ff 	movh.a %a15,61443
80008fea:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
80008fee:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
80008ff0:	4c f0       	ld.w %d15,[%a15]0
80008ff2:	6f 0f ff 7f 	jz.t %d15,0,80008ff0 <osEE_tc_core2_start+0x1ba>

/* Set the ENDINIT bit in the WDT_CON0 register back */
  osEE_tc_set_cpu_endinit(2U, cpu_wdt_pw);

/* Initialize SDA base pointers */
  osEE_tc_setareg(a0, _SMALL_DATA_);
80008ff6:	91 10 00 f7 	movh.a %a15,28673
80008ffa:	d9 ff 00 08 	lea %a15,[%a15]-32768 <70008000 <_SMALL_DATA_>>
80008ffe:	40 f0       	mov.aa %a0,%a15
  osEE_tc_setareg(a1, _SMALL_DATA2_);
80009000:	91 10 00 f8 	movh.a %a15,32769
80009004:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80009008:	40 f1       	mov.aa %a1,%a15

/* Initialization of A8 and A9 */
  osEE_tc_setareg(a8, _SMALL_DATA3_);
8000900a:	91 10 00 f8 	movh.a %a15,32769
8000900e:	d9 ff 00 08 	lea %a15,[%a15]-32768 <80008000 <_SMALL_DATA2_>>
80009012:	40 f8       	mov.aa %a8,%a15
#if (defined(OSEE_TC_DISABLE_A9_OPTIMIZATION))
  osEE_tc_setareg(a9, _SMALL_DATA4_);
#else
  osEE_tc_setareg(a9, &osEE_cdb_var_core2);
80009014:	91 00 00 f8 	movh.a %a15,32768
80009018:	d9 ff 14 60 	lea %a15,[%a15]404 <80000194 <osEE_cdb_var_core2>>
8000901c:	40 f9       	mov.aa %a9,%a15
/* Nr of CSAs in area. Best solution, even though is a MISRA deviation, since
   pointers subtraction handles OsEE_csa size and p_csa_end/p_csa_begin
   are the extremes of an array constructed in linker script
   (condition under where C language specification allows pointer subtraction).
 */
  size_t const no_of_csas = (size_t)(p_csa_end - p_csa_begin);
8000901e:	7b 20 00 35 	movh %d3,20482
80009022:	7b 20 00 55 	movh %d5,20482
80009026:	1b 03 c0 7b 	addi %d7,%d3,-17408
8000902a:	1b 05 c0 5d 	addi %d5,%d5,-9216
8000902e:	a2 75       	sub %d5,%d7
80009030:	86 a5       	sha %d5,-6

/* Previous Context Pointer (CSA Link Word) */
  OsEE_reg pcxi_val = 0U;
80009032:	82 0f       	mov %d15,0
/*
  IMPORTANT:
  I initialize the Free Context List in reverse order.
  So I will end with a list that will grow toward bigger addresses.
 */
  for (i = no_of_csas; i > 0U; --i) {
80009034:	df 05 1d 00 	jeq %d5,0,8000906e <osEE_tc_core2_start+0x238>
/* CSA PCXI segment */
    OsEE_reg   pcxi_s;
/* CSA PCXI offset */
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];
80009038:	1b f5 ff 3f 	addi %d3,%d5,-1
8000903c:	06 63       	sh %d3,6
8000903e:	0b 73 00 40 	add %d4,%d3,%d7

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
80009042:	60 4f       	mov.a %a15,%d4
80009044:	82 01       	mov %d1,0
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80009046:	8f 44 1e f0 	sh %d15,%d4,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
8000904a:	37 04 70 03 	extr.u %d0,%d4,6,16
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000904e:	68 01       	st.w [%a15]0,%d1
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009050:	60 5f       	mov.a %a15,%d5
80009052:	1b 03 fc 3f 	addi %d3,%d3,-64
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009056:	37 f0 10 f8 	insert %d15,%d0,%d15,16,16
8000905a:	42 73       	add %d3,%d7

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
8000905c:	82 54       	mov %d4,5
8000905e:	b0 ff       	add.a %a15,-1
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
80009060:	8f 43 1e 70 	sh %d7,%d3,-28
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009064:	37 03 70 53 	extr.u %d5,%d3,6,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
80009068:	c2 f4       	add %d4,-1
8000906a:	fd f0 71 00 	loop %a15,8000914c <osEE_tc_core2_start+0x316>
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
    }
  }
/* Initialize the HEAD of Free Context List */
  osEE_tc_set_csfr(OSEE_CSFR_FCX, pcxi_val);
8000906e:	cd 8f e3 0f 	mtcr $fcx,%d15
80009072:	0d 00 c0 04 	isync 
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
80009076:	91 30 00 ff 	movh.a %a15,61443
8000907a:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
8000907e:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
80009080:	2e 16       	jz.t %d15,1,8000908c <osEE_tc_core2_start+0x256>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
80009082:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
80009086:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
8000908a:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 0U;
8000908c:	8f 1f c0 f1 	andn %d15,%d15,1
  cpu_wdt_con0.bits.lck     = 1U;
80009090:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
80009094:	91 30 00 ff 	movh.a %a15,61443
80009098:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
8000909c:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (p_cpu_wdt->con0.bits.endinit == 1U) {
8000909e:	40 f2       	mov.aa %a2,%a15
800090a0:	4c 20       	ld.w %d15,[%a2]0
800090a2:	91 30 00 ff 	movh.a %a15,61443
800090a6:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
800090aa:	6f 0f fb ff 	jnz.t %d15,0,800090a0 <osEE_tc_core2_start+0x26a>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_cpu_wdt(OsEE_reg core_index, uint16_t pw)
{
  osEE_tc_clear_cpu_endinit(core_index, pw);
/* Set "Disable Request bit" on CPU_WDT[core_index].CON1 */
  OSEE_TC_SCU_WDTCPU[core_index].con1.bits.dr = 1U;
800090ae:	91 30 00 2f 	movh.a %a2,61443
800090b2:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x4002e100>>
800090b6:	4c 27       	ld.w %d15,[%a2]28
800090b8:	96 08       	or %d15,8
800090ba:	6c 27       	st.w [%a2]28,%d15
/* Prepare a "reference" to the CPU watchdog */
  OsEE_tc_SCU_WDTCPU volatile * const
    p_cpu_wdt = &OSEE_TC_SCU_WDTCPU[core_index];

/* Read Config_0 register */
  cpu_wdt_con0.reg = p_cpu_wdt->con0.reg;
800090bc:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (cpu_wdt_con0.bits.lck != 0U) {
800090be:	2e 16       	jz.t %d15,1,800090ca <osEE_tc_core2_start+0x294>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    cpu_wdt_con0.bits.endinit = 1U;
    cpu_wdt_con0.bits.lck     = 0U;
800090c0:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    cpu_wdt_con0.bits.pw      = pw;
800090c4:	37 2f 0e f1 	insert %d15,%d15,%d2,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    p_cpu_wdt->con0.reg = cpu_wdt_con0.reg;
800090c8:	68 0f       	st.w [%a15]0,%d15
  }

/* Set ENDINT and set LCK bit in Config_0 register */
  cpu_wdt_con0.bits.endinit = 1U;
800090ca:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  cpu_wdt_con0.bits.lck     = 1U;
800090ce:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  p_cpu_wdt->con0.reg       = cpu_wdt_con0.reg;
800090d2:	91 30 00 ff 	movh.a %a15,61443
800090d6:	d9 ff 18 46 	lea %a15,[%a15]24856 <f0036118 <_SMALL_DATA4_+0x4002e118>>
800090da:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been set */
  while (p_cpu_wdt->con0.bits.endinit == 0U) {
800090dc:	4c f0       	ld.w %d15,[%a15]0
800090de:	6f 0f ff 7f 	jz.t %d15,0,800090dc <osEE_tc_core2_start+0x2a6>
  osEE_tc_clear_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
800090e2:	91 30 00 ff 	movh.a %a15,61443
800090e6:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
800090ea:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
800090ec:	2e 16       	jz.t %d15,1,800090f8 <osEE_tc_core2_start+0x2c2>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
800090ee:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
800090f2:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
800090f6:	68 0f       	st.w [%a15]0,%d15
  }

/* Clear ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 0U;
800090f8:	8f 1f c0 f1 	andn %d15,%d15,1
  safety_wdt_con0.bits.lck     = 1U;
800090fc:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg    = safety_wdt_con0.reg;
80009100:	91 30 00 ff 	movh.a %a15,61443
80009104:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009108:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 1U) {
8000910a:	40 f2       	mov.aa %a2,%a15
8000910c:	4c 20       	ld.w %d15,[%a2]0
8000910e:	91 30 00 ff 	movh.a %a15,61443
80009112:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
80009116:	6f 0f fb ff 	jnz.t %d15,0,8000910c <osEE_tc_core2_start+0x2d6>
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_disable_safety_wdt(uint16_t pw)
{
  osEE_tc_clear_safety_endinit(pw);
/* Set "Disable Request bit" on CPU_WDTS.CON1 */
  OSEE_TC_SCU_WDTS.con1.bits.dr = 1U;
8000911a:	4c f1       	ld.w %d15,[%a15]4
8000911c:	96 08       	or %d15,8
8000911e:	68 1f       	st.w [%a15]4,%d15
  osEE_tc_set_safety_endinit(uint16_t pw)
{
/* Read Config_0 register */
  OsEE_tc_SCU_WDTS_CON0 safety_wdt_con0;

  safety_wdt_con0.reg = OSEE_TC_SCU_WDTS.con0.reg;
80009120:	4c f0       	ld.w %d15,[%a15]0

/* If locked unlock it */
  if (safety_wdt_con0.bits.lck != 0U) {
80009122:	2e 16       	jz.t %d15,1,8000912e <osEE_tc_core2_start+0x2f8>
/* see Table 1 (Pass.word Access Bit Pattern Requirements) */
    safety_wdt_con0.bits.endinit = 1U;
    safety_wdt_con0.bits.lck     = 0U;
80009124:	b7 1f 02 f0 	insert %d15,%d15,1,0,2
    safety_wdt_con0.bits.pw      = pw;
80009128:	37 6f 0e f1 	insert %d15,%d15,%d6,2,14

/* Password ready. Store it to WDT_CON0 to unprotect the register */
    OSEE_TC_SCU_WDTS.con0.reg = safety_wdt_con0.reg;
8000912c:	68 0f       	st.w [%a15]0,%d15
  }


/* Set ENDINT and set LCK bit in Config_0 register */
  safety_wdt_con0.bits.endinit = 1U;
8000912e:	b7 1f 01 f0 	insert %d15,%d15,1,0,1
  safety_wdt_con0.bits.lck     = 1U;
80009132:	b7 1f 81 f0 	insert %d15,%d15,1,1,1
  OSEE_TC_SCU_WDTS.con0.reg   = safety_wdt_con0.reg;
80009136:	91 30 00 ff 	movh.a %a15,61443
8000913a:	d9 ff 30 36 	lea %a15,[%a15]24816 <f00360f0 <_SMALL_DATA4_+0x4002e0f0>>
8000913e:	68 0f       	st.w [%a15]0,%d15

/* Read back ENDINIT and wait until it has been cleared */
  while (OSEE_TC_SCU_WDTS.con0.bits.endinit == 0U) {
80009140:	4c f0       	ld.w %d15,[%a15]0
80009142:	6f 0f ff 7f 	jz.t %d15,0,80009140 <osEE_tc_core2_start+0x30a>
/* C core 2 private initialization */
  _c_init_tc2();
#endif /* __TASKING__ */

/* Call main function */
  (void)main();
80009146:	6d ff a3 d9 	call 8000448c <main>
  
/* TODO: handle main return */
  for (;;) {
    ;
  }
8000914a:	3c 00       	j 8000914a <osEE_tc_core2_start+0x314>
    OsEE_reg   pcxi_o;
/* Get current CSA pointer */
    OsEE_csa * const p_csa = &p_csa_begin[(i - 1U)];

/* Store in current CSA previous pointer (null in last CSA. i.e. First time!) */
    p_csa->l_next.reg = pcxi_val;
8000914c:	60 32       	mov.a %a2,%d3
8000914e:	6c 20       	st.w [%a2]0,%d15
/* Current CSA segment */
    pcxi_s  = (((OsEE_reg)p_csa >> 28U) & 0xFU) << 16U;
/* Evaluate CSA Segment Offset */
    pcxi_o  = (((OsEE_reg)p_csa >> 6U) & 0xFFFFU);
/* Compose pcxi_s and pcxi_o in the pcxi_val to be stored in next CSA */
    pcxi_val = pcxi_s | pcxi_o;
80009150:	37 75 10 f8 	insert %d15,%d5,%d7,16,16

/* Check if you have to populate LCX that point to the 'almost empty'
   position */
    --fcd_needed_csa;
    if (fcd_needed_csa == 0U) {
80009154:	76 44       	jz %d4,8000915c <osEE_tc_core2_start+0x326>
80009156:	1b 03 fc 3f 	addi %d3,%d3,-64
8000915a:	3c 83       	j 80009060 <osEE_tc_core2_start+0x22a>
/* After having stored the LCX, I would have to have a 32 bit wrap around to
   override the previous value and in a 32-bit address space is not possible. */
      osEE_tc_set_csfr(OSEE_CSFR_LCX, pcxi_val);
8000915c:	cd cf e3 0f 	mtcr $lcx,%d15
80009160:	0d 00 c0 04 	isync 
80009164:	3c f9       	j 80009156 <osEE_tc_core2_start+0x320>

80009166 <osEE_tc_stm_us_ticks>:
#if (defined(__TASKING__))
#define OS_STOP_SEC_GLOBAL_VAR_CLEARED
#include "Os_MemMap.h"
#endif /* __TASKING__ */

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
80009166:	40 ae       	mov.aa %a14,%sp
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
80009168:	91 00 00 f7 	movh.a %a15,28672
8000916c:	19 ff a0 c0 	ld.w %d15,[%a15]2848 <70000b20 <osEE_tc_stm_freq_khz>>
80009170:	3b 80 3e 20 	mov %d2,1000
80009174:	3f 2f 0c 80 	jlt.u %d15,%d2,8000918c <osEE_tc_stm_us_ticks+0x26>
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
80009178:	7b 20 06 21 	movh %d2,4194
8000917c:	1b 32 dd 24 	addi %d2,%d2,19923
80009180:	73 2f 68 20 	mul.u %e2,%d15,%d2
80009184:	8f a3 1f 20 	sh %d2,%d3,-6
80009188:	e2 42       	mul %d2,%d4
8000918a:	00 90       	ret 
  } else if (usec >= OSEE_KILO) {
8000918c:	02 25       	mov %d5,%d2
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
8000918e:	73 f4 0a 20 	mul %d2,%d4,%d15
80009192:	7b 20 06 31 	movh %d3,4194
80009196:	1b 33 dd 34 	addi %d3,%d3,19923
8000919a:	73 32 68 20 	mul.u %e2,%d2,%d3
8000919e:	8f a3 1f 20 	sh %d2,%d3,-6

static OsEE_reg osEE_tc_stm_us_ticks(OsEE_reg usec) {
  OsEE_reg ticks;
  if (osEE_tc_stm_freq_khz >= OSEE_KILO) {
    ticks = usec * (osEE_tc_stm_freq_khz / OSEE_KILO);
  } else if (usec >= OSEE_KILO) {
800091a2:	3f 54 0b 80 	jlt.u %d4,%d5,800091b8 <osEE_tc_stm_us_ticks+0x52>
    ticks = (usec / OSEE_KILO) * osEE_tc_stm_freq_khz;
800091a6:	7b 20 06 21 	movh %d2,4194
800091aa:	1b 32 dd 24 	addi %d2,%d2,19923
800091ae:	73 24 68 40 	mul.u %e4,%d4,%d2
800091b2:	8f a5 1f 20 	sh %d2,%d5,-6
800091b6:	e2 f2       	mul %d2,%d15
  } else {
    ticks = (usec * osEE_tc_stm_freq_khz) / OSEE_KILO;
  }
  return ticks;
}
800091b8:	00 90       	ret 

800091ba <osEE_tc_set_pll_fsource>:
#define OSEE_TC_K2_MIN      (1U)
#define OSEE_TC_N_MAX       (128U)  /* '7 bits */
#define OSEE_TC_N_MIN       (1U)
#define OSEE_TC_DEV_ALLOWED (2U)

void osEE_tc_set_pll_fsource(OsEE_reg fpll) {
800091ba:	40 ae       	mov.aa %a14,%sp
  fPllLeastError  = OSEE_TC_CLOCK_MAX;
  fPllError       = OSEE_TC_CLOCK_MAX;

  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
800091bc:	7b e0 e4 20 	movh %d2,3662
800091c0:	1b 12 c0 21 	addi %d2,%d2,7169
800091c4:	0b 24 30 f1 	lt.u %d15,%d4,%d2
800091c8:	82 22       	mov %d2,2
800091ca:	ab 12 80 ff 	sel %d15,%d15,%d2,1
800091ce:	60 f4       	mov.a %a4,%d15
800091d0:	53 ff 20 f0 	mul %d15,%d15,15
800091d4:	60 f5       	mov.a %a5,%d15
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800091d6:	3b 00 01 e0 	mov %d14,16
800091da:	82 03       	mov %d3,0
800091dc:	7b c0 be 20 	movh %d2,3052
800091e0:	1b 02 20 2c 	addi %d2,%d2,-15872
800091e4:	02 28       	mov %d8,%d2
800091e6:	82 01       	mov %d1,0
800091e8:	82 0b       	mov %d11,0
800091ea:	82 0d       	mov %d13,0
800091ec:	82 0c       	mov %d12,0
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
800091ee:	7b 10 13 a0 	movh %d10,305
800091f2:	1b 0a d0 a2 	addi %d10,%d10,11520

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
800091f6:	91 40 0f 60 	movh.a %a6,244
800091fa:	d9 66 41 02 	lea %a6,[%a6]9217 <f42401 <__DSPR1_SIZE+0xf24401>>
    {
      for (
800091fe:	a0 1d       	mov.a %a13,1
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009200:	53 14 40 60 	mul.u %e6,%d4,1
80009204:	60 62       	mov.a %a2,%d6
80009206:	60 73       	mov.a %a3,%d7

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
80009208:	91 80 7d f1 	movh.a %a15,6104
8000920c:	d9 ff 41 08 	lea %a15,[%a15]-31743 <17d78401 <__DSPR1_SIZE+0x17d5a401>>
        {
          for (
80009210:	a0 1c       	mov.a %a12,1
80009212:	3c 5e       	j 800092ce <osEE_tc_set_pll_fsource+0x114>
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
  )
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);
80009214:	4b ea 11 62 	div.u %e6,%d10,%d14
80009218:	82 07       	mov %d7,0

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
8000921a:	7b 60 f8 ff 	movh %d15,65414
8000921e:	1b 0f e0 fe 	addi %d15,%d15,-4608
80009222:	0b f6 40 60 	addx %d6,%d6,%d15
80009226:	8b f7 bf 50 	addc %d5,%d7,-1
8000922a:	ba 05       	eq %d15,%d5,0
8000922c:	80 67       	mov.d %d7,%a6
8000922e:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80009232:	8b 05 00 f5 	or.ne %d15,%d5,0
80009236:	ee 4a       	jnz %d15,800092ca <osEE_tc_set_pll_fsource+0x110>
    {
      for (
80009238:	df 00 56 00 	jeq %d0,0,800092e4 <osEE_tc_set_pll_fsource+0x12a>
8000923c:	02 e9       	mov %d9,%d14
8000923e:	80 d0       	mov.d %d0,%a13
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
80009240:	60 e7       	mov.a %a7,%d14
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
        )
      {
        fVco = ((uint64_t)fpll) * k2;
80009242:	80 2f       	mov.d %d15,%a2
80009244:	73 f0 68 60 	mul.u %e6,%d0,%d15
80009248:	80 3f       	mov.d %d15,%a3
8000924a:	03 f0 0a 77 	madd %d7,%d7,%d0,%d15

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
8000924e:	7b 80 82 fe 	movh %d15,59432
80009252:	1b 0f c0 f7 	addi %d15,%d15,31744
80009256:	0b f6 40 60 	addx %d6,%d6,%d15
8000925a:	8b f7 bf 50 	addc %d5,%d7,-1
8000925e:	ba 05       	eq %d15,%d5,0
80009260:	80 f7       	mov.d %d7,%a15
80009262:	0b 76 50 f2 	and.ge.u %d15,%d6,%d7
80009266:	8b 05 00 f5 	or.ne %d15,%d5,0
8000926a:	ee 25       	jnz %d15,800092b4 <osEE_tc_set_pll_fsource+0xfa>
        {
          for (
8000926c:	0f 23 a0 f0 	or %d15,%d3,%d2
80009270:	6e 2d       	jz %d15,800092ca <osEE_tc_set_pll_fsource+0x110>
80009272:	80 c6       	mov.d %d6,%a12
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
80009274:	4b 96 11 22 	div.u %e2,%d6,%d9
80009278:	02 2f       	mov %d15,%d2
8000927a:	e2 af       	mul %d15,%d10
8000927c:	a2 4f       	sub %d15,%d4
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
8000927e:	53 1f 40 20 	mul.u %e2,%d15,1
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
80009282:	df 0f ac 00 	jeq %d15,0,800093da <osEE_tc_set_pll_fsource+0x220>
              bestK2         = k2;
              bestN          = n;
              bestP          = p;
            }

            if (fPllLeastError > fPllError)
80009286:	0b 13 00 51 	eq %d5,%d3,%d1
8000928a:	0b 8f 50 52 	and.ge.u %d5,%d15,%d8
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
            )
          {
            fPllError = (
8000928e:	2b f8 40 85 	sel %d8,%d5,%d8,%d15
80009292:	ab 01 80 15 	sel %d1,%d5,%d1,0
80009296:	2b eb 40 b5 	sel %d11,%d5,%d11,%d14
8000929a:	2b 6d 40 d5 	sel %d13,%d5,%d13,%d6
8000929e:	2b 0c 40 c5 	sel %d12,%d5,%d12,%d0
        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
              n = OSEE_TC_N_MIN;
              ((n <= OSEE_TC_N_MAX) && (fPllError != 0U));
              ++n
800092a2:	c2 16       	add %d6,1
      {
        fVco = ((uint64_t)fpll) * k2;

        if ((fVco >= OSEE_TC_FVCO_MIN) && (fVco <= OSEE_TC_FVCO_MAX))
        {
          for (
800092a4:	8b 16 68 52 	lt.u %d5,%d6,129
800092a8:	8b 0f 20 54 	and.ne %d5,%d15,0
800092ac:	df 05 e4 ff 	jne %d5,0,80009274 <osEE_tc_set_pll_fsource+0xba>
800092b0:	02 d6       	mov %d6,%d13
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800092b2:	02 6d       	mov %d13,%d6
    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
          k2 += k2Steps
800092b4:	80 4f       	mov.d %d15,%a4
800092b6:	42 f0       	add %d0,%d15
800092b8:	80 56       	mov.d %d6,%a5
800092ba:	42 69       	add %d9,%d6

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
          k2 = OSEE_TC_K2_MIN;
          ((k2 <= OSEE_TC_K2_MAX) && (fPllError != 0U));
800092bc:	0f 32 a0 50 	or %d5,%d2,%d3
  {
    fRef = ((uint64_t)OSEE_TC_BOARD_FOSC / p);

    if ((fRef >= OSEE_TC_FREF_MIN) && (fRef <= OSEE_TC_FREF_MAX))
    {
      for (
800092c0:	8b d0 61 f2 	lt.u %d15,%d0,29
800092c4:	8b 05 20 f4 	and.ne %d15,%d5,0
800092c8:	ee bd       	jnz %d15,80009242 <osEE_tc_set_pll_fsource+0x88>
800092ca:	01 45 20 50 	sub.a %a5,%a5,%a4
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
800092ce:	c2 fe       	add %d14,-1
    k2Steps = 1;
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
800092d0:	0f 32 a0 f0 	or %d15,%d2,%d3
800092d4:	8b 0f 20 02 	ne %d0,%d15,0
  if (fpll > OSEE_TC_FPLL_KSTEP)
  {
    k2Steps = 1;
  }

  for (
800092d8:	8b 0e 20 52 	ne %d5,%d14,0
800092dc:	8b 0f 20 54 	and.ne %d5,%d15,0
800092e0:	df 05 9a ff 	jne %d5,0,80009214 <osEE_tc_set_pll_fsource+0x5a>
      }
    }
  }

  /* Percent ALLOWED_DEVIATION error allowed */
  fpll_maxerrorallowed = (fpll * OSEE_TC_DEV_ALLOWED) / ((OsEE_reg)100U);
800092e4:	06 14       	sh %d4,1
800092e6:	7b c0 1e f5 	movh %d15,20972
800092ea:	1b ff 51 f8 	addi %d15,%d15,-31457
800092ee:	73 f4 68 40 	mul.u %e4,%d4,%d15
800092f2:	8f b5 1f 20 	sh %d2,%d5,-5
  if (fPllLeastError < (uint64_t)fpll_maxerrorallowed)
800092f6:	ba 01       	eq %d15,%d1,0
800092f8:	0b 28 50 f2 	and.ge.u %d15,%d8,%d2
800092fc:	8b 01 00 f5 	or.ne %d15,%d1,0
80009300:	ee 73       	jnz %d15,800093e6 <osEE_tc_set_pll_fsource+0x22c>
  {
    /* Divide by K2DIV + 1 */
    OSEE_TC_SCU_PLLCON1.bits.k2div = (uint8_t)(bestK2 - 1U);
80009302:	c2 fc       	add %d12,-1
80009304:	91 30 00 ff 	movh.a %a15,61443
80009308:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000930c:	4c f0       	ld.w %d15,[%a15]0
8000930e:	37 cf 07 c0 	insert %d12,%d15,%d12,0,7
80009312:	68 0c       	st.w [%a15]0,%d12

    while (OSEE_TC_SCU_PLLSTAT.bits.k2rdy == 0U) {
80009314:	91 30 00 ff 	movh.a %a15,61443
80009318:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000931c:	4c f0       	ld.w %d15,[%a15]0
8000931e:	6f 5f ff 7f 	jz.t %d15,5,8000931c <osEE_tc_set_pll_fsource+0x162>
    }

    /* K1 divider default value */

    /* Enabled the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 1U;
80009322:	91 30 00 ff 	movh.a %a15,61443
80009326:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
8000932a:	4c f0       	ld.w %d15,[%a15]0
8000932c:	96 01       	or %d15,1
8000932e:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 0U) {
80009330:	91 30 00 ff 	movh.a %a15,61443
80009334:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009338:	4c f0       	ld.w %d15,[%a15]0
8000933a:	6f 0f ff 7f 	jz.t %d15,0,80009338 <osEE_tc_set_pll_fsource+0x17e>
      ; /* Wait until prescaler mode is entered */
    }

    /* I will use n=80 and p=2. Because I can get al the
       needed values */
    OSEE_TC_SCU_PLLCON0.bits.pdiv = (uint8_t)(bestP - 1U);
8000933e:	9a fb       	add %d15,%d11,-1
80009340:	91 30 00 ff 	movh.a %a15,61443
80009344:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009348:	16 0f       	and %d15,15
8000934a:	8f 8f 01 f0 	sh %d15,%d15,24
8000934e:	48 02       	ld.w %d2,[%a15]0
80009350:	b7 02 04 2c 	insert %d2,%d2,0,24,4
80009354:	a6 2f       	or %d15,%d2
80009356:	68 0f       	st.w [%a15]0,%d15
    OSEE_TC_SCU_PLLCON0.bits.ndiv = (uint8_t)(bestN - 1U);
80009358:	9a fd       	add %d15,%d13,-1
8000935a:	16 7f       	and %d15,127
8000935c:	8f 9f 00 f0 	sh %d15,%d15,9
80009360:	48 02       	ld.w %d2,[%a15]0
80009362:	b7 02 87 24 	insert %d2,%d2,0,9,7
80009366:	a6 2f       	or %d15,%d2
80009368:	68 0f       	st.w [%a15]0,%d15

    /* Power down VCO Normal Behavior */
    OSEE_TC_SCU_PLLCON0.bits.vcopwd = 0U;
8000936a:	4c f0       	ld.w %d15,[%a15]0
8000936c:	8f 2f c0 f1 	andn %d15,%d15,2
80009370:	68 0f       	st.w [%a15]0,%d15

    /***** Configure PLL normal mode. *****/

    /* Automatic oscillator disconnect disabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 1U;
80009372:	4c f0       	ld.w %d15,[%a15]0
80009374:	96 40       	or %d15,64
80009376:	68 0f       	st.w [%a15]0,%d15
    /* Connect VCO to the oscillator */
    OSEE_TC_SCU_PLLCON0.bits.clrfindis = 1U;
80009378:	4c f0       	ld.w %d15,[%a15]0
8000937a:	96 20       	or %d15,32
8000937c:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.findis == 1U) {
8000937e:	91 30 00 ff 	movh.a %a15,61443
80009382:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
80009386:	4c f0       	ld.w %d15,[%a15]0
80009388:	6f 3f ff ff 	jnz.t %d15,3,80009386 <osEE_tc_set_pll_fsource+0x1cc>
      ; /* Wait until oscillator is connected to the VCO */
    }

    /* Restart VCO lock detection */
    OSEE_TC_SCU_PLLCON0.bits.resld = 1U;
8000938c:	91 30 00 ff 	movh.a %a15,61443
80009390:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009394:	4c f0       	ld.w %d15,[%a15]0
80009396:	b7 ff 01 f9 	insert %d15,%d15,15,18,1
8000939a:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcolock == 0U) {
8000939c:	91 30 00 ff 	movh.a %a15,61443
800093a0:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800093a4:	4c f0       	ld.w %d15,[%a15]0
800093a6:	6f 2f ff 7f 	jz.t %d15,2,800093a4 <osEE_tc_set_pll_fsource+0x1ea>
      ; /* Wait until the VCO becomes locked */
    }

    /* Disable the VCO Bypass Mode */
    OSEE_TC_SCU_PLLCON0.bits.vcobyp = 0U;
800093aa:	91 30 00 ff 	movh.a %a15,61443
800093ae:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800093b2:	4c f0       	ld.w %d15,[%a15]0
800093b4:	8f 1f c0 f1 	andn %d15,%d15,1
800093b8:	68 0f       	st.w [%a15]0,%d15

    while (OSEE_TC_SCU_PLLSTAT.bits.vcobyst == 1U) {
800093ba:	91 30 00 ff 	movh.a %a15,61443
800093be:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
800093c2:	4c f0       	ld.w %d15,[%a15]0
800093c4:	6f 0f ff ff 	jnz.t %d15,0,800093c2 <osEE_tc_set_pll_fsource+0x208>
      ; /* Wait until normal mode is entered */
    }

    /* Automatic oscillator disconnect enabled */
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
800093c8:	91 30 00 ff 	movh.a %a15,61443
800093cc:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
800093d0:	4c f0       	ld.w %d15,[%a15]0
800093d2:	8f 0f c4 f1 	andn %d15,%d15,64
800093d6:	68 0f       	st.w [%a15]0,%d15
800093d8:	00 90       	ret 
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
            {
              fPllLeastError = fPllError;
800093da:	02 28       	mov %d8,%d2
800093dc:	02 31       	mov %d1,%d3
  }

  for (
    p = OSEE_TC_P_MAX;
    ((p >= OSEE_TC_P_MIN ) && (fPllError != 0ULL));
    --p
800093de:	80 7b       	mov.d %d11,%a7
          {
            fPllError = (
              (((n) / (p * k2)) * OSEE_TC_BOARD_FOSC) - fpll
            );

            if (fPllError == ((uint64_t)0U) )
800093e0:	02 0c       	mov %d12,%d0
800093e2:	1d ff 68 ff 	j 800092b2 <osEE_tc_set_pll_fsource+0xf8>
800093e6:	00 90       	ret 

800093e8 <osEE_tc_get_fsource>:
    OSEE_TC_SCU_PLLCON0.bits.oscdisdis = 0U;
  }

}

OsEE_reg osEE_tc_get_fsource(void) {
800093e8:	40 ae       	mov.aa %a14,%sp
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
800093ea:	91 30 00 ff 	movh.a %a15,61443
800093ee:	d9 ff 30 06 	lea %a15,[%a15]24624 <f0036030 <_SMALL_DATA4_+0x4002e030>>
800093f2:	4c f0       	ld.w %d15,[%a15]0
800093f4:	37 0f 62 fe 	extr.u %d15,%d15,28,2
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
      }
    }
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
800093f8:	7b 60 5f 20 	movh %d2,1526
800093fc:	1b 02 10 2e 	addi %d2,%d2,-7936

OsEE_reg osEE_tc_get_fsource(void) {
  /*  fSOURCE Frequency */
  OsEE_reg fsource;

  if (OSEE_TC_SCU_CCUCON0.bits.clksel != 0U) {
80009400:	6e 45       	jz %d15,8000948a <osEE_tc_get_fsource+0xa2>
    /* PLL */
    /* PLL dividers */
    OsEE_reg k1, k2, p, n;
    /* Prescaler mode */
    if (OSEE_TC_SCU_PLLSTAT.bits.vcobyst != 0U)
80009402:	91 30 00 ff 	movh.a %a15,61443
80009406:	d9 ff 14 06 	lea %a15,[%a15]24596 <f0036014 <_SMALL_DATA4_+0x4002e014>>
8000940a:	4c f0       	ld.w %d15,[%a15]0
8000940c:	6f 0f 11 00 	jz.t %d15,0,8000942e <osEE_tc_get_fsource+0x46>
    {
      k1 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k1div + 1U;
80009410:	91 30 00 ff 	movh.a %a15,61443
80009414:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
80009418:	48 02       	ld.w %d2,[%a15]0
8000941a:	37 02 67 28 	extr.u %d2,%d2,16,7
8000941e:	c2 12       	add %d2,1
      fsource = OSEE_TC_BOARD_FOSC / k1;
80009420:	7b 10 13 f0 	movh %d15,305
80009424:	1b 0f d0 f2 	addi %d15,%d15,11520
80009428:	4b 2f 11 22 	div.u %e2,%d15,%d2
8000942c:	00 90       	ret 
    } else {
      /* Free running mode */
      if (OSEE_TC_SCU_PLLSTAT.bits.findis != 0U)
8000942e:	4c f0       	ld.w %d15,[%a15]0
80009430:	6f 3f 11 00 	jz.t %d15,3,80009452 <osEE_tc_get_fsource+0x6a>
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009434:	91 30 00 ff 	movh.a %a15,61443
80009438:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000943c:	48 02       	ld.w %d2,[%a15]0
8000943e:	8f f2 07 21 	and %d2,%d2,127
80009442:	9a 12       	add %d15,%d2,1
        fsource = OSEE_TC_BOARD_FOSC / k2;
80009444:	7b 10 13 20 	movh %d2,305
80009448:	1b 02 d0 22 	addi %d2,%d2,11520
8000944c:	4b f2 11 22 	div.u %e2,%d2,%d15
80009450:	00 90       	ret 
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009452:	91 30 00 ff 	movh.a %a15,61443
80009456:	d9 ff 1c 06 	lea %a15,[%a15]24604 <f003601c <_SMALL_DATA4_+0x4002e01c>>
8000945a:	4c f0       	ld.w %d15,[%a15]0
8000945c:	8f ff 07 51 	and %d5,%d15,127
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
80009460:	91 30 00 ff 	movh.a %a15,61443
80009464:	d9 ff 18 06 	lea %a15,[%a15]24600 <f0036018 <_SMALL_DATA4_+0x4002e018>>
80009468:	4c f0       	ld.w %d15,[%a15]0
8000946a:	37 0f 64 3c 	extr.u %d3,%d15,24,4
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;
8000946e:	48 02       	ld.w %d2,[%a15]0
80009470:	37 02 e7 44 	extr.u %d4,%d2,9,7
      {
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
        fsource = OSEE_TC_BOARD_FOSC / k2;
      } else {
        /* PLL Normal mode */
        k2 = (OsEE_reg)OSEE_TC_SCU_PLLCON1.bits.k2div + 1U;
80009474:	9a 15       	add %d15,%d5,1
        p = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.pdiv + 1U;
        n = (OsEE_reg)OSEE_TC_SCU_PLLCON0.bits.ndiv + 1U;

        /* cpu clock value fclk = (fosc * n)/(P * k2) */
        fsource = n * (OSEE_TC_BOARD_FOSC / (p * k2));
80009476:	03 f3 0a ff 	madd %d15,%d15,%d3,%d15
8000947a:	7b 10 13 20 	movh %d2,305
8000947e:	1b 02 d0 22 	addi %d2,%d2,11520
80009482:	4b f2 11 22 	div.u %e2,%d2,%d15
80009486:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
  } else {
    /* Backup Oscillator (EVR) */
    fsource = OSEE_TC_EVR_OSC_FREQUENCY;
  }
  return fsource;
}
8000948a:	00 90       	ret 

8000948c <osEE_tc_stm_set_clockpersec>:
  return ticks;
}

/* Set inside std time reference  */
void osEE_tc_stm_set_clockpersec(void)
{
8000948c:	40 ae       	mov.aa %a14,%sp
#if (defined(__TASKING__))
  /* I don't know where is declared */
  extern unsigned long long setfoschz ( unsigned long long );
#endif /* __TASKING__ */
  /* fSOURCE Frequency */
  OsEE_reg const fsource  = osEE_tc_get_fsource();
8000948e:	6d ff ad ff 	call 800093e8 <osEE_tc_get_fsource>
  /* Standard Timer Module period rounded */
  OsEE_reg const fstm     = (fsource + 1U) / OSEE_SCU_HW_FSTM_DIV;
80009492:	91 30 00 ff 	movh.a %a15,61443
80009496:	d9 ff 34 06 	lea %a15,[%a15]24628 <f0036034 <_SMALL_DATA4_+0x4002e034>>
8000949a:	4c f0       	ld.w %d15,[%a15]0
8000949c:	37 0f 64 f4 	extr.u %d15,%d15,8,4
800094a0:	c2 12       	add %d2,1
800094a2:	4b f2 11 22 	div.u %e2,%d2,%d15

  /* Set Global variable with freq in Khz value */
  osEE_tc_stm_freq_khz = fstm / OSEE_KILO;
800094a6:	7b 20 06 f1 	movh %d15,4194
800094aa:	1b 3f dd f4 	addi %d15,%d15,19923
800094ae:	73 f2 68 20 	mul.u %e2,%d2,%d15
800094b2:	8f a3 1f f0 	sh %d15,%d3,-6
800094b6:	91 00 00 f7 	movh.a %a15,28672
800094ba:	59 ff a0 c0 	st.w [%a15]2848 <70000b20 <osEE_tc_stm_freq_khz>>,%d15
800094be:	00 90       	ret 

800094c0 <osEE_tc_stm_set_sr0>:
    that qualifier on pointers.
 */

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0(OsEE_reg usec,
    OsEE_tc_isr_hw_prio intvec)
{
800094c0:	40 ae       	mov.aa %a14,%sp
800094c2:	02 59       	mov %d9,%d5
800094c4:	4d c0 e1 8f 	mfcr %d8,$core_id
    5U;
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
800094c8:	6d ff 4f fe 	call 80009166 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
800094cc:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
800094d0:	8f 38 00 f1 	and %d15,%d8,3
800094d4:	9b 0f 0f 40 	addih %d4,%d15,240
800094d8:	8f 84 00 40 	sh %d4,%d4,8
800094dc:	60 4f       	mov.a %a15,%d4
 *  \return The timer lower word value read.
 */
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_tc_stm_get_time_lower_word(OsEE_reg stm_id)
{
  return OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_TIM0_OFF);
800094de:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
800094e0:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
800094e2:	68 c2       	st.w [%a15]48,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
800094e4:	df 09 23 00 	jeq %d9,0,8000952a <osEE_tc_stm_set_sr0+0x6a>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
800094e8:	48 e2       	ld.w %d2,[%a15]56
800094ea:	b7 02 05 24 	insert %d2,%d2,0,8,5
800094ee:	68 e2       	st.w [%a15]56,%d2
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
800094f0:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart0  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize0   = size_of_compare;
800094f4:	48 e2       	ld.w %d2,[%a15]56
800094f6:	37 32 05 30 	insert %d3,%d2,%d3,0,5
800094fa:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 0 with Compare Register 0 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0os     = 0U;
800094fc:	48 f2       	ld.w %d2,[%a15]60
800094fe:	8f 42 c0 21 	andn %d2,%d2,4
80009502:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en     = 1U;
80009504:	48 f2       	ld.w %d2,[%a15]60
80009506:	8f 12 40 21 	or %d2,%d2,1
8000950a:	68 f2       	st.w [%a15]60,%d2

/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 0U), intvec);
8000950c:	06 3f       	sh %d15,3
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000950e:	60 f2       	mov.a %a2,%d15
80009510:	d9 2f 50 28 	lea %a15,[%a2]-31600
80009514:	11 4f 00 ff 	addih.a %a15,%a15,61444
80009518:	b7 89 99 93 	insert %d9,%d9,8,7,25
8000951c:	8f 38 00 81 	and %d8,%d8,3
80009520:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
80009524:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
80009526:	68 09       	st.w [%a15]0,%d9
80009528:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp0en                 = 0U;
8000952a:	48 f2       	ld.w %d2,[%a15]60
8000952c:	8f 12 c0 21 	andn %d2,%d2,1
80009530:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 0U)) = 0U;
80009532:	1b 2f 09 f7 	addi %d15,%d15,28818
80009536:	9b 0f e0 f1 	addih %d15,%d15,7680
8000953a:	06 3f       	sh %d15,3
8000953c:	82 02       	mov %d2,0
8000953e:	60 ff       	mov.a %a15,%d15
80009540:	68 02       	st.w [%a15]0,%d2
80009542:	00 90       	ret 

80009544 <osEE_tc_stm_set_sr0_next_match>:
  }
}

OSEE_TC_STM_SR0_STORAGE void osEE_tc_stm_set_sr0_next_match(OsEE_reg usec)
{
80009544:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009546:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP0IRR bit 0 => 0x1 | CMP0IRS bit 1 => 0x2 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x1U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP0_OFF) += osEE_tc_stm_us_ticks(usec);
8000954a:	6d ff 0e fe 	call 80009166 <osEE_tc_stm_us_ticks>
8000954e:	16 03       	and %d15,3
80009550:	9b 0f 0f f0 	addih %d15,%d15,240
80009554:	8f 8f 00 f0 	sh %d15,%d15,8
80009558:	60 ff       	mov.a %a15,%d15
8000955a:	4c fc       	ld.w %d15,[%a15]48
8000955c:	42 f2       	add %d2,%d15
8000955e:	68 c2       	st.w [%a15]48,%d2
80009560:	00 90       	ret 

80009562 <osEE_tc_stm_set_sr1>:
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1(OsEE_reg usec,
  OsEE_tc_isr_hw_prio intvec)
{
80009562:	40 ae       	mov.aa %a14,%sp
80009564:	02 59       	mov %d9,%d5
80009566:	4d c0 e1 8f 	mfcr %d8,$core_id
#else
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
8000956a:	6d ff fe fd 	call 80009166 <osEE_tc_stm_us_ticks>
  __asm__ volatile ("mov.aa %0, %%" #areg : "=a"(ptr): : "memory", #areg)

#define osEE_tc_getareg(areg, ptr) osEE_tc_getareg2(areg, ptr)

OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_clz(OsEE_reg reg) {
  return (OsEE_reg)__builtin_clz(reg);
8000956e:	0f 02 b0 31 	clz %d3,%d2
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009572:	8f 38 00 f1 	and %d15,%d8,3
80009576:	9b 0f 0f 40 	addih %d4,%d15,240
8000957a:	8f 84 00 40 	sh %d4,%d4,8
8000957e:	60 4f       	mov.a %a15,%d4
80009580:	48 44       	ld.w %d4,[%a15]16
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);
80009582:	42 42       	add %d2,%d4
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));

/*  Set Compare Value Register (actual value + increment,
    I don't need to handle wrap around) */
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
80009584:	68 d2       	st.w [%a15]52,%d2
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
80009586:	df 09 28 00 	jeq %d9,0,800095d6 <osEE_tc_stm_set_sr1+0x74>
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
8000958a:	48 e2       	ld.w %d2,[%a15]56
8000958c:	b7 02 05 2c 	insert %d2,%d2,0,24,5
80009590:	68 e2       	st.w [%a15]56,%d2
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */

/* Get Interrupt period in ticks */
  us_in_ticks = osEE_tc_stm_us_ticks(usec);
/* Adjust the size of the mask */
  size_of_compare = 31U - ((uint8_t)osEE_tc_clz(us_in_ticks));
80009592:	8b f3 01 31 	rsub %d3,%d3,31
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) =
    us_in_ticks + osEE_tc_stm_get_time_lower_word(stm_id);

  if (intvec != 0U) {
    OSEE_TC_STM_CMCON(stm_id).bits.mstart1  = 0U;
    OSEE_TC_STM_CMCON(stm_id).bits.msize1   = size_of_compare;
80009596:	8f f3 01 31 	and %d3,%d3,31
8000959a:	8f 03 01 30 	sh %d3,%d3,16
8000959e:	48 e2       	ld.w %d2,[%a15]56
800095a0:	b7 02 05 28 	insert %d2,%d2,0,16,5
800095a4:	a6 23       	or %d3,%d2
800095a6:	68 e3       	st.w [%a15]56,%d3
/* Tie STM Service Request 1 with Compare Register 1 */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1os     = 1U;
800095a8:	48 f2       	ld.w %d2,[%a15]60
800095aa:	8f 02 44 21 	or %d2,%d2,64
800095ae:	68 f2       	st.w [%a15]60,%d2
/* Enable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en     = 1U;
800095b0:	48 f2       	ld.w %d2,[%a15]60
800095b2:	8f 02 41 21 	or %d2,%d2,16
800095b6:	68 f2       	st.w [%a15]60,%d2
/*
 *  STM service Request configuration
 */
    osEE_tc_conf_src(core_id, OSEE_TC_STM_SRC_OFFSET(stm_id, 1U), intvec);
800095b8:	06 3f       	sh %d15,3
800095ba:	60 f2       	mov.a %a2,%d15
800095bc:	d9 2f 54 28 	lea %a15,[%a2]-31596
800095c0:	11 4f 00 ff 	addih.a %a15,%a15,61444
800095c4:	b7 89 99 93 	insert %d9,%d9,8,7,25
800095c8:	8f 38 00 81 	and %d8,%d8,3
800095cc:	8f b8 00 80 	sh %d8,%d8,11
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
800095d0:	a6 89       	or %d9,%d8
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
800095d2:	68 09       	st.w [%a15]0,%d9
800095d4:	00 90       	ret 
  } else {
/* Disable STM Service Request Source */
    OSEE_TC_STM_ICR(stm_id).bits.cmp1en                 = 0U;
800095d6:	48 f2       	ld.w %d2,[%a15]60
800095d8:	8f 02 c1 21 	andn %d2,%d2,16
800095dc:	68 f2       	st.w [%a15]60,%d2
    OSEE_TC_SRC_REG(OSEE_TC_STM_SRC_OFFSET(stm_id, 1U)) = 0U;
800095de:	06 3f       	sh %d15,3
800095e0:	60 f2       	mov.a %a2,%d15
800095e2:	d9 2f 54 28 	lea %a15,[%a2]-31596
800095e6:	11 4f 00 ff 	addih.a %a15,%a15,61444
800095ea:	82 0f       	mov %d15,0
800095ec:	68 0f       	st.w [%a15]0,%d15
800095ee:	00 90       	ret 

800095f0 <osEE_tc_stm_set_sr1_next_match>:
  }
}

OSEE_TC_STM_SR1_STORAGE void osEE_tc_stm_set_sr1_next_match(OsEE_reg usec)
{
800095f0:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800095f2:	4d c0 e1 ff 	mfcr %d15,$core_id
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
/* CMP1IRR bit 2 => 0x4 | CMP1IRS bit 3 => 0x8 */
#if 0
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_ISCR_OFF) = 0x4U;
#endif
  OSEE_TC_STM_REG(stm_id, OSEE_TC_STM_CMP1_OFF) += osEE_tc_stm_us_ticks(usec);
800095f6:	6d ff b8 fd 	call 80009166 <osEE_tc_stm_us_ticks>
800095fa:	16 03       	and %d15,3
800095fc:	9b 0f 0f f0 	addih %d15,%d15,240
80009600:	8f 8f 00 f0 	sh %d15,%d15,8
80009604:	60 ff       	mov.a %a15,%d15
80009606:	4c fd       	ld.w %d15,[%a15]52
80009608:	42 f2       	add %d2,%d15
8000960a:	68 d2       	st.w [%a15]52,%d2
8000960c:	00 90       	ret 

8000960e <osEE_tc_delay>:
}

void osEE_tc_delay(OsEE_reg usec)
{
8000960e:	40 ae       	mov.aa %a14,%sp
80009610:	4d c0 e1 ff 	mfcr %d15,$core_id
80009614:	16 03       	and %d15,3
80009616:	9b 0f 0f f0 	addih %d15,%d15,240
8000961a:	8f 8f 00 f0 	sh %d15,%d15,8
8000961e:	60 f2       	mov.a %a2,%d15
80009620:	d9 2f 10 00 	lea %a15,[%a2]16
80009624:	19 28 10 00 	ld.w %d8,[%a2]16
  OsEE_reg   const  stm_id  = (OsEE_reg)core_id;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
  /* Read Start Point */
  OsEE_reg    const start = osEE_tc_stm_get_time_lower_word(stm_id);
  /* Evaluate End Point */
  OsEE_reg    const ticks = osEE_tc_stm_us_ticks(usec);
80009628:	6d ff 9f fd 	call 80009166 <osEE_tc_stm_us_ticks>
8000962c:	4c f0       	ld.w %d15,[%a15]0

  while (ticks > (osEE_tc_stm_get_time_lower_word(stm_id) - start)) {
8000962e:	a2 8f       	sub %d15,%d8
80009630:	3f 2f fe ff 	jlt.u %d15,%d2,8000962c <osEE_tc_delay+0x1e>
    ; /* Wait */
  }
}
80009634:	00 90       	ret 

80009636 <osEE_tc_isr2_wrapper>:

#if (defined(__GNUC__))
#pragma section
#endif /* __GNUC__ */

static void OSEE_COMPILER_KEEP osEE_tc_isr2_wrapper(TaskType isr2_tid) {
80009636:	40 ae       	mov.aa %a14,%sp
#if (!defined(OSEE_SINGLECORE))
  if (isr2_tid == INVALID_TASK) {
80009638:	df f4 5c 80 	jne %d4,-1,800096f0 <osEE_tc_isr2_wrapper+0xba>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000963c:	4d c0 e2 ff 	mfcr %d15,$icr
    OsEE_icr icr  = osEE_tc_get_icr();
    if (icr.bits.ccpn == 1U) {
80009640:	16 ff       	and %d15,255
80009642:	df 1f 59 80 	jne %d15,1,800096f4 <osEE_tc_isr2_wrapper+0xbe>
      CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
      CONSTP2CONST(OsEE_KCB, AUTOMATIC, OS_APPL_DATA) p_kcb = p_kdb->p_kcb;
80009646:	91 00 00 f8 	movh.a %a15,32768
8000964a:	99 f2 28 50 	ld.a %a2,[%a15]360 <80000168 <osEE_kdb_var>>
8000964e:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009652:	8f f8 0f f1 	and %d15,%d8,255
80009656:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000965a:	ee 0a       	jnz %d15,8000966e <osEE_tc_isr2_wrapper+0x38>
    OsEE_icr icr_temp = icr;
8000965c:	02 8f       	mov %d15,%d8
8000965e:	3b 30 01 20 	mov %d2,19
80009662:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009666:	cd cf e2 0f 	mtcr $icr,%d15
8000966a:	0d 00 c0 04 	isync 
8000966e:	4d c0 e1 2f 	mfcr %d2,$core_id
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_ack_signal(void)
{
  CoreIdType core_id = osEE_get_curr_core_id();

  OSEE_TC_SRC_REG(OSEE_TC_GPSR_SRC_OFFSET(OSEE_TC_GPSR_G, core_id)) |=
80009672:	8f f2 0f f1 	and %d15,%d2,255
80009676:	91 40 00 ff 	movh.a %a15,61444
8000967a:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000967e:	ff 4f 0b 80 	jge.u %d15,4,80009694 <osEE_tc_isr2_wrapper+0x5e>
80009682:	37 02 48 20 	extr %d2,%d2,0,8
80009686:	60 23       	mov.a %a3,%d2
80009688:	d9 3f 40 0e 	lea %a15,[%a3]-7168
8000968c:	11 1f c0 f3 	addih.a %a15,%a15,15361
80009690:	30 ff       	add.a %a15,%a15
80009692:	30 ff       	add.a %a15,%a15
80009694:	4c f0       	ld.w %d15,[%a15]0
80009696:	7b 00 20 24 	movh %d2,16896
8000969a:	a6 2f       	or %d15,%d2
8000969c:	68 0f       	st.w [%a15]0,%d15

      /* Ack IIRQ */
      osEE_tc_ack_signal();

      /* Check for ShutdownAllCores */
      if (p_kcb->ar_shutdown_all_cores_flag) {
8000969e:	0c 2e       	ld.bu %d15,[%a2]14
800096a0:	6e 12       	jz %d15,800096c4 <osEE_tc_isr2_wrapper+0x8e>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
800096a2:	40 93       	mov.aa %a3,%a9
        CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
          p_curr_cdb = osEE_get_curr_core();
        osEE_shutdown_os(p_curr_cdb,
800096a4:	39 22 0d 00 	ld.bu %d2,[%a2]13
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
800096a8:	cc 33       	ld.a %a15,[%a3]12
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
800096aa:	39 ff 10 00 	ld.bu %d15,[%a15]16 <f0030003 <_SMALL_DATA4_+0x40028003>>

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
800096ae:	82 33       	mov %d3,3
800096b0:	e9 f3 10 00 	st.b [%a15]16,%d3
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
800096b4:	e9 f2 12 00 	st.b [%a15]18,%d2

  if (os_status == OSEE_KERNEL_STARTED) {
800096b8:	5e 25       	jne %d15,2,800096c2 <osEE_tc_isr2_wrapper+0x8c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
800096ba:	99 34 14 00 	ld.a %a4,[%a3]20 <f0030014 <_SMALL_DATA4_+0x40028014>>
800096be:	6d 00 2c 10 	call 8000b716 <osEE_idle_task_terminate>
800096c2:	3c 00       	j 800096c2 <osEE_tc_isr2_wrapper+0x8c>
          p_kcb->ar_shutdown_all_cores_error);
      } else {
        (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
800096c4:	91 00 00 48 	movh.a %a4,32768
800096c8:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
800096cc:	6d 00 d9 0d 	call 8000b27e <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800096d0:	4d c0 e2 3f 	mfcr %d3,$icr
800096d4:	02 3f       	mov %d15,%d3
800096d6:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800096da:	8f f8 0f 21 	and %d2,%d8,255
800096de:	5f 23 0b 00 	jeq %d3,%d2,800096f4 <osEE_tc_isr2_wrapper+0xbe>
800096e2:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800096e6:	cd cf e2 0f 	mtcr $icr,%d15
800096ea:	0d 00 c0 04 	isync 
800096ee:	3c 03       	j 800096f4 <osEE_tc_isr2_wrapper+0xbe>
    }
    /* TODO: handle other internal priorities? System Timer? */
  } else
#endif /* !OSEE_SINGLECORE */
  {
    osEE_activate_isr2(isr2_tid);
800096f0:	6d 00 4d 0c 	call 8000af8a <osEE_activate_isr2>
  __asm__ volatile ("svlcx" : : : "memory");
}

/** The rslcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rslcx(void) {
  __asm__ volatile ("rslcx" : : : "memory");
800096f4:	0d 00 40 02 	rslcx 
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
800096f8:	00 80       	rfe 
800096fa:	00 90       	ret 

800096fc <osEE_shutdown_os>:
  osEE_shutdown_os
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST) p_cdb,
  VAR(StatusType, AUTOMATIC)                Error
)
{
800096fc:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
800096fe:	cc 43       	ld.a %a15,[%a4]12
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009700:	39 ff 10 00 	ld.bu %d15,[%a15]16

  p_ccb->os_status = OSEE_KERNEL_SHUTDOWN;
80009704:	82 32       	mov %d2,3
80009706:	e9 f2 10 00 	st.b [%a15]16,%d2
  /* Used to propagate the error to the ShutdownHook */
  p_ccb->last_error = Error;
8000970a:	e9 f4 12 00 	st.b [%a15]18,%d4

  if (os_status == OSEE_KERNEL_STARTED) {
8000970e:	5e 25       	jne %d15,2,80009718 <osEE_shutdown_os+0x1c>
    osEE_idle_task_terminate(p_cdb->p_idle_task);
80009710:	99 44 14 00 	ld.a %a4,[%a4]20
80009714:	6d 00 01 10 	call 8000b716 <osEE_idle_task_terminate>
  } else {
    osEE_call_shutdown_hook(p_ccb, Error);
  }
  for (;;) {
    ; /* Endless Loop (entered only if Kernel Not Started) */
  }
80009718:	3c 00       	j 80009718 <osEE_shutdown_os+0x1c>

8000971a <DisableAllInterrupts>:
FUNC(void, OS_CODE)
  DisableAllInterrupts
(
  void
)
{
8000971a:	40 ae       	mov.aa %a14,%sp
8000971c:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000971e:	c8 3f       	ld.a %a15,[%a15]12
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
80009720:	0d 00 40 03 	disable 
  osEE_hal_disableIRQ();

  osEE_stack_monitoring(p_cdb);

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_DisableAllInterrupts);
  p_ccb->d_isr_all_cnt = 1U;
80009724:	82 1f       	mov %d15,1
80009726:	e9 ff 22 00 	st.b [%a15]34,%d15
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
8000972a:	da 0c       	mov %d15,12
8000972c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009730:	82 0f       	mov %d15,0
80009732:	e9 ff 23 00 	st.b [%a15]35,%d15
80009736:	00 90       	ret 

80009738 <EnableAllInterrupts>:
FUNC(void, OS_CODE)
  EnableAllInterrupts
(
  void
)
{
80009738:	40 ae       	mov.aa %a14,%sp
8000973a:	40 9f       	mov.aa %a15,%a9
   * ResumeOSInterrupts() are called and no corresponding DisableAllInterupts()
   * /SuspendAllInterrupts()/SuspendOSInterrupts() was done before, the
   * Operating System module shall not perform this Operating System service.
   * (SRS_Os_11009) */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
8000973c:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000973e:	da 0f       	mov %d15,15
80009740:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009744:	82 1f       	mov %d15,1
80009746:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_EnableAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->d_isr_all_cnt > 0U) {
8000974a:	39 ff 22 00 	ld.bu %d15,[%a15]34
8000974e:	6e 09       	jz %d15,80009760 <EnableAllInterrupts+0x28>
    p_ccb->d_isr_all_cnt = 0U;
80009750:	82 0f       	mov %d15,0
80009752:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009756:	0d 00 00 03 	enable 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000975a:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000975e:	5e 17       	jne %d15,1,8000976c <EnableAllInterrupts+0x34>
    p_ccb->service_id            = service_id;
80009760:	da 0e       	mov %d15,14
80009762:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009766:	82 0f       	mov %d15,0
80009768:	e9 ff 23 00 	st.b [%a15]35,%d15
8000976c:	00 90       	ret 

8000976e <SuspendAllInterrupts>:
FUNC(void, OS_CODE)
  SuspendAllInterrupts
(
  void
)
{
8000976e:	40 ae       	mov.aa %a14,%sp
80009770:	40 94       	mov.aa %a4,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009772:	cc 43       	ld.a %a15,[%a4]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009774:	da 11       	mov %d15,17
80009776:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000977a:	82 1f       	mov %d15,1
8000977c:	e9 ff 23 00 	st.b [%a15]35,%d15
(
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb,
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb
)
{
  if (p_ccb->s_isr_all_cnt == 0U) {
80009780:	39 ff 20 00 	ld.bu %d15,[%a15]32
80009784:	ee 0c       	jnz %d15,8000979c <SuspendAllInterrupts+0x2e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009786:	4d c0 e2 ff 	mfcr %d15,$icr
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
8000978a:	0d 00 40 03 	disable 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_suspendIRQ();
    p_ccb->prev_s_isr_all_status = flags;
8000978e:	68 6f       	st.w [%a15]24,%d15
    ++p_ccb->s_isr_all_cnt;
80009790:	39 ff 20 00 	ld.bu %d15,[%a15]32
80009794:	c2 1f       	add %d15,1
80009796:	e9 ff 20 00 	st.b [%a15]32,%d15
8000979a:	3c 0b       	j 800097b0 <SuspendAllInterrupts+0x42>
  } else if (p_ccb->s_isr_all_cnt < OSEE_MAX_BYTE) {
8000979c:	8b ff 0f 22 	eq %d2,%d15,255
800097a0:	f6 25       	jnz %d2,800097aa <SuspendAllInterrupts+0x3c>
    ++p_ccb->s_isr_all_cnt;
800097a2:	c2 1f       	add %d15,1
800097a4:	e9 ff 20 00 	st.b [%a15]32,%d15
800097a8:	3c 04       	j 800097b0 <SuspendAllInterrupts+0x42>
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
800097aa:	3b 90 01 40 	mov %d4,25
800097ae:	3c a7       	j 800096fc <osEE_shutdown_os>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800097b0:	39 ff 23 00 	ld.bu %d15,[%a15]35
800097b4:	5e 17       	jne %d15,1,800097c2 <SuspendAllInterrupts+0x54>
    p_ccb->service_id            = service_id;
800097b6:	da 10       	mov %d15,16
800097b8:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800097bc:	82 0f       	mov %d15,0
800097be:	e9 ff 23 00 	st.b [%a15]35,%d15
800097c2:	00 90       	ret 

800097c4 <ResumeAllInterrupts>:
FUNC(void, OS_CODE)
  ResumeAllInterrupts
(
  void
)
{
800097c4:	40 ae       	mov.aa %a14,%sp
800097c6:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800097c8:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
800097ca:	da 13       	mov %d15,19
800097cc:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
800097d0:	82 1f       	mov %d15,1
800097d2:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeAllInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_all_cnt > 0U) {
800097d6:	39 ff 20 00 	ld.bu %d15,[%a15]32
800097da:	6e 0e       	jz %d15,800097f6 <ResumeAllInterrupts+0x32>
    --p_ccb->s_isr_all_cnt;
800097dc:	c2 ff       	add %d15,-1
800097de:	16 ff       	and %d15,255
800097e0:	e9 ff 20 00 	st.b [%a15]32,%d15

    if (p_ccb->s_isr_all_cnt == 0U) {
800097e4:	ee 06       	jnz %d15,800097f0 <ResumeAllInterrupts+0x2c>
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800097e6:	4c f6       	ld.w %d15,[%a15]24
800097e8:	cd cf e2 0f 	mtcr $icr,%d15
800097ec:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800097f0:	39 ff 23 00 	ld.bu %d15,[%a15]35
800097f4:	5e 17       	jne %d15,1,80009802 <ResumeAllInterrupts+0x3e>
    p_ccb->service_id            = service_id;
800097f6:	da 12       	mov %d15,18
800097f8:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800097fc:	82 0f       	mov %d15,0
800097fe:	e9 ff 23 00 	st.b [%a15]35,%d15
80009802:	00 90       	ret 

80009804 <SuspendOSInterrupts>:
FUNC(void, OS_CODE)
  SuspendOSInterrupts
(
  void
)
{
80009804:	40 ae       	mov.aa %a14,%sp
80009806:	40 94       	mov.aa %a4,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009808:	cc 43       	ld.a %a15,[%a4]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000980a:	da 15       	mov %d15,21
8000980c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009810:	82 1f       	mov %d15,1
80009812:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_SuspendOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt == 0U) {
80009816:	39 ff 21 00 	ld.bu %d15,[%a15]33
8000981a:	ee 18       	jnz %d15,8000984a <SuspendOSInterrupts+0x46>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000981c:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009820:	8f f2 0f f1 	and %d15,%d2,255
80009824:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009828:	ee 0a       	jnz %d15,8000983c <SuspendOSInterrupts+0x38>
    OsEE_icr icr_temp = icr;
8000982a:	02 2f       	mov %d15,%d2
8000982c:	3b 30 01 30 	mov %d3,19
80009830:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009834:	cd cf e2 0f 	mtcr $icr,%d15
80009838:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_hal_begin_nested_primitive();
    p_ccb->prev_s_isr_os_status = flags;
8000983c:	68 72       	st.w [%a15]28,%d2
    ++p_ccb->s_isr_os_cnt;
8000983e:	39 ff 21 00 	ld.bu %d15,[%a15]33
80009842:	c2 1f       	add %d15,1
80009844:	e9 ff 21 00 	st.b [%a15]33,%d15
80009848:	3c 0c       	j 80009860 <SuspendOSInterrupts+0x5c>
  } else if (p_ccb->s_isr_os_cnt < OSEE_MAX_BYTE) {
8000984a:	8b ff 0f 22 	eq %d2,%d15,255
8000984e:	f6 25       	jnz %d2,80009858 <SuspendOSInterrupts+0x54>
    ++p_ccb->s_isr_os_cnt;
80009850:	c2 1f       	add %d15,1
80009852:	e9 ff 21 00 	st.b [%a15]33,%d15
80009856:	3c 05       	j 80009860 <SuspendOSInterrupts+0x5c>
  } else {
#if (defined(OSEE_HAS_PROTECTIONHOOK))
#error Add ProtectionHook call here once it has been implemented
#else
    osEE_shutdown_os(p_cdb, E_OS_SYS_SUSPEND_NESTING_LIMIT);
80009858:	3b 90 01 40 	mov %d4,25
8000985c:	1d ff 50 ff 	j 800096fc <osEE_shutdown_os>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009860:	39 ff 23 00 	ld.bu %d15,[%a15]35
80009864:	5e 17       	jne %d15,1,80009872 <SuspendOSInterrupts+0x6e>
    p_ccb->service_id            = service_id;
80009866:	da 14       	mov %d15,20
80009868:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000986c:	82 0f       	mov %d15,0
8000986e:	e9 ff 23 00 	st.b [%a15]35,%d15
80009872:	00 90       	ret 

80009874 <ResumeOSInterrupts>:
FUNC(void, OS_CODE)
  ResumeOSInterrupts
(
  void
)
{
80009874:	40 ae       	mov.aa %a14,%sp
80009876:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
80009878:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000987a:	da 17       	mov %d15,23
8000987c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009880:	82 1f       	mov %d15,1
80009882:	e9 ff 23 00 	st.b [%a15]35,%d15

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_ResumeOSInterrupts);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->s_isr_os_cnt > 0U) {
80009886:	39 ff 21 00 	ld.bu %d15,[%a15]33
8000988a:	6e 19       	jz %d15,800098bc <ResumeOSInterrupts+0x48>
    --p_ccb->s_isr_os_cnt;
8000988c:	c2 ff       	add %d15,-1
8000988e:	16 ff       	and %d15,255
80009890:	e9 ff 21 00 	st.b [%a15]33,%d15

    if (p_ccb->s_isr_os_cnt == 0U) {
80009894:	ee 11       	jnz %d15,800098b6 <ResumeOSInterrupts+0x42>
      osEE_hal_end_nested_primitive(p_ccb->prev_s_isr_os_status);
80009896:	48 72       	ld.w %d2,[%a15]28
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009898:	4d c0 e2 3f 	mfcr %d3,$icr
8000989c:	02 3f       	mov %d15,%d3
8000989e:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
800098a2:	8f f2 0f 21 	and %d2,%d2,255
800098a6:	5f 23 08 00 	jeq %d3,%d2,800098b6 <ResumeOSInterrupts+0x42>
800098aa:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098ae:	cd cf e2 0f 	mtcr $icr,%d15
800098b2:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800098b6:	39 ff 23 00 	ld.bu %d15,[%a15]35
800098ba:	5e 17       	jne %d15,1,800098c8 <ResumeOSInterrupts+0x54>
    p_ccb->service_id            = service_id;
800098bc:	da 16       	mov %d15,22
800098be:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800098c2:	82 0f       	mov %d15,0
800098c4:	e9 ff 23 00 	st.b [%a15]35,%d15
800098c8:	00 90       	ret 

800098ca <StartOS>:
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
800098ca:	40 ae       	mov.aa %a14,%sp
800098cc:	20 08       	sub.a %sp,8
800098ce:	02 49       	mov %d9,%d4
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
800098d0:	4d c0 e1 8f 	mfcr %d8,$core_id
  VAR(StatusType, AUTOMATIC)                      ev = E_OK;
  VAR(AppModeType, AUTOMATIC)                     real_mode = Mode;
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)           curr_core_id = osEE_get_curr_core_id();
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)  p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)   p_kcb = p_kdb->p_kcb;
800098d4:	91 00 00 f8 	movh.a %a15,32768
800098d8:	99 fc 28 50 	ld.a %a12,[%a15]360 <80000168 <osEE_kdb_var>>
800098dc:	40 9d       	mov.aa %a13,%a9
#endif /* !OSEE_SINGLECORE */
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)  p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)   p_ccb = p_cdb->p_ccb;
800098de:	cc d3       	ld.a %a15,[%a13]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
800098e0:	4d c0 e2 cf 	mfcr %d12,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
800098e4:	8f fc 0f f1 	and %d15,%d12,255
800098e8:	8b 3f a1 f2 	ge.u %d15,%d15,19
800098ec:	ee 0a       	jnz %d15,80009900 <StartOS+0x36>
    OsEE_icr icr_temp = icr;
800098ee:	02 cf       	mov %d15,%d12
800098f0:	3b 30 01 20 	mov %d2,19
800098f4:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
800098f8:	cd cf e2 0f 	mtcr $icr,%d15
800098fc:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009900:	da 4b       	mov %d15,75
80009902:	e9 ff 13 00 	st.b [%a15]19 <80000013 <BootModeHeader0+0x13>>,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009906:	82 1f       	mov %d15,1
80009908:	e9 ff 23 00 	st.b [%a15]35 <80000023 <_start+0x3>>,%d15
  osEE_orti_trace_service_entry(p_ccb, OSServiceId_StartOS);
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  osEE_lock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000990c:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
80009910:	df 0f a9 80 	jne %d15,0,80009a62 <StartOS+0x198>
80009914:	37 08 48 80 	extr %d8,%d8,0,8
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
  } else
#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_MASTER) {
80009918:	df 08 dc 80 	jne %d8,0,80009ad0 <StartOS+0x206>
    /* I rely in C shortcut for boolean expression */
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
8000991c:	6d 00 10 0f 	call 8000b73c <osEE_cpu_startos>
80009920:	df 02 bb 00 	jeq %d2,0,80009a96 <StartOS+0x1cc>
80009924:	1d 00 f1 00 	j 80009b06 <StartOS+0x23c>
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
        0U
    )
    {
      for(;;) {}  /* Endless Loop */
80009928:	3c 00       	j 80009928 <StartOS+0x5e>
    /* Initialize Slaves Hardware after First synchronization point:
       This ensures that all the Master Initializations have been done. */
    if (curr_core_id != OS_CORE_ID_MASTER) {
      if (!osEE_cpu_startos()) {
        /* Enter in an endless loop if it happens */
        for(;;) {}
8000992a:	3c 00       	j 8000992a <StartOS+0x60>
    and shall enter an endless loop on every core. (SRS_Os_80006) */
    {
      VAR(CoreNumType, AUTOMATIC)  i;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
        if ((p_kcb->ar_core_mask & ((CoreMaskType)1U << i)) != 0U) {
8000992c:	54 c2       	ld.w %d2,[%a12]
8000992e:	57 02 61 2d 	extr.u %d2,%d2,%d13,1
80009932:	df 02 15 00 	jeq %d2,0,8000995c <StartOS+0x92>
          CONST(AppModeType, AUTOMATIC)
            /* MISRA-C 2012: Rule 10.5 deviation. Cast back from
               unsigned to enum is safe here, since we are in a loop
               with the right limits. */
            current_mode = osEE_get_core((CoreIdType)i)->p_ccb->app_mode;
80009936:	37 0d 48 40 	extr %d4,%d13,0,8
8000993a:	6d 00 bd 0f 	call 8000b8b4 <osEE_get_core>
8000993e:	99 22 0c 00 	ld.a %a2,[%a2]12
80009942:	39 22 11 00 	ld.bu %d2,[%a2]17

          if (current_mode != DONOTCARE) {
80009946:	8b f2 0f 32 	eq %d3,%d2,255
8000994a:	f6 39       	jnz %d3,8000995c <StartOS+0x92>
            if (real_mode == DONOTCARE) {
8000994c:	8b ff 0f 32 	eq %d3,%d15,255
80009950:	f6 33       	jnz %d3,80009956 <StartOS+0x8c>
              real_mode = current_mode;
            } else if (real_mode != current_mode) {
80009952:	3e 24       	jeq %d15,%d2,8000995a <StartOS+0x90>
            /* Error condition specified by SWS_Os_00608 requirement:
               enter in an endless loop */
              for(;;) {}
80009954:	3c 00       	j 80009954 <StartOS+0x8a>
               with the right limits. */
            current_mode = osEE_get_core((CoreIdType)i)->p_ccb->app_mode;

          if (current_mode != DONOTCARE) {
            if (real_mode == DONOTCARE) {
              real_mode = current_mode;
80009956:	02 2f       	mov %d15,%d2
80009958:	3c 02       	j 8000995c <StartOS+0x92>
8000995a:	02 2f       	mov %d15,%d2
8000995c:	c2 1d       	add %d13,1
    StartOS shall not start the scheduling, shall not call any StartupHooks,
    and shall enter an endless loop on every core. (SRS_Os_80006) */
    {
      VAR(CoreNumType, AUTOMATIC)  i;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
8000995e:	df 3d e7 ff 	jne %d13,3,8000992c <StartOS+0x62>
            }
          }
        }
      }

      if (real_mode != DONOTCARE) {
80009962:	8b ff 0f 22 	eq %d2,%d15,255
80009966:	f6 27       	jnz %d2,80009974 <StartOS+0xaa>
        /* Set mode for this core as real_mode */
        if (Mode == DONOTCARE) {
80009968:	8b f9 2f 92 	ne %d9,%d9,255
8000996c:	f6 98       	jnz %d9,8000997c <StartOS+0xb2>
          p_ccb->app_mode = real_mode;
8000996e:	e9 ff 11 00 	st.b [%a15]17 <80000011 <BootModeHeader0+0x11>>,%d15
80009972:	3c 05       	j 8000997c <StartOS+0xb2>
        }
      } else {
        /* XXX: It is not specified how to handle the condition that no cores
                defines an AppMode different from DONOTCARE.
                I choose to handle it using OSDEFAULTAPPMODE */
        p_ccb->app_mode = OSDEFAULTAPPMODE;
80009974:	82 0f       	mov %d15,0
80009976:	e9 ff 11 00 	st.b [%a15]17 <80000011 <BootModeHeader0+0x11>>,%d15
#if (defined(OSEE_HAS_AUTOSTART_TRIGGER)) || (defined(OSEE_HAS_AUTOSTART_TASK))
        real_mode = OSDEFAULTAPPMODE;
8000997a:	82 0f       	mov %d15,0
#if (defined(OSEE_HAS_AUTOSTART_TRIGGER))
    {
      VAR(MemSize, AUTOMATIC) i;
      VAR(MemSize, AUTOMATIC) trigger_size;
      CONSTP2VAR(OsEE_autostart_trigger, AUTOMATIC, OS_APPL_CONST)
        p_auto_triggers = &(*p_cdb->p_autostart_trigger_array)[real_mode];
8000997c:	19 d2 18 00 	ld.w %d2,[%a13]24
      P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_CONST) p_alarm_db_tmp;  /* MISRA R13.2 */
#endif /* OSEE_HAS_ALARMS */
      P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db_tmp;   /* MISRA R13.2 */
#endif /* OSEE_HAS_SCHEDULE_TABLES */

      trigger_size = p_auto_triggers->trigger_array_size;
80009980:	60 23       	mov.a %a3,%d2
80009982:	d0 32       	addsc.a %a2,%a3,%d15,3
80009984:	19 29 04 00 	ld.w %d9,[%a2]4
      for (i = 0U; i < trigger_size; ++i) {
80009988:	df 09 14 00 	jeq %d9,0,800099b0 <StartOS+0xe6>
8000998c:	82 0f       	mov %d15,0
        CONSTP2VAR(OsEE_autostart_trigger_info, AUTOMATIC, OS_APPL_CONST)
          p_trigger_to_act_info = &(*p_auto_triggers->p_trigger_ptr_array)[i];
8000998e:	40 2d       	mov.aa %a13,%a2
80009990:	54 d2       	ld.w %d2,[%a13]
        CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_CONST)
          p_trigger_to_act_db   = p_trigger_to_act_info->p_trigger_db;
80009992:	13 cf 20 32 	madd %d3,%d2,%d15,12
80009996:	60 32       	mov.a %a2,%d3
80009998:	d4 25       	ld.a %a5,[%a2]
#if (!defined(OSEE_HAS_SCHEDULE_TABLES))
        (void)osEE_alarm_set_rel(
8000999a:	99 54 04 00 	ld.a %a4,[%a5]4
8000999e:	19 24 04 00 	ld.w %d4,[%a2]4
800099a2:	19 25 08 00 	ld.w %d5,[%a2]8
800099a6:	6d 00 bb 0d 	call 8000b51c <osEE_alarm_set_rel>
#endif /* OSEE_HAS_ALARMS */
      P2VAR(OsEE_SchedTabDB, AUTOMATIC, OS_APPL_CONST) p_st_db_tmp;   /* MISRA R13.2 */
#endif /* OSEE_HAS_SCHEDULE_TABLES */

      trigger_size = p_auto_triggers->trigger_array_size;
      for (i = 0U; i < trigger_size; ++i) {
800099aa:	c2 1f       	add %d15,1
800099ac:	5f 9f f2 ff 	jne %d15,%d9,80009990 <StartOS+0xc6>
    Specification paragraph 7.9.4 Multi-Core start-up concept:
    "This release of the AUTOSAR specification does not support timeouts
    during the synchronization phase. Cores that are activated with
    StartCore but do not call StartOS may cause the system to hang.
    It is in the responsibility of the integrator to avoid such behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
800099b0:	60 e4       	mov.a %a4,%d14
800099b2:	99 e5 fc ff 	ld.a %a5,[%a14]-4
800099b6:	a0 06       	mov.a %a6,0
800099b8:	6d 00 43 0f 	call 8000b83e <osEE_hal_sync_barrier>
      OSEE_STARTOS_2ND_SYNC_BARRIER_CB);
/* After second synchronization I'm sure that no more AR cores will be
   started: I initialize the Shutdown(AllCores) mask in master core */
    if (curr_core_id == OS_CORE_ID_MASTER) {
800099bc:	f6 83       	jnz %d8,800099c2 <StartOS+0xf8>
      p_kcb->ar_shutdown_mask = p_kcb->ar_core_mask;
800099be:	4c c0       	ld.w %d15,[%a12]0
800099c0:	6c c2       	st.w [%a12]8,%d15
    }
#endif /* !OSEE_SINGLECORE */

/* [SWS_Os_00607] StartOS shall start the OS on the core on which it is called.
    (SRS_Os_80006, SRS_Os_80013) */
    if (p_ccb->os_status == OSEE_KERNEL_STARTING) {
800099c2:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
800099c6:	5e 14       	jne %d15,1,800099ce <StartOS+0x104>
      p_ccb->os_status = OSEE_KERNEL_STARTED;
800099c8:	82 2f       	mov %d15,2
800099ca:	e9 ff 10 00 	st.b [%a15]16 <80000010 <BootModeHeader0+0x10>>,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
800099ce:	39 ff 23 00 	ld.bu %d15,[%a15]35 <80000023 <_start+0x3>>
800099d2:	5e 17       	jne %d15,1,800099e0 <StartOS+0x116>
    p_ccb->service_id            = service_id;
800099d4:	da 4a       	mov %d15,74
800099d6:	e9 ff 13 00 	st.b [%a15]19 <80000013 <BootModeHeader0+0x13>>,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
800099da:	82 0f       	mov %d15,0
800099dc:	e9 ff 23 00 	st.b [%a15]35 <80000023 <_start+0x3>>,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */

    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);

#if (!defined(OSEE_STARTOS_RETURN)) && (!defined(OSEE_API_DYNAMIC))
    if (p_ccb->os_status == OSEE_KERNEL_STARTED) {
800099e0:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000010 <BootModeHeader0+0x10>>
800099e4:	5e 2a       	jne %d15,2,800099f8 <StartOS+0x12e>
  osEE_idle_task_start
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_idle_tdb
)
{
  osEE_hal_save_ctx_and_ready2stacked(p_idle_tdb, p_idle_tdb->hdb.p_scb,
800099e6:	60 c4       	mov.a %a4,%d12
800099e8:	99 45 04 00 	ld.a %a5,[%a4]4
800099ec:	40 56       	mov.aa %a6,%a5
800099ee:	6d 00 cf 0f 	call 8000b98c <osEE_hal_save_ctx_and_ready2stacked>
      osEE_idle_task_start(p_idle_tdb);
      osEE_task_end(p_idle_tdb);
800099f2:	60 c4       	mov.a %a4,%d12
800099f4:	6d 00 83 0a 	call 8000aefa <osEE_task_end>
}

/* Disable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_disableIRQ(void)
{
    __asm__ volatile ("disable" : : : "memory");
800099f8:	0d 00 40 03 	disable 
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
800099fc:	91 00 00 f8 	movh.a %a15,32768
80009a00:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
80009a04:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
80009a06:	82 1a       	mov %d10,1
80009a08:	82 0b       	mov %d11,0
80009a0a:	0b ab 10 28 	mov %e2,%d11,%d10
80009a0e:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
80009a12:	df 02 fa ff 	jne %d2,0,80009a06 <StartOS+0x13c>
#if (!defined(OSEE_SINGLECORE))
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
80009a16:	91 00 00 28 	movh.a %a2,32768
80009a1a:	99 25 28 50 	ld.a %a5,[%a2]360 <80000168 <osEE_kdb_var>>

    if (p_kcb->ar_shutdown_all_cores_flag) {
80009a1e:	0c 5e       	ld.bu %d15,[%a5]14
80009a20:	6e 0e       	jz %d15,80009a3c <StartOS+0x172>
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80009a22:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
80009a26:	82 0f       	mov %d15,0
80009a28:	68 0f       	st.w [%a15]0,%d15
         participating to shutdown */
      osEE_unlock_kernel();

      /* [OS587]: Before calling the global ShutdownHook, all cores shall be
          synchronized. (BSW4080007) */
      osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_shutdown_mask,
80009a2a:	d9 2f 28 50 	lea %a15,[%a2]360 <80000168 <osEE_kdb_var>>
80009a2e:	c8 24       	ld.a %a4,[%a15]8
80009a30:	d9 55 08 00 	lea %a5,[%a5]8 <80000002 <BootModeHeader0+0x2>>
80009a34:	a0 06       	mov.a %a6,0
80009a36:	6d 00 04 0f 	call 8000b83e <osEE_hal_sync_barrier>
80009a3a:	3c 13       	j 80009a60 <StartOS+0x196>
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
80009a3c:	4d c0 e1 ff 	mfcr %d15,$core_id
        OSEE_SHUTDOWNOS_SYNC_BARRIER_CB);
    } else {
      /* Remove this core from the waiting mask: this core has already reached
         the barrier/ it's already shutdown */
      p_kcb->ar_shutdown_mask &=
        (~((CoreMaskType)1U << (OsEE_reg)osEE_get_curr_core_id()));
80009a40:	37 0f 48 f0 	extr %d15,%d15,0,8
      osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_shutdown_mask,
        OSEE_SHUTDOWNOS_SYNC_BARRIER_CB);
    } else {
      /* Remove this core from the waiting mask: this core has already reached
         the barrier/ it's already shutdown */
      p_kcb->ar_shutdown_mask &=
80009a44:	19 52 08 00 	ld.w %d2,[%a5]8
80009a48:	d7 02 01 ff 	insert %d15,%d2,0,%d15,1
80009a4c:	6c 52       	st.w [%a5]8,%d15
 *  \brief Unlocks the kernel.
 *  
 *  Unlock the kernel by releasing the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_unlock_kernel(void) {
  osEE_hal_spin_unlock(osEE_kdb_var.p_lock);
80009a4e:	91 00 00 f8 	movh.a %a15,32768
80009a52:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
80009a56:	c8 1f       	ld.a %a15,[%a15]4
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
80009a58:	0d 00 80 04 	dsync 
80009a5c:	82 0f       	mov %d15,0
80009a5e:	68 0f       	st.w [%a15]0,%d15
    }
#if (!defined(OSEE_SHUTDOWN_DO_NOT_RETURN_ON_MAIN))
    osEE_hal_disableIRQ();
    osEE_shutdown_os_extra();
    osEE_call_shutdown_hook(p_ccb, p_ccb->last_error);
    for(;;) {} /* Endless Loop */
80009a60:	3c 00       	j 80009a60 <StartOS+0x196>

  if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
    ev = E_OS_ACCESS;
80009a62:	82 12       	mov %d2,1
80009a64:	3c 03       	j 80009a6a <StartOS+0x1a0>
#endif /* !OSEE_SINGLECORE */
    if (osEE_cpu_startos() == OSEE_FALSE) {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
      osEE_unlock_kernel();
#endif /* OSEE_ALLOW_TASK_MIGRATION */
      ev = E_OS_SYS_INIT;
80009a66:	3b 80 01 20 	mov %d2,24
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
80009a6a:	da 4a       	mov %d15,74
80009a6c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009a70:	82 0f       	mov %d15,0
80009a72:	e9 ff 23 00 	st.b [%a15]35,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009a76:	4d c0 e2 4f 	mfcr %d4,$icr
80009a7a:	02 4f       	mov %d15,%d4
80009a7c:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009a80:	8f fc 0f 31 	and %d3,%d12,255
80009a84:	5f 34 4e 00 	jeq %d4,%d3,80009b20 <StartOS+0x256>
80009a88:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009a8c:	cd cf e2 0f 	mtcr $icr,%d15
80009a90:	0d 00 c0 04 	isync 
80009a94:	00 90       	ret 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009a96:	39 ff 23 00 	ld.bu %d15,[%a15]35
80009a9a:	3b 80 01 20 	mov %d2,24
80009a9e:	df 1f ec ff 	jne %d15,1,80009a76 <StartOS+0x1ac>
80009aa2:	3c e2       	j 80009a66 <StartOS+0x19c>
FUNC(StatusType, OS_CODE)
  StartOS
(
  VAR(AppModeType, AUTOMATIC) Mode
)
{
80009aa4:	02 9f       	mov %d15,%d9
80009aa6:	82 0d       	mov %d13,0
80009aa8:	1d ff 42 ff 	j 8000992c <StartOS+0x62>
          "This release of the AUTOSAR specification does not support timeouts
          during the synchronization phase. Cores that are activated with
          StartCore but do not call StartOS may cause the system to hang.
          It is in the responsibility of the integrator to avoid such
          behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
80009aac:	91 00 00 28 	movh.a %a2,32768
80009ab0:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009ab4:	19 2e 08 00 	ld.w %d14,[%a2]8 <80000008 <BootModeHeader0+0x8>>
80009ab8:	b5 ec fc ff 	st.a [%a14]-4 <80000008 <BootModeHeader0+0x8>>,%a12
80009abc:	60 e4       	mov.a %a4,%d14
80009abe:	40 c5       	mov.aa %a5,%a12
80009ac0:	a0 06       	mov.a %a6,0
80009ac2:	6d 00 be 0e 	call 8000b83e <osEE_hal_sync_barrier>
      OSEE_STARTOS_1ST_SYNC_BARRIER_CB);

    /* Initialize Slaves Hardware after First synchronization point:
       This ensures that all the Master Initializations have been done. */
    if (curr_core_id != OS_CORE_ID_MASTER) {
      if (!osEE_cpu_startos()) {
80009ac6:	6d 00 3b 0e 	call 8000b73c <osEE_cpu_startos>
80009aca:	df 02 30 7f 	jeq %d2,0,8000992a <StartOS+0x60>
80009ace:	3c eb       	j 80009aa4 <StartOS+0x1da>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
80009ad0:	19 dc 14 00 	ld.w %d12,[%a13]20
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80009ad4:	82 1f       	mov %d15,1
80009ad6:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
80009ada:	e9 f9 11 00 	st.b [%a15]17,%d9
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
80009ade:	4c c0       	ld.w %d15,[%a12]0
80009ae0:	57 0f 61 f8 	extr.u %d15,%d15,%d8,1
    shall be used. (SRS_Os_80006) */
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
80009ae4:	df 0f 22 7f 	jeq %d15,0,80009928 <StartOS+0x5e>
80009ae8:	3c e2       	j 80009aac <StartOS+0x1e2>
          "This release of the AUTOSAR specification does not support timeouts
          during the synchronization phase. Cores that are activated with
          StartCore but do not call StartOS may cause the system to hang.
          It is in the responsibility of the integrator to avoid such
          behavior." */
    osEE_hal_sync_barrier(p_kdb->p_barrier, &p_kcb->ar_core_mask,
80009aea:	91 00 00 28 	movh.a %a2,32768
80009aee:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009af2:	19 2e 08 00 	ld.w %d14,[%a2]8 <80000008 <BootModeHeader0+0x8>>
80009af6:	b5 ec fc ff 	st.a [%a14]-4 <80000008 <BootModeHeader0+0x8>>,%a12
80009afa:	60 e4       	mov.a %a4,%d14
80009afc:	40 c5       	mov.aa %a5,%a12
80009afe:	a0 06       	mov.a %a6,0
80009b00:	6d 00 9f 0e 	call 8000b83e <osEE_hal_sync_barrier>
80009b04:	3c d0       	j 80009aa4 <StartOS+0x1da>
  }
#endif /* !OSEE_SINGLECORE */
  if (ev == E_OK) {
#if (!defined(OSEE_STARTOS_RETURN)) || (defined(OSEE_API_DYNAMIC))
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_idle_tdb = p_cdb->p_idle_task;
80009b06:	19 dc 14 00 	ld.w %d12,[%a13]20
    /* Fill CCB */
    p_ccb->p_curr                   = p_idle_tdb;
#endif /* OSEE_API_DYNAMIC */

    /* GetActiveApplicationMode can be called inside StartupHook */
    p_ccb->os_status                = OSEE_KERNEL_STARTING;
80009b0a:	82 1f       	mov %d15,1
80009b0c:	e9 ff 10 00 	st.b [%a15]16,%d15
    p_ccb->app_mode                 = real_mode;
80009b10:	e9 f9 11 00 	st.b [%a15]17,%d9
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
      (p_kcb->ar_core_mask & ((CoreMaskType)1U << (OsEE_reg)curr_core_id)) ==
80009b14:	4c c0       	ld.w %d15,[%a12]0
80009b16:	57 0f 61 f8 	extr.u %d15,%d15,%d8,1
    shall be used. (SRS_Os_80006) */
/* [SWS_Os_00610] At least one core shall define an AppMode other than
     "DONOTCARE". (SRS_Os_80006) */
/* [SWS_Os_00611] If the IOC is configured, StartOS shall initialize the data
     structures of the IOC. (SRS_Os_80020) */
    if (
80009b1a:	df 0f 07 7f 	jeq %d15,0,80009928 <StartOS+0x5e>
80009b1e:	3c e6       	j 80009aea <StartOS+0x220>
    osEE_orti_trace_service_exit(p_ccb, OSServiceId_StartOS);
    osEE_end_primitive(flags);
  }

  return ev;
}
80009b20:	00 90       	ret 

80009b22 <GetActiveApplicationMode>:
FUNC(AppModeType, OS_CODE)
  GetActiveApplicationMode
(
  void
)
{
80009b22:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
80009b24:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
80009b26:	c8 3f       	ld.a %a15,[%a15]12

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009b28:	39 ff 10 00 	ld.bu %d15,[%a15]16 <3 <_.+0x2>>
    app_mode = p_ccb->app_mode;
  } else {
    app_mode = INVALID_APPMODE;
80009b2c:	3b f0 0f 20 	mov %d2,255

  osEE_orti_trace_service_entry(p_ccb, OSServiceId_GetActiveApplicationMode);

  osEE_stack_monitoring(p_cdb);

  if (p_ccb->os_status >= OSEE_KERNEL_STARTING) {
80009b30:	6e 03       	jz %d15,80009b36 <GetActiveApplicationMode+0x14>
    app_mode = p_ccb->app_mode;
80009b32:	39 f2 11 00 	ld.bu %d2,[%a15]17
    p_ccb->service_id            = service_id;
80009b36:	da 46       	mov %d15,70
80009b38:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009b3c:	82 0f       	mov %d15,0
80009b3e:	e9 ff 23 00 	st.b [%a15]35,%d15
  }

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetActiveApplicationMode);

  return app_mode;
}
80009b42:	00 90       	ret 

80009b44 <ActivateTask>:
FUNC(StatusType, OS_CODE)
  ActivateTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80009b44:	40 ae       	mov.aa %a14,%sp
80009b46:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009b48:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009b4a:	82 1f       	mov %d15,1
80009b4c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009b50:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80009b54:	91 00 00 28 	movh.a %a2,32768
80009b58:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009b5c:	4c 24       	ld.w %d15,[%a2]16
80009b5e:	82 38       	mov %d8,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009b60:	7f f4 3d 80 	jge.u %d4,%d15,80009bda <ActivateTask+0x96>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009b64:	91 00 00 28 	movh.a %a2,32768
80009b68:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009b6c:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
80009b70:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80009b74:	d4 2c       	ld.a %a12,[%a2]

    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009b76:	39 cf 14 00 	ld.bu %d15,[%a12]20
80009b7a:	ff 2f 30 80 	jge.u %d15,2,80009bda <ActivateTask+0x96>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009b7e:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009b82:	8f f9 0f f1 	and %d15,%d9,255
80009b86:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009b8a:	ee 0a       	jnz %d15,80009b9e <ActivateTask+0x5a>
    OsEE_icr icr_temp = icr;
80009b8c:	02 9f       	mov %d15,%d9
80009b8e:	3b 30 01 20 	mov %d2,19
80009b92:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009b96:	cd cf e2 0f 	mtcr $icr,%d15
80009b9a:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

      ev = osEE_task_activated(p_tdb_act);
80009b9e:	40 c4       	mov.aa %a4,%a12
80009ba0:	6d 00 8d 09 	call 8000aeba <osEE_task_activated>
80009ba4:	02 28       	mov %d8,%d2

      if (ev == E_OK) {
80009ba6:	f6 28       	jnz %d2,80009bb6 <ActivateTask+0x72>
        (void)osEE_scheduler_task_activated(p_kdb, p_tdb_act);
80009ba8:	91 00 00 48 	movh.a %a4,32768
80009bac:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
80009bb0:	40 c5       	mov.aa %a5,%a12
80009bb2:	6d 00 10 0a 	call 8000afd2 <osEE_scheduler_task_activated>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009bb6:	4d c0 e2 3f 	mfcr %d3,$icr
80009bba:	02 3f       	mov %d15,%d3
80009bbc:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009bc0:	8f f9 0f 21 	and %d2,%d9,255
80009bc4:	5f 23 08 00 	jeq %d3,%d2,80009bd4 <ActivateTask+0x90>
80009bc8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009bcc:	cd cf e2 0f 	mtcr $icr,%d15
80009bd0:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009bd4:	39 ff 23 00 	ld.bu %d15,[%a15]35
80009bd8:	5e 16       	jne %d15,1,80009be4 <ActivateTask+0xa0>
    p_ccb->service_id            = service_id;
80009bda:	82 0f       	mov %d15,0
80009bdc:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009be0:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ActivateTask);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
80009be4:	02 82       	mov %d2,%d8
80009be6:	00 90       	ret 

80009be8 <ChainTask>:
FUNC(StatusType, OS_CODE)
  ChainTask
(
  VAR(TaskType, AUTOMATIC) TaskID
)
{
80009be8:	40 ae       	mov.aa %a14,%sp
80009bea:	40 9f       	mov.aa %a15,%a9
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb = p_cdb->p_ccb;
80009bec:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_curr = p_ccb->p_curr;
80009bee:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009bf0:	82 5f       	mov %d15,5
80009bf2:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009bf6:	82 1f       	mov %d15,1
80009bf8:	e9 ff 23 00 	st.b [%a15]35,%d15
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009bfc:	39 2f 14 00 	ld.bu %d15,[%a2]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
      || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80009c00:	82 22       	mov %d2,2
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009c02:	ff 2f 5d 80 	jge.u %d15,2,80009cbc <ChainTask+0xd4>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80009c06:	91 00 00 38 	movh.a %a3,32768
80009c0a:	d9 33 28 50 	lea %a3,[%a3]360 <80000168 <osEE_kdb_var>>
80009c0e:	4c 34       	ld.w %d15,[%a3]16
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009c10:	82 32       	mov %d2,3
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_CHECKS */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009c12:	7f f4 55 80 	jge.u %d4,%d15,80009cbc <ChainTask+0xd4>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009c16:	91 00 00 38 	movh.a %a3,32768
80009c1a:	d9 33 28 50 	lea %a3,[%a3]360 <80000168 <osEE_kdb_var>>
80009c1e:	99 33 0c 00 	ld.a %a3,[%a3]12 <8000000c <BootModeHeader0+0xc>>
80009c22:	01 34 02 36 	addsc.a %a3,%a3,%d4,2
80009c26:	d4 3c       	ld.a %a12,[%a3]
#if (defined(OSEE_HAS_CHECKS))
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb  = p_curr->p_tcb;
    if (p_curr_tcb->p_last_m != NULL) {
80009c28:	99 23 0c 00 	ld.a %a3,[%a2]12
80009c2c:	4c 31       	ld.w %d15,[%a3]4
      }
#else
      ev = E_OS_RESOURCE;
#endif /* OSEE_HAS_SPINLOCKS */
#else
      ev = E_OS_SPINLOCK;
80009c2e:	3b 40 01 20 	mov %d2,20
      p_tdb_act = (*p_kdb->p_tdb_ptr_array)[TaskID];
#if (defined(OSEE_HAS_CHECKS))
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_curr_tcb  = p_curr->p_tcb;
    if (p_curr_tcb->p_last_m != NULL) {
80009c32:	ee 45       	jnz %d15,80009cbc <ChainTask+0xd4>
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009c34:	39 cf 14 00 	ld.bu %d15,[%a12]20
        osEE_hal_terminate_activation(&osEE_get_curr_task()->hdb,
          OSEE_KERNEL_TERMINATE_ACTIVATION_CB);
      }
      osEE_end_primitive(flags);
    } else {
      ev = E_OS_ID;
80009c38:	82 32       	mov %d2,3
      ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
    } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
    if (p_tdb_act->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009c3a:	ff 2f 41 80 	jge.u %d15,2,80009cbc <ChainTask+0xd4>
      VAR(OsEE_reg, AUTOMATIC)  flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009c3e:	39 ff 20 00 	ld.bu %d15,[%a15]32
80009c42:	6e 09       	jz %d15,80009c54 <ChainTask+0x6c>
        p_ccb->s_isr_all_cnt = 0U;
80009c44:	82 0f       	mov %d15,0
80009c46:	e9 ff 20 00 	st.b [%a15]32,%d15
80009c4a:	4c f6       	ld.w %d15,[%a15]24
80009c4c:	cd cf e2 0f 	mtcr $icr,%d15
80009c50:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
80009c54:	39 ff 22 00 	ld.bu %d15,[%a15]34
80009c58:	6e 06       	jz %d15,80009c64 <ChainTask+0x7c>
        p_ccb->d_isr_all_cnt = 0U;
80009c5a:	82 0f       	mov %d15,0
80009c5c:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009c60:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009c64:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009c68:	8f f8 0f f1 	and %d15,%d8,255
80009c6c:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009c70:	ee 0a       	jnz %d15,80009c84 <ChainTask+0x9c>
    OsEE_icr icr_temp = icr;
80009c72:	02 8f       	mov %d15,%d8
80009c74:	3b 30 01 20 	mov %d2,19
80009c78:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009c7c:	cd cf e2 0f 	mtcr $icr,%d15
80009c80:	0d 00 c0 04 	isync 
      }
#endif /* !OSEE_HAS_SERVICE_PROTECTION */

      flags = osEE_begin_primitive();

      if (p_tdb_act == p_curr) {
80009c84:	7d 2c 06 80 	jne.a %a12,%a2,80009c90 <ChainTask+0xa8>
        /* If the Task chain on it self, flag it. */
        p_tdb_act->p_tcb->status = OSEE_TASK_CHAINED;
80009c88:	cc c3       	ld.a %a15,[%a12]12
80009c8a:	82 5f       	mov %d15,5
80009c8c:	28 2f       	st.b [%a15]2,%d15
80009c8e:	3c 1e       	j 80009cca <ChainTask+0xe2>
        ev = E_OK;
      } else {
        ev = osEE_task_activated(p_tdb_act);
80009c90:	40 c4       	mov.aa %a4,%a12
80009c92:	6d 00 14 09 	call 8000aeba <osEE_task_activated>
        if (ev == E_OK) {
80009c96:	df 02 21 80 	jne %d2,0,80009cd8 <ChainTask+0xf0>
          (void)osEE_scheduler_task_insert(p_kdb, p_tdb_act);
80009c9a:	91 00 00 48 	movh.a %a4,32768
80009c9e:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
80009ca2:	40 c5       	mov.aa %a5,%a12
80009ca4:	6d 00 02 0a 	call 8000b0a8 <osEE_scheduler_task_insert>
80009ca8:	3c 11       	j 80009cca <ChainTask+0xe2>
80009caa:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
80009cae:	cd cf e2 0f 	mtcr $icr,%d15
80009cb2:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009cb6:	39 ff 23 00 	ld.bu %d15,[%a15]35
80009cba:	de 19       	jne %d15,1,80009cec <ChainTask+0x104>
    p_ccb->service_id            = service_id;
80009cbc:	82 4f       	mov %d15,4
80009cbe:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009cc2:	82 0f       	mov %d15,0
80009cc4:	e9 ff 23 00 	st.b [%a15]35,%d15
80009cc8:	00 90       	ret 
80009cca:	40 9f       	mov.aa %a15,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
80009ccc:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA)  p_to_term,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
  osEE_hal_terminate_ctx(p_to_term->p_scb, kernel_cb);
80009cce:	c8 0f       	ld.a %a15,[%a15]0
80009cd0:	c8 14       	ld.a %a4,[%a15]4
80009cd2:	a0 05       	mov.a %a5,0
80009cd4:	1d 00 93 0e 	j 8000b9fa <osEE_hal_terminate_ctx>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009cd8:	4d c0 e2 4f 	mfcr %d4,$icr
80009cdc:	02 4f       	mov %d15,%d4
80009cde:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009ce2:	8f f8 0f 31 	and %d3,%d8,255
80009ce6:	5f 34 e2 ff 	jne %d4,%d3,80009caa <ChainTask+0xc2>
80009cea:	3c e6       	j 80009cb6 <ChainTask+0xce>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ChainTask);

  return ev;
}
80009cec:	00 90       	ret 

80009cee <TerminateTask>:
FUNC(StatusType, OS_CODE)
  TerminateTask
(
  void
)
{
80009cee:	40 ae       	mov.aa %a14,%sp
80009cf0:	40 9f       	mov.aa %a15,%a9
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK &&
          OSEE_HAS_SERVICE_PROTECTION */
    p_ccb       = p_cdb->p_ccb;
80009cf2:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
80009cf4:	c8 02       	ld.a %a2,[%a15]0
#if (defined(OSEE_HAS_CHECKS))
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
80009cf6:	99 23 0c 00 	ld.a %a3,[%a2]12 <0 <NULL>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009cfa:	82 3f       	mov %d15,3
80009cfc:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009d00:	82 1f       	mov %d15,1
80009d02:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009d06:	39 2f 14 00 	ld.bu %d15,[%a2]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80009d0a:	82 22       	mov %d2,2
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009d0c:	ff 2f 2d 80 	jge.u %d15,2,80009d66 <TerminateTask+0x78>
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_curr_tcb->p_last_m != NULL) {
80009d10:	4c 31       	ld.w %d15,[%a3]4
    }
#else
    ev = E_OS_RESOURCE;
#endif /* OSEE_HAS_SPINLOCKS */
#else
    ev = E_OS_SPINLOCK;
80009d12:	3b 40 01 20 	mov %d2,20
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_curr_tcb->p_last_m != NULL) {
80009d16:	ee 28       	jnz %d15,80009d66 <TerminateTask+0x78>
#endif /* OSEE_HAS_CHECKS elif (OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING) */
  {
    VAR(OsEE_reg, AUTOMATIC) flags;
#if (!defined(OSEE_HAS_SERVICE_PROTECTION))
      /* Silently reset ISR counters if service protection is not configured */
      if (p_ccb->s_isr_all_cnt > 0U) {
80009d18:	39 ff 20 00 	ld.bu %d15,[%a15]32
80009d1c:	6e 09       	jz %d15,80009d2e <TerminateTask+0x40>
        p_ccb->s_isr_all_cnt = 0U;
80009d1e:	82 0f       	mov %d15,0
80009d20:	e9 ff 20 00 	st.b [%a15]32,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009d24:	4c f6       	ld.w %d15,[%a15]24
80009d26:	cd cf e2 0f 	mtcr $icr,%d15
80009d2a:	0d 00 c0 04 	isync 
        osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
      }
      if (p_ccb->d_isr_all_cnt > 0U) {
80009d2e:	39 ff 22 00 	ld.bu %d15,[%a15]34
80009d32:	6e 06       	jz %d15,80009d3e <TerminateTask+0x50>
        p_ccb->d_isr_all_cnt = 0U;
80009d34:	82 0f       	mov %d15,0
80009d36:	e9 ff 22 00 	st.b [%a15]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
80009d3a:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009d3e:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009d42:	8f ff 0f 21 	and %d2,%d15,255
80009d46:	8b 32 a1 22 	ge.u %d2,%d2,19
80009d4a:	f6 29       	jnz %d2,80009d5c <TerminateTask+0x6e>
80009d4c:	3b 30 01 20 	mov %d2,19
80009d50:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009d54:	cd cf e2 0f 	mtcr $icr,%d15
80009d58:	0d 00 c0 04 	isync 
80009d5c:	99 24 04 00 	ld.a %a4,[%a2]4
80009d60:	a0 05       	mov.a %a5,0
80009d62:	1d 00 4c 0e 	j 8000b9fa <osEE_hal_terminate_ctx>
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
80009d66:	82 2f       	mov %d15,2
80009d68:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009d6c:	82 0f       	mov %d15,0
80009d6e:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_TerminateTask);

  return ev;
}
80009d72:	00 90       	ret 

80009d74 <Schedule>:
FUNC(StatusType, OS_CODE)
  Schedule
(
  void
)
{
80009d74:	40 ae       	mov.aa %a14,%sp
80009d76:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb  = p_cdb->p_ccb;
80009d78:	c8 3f       	ld.a %a15,[%a15]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_curr = p_ccb->p_curr;
80009d7a:	c8 0c       	ld.a %a12,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb  = p_curr->p_tcb;
80009d7c:	99 cd 0c 00 	ld.a %a13,[%a12]12 <0 <NULL>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009d80:	82 7f       	mov %d15,7
80009d82:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009d86:	82 1f       	mov %d15,1
80009d88:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_curr_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009d8c:	39 cf 14 00 	ld.bu %d15,[%a12]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_curr_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
80009d90:	82 22       	mov %d2,2
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
  if (osEE_check_disableint(p_curr_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
80009d92:	ff 2f 3c 80 	jge.u %d15,2,80009e0a <Schedule+0x96>
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_tcb->p_last_m != NULL) {
80009d96:	4c d1       	ld.w %d15,[%a13]4
    }
#else
    ev = E_OS_RESOURCE;
#endif /* OSEE_HAS_SPINLOCKS */
#else
    ev = E_OS_SPINLOCK;
80009d98:	3b 40 01 20 	mov %d2,20
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_tcb->p_last_m != NULL) {
80009d9c:	ee 37       	jnz %d15,80009e0a <Schedule+0x96>
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
80009d9e:	39 d3 01 00 	ld.bu %d3,[%a13]1
80009da2:	39 cf 1d 00 	ld.bu %d15,[%a12]29
    osEE_end_primitive(flags);

    ev = E_OK;
  } else {
    /* Ignore Schedule if the TASK got an explicit Resource */
    ev = E_OK;
80009da6:	82 02       	mov %d2,0
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
#endif /* OSEE_HAS_CHECKS */
  if (p_tcb->current_prio == p_curr->dispatch_prio)
80009da8:	5f f3 31 80 	jne %d3,%d15,80009e0a <Schedule+0x96>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009dac:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009db0:	8f f8 0f f1 	and %d15,%d8,255
80009db4:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009db8:	ee 0a       	jnz %d15,80009dcc <Schedule+0x58>
    OsEE_icr icr_temp = icr;
80009dba:	02 8f       	mov %d15,%d8
80009dbc:	3b 30 01 20 	mov %d2,19
80009dc0:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009dc4:	cd cf e2 0f 	mtcr $icr,%d15
80009dc8:	0d 00 c0 04 	isync 
  {
    /* Begin primitive */
    CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();

    /* Release internal resources */
    p_tcb->current_prio = p_curr->ready_prio;
80009dcc:	39 cf 1c 00 	ld.bu %d15,[%a12]28
80009dd0:	2c d1       	st.b [%a13]1,%d15
    /* Try preemption */
    (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
80009dd2:	91 00 00 48 	movh.a %a4,32768
80009dd6:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
80009dda:	6d 00 52 0a 	call 8000b27e <osEE_scheduler_task_preemption_point>
    /* Restore internal resources */
    p_tcb->current_prio = p_curr->dispatch_prio;
80009dde:	39 cf 1d 00 	ld.bu %d15,[%a12]29
80009de2:	2c d1       	st.b [%a13]1,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009de4:	4d c0 e2 3f 	mfcr %d3,$icr
80009de8:	02 3f       	mov %d15,%d3
80009dea:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009dee:	8f f8 0f 21 	and %d2,%d8,255
80009df2:	5f 23 08 00 	jeq %d3,%d2,80009e02 <Schedule+0x8e>
80009df6:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009dfa:	cd cf e2 0f 	mtcr $icr,%d15
80009dfe:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009e02:	39 ff 23 00 	ld.bu %d15,[%a15]35

    /* End primitives */
    osEE_end_primitive(flags);

    ev = E_OK;
80009e06:	82 02       	mov %d2,0
80009e08:	5e 17       	jne %d15,1,80009e16 <Schedule+0xa2>
    p_ccb->service_id            = service_id;
80009e0a:	82 6f       	mov %d15,6
80009e0c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009e10:	82 0f       	mov %d15,0
80009e12:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_Schedule);

  return ev;
}
80009e16:	00 90       	ret 

80009e18 <ShutdownOS>:
FUNC(StatusType, OS_CODE)
  ShutdownOS
(
  VAR(StatusType, AUTOMATIC) Error
)
{
80009e18:	40 ae       	mov.aa %a14,%sp
80009e1a:	40 94       	mov.aa %a4,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009e1c:	cc 43       	ld.a %a15,[%a4]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009e1e:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009e22:	8f f2 0f f1 	and %d15,%d2,255
80009e26:	8b 3f a1 f2 	ge.u %d15,%d15,19
80009e2a:	ee 0a       	jnz %d15,80009e3e <ShutdownOS+0x26>
    OsEE_icr icr_temp = icr;
80009e2c:	02 2f       	mov %d15,%d2
80009e2e:	3b 30 01 30 	mov %d3,19
80009e32:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009e36:	cd cf e2 0f 	mtcr $icr,%d15
80009e3a:	0d 00 c0 04 	isync 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
80009e3e:	39 ff 10 00 	ld.bu %d15,[%a15]16
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009e42:	3b 90 04 30 	mov %d3,73
80009e46:	e9 f3 13 00 	st.b [%a15]19,%d3
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009e4a:	82 13       	mov %d3,1
80009e4c:	e9 f3 23 00 	st.b [%a15]35,%d3
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  {
    if ((os_status == OSEE_KERNEL_STARTED) ||
80009e50:	c2 ff       	add %d15,-1
80009e52:	16 ff       	and %d15,255
80009e54:	ff 2f 04 80 	jge.u %d15,2,80009e5c <ShutdownOS+0x44>
        (os_status == OSEE_KERNEL_STARTING))
    {
      osEE_shutdown_os(p_cdb, Error);
80009e58:	1d ff 52 fc 	j 800096fc <osEE_shutdown_os>
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
80009e5c:	da 48       	mov %d15,72
80009e5e:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009e62:	82 0f       	mov %d15,0
80009e64:	e9 ff 23 00 	st.b [%a15]35,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009e68:	4d c0 e2 3f 	mfcr %d3,$icr
80009e6c:	02 3f       	mov %d15,%d3
80009e6e:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
80009e72:	8f f2 0f 21 	and %d2,%d2,255
80009e76:	5f 23 08 00 	jeq %d3,%d2,80009e86 <ShutdownOS+0x6e>
80009e7a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
80009e7e:	cd cf e2 0f 	mtcr $icr,%d15
80009e82:	0d 00 c0 04 	isync 

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ShutdownOS);
  osEE_end_primitive(flags);

  return ev;
}
80009e86:	82 72       	mov %d2,7
80009e88:	00 90       	ret 

80009e8a <GetTaskID>:
FUNC(StatusType, OS_CODE)
  GetTaskID
(
  VAR(TaskRefType, AUTOMATIC) TaskID
)
{
80009e8a:	40 ae       	mov.aa %a14,%sp
80009e8c:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009e8e:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009e90:	da 09       	mov %d15,9
80009e92:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009e96:	82 1f       	mov %d15,1
80009e98:	e9 ff 23 00 	st.b [%a15]35,%d15
  /* [OS566]: The Operating System API shall check in extended mode all pointer
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
80009e9c:	bd 04 2a 00 	jz.a %a4,80009ef0 <GetTaskID+0x66>
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_tdb = p_ccb->p_curr;
80009ea0:	c8 02       	ld.a %a2,[%a15]0
       value to return. If it its ISR2 we have to follow the chain and
       find the first task in the list (which is the running task
       which was preempted by the ISR, which could be the idle task),
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009ea2:	39 2f 14 00 	ld.bu %d15,[%a2]20 <0 <NULL>>
80009ea6:	ff 2f 05 80 	jge.u %d15,2,80009eb0 <GetTaskID+0x26>
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
80009eaa:	19 22 10 00 	ld.w %d2,[%a2]16
80009eae:	3c 1b       	j 80009ee4 <GetTaskID+0x5a>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009eb0:	82 f2       	mov %d2,-1
       or we are idle. */
    
    if (p_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
      /* BASIC or EXTENDED tasks are the first ones in the stacked queue */
      tid = p_tdb->tid;
    } else if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
80009eb2:	de 29       	jne %d15,2,80009ee4 <GetTaskID+0x5a>
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;
80009eb4:	c8 32       	ld.a %a2,[%a15]12
80009eb6:	d4 22       	ld.a %a2,[%a2]

      while (p_sn != NULL) {
80009eb8:	bd 02 16 00 	jz.a %a2,80009ee4 <GetTaskID+0x5a>
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009ebc:	99 23 04 00 	ld.a %a3,[%a2]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009ec0:	39 3f 14 00 	ld.bu %d15,[%a3]20
80009ec4:	ff 2f 0c 80 	jge.u %d15,2,80009edc <GetTaskID+0x52>
80009ec8:	3c 07       	j 80009ed6 <GetTaskID+0x4c>
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
        CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
          p_searched_tdb = p_sn->p_tdb;
80009eca:	99 23 04 00 	ld.a %a3,[%a2]4
        if (p_searched_tdb->task_type <= OSEE_TASK_TYPE_EXTENDED) {
80009ece:	39 3f 14 00 	ld.bu %d15,[%a3]20
80009ed2:	ff 2f 05 80 	jge.u %d15,2,80009edc <GetTaskID+0x52>
          tid = p_searched_tdb->tid;
80009ed6:	19 32 10 00 	ld.w %d2,[%a3]16
          break;
80009eda:	3c 05       	j 80009ee4 <GetTaskID+0x5a>
        } else {
          p_sn = p_sn->p_next;
80009edc:	d4 22       	ld.a %a2,[%a2]
      /* In case of ISR2 search the first stacked that is not an
         ISR2. it could be a basic/extended task or an IDLE task */
      P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn = p_ccb->p_stk_sn->p_next;

      while (p_sn != NULL) {
80009ede:	bd 02 f6 ff 	jnz.a %a2,80009eca <GetTaskID+0x40>
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else {
    VAR(TaskType, AUTOMATIC)
      tid = INVALID_TASK;
80009ee2:	82 f2       	mov %d2,-1
    } else {
      /* This is the case of the IDLE task. we do nothing because tid
         is already initialized */
    }
    /* XXX: This SHALL be atomic. */
    (*TaskID) = tid;
80009ee4:	74 42       	st.w [%a4],%d2
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009ee6:	39 ff 23 00 	ld.bu %d15,[%a15]35
    ev = E_OK;
80009eea:	82 02       	mov %d2,0
80009eec:	5e 1a       	jne %d15,1,80009f00 <GetTaskID+0x76>
80009eee:	3c 03       	j 80009ef4 <GetTaskID+0x6a>
      argument for NULL pointer and return OS_E_PARAMETER_POINTER
      if such argument is NULL.
      +
      MISRA dictate NULL check for pointers always. */
  if (TaskID == NULL) {
    ev = E_OS_PARAM_POINTER;
80009ef0:	3b e0 00 20 	mov %d2,14
    p_ccb->service_id            = service_id;
80009ef4:	da 08       	mov %d15,8
80009ef6:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009efa:	82 0f       	mov %d15,0
80009efc:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskID);

  return ev;
}
80009f00:	00 90       	ret 

80009f02 <GetTaskState>:
  GetTaskState
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(TaskStateRefType, AUTOMATIC)  State
)
{
80009f02:	40 ae       	mov.aa %a14,%sp
80009f04:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009f06:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009f08:	da 0b       	mov %d15,11
80009f0a:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009f0e:	82 1f       	mov %d15,1
80009f10:	e9 ff 23 00 	st.b [%a15]35,%d15
  /* [SWS_Os_00566]: The Operating System API shall check in extended mode all
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
80009f14:	bd 04 40 00 	jz.a %a4,80009f94 <GetTaskState+0x92>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
80009f18:	91 00 00 28 	movh.a %a2,32768
80009f1c:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009f20:	4c 24       	ld.w %d15,[%a2]16
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
80009f22:	82 32       	mov %d2,3
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
  } else
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
80009f24:	7f f4 31 80 	jge.u %d4,%d15,80009f86 <GetTaskState+0x84>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb = (*p_kdb->p_tdb_ptr_array)[TaskID];
80009f28:	91 00 00 28 	movh.a %a2,32768
80009f2c:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009f30:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
80009f34:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    /* XXX: This SHALL be atomic. Sure for TriCore,
            visually check generate asm for each architecture */
    CONST(OsEE_task_status, AUTOMATIC) local_state = p_tdb->p_tcb->status;
80009f38:	d4 22       	ld.a %a2,[%a2]
80009f3a:	99 22 0c 00 	ld.a %a2,[%a2]12
    switch (local_state) {
80009f3e:	0c 22       	ld.bu %d15,[%a2]2
80009f40:	ff 6f 1f 80 	jge.u %d15,6,80009f7e <GetTaskState+0x7c>
80009f44:	91 10 00 28 	movh.a %a2,32769
80009f48:	d9 22 d0 d9 	lea %a2,[%a2]-24752 <80009f50 <GetTaskState+0x4e>>
80009f4c:	90 22       	addsc.a %a2,%a2,%d15,2
80009f4e:	dc 02       	ji %a2
80009f50:	1d 00 0c 00 	j 80009f68 <GetTaskState+0x66>
80009f54:	1d 00 0d 00 	j 80009f6e <GetTaskState+0x6c>
80009f58:	1d 00 0b 00 	j 80009f6e <GetTaskState+0x6c>
80009f5c:	1d 00 0c 00 	j 80009f74 <GetTaskState+0x72>
80009f60:	1d 00 0d 00 	j 80009f7a <GetTaskState+0x78>
80009f64:	1d 00 0b 00 	j 80009f7a <GetTaskState+0x78>
      case OSEE_TASK_SUSPENDED:
        (*State) = SUSPENDED;
80009f68:	82 0f       	mov %d15,0
80009f6a:	2c 40       	st.b [%a4]0,%d15
        break;
80009f6c:	3c 09       	j 80009f7e <GetTaskState+0x7c>
      case OSEE_TASK_READY:
      case OSEE_TASK_READY_STACKED:
        (*State) = READY;
80009f6e:	82 1f       	mov %d15,1
80009f70:	2c 40       	st.b [%a4]0,%d15
        break;
80009f72:	3c 06       	j 80009f7e <GetTaskState+0x7c>
      case OSEE_TASK_WAITING:
        (*State) = WAITING;
80009f74:	82 3f       	mov %d15,3
80009f76:	2c 40       	st.b [%a4]0,%d15
        break;
80009f78:	3c 03       	j 80009f7e <GetTaskState+0x7c>
      case OSEE_TASK_RUNNING:
      case OSEE_TASK_CHAINED:
        (*State) = RUNNING;
80009f7a:	82 4f       	mov %d15,4
80009f7c:	2c 40       	st.b [%a4]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
80009f7e:	39 ff 23 00 	ld.bu %d15,[%a15]35
80009f82:	82 02       	mov %d2,0
80009f84:	5e 1b       	jne %d15,1,80009f9a <GetTaskState+0x98>
    p_ccb->service_id            = service_id;
80009f86:	da 0a       	mov %d15,10
80009f88:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
80009f8c:	82 0f       	mov %d15,0
80009f8e:	e9 ff 23 00 	st.b [%a15]35,%d15
80009f92:	00 90       	ret 
     pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER
     if such argument is NULL.
     +
     MISRA dictate NULL check for pointers always. */
  if (State == NULL) {
    ev = E_OS_PARAM_POINTER;
80009f94:	3b e0 00 20 	mov %d2,14
80009f98:	3c f7       	j 80009f86 <GetTaskState+0x84>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetTaskState);

  return ev;
}
80009f9a:	00 90       	ret 

80009f9c <SetRelAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  increment,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
80009f9c:	40 ae       	mov.aa %a14,%sp
80009f9e:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
80009fa0:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
80009fa2:	da 29       	mov %d15,41
80009fa4:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
80009fa8:	82 1f       	mov %d15,1
80009faa:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
80009fae:	91 00 00 28 	movh.a %a2,32768
80009fb2:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009fb6:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
80009fb8:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
80009fba:	7f f4 45 80 	jge.u %d4,%d15,8000a044 <SetRelAlarm+0xa8>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
80009fbe:	91 00 00 28 	movh.a %a2,32768
80009fc2:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
80009fc6:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
80009fca:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
80009fce:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
80009fd0:	99 54 04 00 	ld.a %a4,[%a5]4
        (increment > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
80009fd4:	3b 80 00 20 	mov %d2,8
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((increment == 0U) ||
80009fd8:	df 05 36 00 	jeq %d5,0,8000a044 <SetRelAlarm+0xa8>
        (increment > p_counter_db->info.maxallowedvalue) ||
80009fdc:	4c 41       	ld.w %d15,[%a4]4
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((increment == 0U) ||
80009fde:	3f 5f 33 80 	jlt.u %d15,%d5,8000a044 <SetRelAlarm+0xa8>
        (increment > p_counter_db->info.maxallowedvalue) ||
80009fe2:	76 6b       	jz %d6,80009ff8 <SetRelAlarm+0x5c>
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
80009fe4:	19 42 0c 00 	ld.w %d2,[%a4]12
80009fe8:	0b 26 30 31 	lt.u %d3,%d6,%d2
80009fec:	0b 6f a0 32 	or.lt.u %d3,%d15,%d6
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
80009ff0:	3b 80 00 20 	mov %d2,8

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((increment == 0U) ||
        (increment > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
80009ff4:	df 03 28 80 	jne %d3,0,8000a044 <SetRelAlarm+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
80009ff8:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
80009ffc:	8f f8 0f f1 	and %d15,%d8,255
8000a000:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a004:	ee 0a       	jnz %d15,8000a018 <SetRelAlarm+0x7c>
    OsEE_icr icr_temp = icr;
8000a006:	02 8f       	mov %d15,%d8
8000a008:	3b 30 01 20 	mov %d2,19
8000a00c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a010:	cd cf e2 0f 	mtcr $icr,%d15
8000a014:	0d 00 c0 04 	isync 
8000a018:	02 54       	mov %d4,%d5
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_rel(p_counter_db, p_alarm_db, increment, cycle);
8000a01a:	02 65       	mov %d5,%d6
8000a01c:	6d 00 80 0a 	call 8000b51c <osEE_alarm_set_rel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a020:	4d c0 e2 4f 	mfcr %d4,$icr
8000a024:	02 4f       	mov %d15,%d4
8000a026:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a02a:	8f f8 0f 31 	and %d3,%d8,255
8000a02e:	5f 34 08 00 	jeq %d4,%d3,8000a03e <SetRelAlarm+0xa2>
8000a032:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a036:	cd cf e2 0f 	mtcr $icr,%d15
8000a03a:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a03e:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a042:	5e 17       	jne %d15,1,8000a050 <SetRelAlarm+0xb4>
    p_ccb->service_id            = service_id;
8000a044:	da 28       	mov %d15,40
8000a046:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a04a:	82 0f       	mov %d15,0
8000a04c:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetRelAlarm);

  return ev;
}
8000a050:	00 90       	ret 

8000a052 <SetAbsAlarm>:
(
  VAR(AlarmType,  AUTOMATIC)  AlarmID,
  VAR(TickType,   AUTOMATIC)  start,
  VAR(TickType,   AUTOMATIC)  cycle
)
{
8000a052:	40 ae       	mov.aa %a14,%sp
8000a054:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a056:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a058:	da 2b       	mov %d15,43
8000a05a:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a05e:	82 1f       	mov %d15,1
8000a060:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
8000a064:	91 00 00 28 	movh.a %a2,32768
8000a068:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a06c:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
8000a06e:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000a070:	7f f4 43 80 	jge.u %d4,%d15,8000a0f6 <SetAbsAlarm+0xa4>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000a074:	91 00 00 28 	movh.a %a2,32768
8000a078:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a07c:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
8000a080:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a084:	d4 25       	ld.a %a5,[%a2]
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;
8000a086:	99 54 04 00 	ld.a %a4,[%a5]4

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((start > p_counter_db->info.maxallowedvalue) ||
8000a08a:	4c 41       	ld.w %d15,[%a4]4
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
8000a08c:	3b 80 00 20 	mov %d2,8
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((start > p_counter_db->info.maxallowedvalue) ||
8000a090:	3f 5f 33 80 	jlt.u %d15,%d5,8000a0f6 <SetAbsAlarm+0xa4>
8000a094:	76 6b       	jz %d6,8000a0aa <SetAbsAlarm+0x58>
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
8000a096:	19 42 0c 00 	ld.w %d2,[%a4]12
8000a09a:	0b 26 30 31 	lt.u %d3,%d6,%d2
8000a09e:	0b 6f a0 32 	or.lt.u %d3,%d15,%d6
          (cycle > p_counter_db->info.maxallowedvalue)))
      )
    {
      ev = E_OS_VALUE;
8000a0a2:	3b 80 00 20 	mov %d2,8
      p_counter_db = osEE_alarm_get_trigger_db(p_alarm_db)->p_counter_db;

#if (defined(OSEE_HAS_CHECKS))
    /* SWS_Os_00304 */
    if ((start > p_counter_db->info.maxallowedvalue) ||
        ((cycle != 0U) && ((cycle < p_counter_db->info.mincycle) ||
8000a0a6:	df 03 28 80 	jne %d3,0,8000a0f6 <SetAbsAlarm+0xa4>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a0aa:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a0ae:	8f f8 0f f1 	and %d15,%d8,255
8000a0b2:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a0b6:	ee 0a       	jnz %d15,8000a0ca <SetAbsAlarm+0x78>
    OsEE_icr icr_temp = icr;
8000a0b8:	02 8f       	mov %d15,%d8
8000a0ba:	3b 30 01 20 	mov %d2,19
8000a0be:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a0c2:	cd cf e2 0f 	mtcr $icr,%d15
8000a0c6:	0d 00 c0 04 	isync 
8000a0ca:	02 54       	mov %d4,%d5
#endif /* OSEE_HAS_CHECKS */
    {
      CONST(OsEE_reg, AUTOMATIC)
        flags = osEE_begin_primitive();

      ev = osEE_alarm_set_abs(p_counter_db, p_alarm_db, start, cycle);
8000a0cc:	02 65       	mov %d5,%d6
8000a0ce:	6d 00 69 0a 	call 8000b5a0 <osEE_alarm_set_abs>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a0d2:	4d c0 e2 4f 	mfcr %d4,$icr
8000a0d6:	02 4f       	mov %d15,%d4
8000a0d8:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a0dc:	8f f8 0f 31 	and %d3,%d8,255
8000a0e0:	5f 34 08 00 	jeq %d4,%d3,8000a0f0 <SetAbsAlarm+0x9e>
8000a0e4:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a0e8:	cd cf e2 0f 	mtcr $icr,%d15
8000a0ec:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a0f0:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a0f4:	5e 17       	jne %d15,1,8000a102 <SetAbsAlarm+0xb0>
    p_ccb->service_id            = service_id;
8000a0f6:	da 2a       	mov %d15,42
8000a0f8:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a0fc:	82 0f       	mov %d15,0
8000a0fe:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetAbsAlarm);

  return ev;
}
8000a102:	00 90       	ret 

8000a104 <CancelAlarm>:
FUNC(StatusType, OS_CODE)
  CancelAlarm
(
  VAR(AlarmType, AUTOMATIC) AlarmID
)
{
8000a104:	40 ae       	mov.aa %a14,%sp
8000a106:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a108:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a10a:	da 2d       	mov %d15,45
8000a10c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a110:	82 1f       	mov %d15,1
8000a112:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
8000a116:	91 00 00 28 	movh.a %a2,32768
8000a11a:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a11e:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
8000a120:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000a122:	7f f4 2f 80 	jge.u %d4,%d15,8000a180 <CancelAlarm+0x7c>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db  = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000a126:	91 00 00 28 	movh.a %a2,32768
8000a12a:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a12e:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
8000a132:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a136:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a138:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a13c:	8f f8 0f f1 	and %d15,%d8,255
8000a140:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a144:	ee 0a       	jnz %d15,8000a158 <CancelAlarm+0x54>
    OsEE_icr icr_temp = icr;
8000a146:	02 8f       	mov %d15,%d8
8000a148:	3b 30 01 20 	mov %d2,19
8000a14c:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a150:	cd cf e2 0f 	mtcr $icr,%d15
8000a154:	0d 00 c0 04 	isync 
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_cancel(p_alarm_db);
8000a158:	6d 00 59 0a 	call 8000b60a <osEE_alarm_cancel>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a15c:	4d c0 e2 4f 	mfcr %d4,$icr
8000a160:	02 4f       	mov %d15,%d4
8000a162:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a166:	8f f8 0f 31 	and %d3,%d8,255
8000a16a:	5f 34 08 00 	jeq %d4,%d3,8000a17a <CancelAlarm+0x76>
8000a16e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a172:	cd cf e2 0f 	mtcr $icr,%d15
8000a176:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a17a:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a17e:	5e 17       	jne %d15,1,8000a18c <CancelAlarm+0x88>
    p_ccb->service_id            = service_id;
8000a180:	da 2c       	mov %d15,44
8000a182:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a186:	82 0f       	mov %d15,0
8000a188:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_CancelAlarm);

  return ev;
}
8000a18c:	00 90       	ret 

8000a18e <GetAlarm>:
  GetAlarm
(
  VAR(AlarmType, AUTOMATIC)   AlarmID,
  VAR(TickRefType, AUTOMATIC) Tick
)
{
8000a18e:	40 ae       	mov.aa %a14,%sp
8000a190:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a192:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a194:	da 27       	mov %d15,39
8000a196:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a19a:	82 1f       	mov %d15,1
8000a19c:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
8000a1a0:	91 00 00 28 	movh.a %a2,32768
8000a1a4:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a1a8:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
8000a1aa:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000a1ac:	7f f4 33 80 	jge.u %d4,%d15,8000a212 <GetAlarm+0x84>
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
8000a1b0:	bd 04 38 00 	jz.a %a4,8000a220 <GetAlarm+0x92>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000a1b4:	91 00 00 28 	movh.a %a2,32768
8000a1b8:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a1bc:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
8000a1c0:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a1c4:	d4 22       	ld.a %a2,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a1c6:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a1ca:	8f f8 0f f1 	and %d15,%d8,255
8000a1ce:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a1d2:	ee 0a       	jnz %d15,8000a1e6 <GetAlarm+0x58>
    OsEE_icr icr_temp = icr;
8000a1d4:	02 8f       	mov %d15,%d8
8000a1d6:	3b 30 01 20 	mov %d2,19
8000a1da:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a1de:	cd cf e2 0f 	mtcr $icr,%d15
8000a1e2:	0d 00 c0 04 	isync 
8000a1e6:	40 45       	mov.aa %a5,%a4
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    ev = osEE_alarm_get(p_alarm_db, Tick);
8000a1e8:	40 24       	mov.aa %a4,%a2
8000a1ea:	6d 00 3f 0a 	call 8000b668 <osEE_alarm_get>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a1ee:	4d c0 e2 4f 	mfcr %d4,$icr
8000a1f2:	02 4f       	mov %d15,%d4
8000a1f4:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a1f8:	8f f8 0f 31 	and %d3,%d8,255
8000a1fc:	5f 34 08 00 	jeq %d4,%d3,8000a20c <GetAlarm+0x7e>
8000a200:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a204:	cd cf e2 0f 	mtcr $icr,%d15
8000a208:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a20c:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a210:	5e 1b       	jne %d15,1,8000a226 <GetAlarm+0x98>
    p_ccb->service_id            = service_id;
8000a212:	da 26       	mov %d15,38
8000a214:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a218:	82 0f       	mov %d15,0
8000a21a:	e9 ff 23 00 	st.b [%a15]35,%d15
8000a21e:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Tick == NULL) {
    ev = E_OS_PARAM_POINTER;
8000a220:	3b e0 00 20 	mov %d2,14
8000a224:	3c f7       	j 8000a212 <GetAlarm+0x84>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarm);

  return ev;
}
8000a226:	00 90       	ret 

8000a228 <GetAlarmBase>:
  GetAlarmBase
(
  VAR(AlarmType, AUTOMATIC)         AlarmID,
  VAR(AlarmBaseRefType, AUTOMATIC)  Info
)
{
8000a228:	40 ae       	mov.aa %a14,%sp
8000a22a:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a22c:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a22e:	da 25       	mov %d15,37
8000a230:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a234:	82 1f       	mov %d15,1
8000a236:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (alarm_id < p_kdb->p_kcb->free_alarm_index);
#else
  return (alarm_id < p_kdb->alarm_array_size);
8000a23a:	91 00 00 28 	movh.a %a2,32768
8000a23e:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a242:	4c 28       	ld.w %d15,[%a2]32
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
8000a244:	82 32       	mov %d2,3
  if (p_ccb->os_context > OSEE_POSTTASKHOOK_CTX)
  {
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
8000a246:	7f f4 1b 80 	jge.u %d4,%d15,8000a27c <GetAlarmBase+0x54>
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
8000a24a:	bd 04 20 00 	jz.a %a4,8000a28a <GetAlarmBase+0x62>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)
      p_alarm_db = (*p_kdb->p_alarm_ptr_array)[AlarmID];
8000a24e:	91 00 00 28 	movh.a %a2,32768
8000a252:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a256:	99 22 1c 00 	ld.a %a2,[%a2]28 <8000001c <BootModeHeader0+0x1c>>
8000a25a:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
    CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
      p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = p_trigger_db->p_counter_db;
8000a25e:	d4 22       	ld.a %a2,[%a2]
8000a260:	19 22 04 00 	ld.w %d2,[%a2]4

    *Info = p_counter_db->info;
8000a264:	60 22       	mov.a %a2,%d2
8000a266:	b0 42       	add.a %a2,4
8000a268:	09 22 48 01 	ld.d %e2,[%a2+]8
8000a26c:	89 42 48 01 	st.d [%a4+]8,%e2
8000a270:	44 22       	ld.w %d2,[%a2+]
8000a272:	64 42       	st.w [%a4+],%d2
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a274:	39 ff 23 00 	ld.bu %d15,[%a15]35

    ev = E_OK;
8000a278:	82 02       	mov %d2,0
8000a27a:	5e 1b       	jne %d15,1,8000a290 <GetAlarmBase+0x68>
    p_ccb->service_id            = service_id;
8000a27c:	da 24       	mov %d15,36
8000a27e:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a282:	82 0f       	mov %d15,0
8000a284:	e9 ff 23 00 	st.b [%a15]35,%d15
8000a288:	00 90       	ret 
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  if (!osEE_is_valid_alarm_id(p_kdb, AlarmID)) {
    ev = E_OS_ID;
  } else
  if (Info == NULL) {
    ev = E_OS_PARAM_POINTER;
8000a28a:	3b e0 00 20 	mov %d2,14
8000a28e:	3c f7       	j 8000a27c <GetAlarmBase+0x54>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetAlarmBase);

  return ev;
}
8000a290:	00 90       	ret 

8000a292 <WaitEvent>:
FUNC(StatusType, OS_CODE)
  WaitEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a292:	40 ae       	mov.aa %a14,%sp
8000a294:	40 9c       	mov.aa %a12,%a9
  VAR(StatusType, AUTOMATIC)  ev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000a296:	cc c3       	ld.a %a15,[%a12]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000a298:	c8 0d       	ld.a %a13,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000a29a:	19 d8 0c 00 	ld.w %d8,[%a13]12 <f0030003 <_SMALL_DATA4_+0x40028003>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a29e:	da 23       	mov %d15,35
8000a2a0:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a2a4:	82 1f       	mov %d15,1
8000a2a6:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000a2aa:	4c f8       	ld.w %d15,[%a15]32
8000a2ac:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
8000a2b0:	3b c0 00 20 	mov %d2,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
8000a2b4:	ee 62       	jnz %d15,8000a378 <WaitEvent+0xe6>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
8000a2b6:	39 df 14 00 	ld.bu %d15,[%a13]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000a2ba:	82 22       	mov %d2,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_EXTENDED)
8000a2bc:	ff 2f 5e 80 	jge.u %d15,2,8000a378 <WaitEvent+0xe6>
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_curr_tcb->p_last_m != NULL) {
8000a2c0:	60 82       	mov.a %a2,%d8
8000a2c2:	19 23 04 00 	ld.w %d3,[%a2]4
    }
#else
    ev = E_OS_RESOURCE;
#endif /* OSEE_HAS_SPINLOCKS */
#else
    ev = E_OS_SPINLOCK;
8000a2c6:	3b 40 01 20 	mov %d2,20
  )
  {
    ev = E_OS_CALLEVEL;
  } else
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
  if (p_curr_tcb->p_last_m != NULL) {
8000a2ca:	df 03 57 80 	jne %d3,0,8000a378 <WaitEvent+0xe6>
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
8000a2ce:	82 12       	mov %d2,1
#else
    ev = E_OS_SPINLOCK;
#endif /* OSEE_HAS_RESOURCES */
  } else
#endif /* OSEE_HAS_RESOURCES || OSEE_HAS_SPINLOCKS */
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000a2d0:	df 1f 54 80 	jne %d15,1,8000a378 <WaitEvent+0xe6>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a2d4:	4d c0 e2 9f 	mfcr %d9,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a2d8:	8f f9 0f f1 	and %d15,%d9,255
8000a2dc:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a2e0:	ee 0a       	jnz %d15,8000a2f4 <WaitEvent+0x62>
    OsEE_icr icr_temp = icr;
8000a2e2:	02 9f       	mov %d15,%d9
8000a2e4:	3b 30 01 20 	mov %d2,19
8000a2e8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a2ec:	cd cf e2 0f 	mtcr $icr,%d15
8000a2f0:	0d 00 c0 04 	isync 
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000a2f4:	99 c2 10 00 	ld.a %a2,[%a12]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000a2f8:	82 16       	mov %d6,1
8000a2fa:	82 07       	mov %d7,0
8000a2fc:	0b 67 10 28 	mov %e2,%d7,%d6
8000a300:	49 22 c0 08 	cmpswap.w [%a2]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000a304:	df 02 fa ff 	jne %d2,0,8000a2f8 <WaitEvent+0x66>
    /* Start Critical Section */
    CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);

    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
8000a308:	60 82       	mov.a %a2,%d8
8000a30a:	4c 23       	ld.w %d15,[%a2]12
8000a30c:	26 4f       	and %d15,%d4
8000a30e:	ee 1c       	jnz %d15,8000a346 <WaitEvent+0xb4>
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;
8000a310:	59 24 08 00 	st.w [%a2]8,%d4

      p_curr_tcb->p_own_sn =
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000a314:	40 c4       	mov.aa %a4,%a12
8000a316:	d9 f5 04 00 	lea %a5,[%a15]4
8000a31a:	6d 00 bc 05 	call 8000ae92 <osEE_scheduler_core_pop_running>
    /* Check if we have to wait */
    if ((p_curr_tcb->event_mask & Mask) == 0U) {
      /* Set the waiting mask */
      p_curr_tcb->wait_mask = Mask;

      p_curr_tcb->p_own_sn =
8000a31e:	60 83       	mov.a %a3,%d8
8000a320:	b5 32 10 00 	st.a [%a3]16,%a2
        osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);

      p_curr_tcb->status = OSEE_TASK_WAITING;
8000a324:	82 3f       	mov %d15,3
8000a326:	2c 32       	st.b [%a3]2,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000a328:	99 c2 10 00 	ld.a %a2,[%a12]16
8000a32c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000a330:	82 0f       	mov %d15,0
8000a332:	6c 20       	st.w [%a2]0,%d15

      osEE_unlock_core(p_cdb);

      osEE_change_context_from_running(p_curr, p_ccb->p_curr);
8000a334:	40 d4       	mov.aa %a4,%a13
8000a336:	c8 05       	ld.a %a5,[%a15]0
8000a338:	6d 00 cb 09 	call 8000b6ce <osEE_change_context_from_running>

      /* Reset the waiting mask when we exit from the wait condition. */
      p_curr_tcb->wait_mask = 0U;
8000a33c:	82 02       	mov %d2,0
8000a33e:	60 82       	mov.a %a2,%d8
8000a340:	59 22 08 00 	st.w [%a2]8,%d2
8000a344:	3c 07       	j 8000a352 <WaitEvent+0xc0>
8000a346:	99 c2 10 00 	ld.a %a2,[%a12]16
8000a34a:	0d 00 80 04 	dsync 
8000a34e:	82 0f       	mov %d15,0
8000a350:	6c 20       	st.w [%a2]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a352:	4d c0 e2 3f 	mfcr %d3,$icr
8000a356:	02 3f       	mov %d15,%d3
8000a358:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a35c:	8f f9 0f 21 	and %d2,%d9,255
8000a360:	5f 23 08 00 	jeq %d3,%d2,8000a370 <WaitEvent+0xde>
8000a364:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a368:	cd cf e2 0f 	mtcr $icr,%d15
8000a36c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a370:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a374:	82 02       	mov %d2,0
8000a376:	5e 17       	jne %d15,1,8000a384 <WaitEvent+0xf2>
    p_ccb->service_id            = service_id;
8000a378:	da 22       	mov %d15,34
8000a37a:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a37e:	82 0f       	mov %d15,0
8000a380:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_WaitEvent);

  return ev;
}
8000a384:	00 90       	ret 

8000a386 <SetEvent>:
  SetEvent
(
  VAR(TaskType,      AUTOMATIC) TaskID,
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a386:	40 ae       	mov.aa %a14,%sp
8000a388:	20 08       	sub.a %sp,8
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000a38a:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_get_curr_core();
#if (defined(OSEE_HAS_CHECKS)) || (defined(OSEE_HAS_ERRORHOOK)) ||\
    (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb  = p_cdb->p_ccb;
8000a38c:	c8 3f       	ld.a %a15,[%a15]12
#if (defined(OSEE_HAS_CHECKS))
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr = p_ccb->p_curr;
8000a38e:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a390:	da 1d       	mov %d15,29
8000a392:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a396:	82 1f       	mov %d15,1
8000a398:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000a39c:	4c f8       	ld.w %d15,[%a15]32
8000a39e:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
/* SetEvent is callable by Task and ISR2 */
  if (osEE_check_disableint(p_ccb)) {
8000a3a2:	6e 05       	jz %d15,8000a3ac <SetEvent+0x26>
    ev = E_OS_DISABLEDINT;
8000a3a4:	da 0c       	mov %d15,12
8000a3a6:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000a3aa:	3c 50       	j 8000a44a <SetEvent+0xc4>
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
8000a3ac:	39 2f 14 00 	ld.bu %d15,[%a2]20
8000a3b0:	bf 3f 06 80 	jlt.u %d15,3,8000a3bc <SetEvent+0x36>
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
    || (p_ccb->os_context > OSEE_TASK_ISR2_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000a3b4:	82 2f       	mov %d15,2
8000a3b6:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000a3ba:	3c 48       	j 8000a44a <SetEvent+0xc4>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000a3bc:	91 00 00 28 	movh.a %a2,32768
8000a3c0:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a3c4:	4c 24       	ld.w %d15,[%a2]16
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000a3c6:	3f f4 06 80 	jlt.u %d4,%d15,8000a3d2 <SetEvent+0x4c>
    ev = E_OS_ID;
8000a3ca:	82 3f       	mov %d15,3
8000a3cc:	e9 ef ff ff 	st.b [%a14]-1,%d15
8000a3d0:	3c 3d       	j 8000a44a <SetEvent+0xc4>
  } else {
    P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_sn;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_waking_up = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000a3d2:	91 00 00 28 	movh.a %a2,32768
8000a3d6:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a3da:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000a3de:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a3e2:	d4 24       	ld.a %a4,[%a2]
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a3e4:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a3e8:	8f f8 0f f1 	and %d15,%d8,255
8000a3ec:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a3f0:	ee 0a       	jnz %d15,8000a404 <SetEvent+0x7e>
    OsEE_icr icr_temp = icr;
8000a3f2:	02 8f       	mov %d15,%d8
8000a3f4:	3b 30 01 20 	mov %d2,19
8000a3f8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a3fc:	cd cf e2 0f 	mtcr $icr,%d15
8000a400:	0d 00 c0 04 	isync 
8000a404:	02 54       	mov %d4,%d5
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();

    p_sn = osEE_task_event_set_mask(p_tdb_waking_up, Mask, &ev);
8000a406:	d9 e5 ff ff 	lea %a5,[%a14]-1
8000a40a:	6d 00 87 05 	call 8000af18 <osEE_task_event_set_mask>

    if (p_sn != NULL) {
8000a40e:	bc 2f       	jz.a %a2,8000a42c <SetEvent+0xa6>
      /* Release the TASK (and the SN) */
      if (osEE_scheduler_task_unblocked(p_kdb, p_sn))
8000a410:	91 00 00 48 	movh.a %a4,32768
8000a414:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
8000a418:	40 25       	mov.aa %a5,%a2
8000a41a:	6d 00 8f 06 	call 8000b138 <osEE_scheduler_task_unblocked>
8000a41e:	76 27       	jz %d2,8000a42c <SetEvent+0xa6>
      {
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000a420:	91 00 00 48 	movh.a %a4,32768
8000a424:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
8000a428:	6d 00 2b 07 	call 8000b27e <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a42c:	4d c0 e2 3f 	mfcr %d3,$icr
8000a430:	02 3f       	mov %d15,%d3
8000a432:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a436:	8f f8 0f 21 	and %d2,%d8,255
8000a43a:	5f 23 08 00 	jeq %d3,%d2,8000a44a <SetEvent+0xc4>
8000a43e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a442:	cd cf e2 0f 	mtcr $icr,%d15
8000a446:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a44a:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a44e:	5e 17       	jne %d15,1,8000a45c <SetEvent+0xd6>
    p_ccb->service_id            = service_id;
8000a450:	da 1c       	mov %d15,28
8000a452:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a456:	82 0f       	mov %d15,0
8000a458:	e9 ff 23 00 	st.b [%a15]35,%d15
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_SetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000a45c:	39 e2 ff ff 	ld.bu %d2,[%a14]-1
8000a460:	00 90       	ret 

8000a462 <GetEvent>:
  GetEvent
(
  VAR(TaskType, AUTOMATIC)          TaskID,
  VAR(EventMaskRefType, AUTOMATIC)  Event
)
{
8000a462:	40 ae       	mov.aa %a14,%sp
8000a464:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb       = osEE_get_curr_core();
#if (defined(OSEE_HAS_CHECKS)) || (defined(OSEE_HAS_ERRORHOOK)) ||\
    (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb       = p_cdb->p_ccb;
8000a466:	c8 3f       	ld.a %a15,[%a15]12
  CONST(OsEE_os_context, AUTOMATIC)
    os_context  = p_ccb->os_context;
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#if (defined(OSEE_HAS_CHECKS))
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000a468:	c8 02       	ld.a %a2,[%a15]0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a46a:	da 21       	mov %d15,33
8000a46c:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a470:	82 1f       	mov %d15,1
8000a472:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000a476:	4c f8       	ld.w %d15,[%a15]32
8000a478:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
8000a47c:	3b c0 00 20 	mov %d2,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
8000a480:	ee 27       	jnz %d15,8000a4ce <GetEvent+0x6c>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
8000a482:	39 2f 14 00 	ld.bu %d15,[%a2]20
        (os_context != OSEE_PRETASKHOOK_CTX) &&
        (os_context != OSEE_POSTTASKHOOK_CTX))
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000a486:	82 22       	mov %d2,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type > OSEE_TASK_TYPE_ISR2)
8000a488:	ff 3f 23 80 	jge.u %d15,3,8000a4ce <GetEvent+0x6c>
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (tid < p_kdb->p_kcb->free_task_index);
#else
  return (tid < p_kdb->tdb_array_size);
8000a48c:	91 00 00 28 	movh.a %a2,32768
8000a490:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a494:	4c 24       	ld.w %d15,[%a2]16
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
    ev = E_OS_ID;
8000a496:	82 32       	mov %d2,3
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS */
#else
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_CHECKS || OSEE_HAS_ERRORHOOK || OSEE_HAS_ORTI */
  if (!osEE_is_valid_tid(p_kdb, TaskID)) {
8000a498:	7f f4 1b 80 	jge.u %d4,%d15,8000a4ce <GetEvent+0x6c>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_event = (*p_kdb->p_tdb_ptr_array)[TaskID];
8000a49c:	91 00 00 28 	movh.a %a2,32768
8000a4a0:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a4a4:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000a4a8:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a4ac:	d4 22       	ld.a %a2,[%a2]
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
8000a4ae:	99 23 0c 00 	ld.a %a3,[%a2]12
    /* XXX: We will accept an harmless race condition here for TASKs that want
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000a4b2:	39 2f 14 00 	ld.bu %d15,[%a2]20
      ev = E_OS_ACCESS;
8000a4b6:	82 12       	mov %d2,1
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_event = p_tdb_event->p_tcb;
    /* XXX: We will accept an harmless race condition here for TASKs that want
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000a4b8:	5e 1b       	jne %d15,1,8000a4ce <GetEvent+0x6c>
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
8000a4ba:	0c 32       	ld.bu %d15,[%a3]2
      ev = E_OS_STATE;
8000a4bc:	82 72       	mov %d2,7
     *      read events of TASKs allocated in other cores */
#if (defined(OSEE_HAS_CHECKS))
    if (p_tdb_event->task_type != OSEE_TASK_TYPE_EXTENDED) {
      ev = E_OS_ACCESS;
    } else
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
8000a4be:	6e 08       	jz %d15,8000a4ce <GetEvent+0x6c>
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
8000a4c0:	bc 4e       	jz.a %a4,8000a4dc <GetEvent+0x7a>
      ev = E_OS_PARAM_POINTER;
    } else
    {
      /* N.B. XXX This MUST Be ATOMIC! */
      (*Event) = p_tcb_event->event_mask;
8000a4c2:	4c 33       	ld.w %d15,[%a3]12
8000a4c4:	6c 40       	st.w [%a4]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a4c6:	39 ff 23 00 	ld.bu %d15,[%a15]35

      ev = E_OK;
8000a4ca:	82 02       	mov %d2,0
8000a4cc:	5e 1b       	jne %d15,1,8000a4e2 <GetEvent+0x80>
    p_ccb->service_id            = service_id;
8000a4ce:	da 20       	mov %d15,32
8000a4d0:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a4d4:	82 0f       	mov %d15,0
8000a4d6:	e9 ff 23 00 	st.b [%a15]35,%d15
8000a4da:	00 90       	ret 
    if (p_tcb_event->status == OSEE_TASK_SUSPENDED) {
      ev = E_OS_STATE;
    } else
#endif /* OSEE_HAS_CHECKS */
    if (Event == NULL) {
      ev = E_OS_PARAM_POINTER;
8000a4dc:	3b e0 00 20 	mov %d2,14
8000a4e0:	3c f7       	j 8000a4ce <GetEvent+0x6c>
#if (defined(OSEE_HAS_ORTI))
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetEvent);
#endif /* OSEE_HAS_ORTI */

  return ev;
}
8000a4e2:	00 90       	ret 

8000a4e4 <ClearEvent>:
FUNC(StatusType, OS_CODE)
  ClearEvent
(
  VAR(EventMaskType, AUTOMATIC) Mask
)
{
8000a4e4:	40 ae       	mov.aa %a14,%sp
8000a4e6:	40 92       	mov.aa %a2,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb       = p_cdb->p_ccb;
8000a4e8:	cc 23       	ld.a %a15,[%a2]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_curr      = p_ccb->p_curr;
8000a4ea:	c8 03       	ld.a %a3,[%a15]0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_curr_tcb  = p_curr->p_tcb;
8000a4ec:	99 34 0c 00 	ld.a %a4,[%a3]12 <80000003 <BootModeHeader0+0x3>>
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a4f0:	da 1f       	mov %d15,31
8000a4f2:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a4f6:	82 1f       	mov %d15,1
8000a4f8:	e9 ff 23 00 	st.b [%a15]35,%d15
  osEE_check_disableint
(
  P2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb
)
{
  return (p_ccb->s_isr_all_cnt > 0U) || (p_ccb->s_isr_os_cnt > 0U) ||
8000a4fc:	4c f8       	ld.w %d15,[%a15]32
8000a4fe:	b7 0f 08 fc 	insert %d15,%d15,0,24,8
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
8000a502:	3b c0 00 20 	mov %d2,12
   *    context AND is currently not inside a Category 1 ISR the Operating
   *    System module shall not perform the requested action
   *    (the service call shall have no effect), and return E_OS_CALLEVEL
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
8000a506:	ee 41       	jnz %d15,8000a588 <ClearEvent+0xa4>
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)
8000a508:	39 3f 14 00 	ld.bu %d15,[%a3]20
#if (defined(OSEE_HAS_SERVICE_PROTECTION))
      || (p_ccb->os_context > OSEE_TASK_CTX)
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
8000a50c:	82 22       	mov %d2,2
   *    (see [12], section 13.1) or the "invalid value" of  the service.
   *    (SRS_Os_11009, SRS_Os_11013) */
  if (osEE_check_disableint(p_ccb)) {
    ev = E_OS_DISABLEDINT;
  } else
  if ((p_curr->task_type >= OSEE_TASK_TYPE_ISR2)
8000a50e:	ff 2f 3d 80 	jge.u %d15,2,8000a588 <ClearEvent+0xa4>
  )
  {
    ev = E_OS_CALLEVEL;
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
    ev = E_OS_ACCESS;
8000a512:	82 12       	mov %d2,1
#endif /* OSEE_HAS_SERVICE_PROTECTION */
  )
  {
    ev = E_OS_CALLEVEL;
  } else
  if (p_curr->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000a514:	df 1f 3a 80 	jne %d15,1,8000a588 <ClearEvent+0xa4>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a518:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a51c:	8f f2 0f f1 	and %d15,%d2,255
8000a520:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a524:	ee 0a       	jnz %d15,8000a538 <ClearEvent+0x54>
    OsEE_icr icr_temp = icr;
8000a526:	02 2f       	mov %d15,%d2
8000a528:	3b 30 01 30 	mov %d3,19
8000a52c:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a530:	cd cf e2 0f 	mtcr $icr,%d15
8000a534:	0d 00 c0 04 	isync 
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000a538:	99 23 10 00 	ld.a %a3,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000a53c:	82 16       	mov %d6,1
8000a53e:	82 07       	mov %d7,0
8000a540:	0b 67 10 08 	mov %e0,%d7,%d6
8000a544:	49 30 c0 08 	cmpswap.w [%a3]0,%e0
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000a548:	df 00 fa ff 	jne %d0,0,8000a53c <ClearEvent+0x58>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    osEE_lock_core(p_cdb);
    /* XXX: Maybe we need to introduce an HAL for atomic Load-Modify-Store
            Operations */
    p_curr_tcb->event_mask &= ~Mask;
8000a54c:	4c 43       	ld.w %d15,[%a4]12
8000a54e:	0f 4f e0 40 	andn %d4,%d15,%d4
8000a552:	59 44 0c 00 	st.w [%a4]12,%d4
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000a556:	99 22 10 00 	ld.a %a2,[%a2]16
8000a55a:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000a55e:	82 0f       	mov %d15,0
8000a560:	6c 20       	st.w [%a2]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a562:	4d c0 e2 3f 	mfcr %d3,$icr
8000a566:	02 3f       	mov %d15,%d3
8000a568:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a56c:	8f f2 0f 21 	and %d2,%d2,255
8000a570:	5f 23 08 00 	jeq %d3,%d2,8000a580 <ClearEvent+0x9c>
8000a574:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a578:	cd cf e2 0f 	mtcr $icr,%d15
8000a57c:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a580:	39 ff 23 00 	ld.bu %d15,[%a15]35

    osEE_unlock_core(p_cdb);
    osEE_end_primitive(flags);

    ev = E_OK;
8000a584:	82 02       	mov %d2,0
8000a586:	5e 17       	jne %d15,1,8000a594 <ClearEvent+0xb0>
    p_ccb->service_id            = service_id;
8000a588:	da 1e       	mov %d15,30
8000a58a:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a58e:	82 0f       	mov %d15,0
8000a590:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ClearEvent);

  return ev;
}
8000a594:	00 90       	ret 

8000a596 <GetCounterValue>:
  GetCounterValue
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value
)
{
8000a596:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000a598:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a59a:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a59c:	da 31       	mov %d15,49
8000a59e:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a5a2:	82 1f       	mov %d15,1
8000a5a4:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
8000a5a8:	91 00 00 28 	movh.a %a2,32768
8000a5ac:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a5b0:	4c 26       	ld.w %d15,[%a2]24
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
8000a5b2:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00376] If the input parameter <CounterID> in a call of
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000a5b4:	7f f4 1e 80 	jge.u %d4,%d15,8000a5f0 <GetCounterValue+0x5a>
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
8000a5b8:	bd 04 23 00 	jz.a %a4,8000a5fe <GetCounterValue+0x68>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_CONST)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000a5bc:	91 00 00 28 	movh.a %a2,32768
8000a5c0:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a5c4:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
8000a5c8:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a5cc:	d4 22       	ld.a %a2,[%a2]
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000a5ce:	4d c0 e1 ff 	mfcr %d15,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
8000a5d2:	79 23 10 00 	ld.b %d3,[%a2]16
8000a5d6:	37 0f 48 f0 	extr %d15,%d15,0,8
      ev = E_OS_CORE;
8000a5da:	3b 70 01 20 	mov %d2,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
8000a5de:	5f f3 06 80 	jne %d3,%d15,8000a5ea <GetCounterValue+0x54>
    of hardware timers (which drive counters) in such that the lowest value is
    zero and consecutive reads return an increasing count value until the timer
    wraps at its modulus. (SRS_Frt_00030, SRS_Frt_00031) */
/* EG  TODO: Add support for HARDWARE counters */

      (*Value) = p_counter_db->p_counter_cb->value;
8000a5e2:	d4 22       	ld.a %a2,[%a2]
8000a5e4:	4c 21       	ld.w %d15,[%a2]4
8000a5e6:	6c 40       	st.w [%a4]0,%d15

      ev = E_OK;
8000a5e8:	82 02       	mov %d2,0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a5ea:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a5ee:	5e 1b       	jne %d15,1,8000a604 <GetCounterValue+0x6e>
    p_ccb->service_id            = service_id;
8000a5f0:	da 30       	mov %d15,48
8000a5f2:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a5f6:	82 0f       	mov %d15,0
8000a5f8:	e9 ff 23 00 	st.b [%a15]35,%d15
8000a5fc:	00 90       	ret 
    GetCounterValue() is not valid, GetCounterValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if (Value == NULL) {
    ev = E_OS_PARAM_POINTER;
8000a5fe:	3b e0 00 20 	mov %d2,14
8000a602:	3c f7       	j 8000a5f0 <GetCounterValue+0x5a>
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetCounterValue);

  return ev;
}
8000a604:	00 90       	ret 

8000a606 <GetElapsedValue>:
(
  VAR(CounterType, AUTOMATIC) CounterID,
  VAR(TickRefType, AUTOMATIC) Value,
  VAR(TickRefType, AUTOMATIC) ElapsedValue
)
{
8000a606:	40 ae       	mov.aa %a14,%sp
8000a608:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a60a:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a60c:	da 33       	mov %d15,51
8000a60e:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a612:	82 1f       	mov %d15,1
8000a614:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
8000a618:	91 00 00 28 	movh.a %a2,32768
8000a61c:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a620:	4c 26       	ld.w %d15,[%a2]24
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
8000a622:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000a624:	7f f4 35 80 	jge.u %d4,%d15,8000a68e <GetElapsedValue+0x88>
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000a628:	80 42       	mov.d %d2,%a4
8000a62a:	80 53       	mov.d %d3,%a5
8000a62c:	ba 02       	eq %d15,%d2,0
8000a62e:	8b 03 e0 f4 	or.eq %d15,%d3,0
    ev = E_OS_PARAM_POINTER;
8000a632:	3b e0 00 20 	mov %d2,14
 /* [SWS_Os_00381] If the input parameter <CounterID> in a call of
    GetElapsedValue() is not valid GetElapsedValue() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
  } else
  if ((Value == NULL) || (ElapsedValue == NULL)) {
8000a636:	ee 2c       	jnz %d15,8000a68e <GetElapsedValue+0x88>
    ev = E_OS_PARAM_POINTER;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000a638:	91 00 00 28 	movh.a %a2,32768
8000a63c:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a640:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
8000a644:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a648:	d4 22       	ld.a %a2,[%a2]
    CONST(TickType, AUTOMATIC)
      local_value = (*Value);
8000a64a:	54 44       	ld.w %d4,[%a4]
8000a64c:	4d c0 e1 ff 	mfcr %d15,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
8000a650:	79 23 10 00 	ld.b %d3,[%a2]16
8000a654:	37 0f 48 f0 	extr %d15,%d15,0,8
      ev = E_OS_CORE;
8000a658:	3b 70 01 20 	mov %d2,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) curr_core_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != curr_core_id) {
8000a65c:	5f f3 16 80 	jne %d3,%d15,8000a688 <GetElapsedValue+0x82>
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_CHECKS))
/* [SWS_Os_00391] If the <Value> in a call of GetElapsedValue() is larger than
    the max allowed value of the <CounterID>, GetElapsedValue() shall return
    E_OS_VALUE. */
    if (local_value > p_counter_db->info.maxallowedvalue) {
8000a660:	4c 21       	ld.w %d15,[%a2]4
      ev = E_OS_VALUE;
8000a662:	3b 80 00 20 	mov %d2,8
#endif /* !OSEE_SINGLECORE */
#if (defined(OSEE_HAS_CHECKS))
/* [SWS_Os_00391] If the <Value> in a call of GetElapsedValue() is larger than
    the max allowed value of the <CounterID>, GetElapsedValue() shall return
    E_OS_VALUE. */
    if (local_value > p_counter_db->info.maxallowedvalue) {
8000a666:	3f 4f 11 80 	jlt.u %d15,%d4,8000a688 <GetElapsedValue+0x82>
/* [SWS_Os_00382] If the input parameters in a call of GetElapsedValue()
     are valid, GetElapsedValue() shall return the number of elapsed ticks
     since the given <Value> value via <ElapsedValue> and shall return
     E_OK. (SRS_Frt_00034) */
      CONST(TickType, AUTOMATIC)
        local_curr_value = p_counter_db->p_counter_cb->value;
8000a66a:	d4 22       	ld.a %a2,[%a2]
8000a66c:	19 22 04 00 	ld.w %d2,[%a2]4
8000a670:	42 2f       	add %d15,%d2
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
        /* Timer did not pass the <value> yet */
        (local_curr_value - local_value):
8000a672:	c2 1f       	add %d15,1
8000a674:	0b 42 80 30 	sub %d3,%d2,%d4
8000a678:	a2 4f       	sub %d15,%d4
8000a67a:	0b 42 30 41 	lt.u %d4,%d2,%d4
8000a67e:	2b 3f 40 f4 	sel %d15,%d4,%d15,%d3

/* [SWS_Os_00533] Caveats of GetElapsedValue(): If the timer already passed the
    <Value> value a second (or multiple) time, the result returned is wrong.
    The reason is that the service can not detect such a relative overflow. */
/* EG  TODO: Add support for HARDWARE counters */
      (*ElapsedValue) = (local_curr_value >= local_value)?
8000a682:	6c 50       	st.w [%a5]0,%d15
        ((p_counter_db->info.maxallowedvalue -
          (local_value - local_curr_value)) + 1U);

/* [SWS_Os_00460] GetElapsedValue() shall return the current tick value of the
    counter in the <Value> parameter. */
      (*Value) = local_curr_value;
8000a684:	74 42       	st.w [%a4],%d2

      ev = E_OK;
8000a686:	82 02       	mov %d2,0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a688:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a68c:	5e 17       	jne %d15,1,8000a69a <GetElapsedValue+0x94>
    p_ccb->service_id            = service_id;
8000a68e:	da 32       	mov %d15,50
8000a690:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a694:	82 0f       	mov %d15,0
8000a696:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetElapsedValue);

  return ev;
}
8000a69a:	00 90       	ret 

8000a69c <IncrementCounter>:
FUNC(StatusType, OS_CODE)
  IncrementCounter
(
  VAR(CounterType, AUTOMATIC) CounterID
)
{
8000a69c:	40 ae       	mov.aa %a14,%sp
8000a69e:	40 9f       	mov.aa %a15,%a9
#if (!defined(OSEE_HAS_ORTI)) && (!defined(OSEE_HAS_ERRORHOOK))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI && !OSEE_HAS_ERRORHOOK */
    p_ccb = p_cdb->p_ccb;
8000a6a0:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a6a2:	da 2f       	mov %d15,47
8000a6a4:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a6a8:	82 1f       	mov %d15,1
8000a6aa:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (counter_id < p_kdb->p_kcb->free_counter_index);
#else
  return (counter_id < p_kdb->counter_array_size);
8000a6ae:	91 00 00 28 	movh.a %a2,32768
8000a6b2:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a6b6:	4c 26       	ld.w %d15,[%a2]24
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
    ev = E_OS_ID;
8000a6b8:	82 32       	mov %d2,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00285] If the input parameter <CounterID> in a call of
    IncrementCounter() is not valid OR the counter is a hardware counter,
    IncrementCounter() shall return E_OS_ID. */
  if (!osEE_is_valid_counter_id(p_kdb, CounterID)) {
8000a6ba:	7f f4 48 80 	jge.u %d4,%d15,8000a74a <IncrementCounter+0xae>
    ev = E_OS_ID;
  } else
  {
    CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
      p_counter_db = (*p_kdb->p_counter_ptr_array)[CounterID];
8000a6be:	91 00 00 28 	movh.a %a2,32768
8000a6c2:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a6c6:	99 22 14 00 	ld.a %a2,[%a2]20 <80000014 <BootModeHeader0+0x14>>
8000a6ca:	01 24 02 26 	addsc.a %a2,%a2,%d4,2
8000a6ce:	d4 24       	ld.a %a4,[%a2]
8000a6d0:	4d c0 e1 ff 	mfcr %d15,$core_id
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) current_cpu_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != current_cpu_id) {
8000a6d4:	79 43 10 00 	ld.b %d3,[%a4]16
8000a6d8:	37 0f 48 f0 	extr %d15,%d15,0,8
      ev = E_OS_CORE;
8000a6dc:	3b 70 01 20 	mov %d2,23
/* [SWS_Os_00589] All functions that are not allowed to operate cross core
    shall return E_OS_CORE in extended status if called with parameters that
    require a cross core operation. (SRS_Os_80013) */
#if (!defined(OSEE_SINGLECORE))
    CONST(CoreIdType, AUTOMATIC) current_cpu_id = osEE_get_curr_core_id();
    if (p_counter_db->core_id != current_cpu_id) {
8000a6e0:	5f f3 32 80 	jne %d3,%d15,8000a744 <IncrementCounter+0xa8>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a6e4:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a6e8:	8f f8 0f f1 	and %d15,%d8,255
8000a6ec:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a6f0:	ee 0a       	jnz %d15,8000a704 <IncrementCounter+0x68>
    OsEE_icr icr_temp = icr;
8000a6f2:	02 8f       	mov %d15,%d8
8000a6f4:	3b 30 01 20 	mov %d2,19
8000a6f8:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a6fc:	cd cf e2 0f 	mtcr $icr,%d15
8000a700:	0d 00 c0 04 	isync 
      CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();

/* N.B. Multi-core critical sections are handled inside
   TODO: Pass flags to osEE_counter_increment so it could re-enable
         interrupts/lower IPL outside critical sections. */
      osEE_counter_increment(p_counter_db);
8000a704:	6d 00 62 06 	call 8000b3c8 <osEE_counter_increment>
8000a708:	40 92       	mov.aa %a2,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000a70a:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>

/* [SWS_Os_00529] Caveats of IncrementCounter(): If called from a task,
    rescheduling may take place. */
      if (osEE_get_curr_task()->task_type <= OSEE_TASK_TYPE_EXTENDED) {
8000a70e:	d4 22       	ld.a %a2,[%a2]
8000a710:	39 2f 14 00 	ld.bu %d15,[%a2]20 <8000000c <BootModeHeader0+0xc>>
8000a714:	ff 2f 08 80 	jge.u %d15,2,8000a724 <IncrementCounter+0x88>
        (void)osEE_scheduler_task_preemption_point(p_kdb);
8000a718:	91 00 00 48 	movh.a %a4,32768
8000a71c:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
8000a720:	6d 00 af 05 	call 8000b27e <osEE_scheduler_task_preemption_point>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a724:	4d c0 e2 3f 	mfcr %d3,$icr
8000a728:	02 3f       	mov %d15,%d3
8000a72a:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a72e:	8f f8 0f 21 	and %d2,%d8,255
8000a732:	5f 23 08 00 	jeq %d3,%d2,8000a742 <IncrementCounter+0xa6>
8000a736:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a73a:	cd cf e2 0f 	mtcr $icr,%d15
8000a73e:	0d 00 c0 04 	isync 
      }

      osEE_end_primitive(flags);

      ev = E_OK;
8000a742:	82 02       	mov %d2,0
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000a744:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000a748:	5e 17       	jne %d15,1,8000a756 <IncrementCounter+0xba>
    p_ccb->service_id            = service_id;
8000a74a:	da 2e       	mov %d15,46
8000a74c:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a750:	82 0f       	mov %d15,0
8000a752:	e9 ff 23 00 	st.b [%a15]35,%d15
#endif /* OSEE_HAS_ERRORHOOK */

  osEE_orti_trace_service_exit(p_ccb, OSServiceId_IncrementCounter);

  return ev;
}
8000a756:	00 90       	ret 

8000a758 <GetISRID>:
FUNC(ISRType, OS_CODE)
  GetISRID
(
  void
)
{
8000a758:	40 ae       	mov.aa %a14,%sp
8000a75a:	40 9f       	mov.aa %a15,%a9
  osEE_get_curr_task
(
  void
)
{
  return osEE_get_curr_core()->p_ccb->p_curr ;
8000a75c:	c8 3f       	ld.a %a15,[%a15]12
8000a75e:	c8 0f       	ld.a %a15,[%a15]0
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a760:	39 ff 14 00 	ld.bu %d15,[%a15]20 <0 <NULL>>
    isr_id = p_tdb->tid;
  } else {
    isr_id = INVALID_ISR;
8000a764:	82 f2       	mov %d2,-1
{
  VAR(ISRType, AUTOMATIC) isr_id;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
    p_tdb = osEE_get_curr_task();

  if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000a766:	5e 22       	jne %d15,2,8000a76a <GetISRID+0x12>
    isr_id = p_tdb->tid;
8000a768:	48 42       	ld.w %d2,[%a15]16
  } else {
    isr_id = INVALID_ISR;
  }

  return isr_id;
}
8000a76a:	00 90       	ret 

8000a76c <GetNumberOfActivatedCores>:
FUNC(CoreNumType, OS_CODE)
  GetNumberOfActivatedCores
(
  void
)
{
8000a76c:	40 ae       	mov.aa %a14,%sp
  /* [SWS_Os_00673] The return value of GetNumberOfActivatedCores shall be less
      or equal to the configured value of "OsNumberOfCores". (SRS_Os_80001) */
  return osEE_get_kernel()->p_kcb->ar_num_core_started;
8000a76e:	91 00 00 f8 	movh.a %a15,32768
8000a772:	99 ff 28 50 	ld.a %a15,[%a15]360 <80000168 <osEE_kdb_var>>
}
8000a776:	08 c2       	ld.bu %d2,[%a15]12
8000a778:	00 90       	ret 

8000a77a <StartCore>:
  StartCore
(
  VAR(CoreIdType, AUTOMATIC)                  CoreID,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
8000a77a:	40 ae       	mov.aa %a14,%sp
8000a77c:	40 4c       	mov.aa %a12,%a4
    osEE_unlock_kernel();

    osEE_end_primitive(flags);
  } else {
    /* CoreID >= OS_CORE_ID_ARR_SIZE */
    ev = E_OS_ID;
8000a77e:	82 35       	mov %d5,3
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
  /* Error Value */
  VAR(StatusType, AUTOMATIC) ev = E_OK;
  if (CoreID < OS_CORE_ID_ARR_SIZE) {
8000a780:	ff 34 56 00 	jge %d4,3,8000a82c <StartCore+0xb2>
8000a784:	40 9f       	mov.aa %a15,%a9
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
      p_cdb       = osEE_get_curr_core();
    CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
      p_ccb       = p_cdb->p_ccb;
8000a786:	c8 33       	ld.a %a3,[%a15]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a788:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a78c:	8f f8 0f f1 	and %d15,%d8,255
8000a790:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a794:	ee 0a       	jnz %d15,8000a7a8 <StartCore+0x2e>
    OsEE_icr icr_temp = icr;
8000a796:	02 8f       	mov %d15,%d8
8000a798:	3b 30 01 50 	mov %d5,19
8000a79c:	37 5f 08 f0 	insert %d15,%d15,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a7a0:	cd cf e2 0f 	mtcr $icr,%d15
8000a7a4:	0d 00 c0 04 	isync 
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
8000a7a8:	91 00 00 f8 	movh.a %a15,32768
8000a7ac:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
8000a7b0:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000a7b2:	82 12       	mov %d2,1
8000a7b4:	82 03       	mov %d3,0
8000a7b6:	0b 23 10 68 	mov %e6,%d3,%d2
8000a7ba:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000a7be:	df 06 fa ff 	jne %d6,0,8000a7b2 <StartCore+0x38>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
8000a7c2:	91 00 00 28 	movh.a %a2,32768
8000a7c6:	99 22 28 50 	ld.a %a2,[%a2]360 <80000168 <osEE_kdb_var>>
    /* Variable introduced to meet MISRA 12.1 in the next else if statement */
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
8000a7ca:	54 23       	ld.w %d3,[%a2]
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);
8000a7cc:	82 1f       	mov %d15,1
8000a7ce:	0f 4f 00 f0 	sh %d15,%d15,%d4

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
8000a7d2:	8f 7f 00 21 	and %d2,%d15,7
      ev = E_OS_ID;
8000a7d6:	82 35       	mov %d5,3
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
8000a7d8:	df 02 17 00 	jeq %d2,0,8000a806 <StartCore+0x8c>
      ev = E_OS_ID;
    } else if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000a7dc:	39 32 10 00 	ld.bu %d2,[%a3]16
         If StartCore is called after StartOS it shall return with E_OS_ACCESS
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
8000a7e0:	82 15       	mov %d5,1
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
      ev = E_OS_ID;
    } else if (p_ccb->os_status != OSEE_KERNEL_INITIALIZED) {
8000a7e2:	df 02 12 80 	jne %d2,0,8000a806 <StartCore+0x8c>
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
8000a7e6:	19 22 04 00 	ld.w %d2,[%a2]4
8000a7ea:	a6 32       	or %d2,%d3
8000a7ec:	26 f2       	and %d2,%d15
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      /* [SWS_Os_00680] If the parameter CoreID refers to a core that was
         already started by the function StartNonAutosarCore the related core
         is ignored and E_OS_STATE shall be returned.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
8000a7ee:	82 75       	mov %d5,7
         in extended status. (SRS_Os_80001) */
      /* [SWS_Os_00678] Calls to the StartCore function after StartOS()
         shall return with E_OS_ACCESS and the core shall not be started.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ACCESS;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
8000a7f0:	f6 2b       	jnz %d2,8000a806 <StartCore+0x8c>
        ++p_kcb->ar_num_core_started;

        osEE_hal_start_core(CoreID);
      }

      ev = E_OK;
8000a7f2:	82 05       	mov %d5,0
         is ignored and E_OS_STATE shall be returned.
         (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
    } else {
      /* Really start the core if we are not in MASTER core */
      if (CoreID != OS_CORE_ID_MASTER) {
8000a7f4:	76 49       	jz %d4,8000a806 <StartCore+0x8c>
        /* [SWS_Os_00677] The function StartCore shall start one core that
           shall run under the control of the AUTOSAR OS.
           (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
        /* Flag that core is started as Autosar core */
        p_kcb->ar_core_mask |= core_id_mask;
8000a7f6:	a6 3f       	or %d15,%d3
8000a7f8:	6c 20       	st.w [%a2]0,%d15
        /* Increment the Autosar Cores counter */
        ++p_kcb->ar_num_core_started;
8000a7fa:	0c 2c       	ld.bu %d15,[%a2]12
8000a7fc:	c2 1f       	add %d15,1
8000a7fe:	2c 2c       	st.b [%a2]12,%d15

        osEE_hal_start_core(CoreID);
8000a800:	6d 00 6f 08 	call 8000b8de <osEE_hal_start_core>
      }

      ev = E_OK;
8000a804:	82 05       	mov %d5,0
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000a806:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000a80a:	82 0f       	mov %d15,0
8000a80c:	68 0f       	st.w [%a15]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a80e:	4d c0 e2 3f 	mfcr %d3,$icr
8000a812:	02 3f       	mov %d15,%d3
8000a814:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a818:	8f f8 0f 21 	and %d2,%d8,255
8000a81c:	5f 23 08 00 	jeq %d3,%d2,8000a82c <StartCore+0xb2>
8000a820:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a824:	cd cf e2 0f 	mtcr $icr,%d15
8000a828:	0d 00 c0 04 	isync 
    /* CoreID >= OS_CORE_ID_ARR_SIZE */
    ev = E_OS_ID;
  }
  /* [SWS_Os_00681] There is no call to the ErrorHook() if an error occurs
       during StartCore(); (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
  if (Status != NULL) {
8000a82c:	bc c2       	jz.a %a12,8000a830 <StartCore+0xb6>
    *Status = ev;
8000a82e:	34 c5       	st.b [%a12],%d5
8000a830:	00 90       	ret 

8000a832 <StartNonAutosarCore>:
  StartNonAutosarCore
(
  VAR(CoreIdType, AUTOMATIC)                  CoreID,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  Status
)
{
8000a832:	40 ae       	mov.aa %a14,%sp
8000a834:	40 4c       	mov.aa %a12,%a4
    osEE_end_primitive(flags);
  } else {
    /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
        function StartNonAutosarCore has no effect and sets "Status" to
        E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
    ev = E_OS_ID;
8000a836:	82 35       	mov %d5,3
)
{
  /* Error Value */
  VAR(StatusType, AUTOMATIC) ev;

  if (CoreID < OS_CORE_ID_ARR_SIZE) {
8000a838:	ff 34 4c 00 	jge %d4,3,8000a8d0 <StartNonAutosarCore+0x9e>
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a83c:	4d c0 e2 8f 	mfcr %d8,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a840:	8f f8 0f f1 	and %d15,%d8,255
8000a844:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a848:	ee 0a       	jnz %d15,8000a85c <StartNonAutosarCore+0x2a>
    OsEE_icr icr_temp = icr;
8000a84a:	02 8f       	mov %d15,%d8
8000a84c:	3b 30 01 50 	mov %d5,19
8000a850:	37 5f 08 f0 	insert %d15,%d15,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a854:	cd cf e2 0f 	mtcr $icr,%d15
8000a858:	0d 00 c0 04 	isync 
8000a85c:	91 00 00 f8 	movh.a %a15,32768
8000a860:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
8000a864:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000a866:	82 12       	mov %d2,1
8000a868:	82 03       	mov %d3,0
8000a86a:	0b 23 10 68 	mov %e6,%d3,%d2
8000a86e:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000a872:	df 06 fa ff 	jne %d6,0,8000a866 <StartNonAutosarCore+0x34>
    CONST(OsEE_reg, AUTOMATIC)
      flags = osEE_begin_primitive();
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
8000a876:	91 00 00 28 	movh.a %a2,32768
8000a87a:	99 22 28 50 	ld.a %a2,[%a2]360 <80000168 <osEE_kdb_var>>
    /* Variable introduced to meet MISRA 12.1 in the next else if statement */
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
8000a87e:	54 23       	ld.w %d3,[%a2]
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);
8000a880:	82 1f       	mov %d15,1
8000a882:	0f 4f 00 f0 	sh %d15,%d15,%d4

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
8000a886:	8f 7f 00 21 	and %d2,%d15,7
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
8000a88a:	82 35       	mov %d5,3
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      ar_core_mask = p_kcb->ar_core_mask;
    CONST(OSEE_CORE_MASK_TYPE, AUTOMATIC)
      core_id_mask =  ((CoreMaskType)1U << (OsEE_reg)CoreID);

    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
8000a88c:	76 2f       	jz %d2,8000a8aa <StartNonAutosarCore+0x78>
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
8000a88e:	19 26 04 00 	ld.w %d6,[%a2]4
8000a892:	0f 36 a0 20 	or %d2,%d6,%d3
8000a896:	26 f2       	and %d2,%d15
    {
      /* [SWS_Os_00680] If the parameter CoreID refers to a core that was
          already started by the function StartNonAutosarCore the related core
          is ignored and E_OS_STATE shall be returned.
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
8000a898:	82 75       	mov %d5,7
    if ((core_id_mask & OSEE_CORE_ID_VALID_MASK) == 0U) {
      /* [SWS_Os_00685] If the parameter CoreID refers to an unknown core the
          function StartNonAutosarCore has no effect and sets "Status" to
          E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_ID;
    } else if (((ar_core_mask | p_kcb->not_ar_core_mask) & core_id_mask) != 0U)
8000a89a:	f6 28       	jnz %d2,8000a8aa <StartNonAutosarCore+0x78>
        /* Flag that core is started as non Autosar core */
        p_kcb->not_ar_core_mask |= core_id_mask;
        osEE_hal_start_core(CoreID);
      }

      ev = E_OK;
8000a89c:	82 05       	mov %d5,0
          is ignored and E_OS_STATE shall be returned.
          (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
      ev = E_OS_STATE;
    } else {
      /* Really start the core if we are not in MASTER core */
      if (CoreID != OS_CORE_ID_MASTER) {
8000a89e:	76 46       	jz %d4,8000a8aa <StartNonAutosarCore+0x78>
        /* [SWS_Os_00683] The function StartNonAutosarCore shall start a core
            that is not controlled by the AUTOSAR OS.
            (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
        /* Flag that core is started as non Autosar core */
        p_kcb->not_ar_core_mask |= core_id_mask;
8000a8a0:	a6 6f       	or %d15,%d6
8000a8a2:	6c 21       	st.w [%a2]4,%d15
        osEE_hal_start_core(CoreID);
8000a8a4:	6d 00 1d 08 	call 8000b8de <osEE_hal_start_core>
      }

      ev = E_OK;
8000a8a8:	82 05       	mov %d5,0
8000a8aa:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000a8ae:	82 0f       	mov %d15,0
8000a8b0:	68 0f       	st.w [%a15]0,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a8b2:	4d c0 e2 3f 	mfcr %d3,$icr
8000a8b6:	02 3f       	mov %d15,%d3
8000a8b8:	8f f3 0f 31 	and %d3,%d3,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a8bc:	8f f8 0f 21 	and %d2,%d8,255
8000a8c0:	5f 23 08 00 	jeq %d3,%d2,8000a8d0 <StartNonAutosarCore+0x9e>
8000a8c4:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a8c8:	cd cf e2 0f 	mtcr $icr,%d15
8000a8cc:	0d 00 c0 04 	isync 
        function StartNonAutosarCore has no effect and sets "Status" to
        E_OS_ID. (SRS_Os_80006, SRS_Os_80026, SRS_Os_80027) */
    ev = E_OS_ID;
  }

  if (Status != NULL) {
8000a8d0:	bc c2       	jz.a %a12,8000a8d4 <StartNonAutosarCore+0xa2>
    *Status = ev;
8000a8d2:	34 c5       	st.b [%a12],%d5
8000a8d4:	00 90       	ret 

8000a8d6 <ShutdownAllCores>:
FUNC(void, OS_CODE) 
  ShutdownAllCores
(
  VAR(StatusType, AUTOMATIC)  Error
)
{
8000a8d6:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000a8d8:	40 94       	mov.aa %a4,%a9
#if (!defined(OSEE_HAS_ORTI))
  CONSTP2CONST(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#else
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
#endif /* !OSEE_HAS_ORTI */
    p_ccb = p_cdb->p_ccb;
8000a8da:	cc 43       	ld.a %a15,[%a4]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a8dc:	4d c0 e2 5f 	mfcr %d5,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000a8e0:	8f f5 0f f1 	and %d15,%d5,255
8000a8e4:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000a8e8:	ee 0a       	jnz %d15,8000a8fc <ShutdownAllCores+0x26>
    OsEE_icr icr_temp = icr;
8000a8ea:	02 5f       	mov %d15,%d5
8000a8ec:	3b 30 01 60 	mov %d6,19
8000a8f0:	37 6f 08 f0 	insert %d15,%d15,%d6,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a8f4:	cd cf e2 0f 	mtcr $icr,%d15
8000a8f8:	0d 00 c0 04 	isync 
 
  CONST(OsEE_reg, AUTOMATIC)  flags = osEE_begin_primitive();
  CONST(OsEE_kernel_status, AUTOMATIC) os_status = p_ccb->os_status;
8000a8fc:	39 ff 10 00 	ld.bu %d15,[%a15]16
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a900:	3b d0 04 60 	mov %d6,77
8000a904:	e9 f6 13 00 	st.b [%a15]19,%d6
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a908:	82 16       	mov %d6,1
8000a90a:	e9 f6 23 00 	st.b [%a15]35,%d6
#endif /* OSEE_HAS_SERVICE_PROTECTION */
#ifdef OSEE_HAS_OSAPPLICATIONS
  /* [Os_SWS_00716]: If ShutdownAllCores is called from non trusted code the call
      shall be ignored. (SRS_Os_80007) */
#endif /* EE_HAS_OSAPPLICATIONS__ */
  if ((os_status == OSEE_KERNEL_STARTED) || (os_status == OSEE_KERNEL_STARTING))
8000a90e:	c2 ff       	add %d15,-1
8000a910:	16 ff       	and %d15,255
8000a912:	ff 2f 4c 80 	jge.u %d15,2,8000a9aa <ShutdownAllCores+0xd4>
 *  \brief Locks the kernel.
 *  
 *  Locks the kernel using the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_lock_kernel(void) {
  osEE_hal_spin_lock(osEE_kdb_var.p_lock);
8000a916:	91 00 00 f8 	movh.a %a15,32768
8000a91a:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
8000a91e:	c8 1f       	ld.a %a15,[%a15]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000a920:	82 12       	mov %d2,1
8000a922:	82 03       	mov %d3,0
8000a924:	0b 23 10 68 	mov %e6,%d3,%d2
8000a928:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000a92c:	df 06 fa ff 	jne %d6,0,8000a920 <ShutdownAllCores+0x4a>
  {
    VAR(CoreNumType, AUTOMATIC) i;
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
      p_kdb = osEE_lock_and_get_kernel();
    CONSTP2VAR(OsEE_KCB, AUTOMATIC, OS_APPL_DATA)
      p_kcb = p_kdb->p_kcb;
8000a930:	91 00 00 28 	movh.a %a2,32768
8000a934:	99 22 28 50 	ld.a %a2,[%a2]360 <80000168 <osEE_kdb_var>>
    /* If the procedure have been already started (by another core), just shut
       this core down, after have released all spinlocks */
    if (p_kcb->ar_shutdown_all_cores_flag) {
8000a938:	0c 2e       	ld.bu %d15,[%a2]14
8000a93a:	6e 09       	jz %d15,8000a94c <ShutdownAllCores+0x76>
8000a93c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000a940:	82 0f       	mov %d15,0
8000a942:	68 0f       	st.w [%a15]0,%d15
      /* Release the kernel spinlock */
      osEE_unlock_kernel();
      /* This won't never return */
      osEE_shutdown_os(p_cdb, p_kcb->ar_shutdown_all_cores_error);
8000a944:	39 24 0d 00 	ld.bu %d4,[%a2]13
8000a948:	1d ff da f6 	j 800096fc <osEE_shutdown_os>
    } else {
      /* Save the Error parameter to be used in all other cores */
      p_kcb->ar_shutdown_all_cores_error = Error;
8000a94c:	e9 24 0d 00 	st.b [%a2]13,%d4
      /* Set ShutdownAllCores global flag */
      p_kcb->ar_shutdown_all_cores_flag = OSEE_TRUE;
8000a950:	82 1f       	mov %d15,1
8000a952:	2c 2e       	st.b [%a2]14,%d15
8000a954:	7b 40 00 5f 	movh %d5,61444
8000a958:	1b 05 00 59 	addi %d5,%d5,-28672
8000a95c:	82 0f       	mov %d15,0
/* Signal the core "cpu" (0/1/2/3/4/6) by sending an IIRQ. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_signal_core(CoreIdType core_id)
{

  OSEE_TC_SRC_REG(OSEE_TC_GPSR_SRC_OFFSET(OSEE_TC_GPSR_G, core_id)) |=
8000a95e:	02 56       	mov %d6,%d5
8000a960:	8f ff 0f 21 	and %d2,%d15,255
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000a964:	4d c0 e1 3f 	mfcr %d3,$core_id

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
        if (i != (CoreNumType)osEE_get_curr_core_id()) {
8000a968:	8f f3 0f 31 	and %d3,%d3,255
8000a96c:	5f 23 0f 00 	jeq %d3,%d2,8000a98a <ShutdownAllCores+0xb4>
          if ((p_kcb->ar_core_mask & ((CoreMaskType)1U << i)) != 0U) {
8000a970:	54 23       	ld.w %d3,[%a2]
8000a972:	57 03 61 3f 	extr.u %d3,%d3,%d15,1
8000a976:	76 3a       	jz %d3,8000a98a <ShutdownAllCores+0xb4>
8000a978:	8b 42 60 22 	lt.u %d2,%d2,4
8000a97c:	2b 65 40 22 	sel %d2,%d2,%d5,%d6
8000a980:	60 2f       	mov.a %a15,%d2
8000a982:	48 02       	ld.w %d2,[%a15]0
8000a984:	b7 f2 01 2d 	insert %d2,%d2,15,26,1
8000a988:	68 02       	st.w [%a15]0,%d2
8000a98a:	c2 1f       	add %d15,1
8000a98c:	c2 45       	add %d5,4
      /* Save the Error parameter to be used in all other cores */
      p_kcb->ar_shutdown_all_cores_error = Error;
      /* Set ShutdownAllCores global flag */
      p_kcb->ar_shutdown_all_cores_flag = OSEE_TRUE;

      for (i = 0U; i <= OSEE_CORE_ID_MAX; ++i) {
8000a98e:	df 3f e9 ff 	jne %d15,3,8000a960 <ShutdownAllCores+0x8a>
 *  \brief Unlocks the kernel.
 *  
 *  Unlock the kernel by releasing the KDB p_lock spinlock.
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_unlock_kernel(void) {
  osEE_hal_spin_unlock(osEE_kdb_var.p_lock);
8000a992:	91 00 00 f8 	movh.a %a15,32768
8000a996:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
8000a99a:	c8 1f       	ld.a %a15,[%a15]4
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000a99c:	0d 00 80 04 	dsync 
8000a9a0:	82 0f       	mov %d15,0
8000a9a2:	68 0f       	st.w [%a15]0,%d15

      /* Release the kernel spinlock */
      osEE_unlock_kernel();
      /* After signaling the shutdown all cores status: shut this core down:
         This won't never return */
      osEE_shutdown_os(osEE_get_curr_core(), Error);
8000a9a4:	40 94       	mov.aa %a4,%a9
8000a9a6:	1d ff ab f6 	j 800096fc <osEE_shutdown_os>
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
    p_ccb->service_id            = service_id;
8000a9aa:	da 4c       	mov %d15,76
8000a9ac:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000a9b0:	82 0f       	mov %d15,0
8000a9b2:	e9 ff 23 00 	st.b [%a15]35,%d15
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000a9b6:	4d c0 e2 2f 	mfcr %d2,$icr
8000a9ba:	02 2f       	mov %d15,%d2
8000a9bc:	8f f2 0f 21 	and %d2,%d2,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000a9c0:	8f f5 0f 51 	and %d5,%d5,255
8000a9c4:	5f 52 08 00 	jeq %d2,%d5,8000a9d4 <ShutdownAllCores+0xfe>
8000a9c8:	37 5f 08 f0 	insert %d15,%d15,%d5,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000a9cc:	cd cf e2 0f 	mtcr $icr,%d15
8000a9d0:	0d 00 c0 04 	isync 
8000a9d4:	00 90       	ret 

8000a9d6 <GetSpinlock>:
FUNC(StatusType, OS_CODE)
  GetSpinlock
(
  VAR(SpinlockIdType, AUTOMATIC) SpinlockID
)
{
8000a9d6:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000a9d8:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
    p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000a9da:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000a9dc:	da 41       	mov %d15,65
8000a9de:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000a9e2:	82 1f       	mov %d15,1
8000a9e4:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (spinlock_id < p_kdb->p_kcb->free_spinlock_index);
#else
  return (spinlock_id < p_kdb->spinlock_array_size);
8000a9e8:	91 00 00 28 	movh.a %a2,32768
8000a9ec:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000a9f0:	4c 2a       	ld.w %d15,[%a2]40
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00689]: The function GetSpinlock shall return E_OS_ID if the parameter
      SpinlockID refers to a spinlock that does not exist. (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
    ev = E_OS_ID;
8000a9f2:	82 32       	mov %d2,3
    ev = E_OS_CALLEVEL;
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00689]: The function GetSpinlock shall return E_OS_ID if the parameter
      SpinlockID refers to a spinlock that does not exist. (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
8000a9f4:	7f f4 5f 80 	jge.u %d4,%d15,8000aab2 <GetSpinlock+0xdc>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_spinlock_db = &(*p_kdb->p_spinlock_array)[SpinlockID];
8000a9f8:	91 00 00 28 	movh.a %a2,32768
8000a9fc:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000aa00:	19 20 24 00 	ld.w %d0,[%a2]36 <80000024 <_start+0x4>>
8000aa04:	13 c4 20 30 	madd %d3,%d0,%d4,12
    CONSTP2VAR(OsEE_SpinlockCB, AUTOMATIC, OS_APPL_DATA)
      p_spinlock_cb = p_spinlock_db->p_cb;
8000aa08:	60 32       	mov.a %a2,%d3
8000aa0a:	d4 23       	ld.a %a3,[%a2]
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_curr = p_ccb->p_curr;
8000aa0c:	c8 05       	ld.a %a5,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_CONST)
      p_curr_tcb = p_curr->p_tcb;
8000aa0e:	99 54 0c 00 	ld.a %a4,[%a5]12
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_core_last_spinlock_db = p_ccb->p_last_spinlock;
8000aa12:	48 55       	ld.w %d5,[%a15]20
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_last_m = p_curr_tcb->p_last_m;
8000aa14:	19 48 04 00 	ld.w %d8,[%a4]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000aa18:	4d c0 e2 2f 	mfcr %d2,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000aa1c:	8f f2 0f f1 	and %d15,%d2,255
8000aa20:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000aa24:	ee 4e       	jnz %d15,8000aac0 <GetSpinlock+0xea>
    OsEE_icr icr_temp = icr;
8000aa26:	02 2f       	mov %d15,%d2
8000aa28:	3b 30 01 10 	mov %d1,19
8000aa2c:	37 1f 08 f0 	insert %d15,%d15,%d1,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000aa30:	cd cf e2 0f 	mtcr $icr,%d15
8000aa34:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000aa38:	02 29       	mov %d9,%d2
      (SRS_Os_80018, SRS_Os_80021) */
  /* [SWS_Os_000691]: The function GetSpinlock shall return
      E_OS_NESTING_DEADLOCK if the sequence by which multiple spinlocks are
      occupied at the same time do not comply with the configured order.
      (SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000aa3a:	99 32 08 00 	ld.a %a2,[%a3]8
8000aa3e:	bc 2b       	jz.a %a2,8000aa54 <GetSpinlock+0x7e>
{
  CoreIdType core_id;

  if (p_tdb != NULL) {
#if (!defined(OSEE_ALLOW_TASK_MIGRATION))
    core_id = p_tdb->orig_core_id;
8000aa40:	79 21 1f 00 	ld.b %d1,[%a2]31
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000aa44:	4d c0 e1 ff 	mfcr %d15,$core_id
8000aa48:	37 0f 48 f0 	extr %d15,%d15,0,8
        (osEE_task_get_curr_core_id(p_spinlock_cb->p_owner) ==
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
8000aa4c:	3b 50 01 20 	mov %d2,21
      (SRS_Os_80018, SRS_Os_80021) */
  /* [SWS_Os_000691]: The function GetSpinlock shall return
      E_OS_NESTING_DEADLOCK if the sequence by which multiple spinlocks are
      occupied at the same time do not comply with the configured order.
      (SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000aa50:	5f f1 1f 00 	jeq %d1,%d15,8000aa8e <GetSpinlock+0xb8>
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
    } else
#if (defined(OSEE_SPINLOCKS_ORDERED))
    if ((p_core_last_spinlock_db != NULL) &&
8000aa54:	8b 05 20 f2 	ne %d15,%d5,0
8000aa58:	0b 35 50 f2 	and.ge.u %d15,%d5,%d3
    )
#else /* OSEE_SPINLOCKS_ORDERED */
    if (p_core_last_spinlock_db != NULL)
#endif /* OSEE_SPINLOCKS_ORDERED */
    {
      ev = E_OS_NESTING_DEADLOCK;
8000aa5c:	3b 60 01 20 	mov %d2,22
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
    } else
#if (defined(OSEE_SPINLOCKS_ORDERED))
    if ((p_core_last_spinlock_db != NULL) &&
8000aa60:	ee 17       	jnz %d15,8000aa8e <GetSpinlock+0xb8>
          already occupied, GetSpinlock shall keep on trying to occupy the
          spinlock until it succeeds. (SRS_Os_80018, SRS_Os_80021)
          Same of [SWS_Os_00687] */

      /* Spin until get the lock */
      osEE_hal_spin_lock(p_spinlock_db->p_spinlock_arch);
8000aa62:	13 c4 20 10 	madd %d1,%d0,%d4,12
8000aa66:	60 12       	mov.a %a2,%d1
8000aa68:	99 22 04 00 	ld.a %a2,[%a2]4
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000aa6c:	82 16       	mov %d6,1
8000aa6e:	82 07       	mov %d7,0
8000aa70:	0b 67 10 08 	mov %e0,%d7,%d6
8000aa74:	49 20 c0 08 	cmpswap.w [%a2]0,%e0
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000aa78:	df 00 fa ff 	jne %d0,0,8000aa6c <GetSpinlock+0x96>

      /* Populate M Stack for Current TASK and Spinlock Stack for CCB */
      p_spinlock_cb->p_next = (p_last_m != NULL)?
        p_last_m: p_core_last_spinlock_db;
8000aa7c:	2b 58 40 88 	sel %d8,%d8,%d8,%d5

      /* Spin until get the lock */
      osEE_hal_spin_lock(p_spinlock_db->p_spinlock_arch);

      /* Populate M Stack for Current TASK and Spinlock Stack for CCB */
      p_spinlock_cb->p_next = (p_last_m != NULL)?
8000aa80:	74 38       	st.w [%a3],%d8
        p_last_m: p_core_last_spinlock_db;

      /* Update Heads pointers: Current TASK and CCB */
      p_curr_tcb->p_last_m = p_spinlock_db;
8000aa82:	59 43 04 00 	st.w [%a4]4,%d3
      p_ccb->p_last_spinlock = p_spinlock_db;
8000aa86:	68 53       	st.w [%a15]20,%d3

      /* Set Current TASK/ISR2 as spinlock locker */
      p_spinlock_cb->p_owner = p_curr;
8000aa88:	b5 35 08 00 	st.a [%a3]8,%a5
#endif /* OSEE_SPINLOCKS_HAS_LOCK_METHOD */

    /* [SWS_Os_00688]: The function GetSpinlock shall return E_OK if no error
        was detected. The spinlock is now occupied by the calling TASK/ISR2 on
        the calling core. */
      ev = E_OK;
8000aa8c:	82 02       	mov %d2,0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000aa8e:	4d c0 e2 4f 	mfcr %d4,$icr
8000aa92:	02 4f       	mov %d15,%d4
8000aa94:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000aa98:	8f f9 0f 31 	and %d3,%d9,255
8000aa9c:	5f 34 08 00 	jeq %d4,%d3,8000aaac <GetSpinlock+0xd6>
8000aaa0:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000aaa4:	cd cf e2 0f 	mtcr $icr,%d15
8000aaa8:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000aaac:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000aab0:	5e 1e       	jne %d15,1,8000aacc <GetSpinlock+0xf6>
    p_ccb->service_id            = service_id;
8000aab2:	da 40       	mov %d15,64
8000aab4:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000aab8:	82 0f       	mov %d15,0
8000aaba:	e9 ff 23 00 	st.b [%a15]35,%d15
8000aabe:	00 90       	ret 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000aac0:	02 29       	mov %d9,%d2
      (SRS_Os_80018, SRS_Os_80021) */
  /* [SWS_Os_000691]: The function GetSpinlock shall return
      E_OS_NESTING_DEADLOCK if the sequence by which multiple spinlocks are
      occupied at the same time do not comply with the configured order.
      (SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000aac2:	99 32 08 00 	ld.a %a2,[%a3]8
8000aac6:	bd 02 bd ff 	jnz.a %a2,8000aa40 <GetSpinlock+0x6a>
8000aaca:	3c c5       	j 8000aa54 <GetSpinlock+0x7e>
  }
#endif /* OSEE_HAS_ERRORHOOK */
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_GetSpinlock);

  return ev;
}
8000aacc:	00 90       	ret 

8000aace <ReleaseSpinlock>:
FUNC(StatusType, OS_CODE)
  ReleaseSpinlock
(
  VAR(SpinlockIdType, AUTOMATIC) SpinlockID
)
{
8000aace:	40 ae       	mov.aa %a14,%sp
8000aad0:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
    p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000aad2:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000aad4:	da 43       	mov %d15,67
8000aad6:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000aada:	82 1f       	mov %d15,1
8000aadc:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (spinlock_id < p_kdb->p_kcb->free_spinlock_index);
#else
  return (spinlock_id < p_kdb->spinlock_array_size);
8000aae0:	91 00 00 28 	movh.a %a2,32768
8000aae4:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000aae8:	4c 2a       	ld.w %d15,[%a2]40
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00698] The function ReleaseSpinlock shall return E_OS_ID if the
    parameter SpinlockID refers to a spinlock that does not exist.
    (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
    ev = E_OS_ID;
8000aaea:	82 32       	mov %d2,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00698] The function ReleaseSpinlock shall return E_OS_ID if the
    parameter SpinlockID refers to a spinlock that does not exist.
    (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
8000aaec:	7f f4 4a 80 	jge.u %d4,%d15,8000ab80 <ReleaseSpinlock+0xb2>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_spinlock_db = &(*p_kdb->p_spinlock_array)[SpinlockID];
8000aaf0:	91 00 00 28 	movh.a %a2,32768
8000aaf4:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000aaf8:	19 23 24 00 	ld.w %d3,[%a2]36 <80000024 <_start+0x4>>
    CONSTP2VAR(OsEE_SpinlockCB, AUTOMATIC, OS_APPL_DATA)
      p_spinlock_cb = p_spinlock_db->p_cb;
8000aafc:	13 c4 20 63 	madd %d6,%d3,%d4,12
8000ab00:	60 62       	mov.a %a2,%d6
8000ab02:	d4 22       	ld.a %a2,[%a2]
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_curr = p_ccb->p_curr;
8000ab04:	c8 03       	ld.a %a3,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_CONST)
      p_curr_tcb = p_curr->p_tcb;
8000ab06:	99 34 0c 00 	ld.a %a4,[%a3]12
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ab0a:	4d c0 e2 5f 	mfcr %d5,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000ab0e:	8f f5 0f f1 	and %d15,%d5,255
8000ab12:	8b 3f a1 f2 	ge.u %d15,%d15,19
8000ab16:	ee 0a       	jnz %d15,8000ab2a <ReleaseSpinlock+0x5c>
    OsEE_icr icr_temp = icr;
8000ab18:	02 5f       	mov %d15,%d5
8000ab1a:	3b 30 01 20 	mov %d2,19
8000ab1e:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ab22:	cd cf e2 0f 	mtcr $icr,%d15
8000ab26:	0d 00 c0 04 	isync 
      calling TASK. (SRS_Os_80021) */
/*  [SWS_Os_00701] The function ReleaseSpinlock shall return E_OS_NOFUNC if the
      TASK tries to release a spinlock while another spinlock (or resource)
      has to be released before. No functionality shall be performed.
      (SRS_Os_80021) */
    if (p_spinlock_cb->p_owner != p_curr) {
8000ab2a:	4c 22       	ld.w %d15,[%a2]8
      ev = E_OS_STATE;
8000ab2c:	82 72       	mov %d2,7
      calling TASK. (SRS_Os_80021) */
/*  [SWS_Os_00701] The function ReleaseSpinlock shall return E_OS_NOFUNC if the
      TASK tries to release a spinlock while another spinlock (or resource)
      has to be released before. No functionality shall be performed.
      (SRS_Os_80021) */
    if (p_spinlock_cb->p_owner != p_curr) {
8000ab2e:	80 36       	mov.d %d6,%a3
8000ab30:	fe 66       	jne %d15,%d6,8000ab5c <ReleaseSpinlock+0x8e>
    (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_spinlock_db = &(*p_kdb->p_spinlock_array)[SpinlockID];
8000ab32:	13 c4 20 f3 	madd %d15,%d3,%d4,12
      has to be released before. No functionality shall be performed.
      (SRS_Os_80021) */
    if (p_spinlock_cb->p_owner != p_curr) {
      ev = E_OS_STATE;
    } else
    if (p_spinlock_db != osEE_task_get_last_spinlock_db(p_curr_tcb)) {
8000ab36:	19 46 04 00 	ld.w %d6,[%a4]4
      ev = E_OS_NOFUNC;
8000ab3a:	82 52       	mov %d2,5
      has to be released before. No functionality shall be performed.
      (SRS_Os_80021) */
    if (p_spinlock_cb->p_owner != p_curr) {
      ev = E_OS_STATE;
    } else
    if (p_spinlock_db != osEE_task_get_last_spinlock_db(p_curr_tcb)) {
8000ab3c:	5f f6 10 80 	jne %d6,%d15,8000ab5c <ReleaseSpinlock+0x8e>
/*  [SWS_Os_00697] The function ReleaseSpinlock shall return E_OK if no error
     was detected. The spinlock is now free and can be occupied by the same or
     other TASKs. (SRS_Os_80021) */

      /* Release the spinlock from its owner */
      p_spinlock_cb->p_owner = NULL;
8000ab40:	82 02       	mov %d2,0
8000ab42:	59 22 08 00 	st.w [%a2]8,%d2

      /* Pop M Stack for Current TASK */
      p_curr_tcb->p_last_m = p_spinlock_cb->p_next;
8000ab46:	4c 20       	ld.w %d15,[%a2]0
8000ab48:	6c 41       	st.w [%a4]4,%d15

      /* Look for the new last spinlock */
      p_ccb->p_last_spinlock = osEE_task_get_last_spinlock_db(p_curr_tcb);
8000ab4a:	68 5f       	st.w [%a15]20,%d15

      /* Release the spinlock */
      osEE_hal_spin_unlock(p_spinlock_db->p_spinlock_arch);
8000ab4c:	13 c4 20 f3 	madd %d15,%d3,%d4,12
8000ab50:	60 f2       	mov.a %a2,%d15
8000ab52:	99 22 04 00 	ld.a %a2,[%a2]4
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000ab56:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000ab5a:	74 22       	st.w [%a2],%d2
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ab5c:	4d c0 e2 4f 	mfcr %d4,$icr
8000ab60:	02 4f       	mov %d15,%d4
8000ab62:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000ab66:	8f f5 0f 31 	and %d3,%d5,255
8000ab6a:	5f 34 08 00 	jeq %d4,%d3,8000ab7a <ReleaseSpinlock+0xac>
8000ab6e:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ab72:	cd cf e2 0f 	mtcr $icr,%d15
8000ab76:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000ab7a:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000ab7e:	5e 17       	jne %d15,1,8000ab8c <ReleaseSpinlock+0xbe>
    p_ccb->service_id            = service_id;
8000ab80:	da 42       	mov %d15,66
8000ab82:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000ab86:	82 0f       	mov %d15,0
8000ab88:	e9 ff 23 00 	st.b [%a15]35,%d15
  }
#endif /* OSEE_HAS_ERRORHOOK */
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_ReleaseSpinlock);

  return ev;
}
8000ab8c:	00 90       	ret 

8000ab8e <TryToGetSpinlock>:
  TryToGetSpinlock
(
  VAR(SpinlockIdType, AUTOMATIC)                        SpinlockID,
  P2VAR(TryToGetSpinlockType, AUTOMATIC, OS_APPL_DATA)  Success
)
{
8000ab8e:	40 ae       	mov.aa %a14,%sp
8000ab90:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_CONST)
    p_kdb = osEE_get_kernel();
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000ab92:	c8 3f       	ld.a %a15,[%a15]12
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  p_ccb->service_id = (service_id + 1U);
8000ab94:	da 45       	mov %d15,69
8000ab96:	e9 ff 13 00 	st.b [%a15]19,%d15
  p_ccb->orti_service_id_valid = OSEE_TRUE;
8000ab9a:	82 1f       	mov %d15,1
8000ab9c:	e9 ff 23 00 	st.b [%a15]35,%d15
)
{
#if (defined(OSEE_API_DYNAMIC))
  return (spinlock_id < p_kdb->p_kcb->free_spinlock_index);
#else
  return (spinlock_id < p_kdb->spinlock_array_size);
8000aba0:	91 00 00 28 	movh.a %a2,32768
8000aba4:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000aba8:	4c 2a       	ld.w %d15,[%a2]40
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00707] The function TryToGetSpinlock shall return E_OS_ID if the
    parameter SpinlockID refers to a spinlock that does not exist.
   (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
    ev = E_OS_ID;
8000abaa:	82 32       	mov %d2,3
  } else
#endif /* OSEE_HAS_SERVICE_PROTECTION */
/* [SWS_Os_00707] The function TryToGetSpinlock shall return E_OS_ID if the
    parameter SpinlockID refers to a spinlock that does not exist.
   (SRS_Os_80021) */
  if (!osEE_is_valid_spinlock_id(p_kdb, SpinlockID)) {
8000abac:	7f f4 66 80 	jge.u %d4,%d15,8000ac78 <TryToGetSpinlock+0xea>
    ev = E_OS_ID;
  } else {
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_spinlock_db = &(*p_kdb->p_spinlock_array)[SpinlockID];
8000abb0:	91 00 00 28 	movh.a %a2,32768
8000abb4:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000abb8:	19 26 24 00 	ld.w %d6,[%a2]36 <80000024 <_start+0x4>>
8000abbc:	13 c4 20 f6 	madd %d15,%d6,%d4,12
    CONSTP2VAR(OsEE_SpinlockCB, AUTOMATIC, OS_APPL_DATA)
      p_spinlock_cb = p_spinlock_db->p_cb;
8000abc0:	60 f2       	mov.a %a2,%d15
8000abc2:	d4 23       	ld.a %a3,[%a2]
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)
      p_curr = p_ccb->p_curr;
8000abc4:	c8 06       	ld.a %a6,[%a15]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_CONST)
      p_curr_tcb = p_curr->p_tcb;
8000abc6:	99 65 0c 00 	ld.a %a5,[%a6]12
    CONSTP2VAR(OsEE_SpinlockDB, AUTOMATIC, OS_APPL_CONST)
      p_core_last_spinlock_db = p_ccb->p_last_spinlock;
8000abca:	48 53       	ld.w %d3,[%a15]20
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_last_m = p_curr_tcb->p_last_m;
8000abcc:	19 51 04 00 	ld.w %d1,[%a5]4
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000abd0:	4d c0 e2 5f 	mfcr %d5,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000abd4:	8f f5 0f 21 	and %d2,%d5,255
8000abd8:	8b 32 a1 22 	ge.u %d2,%d2,19
8000abdc:	df 02 55 80 	jne %d2,0,8000ac86 <TryToGetSpinlock+0xf8>
    OsEE_icr icr_temp = icr;
8000abe0:	02 52       	mov %d2,%d5
8000abe2:	3b 30 01 70 	mov %d7,19
8000abe6:	37 72 08 20 	insert %d2,%d2,%d7,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000abea:	cd c2 e2 0f 	mtcr $icr,%d2
8000abee:	0d 00 c0 04 	isync 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000abf2:	02 58       	mov %d8,%d5
      TASK/ISR2 that currently holds a spinlock tries to seize another spinlock
      that has not been configured as a direct or indirect successor of the
      latest acquired spinlock (by means of the OsSpinlockSuccessor
      configuration parameter) or if no successor is configured.
      (SRS_Os_80018, SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000abf4:	99 32 08 00 	ld.a %a2,[%a3]8
8000abf8:	bc 2b       	jz.a %a2,8000ac0e <TryToGetSpinlock+0x80>
{
  CoreIdType core_id;

  if (p_tdb != NULL) {
#if (!defined(OSEE_ALLOW_TASK_MIGRATION))
    core_id = p_tdb->orig_core_id;
8000abfa:	79 20 1f 00 	ld.b %d0,[%a2]31
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000abfe:	4d c0 e1 7f 	mfcr %d7,$core_id
8000ac02:	37 07 48 70 	extr %d7,%d7,0,8
        (osEE_task_get_curr_core_id(p_spinlock_cb->p_owner) ==
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
8000ac06:	3b 50 01 20 	mov %d2,21
      TASK/ISR2 that currently holds a spinlock tries to seize another spinlock
      that has not been configured as a direct or indirect successor of the
      latest acquired spinlock (by means of the OsSpinlockSuccessor
      configuration parameter) or if no successor is configured.
      (SRS_Os_80018, SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000ac0a:	5f 70 25 00 	jeq %d0,%d7,8000ac54 <TryToGetSpinlock+0xc6>
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
    } else
#if (defined(OSEE_SPINLOCKS_ORDERED))
    if ((p_core_last_spinlock_db != NULL) &&
8000ac0e:	8b 03 20 72 	ne %d7,%d3,0
8000ac12:	0b f3 50 72 	and.ge.u %d7,%d3,%d15
    )
#else /* OSEE_SPINLOCKS_ORDERED */
    if (p_core_last_spinlock_db != NULL)
#endif /* OSEE_SPINLOCKS_ORDERED */
    {
      ev = E_OS_NESTING_DEADLOCK;
8000ac16:	3b 60 01 20 	mov %d2,22
          osEE_get_curr_core_id()))
    {
      ev = E_OS_INTERFERENCE_DEADLOCK;
    } else
#if (defined(OSEE_SPINLOCKS_ORDERED))
    if ((p_core_last_spinlock_db != NULL) &&
8000ac1a:	df 07 1d 80 	jne %d7,0,8000ac54 <TryToGetSpinlock+0xc6>
      if such argument is NULL. +
      MISRA dictate NULL check for pointers always. */
  /* [SWS_Os_706]: If the function TryToGetSpinlock does not return E_OK, the
      OUT parameter "Success" shall be undefined. (SRS_Os_80021) */
    if (Success == NULL) {
      ev = E_OS_PARAM_POINTER;
8000ac1e:	3b e0 00 20 	mov %d2,14
      pointer argument for NULL pointer and return OS_E_PARAMETER_POINTER 
      if such argument is NULL. +
      MISRA dictate NULL check for pointers always. */
  /* [SWS_Os_706]: If the function TryToGetSpinlock does not return E_OK, the
      OUT parameter "Success" shall be undefined. (SRS_Os_80021) */
    if (Success == NULL) {
8000ac22:	bd 04 19 00 	jz.a %a4,8000ac54 <TryToGetSpinlock+0xc6>
      while a RESOURCE is occupied. (SRS_Os_80021) */
/* [SWS_Os_00704] The function TryToGetSpinlock shall atomically test the
    availability of the spinlock and if available occupy it. The result of
    success is returned. (SRS_Os_80021) */
      /* Try to get the lock */
      if (osEE_hal_try_spin_lock(p_spinlock_db->p_spinlock_arch)) {
8000ac26:	13 c4 20 26 	madd %d2,%d6,%d4,12
8000ac2a:	60 22       	mov.a %a2,%d2
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000ac2c:	99 22 04 00 	ld.a %a2,[%a2]4
8000ac30:	d2 14       	mov %e4,1
8000ac32:	49 24 c0 08 	cmpswap.w [%a2]0,%e4
8000ac36:	f6 4c       	jnz %d4,8000ac4e <TryToGetSpinlock+0xc0>
        /* Populate M Stack for Current TASK and Spinlock Stack for CCB */
        p_spinlock_cb->p_next = (p_last_m != NULL)?
          p_last_m: p_core_last_spinlock_db;
8000ac38:	2b 31 40 11 	sel %d1,%d1,%d1,%d3
    availability of the spinlock and if available occupy it. The result of
    success is returned. (SRS_Os_80021) */
      /* Try to get the lock */
      if (osEE_hal_try_spin_lock(p_spinlock_db->p_spinlock_arch)) {
        /* Populate M Stack for Current TASK and Spinlock Stack for CCB */
        p_spinlock_cb->p_next = (p_last_m != NULL)?
8000ac3c:	74 31       	st.w [%a3],%d1
          p_last_m: p_core_last_spinlock_db;

        /* Update Heads pointers: Current TASK and CCB */
        p_curr_tcb->p_last_m = p_spinlock_db;
8000ac3e:	6c 51       	st.w [%a5]4,%d15
        p_ccb->p_last_spinlock = p_spinlock_db;
8000ac40:	68 5f       	st.w [%a15]20,%d15

        /* Set Current TASK/ISR2 as spinlock locker */
        p_spinlock_cb->p_owner = p_curr;
8000ac42:	b5 36 08 00 	st.a [%a3]8,%a6

      /* [SWS_Os_00705] The function TryToGetSpinlock shall set the OUT
           parameter "Success" to TRYTOGETSPINLOCK_SUCCESS if the spinlock was
           successfully occupied, and TRYTOGETSPINLOCK_NOSUCCESS if not.
           In both cases E_OK shall be returned. (SRS_Os_80021) */
        *Success = TRYTOGETSPINLOCK_SUCCESS;
8000ac46:	82 1f       	mov %d15,1
8000ac48:	2c 40       	st.b [%a4]0,%d15
      } else {
        *Success = TRYTOGETSPINLOCK_NOSUCCESS;
      }

      ev = E_OK;
8000ac4a:	82 02       	mov %d2,0
8000ac4c:	3c 04       	j 8000ac54 <TryToGetSpinlock+0xc6>
           parameter "Success" to TRYTOGETSPINLOCK_SUCCESS if the spinlock was
           successfully occupied, and TRYTOGETSPINLOCK_NOSUCCESS if not.
           In both cases E_OK shall be returned. (SRS_Os_80021) */
        *Success = TRYTOGETSPINLOCK_SUCCESS;
      } else {
        *Success = TRYTOGETSPINLOCK_NOSUCCESS;
8000ac4e:	82 0f       	mov %d15,0
8000ac50:	2c 40       	st.b [%a4]0,%d15
      }

      ev = E_OK;
8000ac52:	82 02       	mov %d2,0
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ac54:	4d c0 e2 4f 	mfcr %d4,$icr
8000ac58:	02 4f       	mov %d15,%d4
8000ac5a:	8f f4 0f 41 	and %d4,%d4,255
  osEE_hal_end_nested_primitive(OsEE_reg flags)
{
  OsEE_icr flags_icr;
  OsEE_icr icr = osEE_tc_get_icr();
  flags_icr.reg = flags;
  if (icr.bits.ccpn != flags_icr.bits.ccpn) {
8000ac5e:	8f f8 0f 31 	and %d3,%d8,255
8000ac62:	5f 34 08 00 	jeq %d4,%d3,8000ac72 <TryToGetSpinlock+0xe4>
8000ac66:	37 3f 08 f0 	insert %d15,%d15,%d3,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ac6a:	cd cf e2 0f 	mtcr $icr,%d15
8000ac6e:	0d 00 c0 04 	isync 
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  CONST(OSServiceIdType, AUTOMATIC) service_id
)
{
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000ac72:	39 ff 23 00 	ld.bu %d15,[%a15]35
8000ac76:	5e 1e       	jne %d15,1,8000ac92 <TryToGetSpinlock+0x104>
    p_ccb->service_id            = service_id;
8000ac78:	da 44       	mov %d15,68
8000ac7a:	e9 ff 13 00 	st.b [%a15]19,%d15
    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000ac7e:	82 0f       	mov %d15,0
8000ac80:	e9 ff 23 00 	st.b [%a15]35,%d15
8000ac84:	00 90       	ret 
    /* Set new CCPN value */
    icr_temp.bits.ccpn = OSEE_ISR2_MAX_HW_PRIO;
    osEE_tc_set_icr(icr_temp);
  }

  return icr.reg;
8000ac86:	02 58       	mov %d8,%d5
      TASK/ISR2 that currently holds a spinlock tries to seize another spinlock
      that has not been configured as a direct or indirect successor of the
      latest acquired spinlock (by means of the OsSpinlockSuccessor
      configuration parameter) or if no successor is configured.
      (SRS_Os_80018, SRS_Os_80021) */
    if ((p_spinlock_cb->p_owner != NULL) &&
8000ac88:	99 32 08 00 	ld.a %a2,[%a3]8
8000ac8c:	bd 02 b7 ff 	jnz.a %a2,8000abfa <TryToGetSpinlock+0x6c>
8000ac90:	3c bf       	j 8000ac0e <TryToGetSpinlock+0x80>
#endif /* OSEE_HAS_ERRORHOOK */
  osEE_orti_trace_service_exit(p_ccb, OSServiceId_TryToGetSpinlock);

  return ev;

}
8000ac92:	00 90       	ret 

8000ac94 <osEE_release_all_m>:
static FUNC_P2VAR(OsEE_MDB, OS_APPL_CONST, OS_CODE)
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
8000ac94:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000ac96:	99 43 0c 00 	ld.a %a3,[%a4]12

  while ((p_tcb->p_last_m != NULL)
8000ac9a:	cc 31       	ld.a %a15,[%a3]4
  osEE_release_all_m
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
8000ac9c:	a0 02       	mov.a %a2,0
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000ac9e:	bd 0f 1a 00 	jz.a %a15,8000acd2 <osEE_release_all_m+0x3e>
#if (defined(OSEE_HAS_SPINLOCKS))
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
8000aca2:	c8 0f       	ld.a %a15,[%a15]0
8000aca4:	4c f2       	ld.w %d15,[%a15]8
8000aca6:	80 42       	mov.d %d2,%a4
8000aca8:	fe 25       	jne %d15,%d2,8000acd2 <osEE_release_all_m+0x3e>
  )
  {
    CONSTP2VAR(OsEE_MCB, AUTOMATIC, OS_APPL_DATA)
      p_last_m_cb = p_tcb->p_last_m->p_cb;
    /* Release the M from the owner */
    p_last_m_cb->p_owner = NULL;
8000acaa:	82 02       	mov %d2,0
8000acac:	68 22       	st.w [%a15]8,%d2
    /* Save the first M not realesed */
    if (p_mdb == NULL) {
8000acae:	7c 23       	jnz.a %a2,8000acb4 <osEE_release_all_m+0x20>
      p_mdb = p_tcb->p_last_m;
8000acb0:	99 32 04 00 	ld.a %a2,[%a3]4
    }
#if (defined(OSEE_HAS_SPINLOCKS))
    /* Release arch dependent spinlock */
    if (p_tcb->p_last_m->p_spinlock_arch != NULL) {
8000acb4:	99 34 04 00 	ld.a %a4,[%a3]4
8000acb8:	99 44 04 00 	ld.a %a4,[%a4]4
8000acbc:	bc 44       	jz.a %a4,8000acc4 <osEE_release_all_m+0x30>
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000acbe:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000acc2:	74 42       	st.w [%a4],%d2
      osEE_hal_spin_unlock(p_tcb->p_last_m->p_spinlock_arch);
    }
#endif /* OSEE_HAS_SPINLOCKS */

    /* Pop the M head */
    p_tcb->p_last_m = p_last_m_cb->p_next;
8000acc4:	c8 0f       	ld.a %a15,[%a15]0
8000acc6:	ec 31       	st.a [%a3]4,%a15
)
{
  P2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)     p_mdb = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;

  while ((p_tcb->p_last_m != NULL)
8000acc8:	bc f5       	jz.a %a15,8000acd2 <osEE_release_all_m+0x3e>
#if (defined(OSEE_HAS_SPINLOCKS))
    && (p_tcb->p_last_m->p_cb->p_owner == p_tdb)
8000acca:	c8 0f       	ld.a %a15,[%a15]0
8000accc:	48 23       	ld.w %d3,[%a15]8
8000acce:	5f f3 ef 7f 	jeq %d3,%d15,8000acac <osEE_release_all_m+0x18>
8000acd2:	40 9f       	mov.aa %a15,%a9
          I set it to NULL in any case) */
  {
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    p_cdb->p_ccb->p_last_spinlock = p_tcb->p_last_m;
8000acd4:	c8 3f       	ld.a %a15,[%a15]12
8000acd6:	4c 31       	ld.w %d15,[%a3]4
8000acd8:	68 5f       	st.w [%a15]20,%d15
    p_tcb->p_last_m = NULL;
8000acda:	82 0f       	mov %d15,0
8000acdc:	6c 31       	st.w [%a3]4,%d15
  }
#endif /* OSEE_HAS_SPINLOCKS */

  return p_mdb;
}
8000acde:	00 90       	ret 

8000ace0 <osEE_scheduler_task_wrapper_restore>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_restore
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000ace0:	40 ae       	mov.aa %a14,%sp
8000ace2:	40 9f       	mov.aa %a15,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
#endif /* OSEE_HAS_PRETASKHOOK || OSEE_SCHEDULER_GLOBAL || OSEE_HAS_CONTEXT ||
          OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */
#if (defined(OSEE_HAS_PRETASKHOOK)) || (defined(OSEE_SCHEDULER_GLOBAL)) ||\
    (defined(OSEE_HAS_CONTEXT)) || (defined(OSEE_HAS_ORTI))
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000ace4:	c8 3f       	ld.a %a15,[%a15]12
          OSEE_HAS_ORTI */
#if (defined(OSEE_HAS_STACK_MONITORING))
  osEE_stack_monitoring(p_cdb);
#endif /* OSEE_HAS_STACK_MONITORING */
#if (defined(OSEE_HAS_ORTI))
  if (p_ccb->orti_service_id_valid == OSEE_TRUE) {
8000ace6:	39 ff 23 00 	ld.bu %d15,[%a15]35 <3 <_.+0x2>>
8000acea:	5e 1a       	jne %d15,1,8000acfe <osEE_scheduler_task_wrapper_restore+0x1e>
/* Reset last bit of service_id to mark OS service exit */
    p_ccb->service_id = (OSServiceIdType)
8000acec:	39 ff 13 00 	ld.bu %d15,[%a15]19
8000acf0:	8f 1f c0 f1 	andn %d15,%d15,1
8000acf4:	e9 ff 13 00 	st.b [%a15]19,%d15
      (((OsEE_reg)p_ccb->service_id) & (~((OsEE_reg)0x1U)));

    p_ccb->orti_service_id_valid = OSEE_FALSE;
8000acf8:	82 0f       	mov %d15,0
8000acfa:	e9 ff 23 00 	st.b [%a15]35,%d15
  }

#endif /* OSEE_HAS_ORTI */

  /* Set the TASK status to RUNNING. Before calling PreTaskHook */
  p_tdb_to->p_tcb->status = OSEE_TASK_RUNNING;
8000acfe:	cc 43       	ld.a %a15,[%a4]12
8000ad00:	82 4f       	mov %d15,4
8000ad02:	28 2f       	st.b [%a15]2,%d15
8000ad04:	00 90       	ret 

8000ad06 <osEE_scheduler_task_wrapper_run>:
FUNC(void, OS_CODE)
  osEE_scheduler_task_wrapper_run
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_to
)
{
8000ad06:	40 ae       	mov.aa %a14,%sp
8000ad08:	40 4f       	mov.aa %a15,%a4
  CONST(TaskPrio, AUTOMATIC) task_priority = p_tdb_to->p_tcb->current_prio;
8000ad0a:	99 42 0c 00 	ld.a %a2,[%a4]12
8000ad0e:	39 28 01 00 	ld.bu %d8,[%a2]1
  osEE_scheduler_task_wrapper_restore(p_tdb_to);
8000ad12:	6d ff e7 ff 	call 8000ace0 <osEE_scheduler_task_wrapper_restore>

  if (task_priority < OSEE_ISR_ALL_PRIO) {
8000ad16:	8b f8 0f f2 	eq %d15,%d8,255
8000ad1a:	ee 13       	jnz %d15,8000ad40 <osEE_scheduler_task_wrapper_run+0x3a>
8000ad1c:	4d c0 e2 ff 	mfcr %d15,$icr

/* We always use virtual priorities */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_set_ipl(TaskPrio virt_prio)
{
  OsEE_icr icr  = osEE_tc_get_icr();
  icr.bits.ccpn = (virt_prio < OSEE_ISR2_PRIO_BIT)?
8000ad20:	37 08 48 30 	extr %d3,%d8,0,8
8000ad24:	82 02       	mov %d2,0
8000ad26:	ce 35       	jgez %d3,8000ad30 <osEE_scheduler_task_wrapper_run+0x2a>
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000ad28:	8f f8 07 81 	and %d8,%d8,127
8000ad2c:	1b 18 00 20 	addi %d2,%d8,1
8000ad30:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ad34:	cd cf e2 0f 	mtcr $icr,%d15
8000ad38:	0d 00 c0 04 	isync 
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000ad3c:	0d 00 00 03 	enable 
    /* Set-up IPL at current TASK level in addition to enable IRQ */
    osEE_hal_set_ipl(task_priority);
    osEE_hal_enableIRQ();
  }
  p_tdb_to->task_func();
8000ad40:	c8 62       	ld.a %a2,[%a15]24
8000ad42:	2d 02 00 00 	calli %a2
8000ad46:	40 92       	mov.aa %a2,%a9
)
{
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
    p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000ad48:	99 22 0c 00 	ld.a %a2,[%a2]12 <8000000c <BootModeHeader0+0xc>>

  /* Reset ISR Counters */
/* [SWS_Os_00239] If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and interrupts are still disabled,
    the Operating System module shall enable them. */
  p_ccb->s_isr_os_cnt  = 0U;
8000ad4c:	82 0f       	mov %d15,0
8000ad4e:	e9 2f 21 00 	st.b [%a2]33,%d15
  /* I won't re-enable OS Interrupts since I'm going to enter rescheduling
     critical section */
  if (p_ccb->s_isr_all_cnt > 0U) {
8000ad52:	39 2f 20 00 	ld.bu %d15,[%a2]32
8000ad56:	6e 09       	jz %d15,8000ad68 <osEE_scheduler_task_wrapper_run+0x62>
    p_ccb->s_isr_all_cnt = 0U;
8000ad58:	82 0f       	mov %d15,0
8000ad5a:	e9 2f 20 00 	st.b [%a2]32,%d15
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ad5e:	4c 26       	ld.w %d15,[%a2]24
8000ad60:	cd cf e2 0f 	mtcr $icr,%d15
8000ad64:	0d 00 c0 04 	isync 
    osEE_hal_resumeIRQ(p_ccb->prev_s_isr_all_status);
  }
  if (p_ccb->d_isr_all_cnt > 0U) {
8000ad68:	39 2f 22 00 	ld.bu %d15,[%a2]34
8000ad6c:	6e 06       	jz %d15,8000ad78 <osEE_scheduler_task_wrapper_run+0x72>
    p_ccb->d_isr_all_cnt = 0U;
8000ad6e:	82 0f       	mov %d15,0
8000ad70:	e9 2f 22 00 	st.b [%a2]34,%d15
}

/* Enable Interrupts */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_hal_enableIRQ(void)
{
  __asm__ volatile ("enable" : : : "memory");
8000ad74:	0d 00 00 03 	enable 
 ============================================================================*/
/* Functions to Access ICR register */
OSEE_STATIC_INLINE OsEE_icr OSEE_ALWAYS_INLINE osEE_tc_get_icr(void)
{
  OsEE_icr icr;
  icr.reg = osEE_tc_get_csfr(OSEE_CSFR_ICR);
8000ad78:	4d c0 e2 ff 	mfcr %d15,$icr
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE
  osEE_hal_begin_nested_primitive(void)
{
  OsEE_icr icr = osEE_tc_get_icr();

  if (icr.bits.ccpn < OSEE_ISR2_MAX_HW_PRIO) {
8000ad7c:	8f ff 0f 21 	and %d2,%d15,255
8000ad80:	8b 32 a1 22 	ge.u %d2,%d2,19
8000ad84:	f6 29       	jnz %d2,8000ad96 <osEE_scheduler_task_wrapper_run+0x90>
8000ad86:	3b 30 01 20 	mov %d2,19
8000ad8a:	37 2f 08 f0 	insert %d15,%d15,%d2,0,8
  return icr;
}

OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_icr(OsEE_icr icr)
{
  osEE_tc_set_csfr(OSEE_CSFR_ICR, icr.reg);
8000ad8e:	cd cf e2 0f 	mtcr $icr,%d15
8000ad92:	0d 00 c0 04 	isync 

  (void)osEE_begin_primitive();

  osEE_stack_monitoring(p_cdb);

  if (p_to_term->task_type == OSEE_TASK_TYPE_ISR2) {
8000ad96:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000ad9a:	5e 25       	jne %d15,2,8000ada4 <osEE_scheduler_task_wrapper_run+0x9e>
  /* [SWS_Os_00369]: If a Category 2 ISR calls GetResource() and ends (returns)
      without calling the corresponding ReleaseResource(), the Operating System
      module shall perform the ReleaseResource() call and shall call the
      ErrorHook() E_OS_RESOURCE */
    CONSTP2VAR(OsEE_MDB, AUTOMATIC, OS_APPL_CONST)
      p_mdb = osEE_release_all_m(p_to_term);
8000ad9c:	40 f4       	mov.aa %a4,%a15
8000ad9e:	6d ff 7b ff 	call 8000ac94 <osEE_release_all_m>
8000ada2:	3c 04       	j 8000adaa <osEE_scheduler_task_wrapper_run+0xa4>
    osEE_call_error_hook(p_ccb, E_OS_MISSINGEND);
#if (defined(OSEE_HAS_RESOURCES)) || (defined(OSEE_HAS_SPINLOCKS))
/* [SWS_Os_0070]: If a task returns from the entry function without making a
    TerminateTask() or ChainTask() call and still holds OSEK Resources,
    the Operating System shall release them. */
    (void)osEE_release_all_m(p_to_term);
8000ada4:	40 f4       	mov.aa %a4,%a15
8000ada6:	6d ff 77 ff 	call 8000ac94 <osEE_release_all_m>
8000adaa:	c8 14       	ld.a %a4,[%a15]4
8000adac:	a0 05       	mov.a %a5,0
8000adae:	1d 00 26 06 	j 8000b9fa <osEE_hal_terminate_ctx>

8000adb2 <osEE_idle_hook_wrapper>:
FUNC(void, OS_CODE)
  osEE_idle_hook_wrapper
(
  void
)
{
8000adb2:	40 ae       	mov.aa %a14,%sp
8000adb4:	40 92       	mov.aa %a2,%a9
  /* Schedule Here: Autostart TASKs */
  CONST(OsEE_reg, AUTOMATIC) flags = osEE_begin_primitive();
  (void)osEE_scheduler_task_preemption_point(osEE_get_kernel());
  osEE_end_primitive(flags);
#endif /* !OSEE_STARTOS_RETURN && !OSEE_API_DYNAMIC && !OSEE_HAS_AUTOSTART_TASK */
  while (p_cdb->p_ccb->os_status == OSEE_KERNEL_STARTED) {
8000adb6:	cc 23       	ld.a %a15,[%a2]12
8000adb8:	39 ff 10 00 	ld.bu %d15,[%a15]16 <80000003 <BootModeHeader0+0x3>>
8000adbc:	df 2f fe 7f 	jeq %d15,2,8000adb8 <osEE_idle_hook_wrapper+0x6>
    }
#else
    ; /* Empty Endless Loop */
#endif /* OSEE_HAS_IDLEHOOK || OSEE_API_DYNAMIC */
  }
  osEE_idle_task_terminate(p_cdb->p_idle_task);
8000adc0:	99 24 14 00 	ld.a %a4,[%a2]20
8000adc4:	6d 00 a9 04 	call 8000b716 <osEE_idle_task_terminate>
8000adc8:	00 90       	ret 

8000adca <osEE_scheduler_core_rq_preempt_stk>:
  osEE_scheduler_core_rq_preempt_stk
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000adca:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000adcc:	99 43 0c 00 	ld.a %a3,[%a4]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn  = (*p_rq);
8000add0:	cc 50       	ld.a %a15,[%a5]0
  P2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)     p_ret_sn = p_ccb->p_stk_sn;
8000add2:	99 32 0c 00 	ld.a %a2,[%a3]12

  VAR(OsEE_bool, AUTOMATIC)                     is_rq_preemption = OSEE_FALSE;
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)      p_ret_tdb;

  if (p_ret_sn != NULL) {
8000add6:	bd 02 13 00 	jz.a %a2,8000adfc <osEE_scheduler_core_rq_preempt_stk+0x32>
    p_ret_tdb = p_ret_sn->p_tdb;
8000adda:	99 22 04 00 	ld.a %a2,[%a2]4
    if (p_rq_sn != NULL) {
8000adde:	bd 0f 1b 00 	jz.a %a15,8000ae14 <osEE_scheduler_core_rq_preempt_stk+0x4a>
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
8000ade2:	99 24 0c 00 	ld.a %a4,[%a2]12
      if (p_ret_tcb->current_prio <
        p_rq_sn->p_tdb->p_tcb->current_prio)
8000ade6:	c8 16       	ld.a %a6,[%a15]4
8000ade8:	99 66 0c 00 	ld.a %a6,[%a6]12
  if (p_ret_sn != NULL) {
    p_ret_tdb = p_ret_sn->p_tdb;
    if (p_rq_sn != NULL) {
      CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
        p_ret_tcb = p_ret_tdb->p_tcb;
      if (p_ret_tcb->current_prio <
8000adec:	39 42 01 00 	ld.bu %d2,[%a4]1
8000adf0:	0c 61       	ld.bu %d15,[%a6]1
8000adf2:	7f f2 13 80 	jge.u %d2,%d15,8000ae18 <osEE_scheduler_core_rq_preempt_stk+0x4e>
      {
        /* RQ preempt STK */
        /* Call PostTaskHook before switching active TASK */
        osEE_call_post_task_hook(p_ccb);

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
8000adf6:	82 2f       	mov %d15,2
8000adf8:	2c 42       	st.b [%a4]2,%d15
8000adfa:	3c 11       	j 8000ae1c <osEE_scheduler_core_rq_preempt_stk+0x52>
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000adfc:	a0 02       	mov.a %a2,0

        p_ret_tcb->status = OSEE_TASK_READY_STACKED;
        is_rq_preemption  = OSEE_TRUE;
      }
    }
  } else if (p_rq_sn != NULL) {
8000adfe:	bd 0f 1e 00 	jz.a %a15,8000ae3a <osEE_scheduler_core_rq_preempt_stk+0x70>
    /* Only Idle TASK stacked -> RQ preempt STK. */
    /* Don't use p_ccb->p_curr, is not reliable here,
     * It points to the terminated TASK, we are still evaluating
     * the next one. */
    p_ret_tdb                 = p_cdb->p_idle_task;
8000ae02:	99 42 14 00 	ld.a %a2,[%a4]20
    p_ret_tdb->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000ae06:	99 24 0c 00 	ld.a %a4,[%a2]12
8000ae0a:	82 2f       	mov %d15,2
8000ae0c:	2c 42       	st.b [%a4]2,%d15
8000ae0e:	3c 07       	j 8000ae1c <osEE_scheduler_core_rq_preempt_stk+0x52>
  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
    if (p_tcb->current_prio < dispatch_prio) {
      p_tcb->current_prio = dispatch_prio;
8000ae10:	2c 51       	st.b [%a5]1,%d15
8000ae12:	00 90       	ret 
    osEE_scheduler_stk_next(p_ccb, p_rq_sn);
  } else {
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
    p_ret_sn  = NULL;
#else
    p_ret_tdb = NULL;
8000ae14:	a0 02       	mov.a %a2,0
8000ae16:	00 90       	ret 
8000ae18:	a0 02       	mov.a %a2,0
8000ae1a:	00 90       	ret 
    p_ret_tdb = NULL;
  }

  if (is_rq_preemption) {
    /* Extract from ready queue */
    (*p_rq)       = p_rq_sn->p_next;
8000ae1c:	4c f0       	ld.w %d15,[%a15]0
8000ae1e:	6c 50       	st.w [%a5]0,%d15
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_rq_sn
)
{
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb = p_rq_sn->p_tdb;
8000ae20:	c8 14       	ld.a %a4,[%a15]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000ae22:	99 45 0c 00 	ld.a %a5,[%a4]12
  /* N.B. The Handling of the preempted SN as Stacked or re-inserted in RQ
   * is done by the calling function */
  p_rq_sn->p_next               = NULL;
  p_tcb->current_core_id        = osEE_get_curr_core_id();
#else
  p_rq_sn->p_next               = p_ccb->p_stk_sn;
8000ae26:	4c 33       	ld.w %d15,[%a3]12
8000ae28:	68 0f       	st.w [%a15]0,%d15
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  p_ccb->p_stk_sn               = p_rq_sn;
8000ae2a:	ec 33       	st.a [%a3]12,%a15
  p_ccb->p_curr                 = p_tdb;
8000ae2c:	f4 34       	st.a [%a3],%a4

  /* Adjust actual priority with dispatch priority: if needed */
  {
    CONST(TaskPrio, AUTOMATIC)
      dispatch_prio = p_tdb->dispatch_prio;
8000ae2e:	39 4f 1d 00 	ld.bu %d15,[%a4]29
    if (p_tcb->current_prio < dispatch_prio) {
8000ae32:	39 52 01 00 	ld.bu %d2,[%a5]1
8000ae36:	3f f2 ed ff 	jlt.u %d2,%d15,8000ae10 <osEE_scheduler_core_rq_preempt_stk+0x46>
#if (defined(OSEE_ALLOW_TASK_MIGRATION))
  return p_ret_sn;
#else
  return p_ret_tdb;
#endif /* OSEE_ALLOW_TASK_MIGRATION */
}
8000ae3a:	00 90       	ret 

8000ae3c <osEE_sn_priority_insert>:
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA)     pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA)     p_sn_new,
  CONST(OsEE_bool, AUTOMATIC)                   as_ready
)
{
8000ae3c:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST)  p_tdb_new = p_sn_new->p_tdb;
8000ae3e:	cc 51       	ld.a %a15,[%a5]4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_new = p_tdb_new->p_tcb;
8000ae40:	c8 32       	ld.a %a2,[%a15]12
  CONST(TaskPrio, AUTOMATIC)                  new_task_prio =
8000ae42:	76 44       	jz %d4,8000ae4a <osEE_sn_priority_insert+0xe>
8000ae44:	39 f2 1c 00 	ld.bu %d2,[%a15]28
8000ae48:	3c 03       	j 8000ae4e <osEE_sn_priority_insert+0x12>
8000ae4a:	39 22 01 00 	ld.bu %d2,[%a2]1
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
8000ae4e:	cc 40       	ld.a %a15,[%a4]0
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000ae50:	a0 06       	mov.a %a6,0
8000ae52:	7c f3       	jnz.a %a15,8000ae58 <osEE_sn_priority_insert+0x1c>
8000ae54:	3c 14       	j 8000ae7c <osEE_sn_priority_insert+0x40>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000ae56:	60 ff       	mov.a %a15,%d15
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
    VAR(TaskPrio, AUTOMATIC)                      prio_to_check;
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_cur_tdb = p_curr->p_tdb;
8000ae58:	c8 12       	ld.a %a2,[%a15]4
    CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_cur_tcb = p_cur_tdb->p_tcb;
8000ae5a:	99 23 0c 00 	ld.a %a3,[%a2]12

    if (as_ready) {
8000ae5e:	76 44       	jz %d4,8000ae66 <osEE_sn_priority_insert+0x2a>
      prio_to_check = p_cur_tdb->ready_prio;
8000ae60:	39 2f 1c 00 	ld.bu %d15,[%a2]28
8000ae64:	3c 02       	j 8000ae68 <osEE_sn_priority_insert+0x2c>
    } else {
      prio_to_check = p_cur_tcb->current_prio;
8000ae66:	0c 31       	ld.bu %d15,[%a3]1
    }

    if (new_task_prio <= prio_to_check)
8000ae68:	3f 2f 06 80 	jlt.u %d15,%d2,8000ae74 <osEE_sn_priority_insert+0x38>
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000ae6c:	4c f0       	ld.w %d15,[%a15]0
8000ae6e:	40 f6       	mov.aa %a6,%a15
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;

  /* Traverse the queue until needed */
  while (p_curr != NULL) {
8000ae70:	ee f3       	jnz %d15,8000ae56 <osEE_sn_priority_insert+0x1a>
    }

    if (new_task_prio <= prio_to_check)
    {
      p_prev = p_curr;
      p_curr = p_curr->p_next;
8000ae72:	60 ff       	mov.a %a15,%d15
    } else {
      break;
    }
  }

  if (p_prev != NULL) {
8000ae74:	bc 64       	jz.a %a6,8000ae7c <osEE_sn_priority_insert+0x40>
    p_prev->p_next = p_sn_new;
8000ae76:	f4 65       	st.a [%a6],%a5
    (as_ready)?
      p_tdb_new->ready_prio:
      p_tcb_new->current_prio;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_prev          = NULL;
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_curr          = (*pp_first);
  VAR(OsEE_bool, AUTOMATIC)               head_changed    = OSEE_FALSE;
8000ae78:	82 02       	mov %d2,0
8000ae7a:	3c 03       	j 8000ae80 <osEE_sn_priority_insert+0x44>
  }

  if (p_prev != NULL) {
    p_prev->p_next = p_sn_new;
  } else {
    (*pp_first)   = p_sn_new;
8000ae7c:	f4 45       	st.a [%a4],%a5
    head_changed  = OSEE_TRUE;
8000ae7e:	82 12       	mov %d2,1
  }

  p_sn_new->p_next = p_curr;
8000ae80:	ec 50       	st.a [%a5]0,%a15

  return head_changed;
}
8000ae82:	00 90       	ret 

8000ae84 <osEE_scheduler_rq_insert>:
(
  P2VAR(OsEE_RQ, AUTOMATIC, OS_APPL_DATA)       p_rq,
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)       p_sn_new,
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb_new
)
{
8000ae84:	40 ae       	mov.aa %a14,%sp
  p_sn_new->p_tdb = p_tdb_new;
8000ae86:	b5 56 04 00 	st.a [%a5]4,%a6

#if (!defined(OSEE_SCHEDULER_GLOBAL))
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_TRUE);
8000ae8a:	82 14       	mov %d4,1
8000ae8c:	6d ff d8 ff 	call 8000ae3c <osEE_sn_priority_insert>
#else
  return osEE_sn_priority_insert(p_rq, p_sn_new, OSEE_FALSE);
#endif /* !OSEE_SCHEDULER_GLOBAL */
}
8000ae90:	00 90       	ret 

8000ae92 <osEE_scheduler_core_pop_running>:
  osEE_scheduler_core_pop_running
(
  P2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)  p_cdb,
  P2VAR(OsEE_RQ,  AUTOMATIC, OS_APPL_DATA)  p_rq
)
{
8000ae92:	40 ae       	mov.aa %a14,%sp
8000ae94:	40 4d       	mov.aa %a13,%a4
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb         = p_cdb->p_ccb;
8000ae96:	cc 43       	ld.a %a15,[%a4]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)  p_prev_stk_sn = p_ccb->p_stk_sn;
8000ae98:	c8 3c       	ld.a %a12,[%a15]12
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_next_stk_sn = p_prev_stk_sn->p_next;

  /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
   * called inside IDLE TASK. */
  p_ccb->p_stk_sn = p_next_stk_sn;
8000ae9a:	54 c3       	ld.w %d3,[%a12]
8000ae9c:	68 33       	st.w [%a15]12,%d3
   * */

  {
    /* Handle if RQ preempt STK (It manipulate the core data structures) */
    CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
      p_preempt = osEE_scheduler_core_rq_preempt_stk(p_cdb, p_rq);
8000ae9e:	6d ff 96 ff 	call 8000adca <osEE_scheduler_core_rq_preempt_stk>
    CONSTP2CONST(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
      p_curr_stk_sn = p_ccb->p_stk_sn;
8000aea2:	4c f3       	ld.w %d15,[%a15]12

    /* If not, resume current STK first */
    if (p_preempt == NULL) {
8000aea4:	7c 29       	jnz.a %a2,8000aeb6 <osEE_scheduler_core_pop_running+0x24>
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

      if (p_curr_stk_sn != NULL) {
        /* Resume STK TASK */
        p_tdb_stk = p_curr_stk_sn->p_tdb;
8000aea6:	80 d3       	mov.d %d3,%a13
8000aea8:	1b 43 01 20 	addi %d2,%d3,20
8000aeac:	92 43       	add %d3,%d15,4
8000aeae:	6a 23       	cmovn %d3,%d15,%d2
8000aeb0:	60 3d       	mov.a %a13,%d3
8000aeb2:	4c d0       	ld.w %d15,[%a13]0
8000aeb4:	68 0f       	st.w [%a15]0,%d15
    }
#endif /* OSEE_ALLOW_TASK_MIGRATION */
  }

  return p_prev_stk_sn;
}
8000aeb6:	40 c2       	mov.aa %a2,%a12
8000aeb8:	00 90       	ret 

8000aeba <osEE_task_activated>:

FUNC(StatusType, OS_CODE) osEE_task_activated
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000aeba:	40 ae       	mov.aa %a14,%sp
8000aebc:	40 4c       	mov.aa %a12,%a4
  VAR(StatusType, AUTOMATIC)                    ev;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act = p_tdb_act->p_tcb;
8000aebe:	99 4d 0c 00 	ld.a %a13,[%a4]12
 *  \return The function returns a pointer to the CDB pointer
 */
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_core(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000aec2:	79 44 1f 00 	ld.b %d4,[%a4]31
8000aec6:	6d 00 f7 04 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000aeca:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000aecc:	82 18       	mov %d8,1
8000aece:	82 09       	mov %d9,0
8000aed0:	0b 89 10 28 	mov %e2,%d9,%d8
8000aed4:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000aed8:	df 02 fa ff 	jne %d2,0,8000aecc <osEE_task_activated+0x12>
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000aedc:	0c d0       	ld.bu %d15,[%a13]0
8000aede:	39 c3 1e 00 	ld.bu %d3,[%a12]30
    ++p_tcb_act->current_num_of_act;
    ev = E_OK;
  } else {
    ev = E_OS_LIMIT;
8000aee2:	82 42       	mov %d2,4
#else
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  if (p_tcb_act->current_num_of_act < p_tdb_act->max_num_of_act) {
8000aee4:	7f 3f 05 80 	jge.u %d15,%d3,8000aeee <osEE_task_activated+0x34>
    ++p_tcb_act->current_num_of_act;
8000aee8:	c2 1f       	add %d15,1
8000aeea:	2c d0       	st.b [%a13]0,%d15
    ev = E_OK;
8000aeec:	82 02       	mov %d2,0
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000aeee:	cc 24       	ld.a %a15,[%a2]16
8000aef0:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000aef4:	82 0f       	mov %d15,0
8000aef6:	68 0f       	st.w [%a15]0,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return ev;
}
8000aef8:	00 90       	ret 

8000aefa <osEE_task_end>:
FUNC(void, OS_CODE)
  osEE_task_end
(
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_tdb
)
{
8000aefa:	40 ae       	mov.aa %a14,%sp
  /* It has to be called already in Multi-Core critical section */
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb = p_tdb->p_tcb;
8000aefc:	cc 43       	ld.a %a15,[%a4]12

  p_tcb->current_prio = p_tdb->ready_prio;
8000aefe:	39 4f 1c 00 	ld.bu %d15,[%a4]28
8000af02:	28 1f       	st.b [%a15]1,%d15

  --p_tcb->current_num_of_act;
8000af04:	0c f0       	ld.bu %d15,[%a15]0
8000af06:	c2 ff       	add %d15,-1
8000af08:	16 ff       	and %d15,255
8000af0a:	28 0f       	st.b [%a15]0,%d15

  if (p_tcb->current_num_of_act == 0U) {
8000af0c:	ee 03       	jnz %d15,8000af12 <osEE_task_end+0x18>
    p_tcb->status = OSEE_TASK_SUSPENDED;
8000af0e:	28 2f       	st.b [%a15]2,%d15
8000af10:	00 90       	ret 
  } else {
    p_tcb->status = OSEE_TASK_READY;
8000af12:	82 1f       	mov %d15,1
8000af14:	28 2f       	st.b [%a15]2,%d15
8000af16:	00 90       	ret 

8000af18 <osEE_task_event_set_mask>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)    p_tdb_waking_up,
  VAR(EventMaskType, AUTOMATIC)               Mask,
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
8000af18:	40 ae       	mov.aa %a14,%sp
8000af1a:	40 4d       	mov.aa %a13,%a4
8000af1c:	02 4a       	mov %d10,%d4
8000af1e:	80 5b       	mov.d %d11,%a5
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_waking_up = p_tdb_waking_up->p_tcb;
8000af20:	99 4c 0c 00 	ld.a %a12,[%a4]12
 *  \return The function returns a pointer to the CDB pointer
 */
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_core(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000af24:	79 44 1f 00 	ld.b %d4,[%a4]31
8000af28:	6d 00 c6 04 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000af2c:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000af2e:	82 18       	mov %d8,1
8000af30:	82 09       	mov %d9,0
8000af32:	0b 89 10 28 	mov %e2,%d9,%d8
8000af36:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000af3a:	df 02 fa ff 	jne %d2,0,8000af2e <osEE_task_event_set_mask+0x16>
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

#if (defined(OSEE_HAS_CHECKS))
  if (p_tdb_waking_up->task_type != OSEE_TASK_TYPE_EXTENDED) {
8000af3e:	39 df 14 00 	ld.bu %d15,[%a13]20
8000af42:	1e 16       	jeq %d15,1,8000af4e <osEE_task_event_set_mask+0x36>
    *p_ev = E_OS_ACCESS;
8000af44:	82 1f       	mov %d15,1
8000af46:	60 bf       	mov.a %a15,%d11
8000af48:	28 0f       	st.b [%a15]0,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000af4a:	a0 0f       	mov.a %a15,0
8000af4c:	3c 17       	j 8000af7a <osEE_task_event_set_mask+0x62>

#if (defined(OSEE_HAS_CHECKS))
  if (p_tdb_waking_up->task_type != OSEE_TASK_TYPE_EXTENDED) {
    *p_ev = E_OS_ACCESS;
  } else
  if (p_tcb_waking_up->status == OSEE_TASK_SUSPENDED) {
8000af4e:	0c c2       	ld.bu %d15,[%a12]2
8000af50:	ee 06       	jnz %d15,8000af5c <osEE_task_event_set_mask+0x44>
    *p_ev = E_OS_STATE;
8000af52:	82 7f       	mov %d15,7
8000af54:	60 bf       	mov.a %a15,%d11
8000af56:	28 0f       	st.b [%a15]0,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000af58:	a0 0f       	mov.a %a15,0
8000af5a:	3c 10       	j 8000af7a <osEE_task_event_set_mask+0x62>
    *p_ev = E_OS_STATE;
  } else
#endif /* OSEE_HAS_CHECKS */
  {
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;
8000af5c:	02 ac       	mov %d12,%d10
8000af5e:	02 ad       	mov %d13,%d10
8000af60:	49 cc 4c 08 	ldmst [%a12]12,%e12

    *p_ev = E_OK;
8000af64:	82 0f       	mov %d15,0
8000af66:	60 bf       	mov.a %a15,%d11
8000af68:	28 0f       	st.b [%a15]0,%d15

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000af6a:	4c c2       	ld.w %d15,[%a12]8
8000af6c:	26 fa       	and %d10,%d15
  P2VAR(StatusType, AUTOMATIC, OS_APPL_DATA)  p_ev
)
{
  /* Initialize the return value to NULL to handle failed error checks. */
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_own_sn        = NULL;
8000af6e:	a0 0f       	mov.a %a15,0
    /* Set the event mask only if the task is not suspended */
    p_tcb_waking_up->event_mask |= Mask;

    *p_ev = E_OK;

    if ((p_tcb_waking_up->wait_mask & Mask) != 0U) {
8000af70:	76 a5       	jz %d10,8000af7a <osEE_task_event_set_mask+0x62>
      p_own_sn = p_tcb_waking_up->p_own_sn;
8000af72:	cc c4       	ld.a %a15,[%a12]16

      /* Set p_own_sn of waking up task to NULL so it won't be inserted in
         RQ more than once. */
      if (p_own_sn != NULL) {
8000af74:	bc f3       	jz.a %a15,8000af7a <osEE_task_event_set_mask+0x62>
        p_tcb_waking_up->p_own_sn = NULL;
8000af76:	82 0f       	mov %d15,0
8000af78:	6c c4       	st.w [%a12]16,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000af7a:	99 22 10 00 	ld.a %a2,[%a2]16
8000af7e:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000af82:	82 0f       	mov %d15,0
8000af84:	6c 20       	st.w [%a2]0,%d15
  osEE_lock_kernel();
#endif /* !OSEE_SCHEDULER_GLOBAL */
#endif /* !OSEE_SINGLECORE */

  return p_own_sn;
}
8000af86:	40 f2       	mov.aa %a2,%a15
8000af88:	00 90       	ret 

8000af8a <osEE_activate_isr2>:
FUNC(void, OS_CODE)
  osEE_activate_isr2
(
  VAR(TaskType, AUTOMATIC) isr2_id
)
{
8000af8a:	40 ae       	mov.aa %a14,%sp
  osEE_stack_monitoring(osEE_get_curr_core());
#endif /* OSEE_HAS_STACK_MONITORING */
  {
    CONSTP2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA) p_kdb = osEE_get_kernel();
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_act_tdb = (*p_kdb->p_tdb_ptr_array)[isr2_id];
8000af8c:	91 00 00 48 	movh.a %a4,32768
8000af90:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
8000af94:	cc 43       	ld.a %a15,[%a4]12
8000af96:	01 f4 02 f6 	addsc.a %a15,%a15,%d4,2
8000af9a:	c8 05       	ld.a %a5,[%a15]0

    /* Mark the TASK as Activated (I don't need to protect this increment
       since ISRs cannot be activated by another core (exception done for
       IPI, that have to be handled in a special way in any case). */
    ++p_act_tdb->p_tcb->current_num_of_act;
8000af9c:	cc 53       	ld.a %a15,[%a5]12
8000af9e:	0c f0       	ld.bu %d15,[%a15]0
8000afa0:	c2 1f       	add %d15,1
8000afa2:	28 0f       	st.b [%a15]0,%d15

    osEE_scheduler_task_set_running(p_kdb, p_act_tdb, NULL);
8000afa4:	a0 06       	mov.a %a6,0
8000afa6:	6d 00 8b 01 	call 8000b2bc <osEE_scheduler_task_set_running>
8000afaa:	00 90       	ret 

8000afac <osEE_scheduler_task_insert_rq>:
(
  P2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)  p_ccb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act,
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb_act
)
{
8000afac:	40 ae       	mov.aa %a14,%sp
8000afae:	40 5f       	mov.aa %a15,%a5
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;

  /* Actually Insert the activated in Ready Queue.
   * Change Status only if is not active yet. */
  if (p_tcb_act->status == OSEE_TASK_SUSPENDED) {
8000afb0:	0c 62       	ld.bu %d15,[%a6]2
8000afb2:	ee 05       	jnz %d15,8000afbc <osEE_scheduler_task_insert_rq+0x10>
    p_tcb_act->status = OSEE_TASK_READY;
8000afb4:	82 1f       	mov %d15,1
8000afb6:	2c 62       	st.b [%a6]2,%d15
  osEE_task_event_reset_mask
(
  P2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)  p_tcb
)
{
  p_tcb->event_mask = 0U;
8000afb8:	82 0f       	mov %d15,0
8000afba:	6c 63       	st.w [%a6]12,%d15
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000afbc:	99 45 08 00 	ld.a %a5,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
8000afc0:	4c 50       	ld.w %d15,[%a5]0
8000afc2:	6c 42       	st.w [%a4]8,%d15
  p_sn_allocated->p_next  = NULL;
8000afc4:	82 0f       	mov %d15,0
8000afc6:	6c 50       	st.w [%a5]0,%d15
    osEE_task_event_reset_mask(p_tcb_act);
  }

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000afc8:	b0 44       	add.a %a4,4
8000afca:	40 f6       	mov.aa %a6,%a15
8000afcc:	6d ff 5c ff 	call 8000ae84 <osEE_scheduler_rq_insert>
    osEE_sn_alloc(&p_ccb->p_free_sn), p_tdb_act);

  return rq_head_changed;
}
8000afd0:	00 90       	ret 

8000afd2 <osEE_scheduler_task_activated>:
  osEE_scheduler_task_activated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000afd2:	40 ae       	mov.aa %a14,%sp
8000afd4:	40 5c       	mov.aa %a12,%a5
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
8000afd6:	19 5a 0c 00 	ld.w %d10,[%a5]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
8000afda:	79 54 1f 00 	ld.b %d4,[%a5]31
8000afde:	6d 00 6b 04 	call 8000b8b4 <osEE_get_core>
8000afe2:	40 2d       	mov.aa %a13,%a2
{
  VAR(OsEE_bool, AUTOMATIC)   is_preemption;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_tcb_act   = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb       = p_cdb->p_ccb;
8000afe4:	99 24 0c 00 	ld.a %a4,[%a2]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr      = p_ccb->p_curr;
8000afe8:	d4 42       	ld.a %a2,[%a4]
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_curr_tcb  = p_curr->p_tcb;
8000afea:	99 23 0c 00 	ld.a %a3,[%a2]12
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000afee:	4d c0 e1 2f 	mfcr %d2,$core_id
8000aff2:	37 02 48 20 	extr %d2,%d2,0,8
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000aff6:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000aff8:	82 18       	mov %d8,1
8000affa:	82 09       	mov %d9,0
8000affc:	0b 89 10 48 	mov %e4,%d9,%d8
8000b000:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b004:	df 04 fa ff 	jne %d4,0,8000aff8 <osEE_scheduler_task_activated+0x26>
  (void)p_kdb;
  osEE_lock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  /* Check if this is a remote activation */
  if (p_tdb_act->orig_core_id != curr_core_id) {
8000b008:	79 cf 1f 00 	ld.b %d15,[%a12]31
8000b00c:	5f 2f 23 00 	jeq %d15,%d2,8000b052 <osEE_scheduler_task_activated+0x80>
    CONST(OsEE_bool, AUTOMATIC) rq_head_changed =
8000b010:	40 c5       	mov.aa %a5,%a12
8000b012:	60 a6       	mov.a %a6,%d10
8000b014:	5c cc       	call 8000afac <osEE_scheduler_task_insert_rq>
8000b016:	02 2f       	mov %d15,%d2
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b018:	cc d4       	ld.a %a15,[%a13]16
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000b01a:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b01e:	82 02       	mov %d2,0
8000b020:	68 02       	st.w [%a15]0,%d2
      osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);

    osEE_unlock_core(p_cdb);

    if (rq_head_changed) {
8000b022:	6e 42       	jz %d15,8000b0a6 <osEE_scheduler_task_activated+0xd4>
      /* if RQ Head is changed, signal the remote core, it needs to
         reschedule */
      osEE_hal_signal_core(p_tdb_act->orig_core_id);
8000b024:	79 c2 1f 00 	ld.b %d2,[%a12]31
8000b028:	8f f2 0f f1 	and %d15,%d2,255
8000b02c:	91 40 00 ff 	movh.a %a15,61444
8000b030:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000b034:	ff 4f 09 80 	jge.u %d15,4,8000b046 <osEE_scheduler_task_activated+0x74>
8000b038:	60 22       	mov.a %a2,%d2
8000b03a:	d9 2f 40 0e 	lea %a15,[%a2]-7168
8000b03e:	11 1f c0 f3 	addih.a %a15,%a15,15361
8000b042:	30 ff       	add.a %a15,%a15
8000b044:	30 ff       	add.a %a15,%a15
8000b046:	4c f0       	ld.w %d15,[%a15]0
8000b048:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
8000b04c:	68 0f       	st.w [%a15]0,%d15
    }
    is_preemption = OSEE_FALSE;
8000b04e:	82 02       	mov %d2,0
8000b050:	00 90       	ret 
  } else
#endif /* !OSEE_SINGLECORE */
  /* Preemption Check */
  if (p_curr_tcb->current_prio < p_tcb_act->current_prio) {
8000b052:	39 32 01 00 	ld.bu %d2,[%a3]1
8000b056:	60 af       	mov.a %a15,%d10
8000b058:	0c f1       	ld.bu %d15,[%a15]1
8000b05a:	7f f2 1d 80 	jge.u %d2,%d15,8000b094 <osEE_scheduler_task_activated+0xc2>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000b05e:	cc 42       	ld.a %a15,[%a4]8
  (*pp_first)              = p_sn_allocated->p_next;
8000b060:	48 02       	ld.w %d2,[%a15]0
8000b062:	59 42 08 00 	st.w [%a4]8,%d2
  p_sn_allocated->p_next  = NULL;
8000b066:	82 0f       	mov %d15,0
8000b068:	68 0f       	st.w [%a15]0,%d15
        osEE_call_post_task_hook(p_ccb);
      }
#endif /* OSEE_HAS_POSTTASKHOOK */

    /* Set Previous TASK status as Ready but stacked */
    p_curr_tcb->status = OSEE_TASK_READY_STACKED;
8000b06a:	82 22       	mov %d2,2
8000b06c:	e9 32 02 00 	st.b [%a3]2,%d2

    /* Set the activated TASK as current */
    p_new_stk->p_tdb            = p_tdb_act;
8000b070:	e8 1c       	st.a [%a15]4,%a12
    p_new_stk->p_next           = p_ccb->p_stk_sn;
8000b072:	19 44 0c 00 	ld.w %d4,[%a4]12
8000b076:	68 04       	st.w [%a15]0,%d4
    p_ccb->p_stk_sn             = p_new_stk;
8000b078:	ec 43       	st.a [%a4]12,%a15
    p_ccb->p_curr               = p_tdb_act;
8000b07a:	f4 4c       	st.a [%a4],%a12
    osEE_task_event_reset_mask(p_tdb_act->p_tcb);
8000b07c:	cc c3       	ld.a %a15,[%a12]12
8000b07e:	68 3f       	st.w [%a15]12,%d15
8000b080:	cc d4       	ld.a %a15,[%a13]16
8000b082:	0d 00 80 04 	dsync 
8000b086:	68 0f       	st.w [%a15]0,%d15

    osEE_unlock_core(p_cdb);

    osEE_change_context_from_running(p_curr, p_tdb_act);
8000b088:	40 24       	mov.aa %a4,%a2
8000b08a:	40 c5       	mov.aa %a5,%a12
8000b08c:	6d 00 21 03 	call 8000b6ce <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000b090:	82 12       	mov %d2,1
8000b092:	00 90       	ret 
  } else {
    /* Actually Insert the activated in READY Queue */
    (void)osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
8000b094:	40 c5       	mov.aa %a5,%a12
8000b096:	60 a6       	mov.a %a6,%d10
8000b098:	5c 8a       	call 8000afac <osEE_scheduler_task_insert_rq>
8000b09a:	cc d4       	ld.a %a15,[%a13]16
8000b09c:	0d 00 80 04 	dsync 
8000b0a0:	82 0f       	mov %d15,0
8000b0a2:	68 0f       	st.w [%a15]0,%d15

    osEE_unlock_core(p_cdb);

    is_preemption = OSEE_FALSE;
8000b0a4:	82 02       	mov %d2,0
  }

  return is_preemption;
}
8000b0a6:	00 90       	ret 

8000b0a8 <osEE_scheduler_task_insert>:
  osEE_scheduler_task_insert
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb_act
)
{
8000b0a8:	40 ae       	mov.aa %a14,%sp
8000b0aa:	40 5c       	mov.aa %a12,%a5
  VAR(OsEE_bool, AUTOMATIC)   head_changed;
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
8000b0ac:	19 5a 0c 00 	ld.w %d10,[%a5]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
8000b0b0:	79 54 1f 00 	ld.b %d4,[%a5]31
8000b0b4:	6d 00 00 04 	call 8000b8b4 <osEE_get_core>
8000b0b8:	40 2d       	mov.aa %a13,%a2
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_act     = p_tdb_act->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb         = osEE_task_get_curr_core(p_tdb_act);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb         = p_cdb->p_ccb;
8000b0ba:	99 24 0c 00 	ld.a %a4,[%a2]12
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000b0be:	4d c0 e1 2f 	mfcr %d2,$core_id
8000b0c2:	37 02 48 20 	extr %d2,%d2,0,8
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b0c6:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b0c8:	82 18       	mov %d8,1
8000b0ca:	82 09       	mov %d9,0
8000b0cc:	0b 89 10 48 	mov %e4,%d9,%d8
8000b0d0:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b0d4:	df 04 fa ff 	jne %d4,0,8000b0c8 <osEE_scheduler_task_insert+0x20>
  (void)p_kdb;
  osEE_lock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  /* Check if this is a remote activation */
  if (p_tdb_act->orig_core_id != curr_core_id) {
8000b0d8:	79 cf 1f 00 	ld.b %d15,[%a12]31
8000b0dc:	5f 2f 24 00 	jeq %d15,%d2,8000b124 <osEE_scheduler_task_insert+0x7c>
    head_changed = osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
8000b0e0:	40 c5       	mov.aa %a5,%a12
8000b0e2:	60 a6       	mov.a %a6,%d10
8000b0e4:	6d ff 64 ff 	call 8000afac <osEE_scheduler_task_insert_rq>
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b0e8:	cc d4       	ld.a %a15,[%a13]16
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000b0ea:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b0ee:	82 0f       	mov %d15,0
8000b0f0:	68 0f       	st.w [%a15]0,%d15

    osEE_unlock_core(p_cdb);

    if (head_changed) {
8000b0f2:	df 02 22 00 	jeq %d2,0,8000b136 <osEE_scheduler_task_insert+0x8e>
      /* if RQ Head is changed, signal the remote core, it needs to
         reschedule */
      osEE_hal_signal_core(p_tdb_act->orig_core_id);
8000b0f6:	79 c2 1f 00 	ld.b %d2,[%a12]31
8000b0fa:	8f f2 0f f1 	and %d15,%d2,255
8000b0fe:	91 40 00 ff 	movh.a %a15,61444
8000b102:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000b106:	ff 4f 09 80 	jge.u %d15,4,8000b118 <osEE_scheduler_task_insert+0x70>
8000b10a:	60 22       	mov.a %a2,%d2
8000b10c:	d9 2f 40 0e 	lea %a15,[%a2]-7168
8000b110:	11 1f c0 f3 	addih.a %a15,%a15,15361
8000b114:	30 ff       	add.a %a15,%a15
8000b116:	30 ff       	add.a %a15,%a15
8000b118:	4c f0       	ld.w %d15,[%a15]0
8000b11a:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
8000b11e:	68 0f       	st.w [%a15]0,%d15
      head_changed = OSEE_FALSE;
8000b120:	82 02       	mov %d2,0
8000b122:	00 90       	ret 
    }
  } else
#endif /* !OSEE_SINGLECORE */
  {
    /* Actually Insert the activated in READY Queue */
    head_changed  = osEE_scheduler_task_insert_rq(p_ccb, p_tdb_act, p_tcb_act);
8000b124:	40 c5       	mov.aa %a5,%a12
8000b126:	60 a6       	mov.a %a6,%d10
8000b128:	6d ff 42 ff 	call 8000afac <osEE_scheduler_task_insert_rq>
8000b12c:	cc d4       	ld.a %a15,[%a13]16
8000b12e:	0d 00 80 04 	dsync 
8000b132:	82 0f       	mov %d15,0
8000b134:	68 0f       	st.w [%a15]0,%d15

    osEE_unlock_core(p_cdb);
  }

  return head_changed;
}
8000b136:	00 90       	ret 

8000b138 <osEE_scheduler_task_unblocked>:
  osEE_scheduler_task_unblocked
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
8000b138:	40 ae       	mov.aa %a14,%sp
8000b13a:	80 5b       	mov.d %d11,%a5
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
    p_tdb_released = p_sn_released->p_tdb;
8000b13c:	99 5c 04 00 	ld.a %a12,[%a5]4
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
8000b140:	19 ca 0c 00 	ld.w %d10,[%a12]12
#if (defined(OSEE_SINGLECORE))
  /* Touch unused parameter */
  (void)p_tdb;
  return osEE_get_curr_core();
#else
  return osEE_get_core(p_tdb->orig_core_id);
8000b144:	79 c4 1f 00 	ld.b %d4,[%a12]31
8000b148:	6d 00 b6 03 	call 8000b8b4 <osEE_get_core>
8000b14c:	40 2d       	mov.aa %a13,%a2
  CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
    p_tcb_released = p_tdb_released->p_tcb;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA)
    p_cdb = osEE_task_get_curr_core(p_tdb_released);
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA)
    p_ccb = p_cdb->p_ccb;
8000b14e:	19 2c 0c 00 	ld.w %d12,[%a2]12

  p_tcb_released->status       = OSEE_TASK_READY_STACKED;
8000b152:	82 2f       	mov %d15,2
8000b154:	60 a2       	mov.a %a2,%d10
8000b156:	2c 22       	st.b [%a2]2,%d15
  p_tcb_released->current_prio = p_tdb_released->ready_prio;
8000b158:	39 cf 1c 00 	ld.bu %d15,[%a12]28
8000b15c:	2c 21       	st.b [%a2]1,%d15
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b15e:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b160:	82 18       	mov %d8,1
8000b162:	82 09       	mov %d9,0
8000b164:	0b 89 10 28 	mov %e2,%d9,%d8
8000b168:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b16c:	df 02 fa ff 	jne %d2,0,8000b160 <osEE_scheduler_task_unblocked+0x28>
  /* Touch unused parameters */
  (void)p_kdb;

  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
8000b170:	60 c4       	mov.a %a4,%d12
8000b172:	b0 44       	add.a %a4,4
8000b174:	60 b5       	mov.a %a5,%d11
8000b176:	40 c6       	mov.aa %a6,%a12
8000b178:	6d ff 86 fe 	call 8000ae84 <osEE_scheduler_rq_insert>
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn_released
)
{
  VAR(OsEE_bool, AUTOMATIC) rq_head_changed;
  VAR(OsEE_bool, AUTOMATIC)
    is_preemption = OSEE_FALSE;
8000b17c:	82 03       	mov %d3,0
  osEE_lock_core(p_cdb);

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
8000b17e:	df 12 0a 80 	jne %d2,1,8000b192 <osEE_scheduler_task_unblocked+0x5a>
    is_preemption = (p_tcb_released->current_prio >
      p_ccb->p_curr->p_tcb->current_prio);
8000b182:	60 c2       	mov.a %a2,%d12
8000b184:	cc 20       	ld.a %a15,[%a2]0
8000b186:	c8 3f       	ld.a %a15,[%a15]12

  rq_head_changed = osEE_scheduler_rq_insert(&p_ccb->rq,
    p_sn_released, p_tdb_released);

  if (rq_head_changed == OSEE_TRUE) {
    is_preemption = (p_tcb_released->current_prio >
8000b188:	60 a2       	mov.a %a2,%d10
8000b18a:	0c 21       	ld.bu %d15,[%a2]1
8000b18c:	08 13       	ld.bu %d3,[%a15]1
8000b18e:	0b f3 30 31 	lt.u %d3,%d3,%d15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b192:	cc d4       	ld.a %a15,[%a13]16
8000b194:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b198:	82 0f       	mov %d15,0
8000b19a:	68 0f       	st.w [%a15]0,%d15

  osEE_unlock_core(p_cdb);

#if (!defined(OSEE_SINGLECORE))
  {
    CONST(CoreIdType, AUTOMATIC) tdb_core_id = p_tdb_released->orig_core_id;
8000b19c:	79 cf 1f 00 	ld.b %d15,[%a12]31
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000b1a0:	4d c0 e1 2f 	mfcr %d2,$core_id
    /* Check if this is a remote release */
    if (tdb_core_id != osEE_get_curr_core_id()) {
8000b1a4:	37 02 48 20 	extr %d2,%d2,0,8
      if (is_preemption) {
8000b1a8:	0b 2f 10 21 	ne %d2,%d15,%d2
8000b1ac:	26 32       	and %d2,%d3
8000b1ae:	df 02 15 00 	jeq %d2,0,8000b1d8 <osEE_scheduler_task_unblocked+0xa0>
8000b1b2:	8f ff 0f 21 	and %d2,%d15,255
8000b1b6:	91 40 00 ff 	movh.a %a15,61444
8000b1ba:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000b1be:	ff 42 08 80 	jge.u %d2,4,8000b1ce <osEE_scheduler_task_unblocked+0x96>
8000b1c2:	1b 0f 40 fe 	addi %d15,%d15,-7168
8000b1c6:	9b 1f c0 f3 	addih %d15,%d15,15361
8000b1ca:	06 2f       	sh %d15,2
8000b1cc:	60 ff       	mov.a %a15,%d15
8000b1ce:	4c f0       	ld.w %d15,[%a15]0
8000b1d0:	b7 ff 01 fd 	insert %d15,%d15,15,26,1
8000b1d4:	68 0f       	st.w [%a15]0,%d15
        osEE_hal_signal_core(tdb_core_id);
        /* If this is a remote release, it is not a preemption for this core */
        is_preemption = OSEE_FALSE;
8000b1d6:	82 03       	mov %d3,0
    }
  }
#endif /* !OSEE_SINGLECORE */

  return is_preemption;
}
8000b1d8:	02 32       	mov %d2,%d3
8000b1da:	00 90       	ret 

8000b1dc <osEE_scheduler_task_terminated>:
  osEE_scheduler_task_terminated
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)    p_kdb,
  P2VAR(OsEE_TDB *, AUTOMATIC, OS_APPL_DATA)  pp_tdb_from
)
{
8000b1dc:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b1de:	40 9d       	mov.aa %a13,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000b1e0:	99 dc 0c 00 	ld.a %a12,[%a13]12 <f003000c <_SMALL_DATA4_+0x4002800c>>
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b1e4:	cc d4       	ld.a %a15,[%a13]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b1e6:	82 12       	mov %d2,1
8000b1e8:	82 03       	mov %d3,0
8000b1ea:	0b 23 10 48 	mov %e4,%d3,%d2
8000b1ee:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b1f2:	df 04 fa ff 	jne %d4,0,8000b1e6 <osEE_scheduler_task_terminated+0xa>
  /* Touch unused parameters */
  (void)p_kdb;
  osEE_lock_core(p_cdb);
  {
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
      p_tdb_term  = p_ccb->p_curr;
8000b1f6:	4c c0       	ld.w %d15,[%a12]0
    CONSTP2VAR(OsEE_TCB, AUTOMATIC, OS_APPL_DATA)
      p_tcb_term  = p_tdb_term->p_tcb;
8000b1f8:	60 f2       	mov.a %a2,%d15
8000b1fa:	cc 23       	ld.a %a15,[%a2]12

    /* Prepare the TDB from return value */
    (*pp_tdb_from) = p_tdb_term;
8000b1fc:	6c 50       	st.w [%a5]0,%d15

    if (p_tcb_term->status == OSEE_TASK_RUNNING) {
8000b1fe:	08 22       	ld.bu %d2,[%a15]2
8000b200:	df 42 18 80 	jne %d2,4,8000b230 <osEE_scheduler_task_terminated+0x54>
      /* Normal Termination */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = osEE_scheduler_core_pop_running(p_cdb, &p_ccb->rq);
8000b204:	40 d4       	mov.aa %a4,%a13
8000b206:	d9 c5 04 00 	lea %a5,[%a12]4
8000b20a:	6d ff 44 fe 	call 8000ae92 <osEE_scheduler_core_pop_running>
8000b20e:	80 29       	mov.d %d9,%a2

      p_tdb_to = p_ccb->p_curr;
8000b210:	54 c8       	ld.w %d8,[%a12]

      /* Handle if there was another activation of the same TASK already
       * as Head of RQ */
      if (p_tdb_term != p_tdb_to) {
8000b212:	3e 85       	jeq %d15,%d8,8000b21c <osEE_scheduler_task_terminated+0x40>
        osEE_task_end(p_tdb_term);
8000b214:	60 f4       	mov.a %a4,%d15
8000b216:	6d ff 72 fe 	call 8000aefa <osEE_task_end>
8000b21a:	3c 04       	j 8000b222 <osEE_scheduler_task_terminated+0x46>
#if (defined(OSEE_HAS_PRETASKHOOK))
        /* If TDB_TERM is equal to TDB_TO, the following assure that
         * PreTaskHook will be called */
        p_ccb->p_last_tdb_hook = NULL;
#endif /* OSEE_HAS_PRETASKHOOK */
        --p_tcb_term->current_num_of_act;
8000b21c:	0c f0       	ld.bu %d15,[%a15]0
8000b21e:	c2 ff       	add %d15,-1
8000b220:	28 0f       	st.b [%a15]0,%d15
(
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first,
  P2VAR(OsEE_SN  , AUTOMATIC, OS_APPL_DATA) p_to_free
)
{
  p_to_free->p_next = (*pp_first);
8000b222:	19 c2 08 00 	ld.w %d2,[%a12]8
8000b226:	60 92       	mov.a %a2,%d9
8000b228:	74 22       	st.w [%a2],%d2
  (*pp_first)       = p_to_free;
8000b22a:	59 c9 08 00 	st.w [%a12]8,%d9
8000b22e:	3c 21       	j 8000b270 <osEE_scheduler_task_terminated+0x94>
      /* In Normal Termination => SN released */
      osEE_sn_release(&p_ccb->p_free_sn, p_sn_term);
    } else {
      /* Handle ChainTask */
      CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
        p_sn_term = p_ccb->p_stk_sn;
8000b230:	99 c5 0c 00 	ld.a %a5,[%a12]12

      /* Pop the current STK SN, if not IDLE TASK. This function MUST not be
       * called inside IDLE TASK. */
      p_ccb->p_stk_sn = p_sn_term->p_next;
8000b234:	54 52       	ld.w %d2,[%a5]
8000b236:	59 c2 0c 00 	st.w [%a12]12,%d2
      /* Wait to see p_ccb->p_curr until you are completely sure to what set */

      /* I need to release internal resource for Chained TASK
       * (set ready prio instead of dispatch prio) to let RQ Tasks 'preempt'
       * the Chained. */
      p_tcb_term->current_prio = p_tdb_term->ready_prio;
8000b23a:	60 f2       	mov.a %a2,%d15
8000b23c:	39 22 1c 00 	ld.bu %d2,[%a2]28
8000b240:	28 12       	st.b [%a15]1,%d2
      p_tcb_term->status = OSEE_TASK_READY;
8000b242:	82 12       	mov %d2,1
8000b244:	28 22       	st.b [%a15]2,%d2
#if (defined(OSEE_HAS_EVENTS))
      /* If this activation is the last of a TASK, a chaining is
       * a transition from SUSPENDED to READY so I need to reset Events. */
      if (p_tcb_term->current_num_of_act == 1U) {
8000b246:	08 02       	ld.bu %d2,[%a15]0
8000b248:	df 12 04 80 	jne %d2,1,8000b250 <osEE_scheduler_task_terminated+0x74>
8000b24c:	82 02       	mov %d2,0
8000b24e:	68 32       	st.w [%a15]12,%d2
        osEE_task_event_reset_mask(p_tcb_term);
      }
#endif /* OSEE_HAS_EVENTS */

      (void)osEE_scheduler_rq_insert(&p_ccb->rq, p_sn_term, p_tdb_term);
8000b250:	d9 cf 04 00 	lea %a15,[%a12]4
8000b254:	40 f4       	mov.aa %a4,%a15
8000b256:	60 f6       	mov.a %a6,%d15
8000b258:	6d ff 16 fe 	call 8000ae84 <osEE_scheduler_rq_insert>

      {
        CONSTP2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)
          p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000b25c:	40 d4       	mov.aa %a4,%a13
8000b25e:	40 f5       	mov.aa %a5,%a15
8000b260:	6d ff b5 fd 	call 8000adca <osEE_scheduler_core_rq_preempt_stk>

        if (p_prev == NULL) {
8000b264:	7c 25       	jnz.a %a2,8000b26e <osEE_scheduler_task_terminated+0x92>
          /* Restore Stacked.
           * Not Needed to Check Idle TASK since just reinserted the chained
           * in RQ */
          p_tdb_to                = p_ccb->p_stk_sn->p_tdb;
8000b266:	cc c3       	ld.a %a15,[%a12]12
8000b268:	48 18       	ld.w %d8,[%a15]4
          p_ccb->p_curr           = p_tdb_to;
8000b26a:	74 c8       	st.w [%a12],%d8
8000b26c:	3c 02       	j 8000b270 <osEE_scheduler_task_terminated+0x94>
        } else {
          p_tdb_to = p_ccb->p_curr;
8000b26e:	54 c8       	ld.w %d8,[%a12]
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b270:	cc d4       	ld.a %a15,[%a13]16
  return sp;
}

/** The dsync assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_dsync(void) {
  __asm__ volatile ("dsync" : : : "memory");
8000b272:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b276:	82 0f       	mov %d15,0
8000b278:	68 0f       	st.w [%a15]0,%d15
    }
  }
  osEE_unlock_core(p_cdb);

  return p_tdb_to;
}
8000b27a:	60 82       	mov.a %a2,%d8
8000b27c:	00 90       	ret 

8000b27e <osEE_scheduler_task_preemption_point>:
FUNC(OsEE_bool, OS_CODE)
  osEE_scheduler_task_preemption_point
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb
)
{
8000b27e:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b280:	40 9c       	mov.aa %a12,%a9
  VAR(OsEE_bool, AUTOMATIC)                     is_preemption;
  P2VAR(OsEE_preempt, AUTOMATIC, OS_APPL_DATA)  p_prev;
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000b282:	99 cd 0c 00 	ld.a %a13,[%a12]12 <f003000c <_SMALL_DATA4_+0x4002800c>>
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b286:	cc c4       	ld.a %a15,[%a12]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b288:	82 12       	mov %d2,1
8000b28a:	82 03       	mov %d3,0
8000b28c:	0b 23 10 48 	mov %e4,%d3,%d2
8000b290:	49 f4 c0 08 	cmpswap.w [%a15]0,%e4
8000b294:	02 4f       	mov %d15,%d4
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b296:	df 04 f9 ff 	jne %d4,0,8000b288 <osEE_scheduler_task_preemption_point+0xa>
  /* Touch unused parameters */
  (void)p_kdb;
  /* Lock the Scheduler */
  osEE_lock_core(p_cdb);

  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);
8000b29a:	40 c4       	mov.aa %a4,%a12
8000b29c:	d9 d5 04 00 	lea %a5,[%a13]4
8000b2a0:	6d ff 95 fd 	call 8000adca <osEE_scheduler_core_rq_preempt_stk>
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b2a4:	cc c4       	ld.a %a15,[%a12]16
8000b2a6:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b2aa:	68 0f       	st.w [%a15]0,%d15

    osEE_change_context_from_running(p_prev, p_curr);

    is_preemption = OSEE_TRUE;
  } else {
    is_preemption = OSEE_FALSE;
8000b2ac:	82 02       	mov %d2,0
  p_prev = osEE_scheduler_core_rq_preempt_stk(p_cdb, &p_ccb->rq);

  /* Unlock the Scheduler (critical section terminated) */
  osEE_unlock_core(p_cdb);

  if (p_prev != NULL) {
8000b2ae:	bc 26       	jz.a %a2,8000b2ba <osEE_scheduler_task_preemption_point+0x3c>
    CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_curr = p_ccb->p_curr;

    osEE_change_context_from_running(p_prev, p_curr);
8000b2b0:	40 24       	mov.aa %a4,%a2
8000b2b2:	d4 d5       	ld.a %a5,[%a13]
8000b2b4:	6d 00 0d 02 	call 8000b6ce <osEE_change_context_from_running>

    is_preemption = OSEE_TRUE;
8000b2b8:	82 12       	mov %d2,1
  } else {
    is_preemption = OSEE_FALSE;
  }

  return is_preemption;
}
8000b2ba:	00 90       	ret 

8000b2bc <osEE_scheduler_task_set_running>:
(
  P2VAR(OsEE_KDB, AUTOMATIC, OS_APPL_DATA)  p_kdb,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_tdb,
  P2VAR(OsEE_SN,  AUTOMATIC, OS_APPL_DATA)  p_sn
)
{
8000b2bc:	40 ae       	mov.aa %a14,%sp
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b2be:	40 92       	mov.aa %a2,%a9
  CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_DATA) p_cdb = osEE_get_curr_core();
  CONSTP2VAR(OsEE_CCB, AUTOMATIC, OS_APPL_DATA) p_ccb = p_cdb->p_ccb;
8000b2c0:	cc 23       	ld.a %a15,[%a2]12
  CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_preempted = p_ccb->p_curr;
8000b2c2:	c8 04       	ld.a %a4,[%a15]0
  CONSTP2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA)
    p_preempted_sn = p_ccb->p_stk_sn;
8000b2c4:	48 34       	ld.w %d4,[%a15]12

  /* Set previous TASK as stacked only if the activation has been completed */
  if (p_preempted->p_tcb->status == OSEE_TASK_RUNNING) {
8000b2c6:	99 43 0c 00 	ld.a %a3,[%a4]12 <80000003 <BootModeHeader0+0x3>>
8000b2ca:	0c 32       	ld.bu %d15,[%a3]2
8000b2cc:	5e 43       	jne %d15,4,8000b2d2 <osEE_scheduler_task_set_running+0x16>
    p_preempted->p_tcb->status  = OSEE_TASK_READY_STACKED;
8000b2ce:	82 2f       	mov %d15,2
8000b2d0:	2c 32       	st.b [%a3]2,%d15
  }
  p_ccb->p_curr                 = p_tdb;
8000b2d2:	e8 05       	st.a [%a15]0,%a5

  /* Touch unused parameters */
  (void)p_kdb;
  if (p_sn == NULL) {
8000b2d4:	bd 06 17 80 	jnz.a %a6,8000b302 <osEE_scheduler_task_set_running+0x46>
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b2d8:	99 23 10 00 	ld.a %a3,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b2dc:	82 12       	mov %d2,1
8000b2de:	82 03       	mov %d3,0
8000b2e0:	0b 23 10 68 	mov %e6,%d3,%d2
8000b2e4:	49 36 c0 08 	cmpswap.w [%a3]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b2e8:	df 06 fa ff 	jne %d6,0,8000b2dc <osEE_scheduler_task_set_running+0x20>
  P2VAR(OsEE_SN *, AUTOMATIC, OS_APPL_DATA) pp_first
)
{
  P2VAR(OsEE_SN, AUTOMATIC, OS_APPL_DATA) p_sn_allocated;

  p_sn_allocated          = (*pp_first);
8000b2ec:	c8 23       	ld.a %a3,[%a15]8
  (*pp_first)              = p_sn_allocated->p_next;
8000b2ee:	54 37       	ld.w %d7,[%a3]
8000b2f0:	68 27       	st.w [%a15]8,%d7
  p_sn_allocated->p_next  = NULL;
8000b2f2:	74 36       	st.w [%a3],%d6
    osEE_lock_core(p_cdb);
    /* Alloc the SN for the new Running TASK */
    p_ccb->p_stk_sn             = osEE_sn_alloc(&p_ccb->p_free_sn);
8000b2f4:	e8 33       	st.a [%a15]12,%a3
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b2f6:	99 22 10 00 	ld.a %a2,[%a2]16
8000b2fa:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b2fe:	74 26       	st.w [%a2],%d6
8000b300:	3c 02       	j 8000b304 <osEE_scheduler_task_set_running+0x48>
    osEE_unlock_core(p_cdb);
  } else {
    p_ccb->p_stk_sn             = p_sn;
8000b302:	e8 36       	st.a [%a15]12,%a6
  }

  /* In Scheduler partitioned the TASK are stacked */
  p_ccb->p_stk_sn->p_tdb        = p_tdb;
8000b304:	c8 32       	ld.a %a2,[%a15]12
8000b306:	b5 25 04 00 	st.a [%a2]4,%a5
  p_ccb->p_stk_sn->p_next       = p_preempted_sn;
8000b30a:	c8 3f       	ld.a %a15,[%a15]12
8000b30c:	68 04       	st.w [%a15]0,%d4

  osEE_change_context_from_running(p_preempted, p_tdb);
8000b30e:	6d 00 e0 01 	call 8000b6ce <osEE_change_context_from_running>
8000b312:	00 90       	ret 

8000b314 <osEE_counter_insert_abs_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       when
)
{
8000b314:	40 ae       	mov.aa %a14,%sp
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000b316:	d4 42       	ld.a %a2,[%a4]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000b318:	4c 20       	ld.w %d15,[%a2]0
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
8000b31a:	19 25 04 00 	ld.w %d5,[%a2]4
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;
8000b31e:	cc 50       	ld.a %a15,[%a5]0
8000b320:	68 14       	st.w [%a15]4,%d4
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
  CONST(TickType, AUTOMATIC)
    counter_value = p_counter_cb->value;
  VAR(OsEE_bool, AUTOMATIC)
    work_not_done = OSEE_TRUE;
8000b322:	82 13       	mov %d3,1
)
{
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_previous    = NULL;
8000b324:	a0 03       	mov.a %a3,0
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000b326:	0b 45 50 61 	ge.u %d6,%d5,%d4
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000b32a:	82 07       	mov %d7,0
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000b32c:	3c 17       	j 8000b35a <osEE_counter_insert_abs_trigger+0x46>
    CONST(TickType, AUTOMATIC) current_when = p_current->p_trigger_cb->when;
8000b32e:	60 f4       	mov.a %a4,%d15
8000b330:	cc 40       	ld.a %a15,[%a4]0
8000b332:	48 12       	ld.w %d2,[%a15]4

    if (current_when > counter_value) {
8000b334:	7f 25 09 80 	jge.u %d5,%d2,8000b346 <osEE_counter_insert_abs_trigger+0x32>
      /* "Current" belong to this counter-loop */
      if ((when >= current_when) || (when <= counter_value)) {
8000b338:	02 60       	mov %d0,%d6
8000b33a:	0b 24 c0 02 	or.ge.u %d0,%d4,%d2
8000b33e:	76 0b       	jz %d0,8000b354 <osEE_counter_insert_abs_trigger+0x40>
8000b340:	60 f3       	mov.a %a3,%d15
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000b342:	4c f0       	ld.w %d15,[%a15]0
8000b344:	3c 0b       	j 8000b35a <osEE_counter_insert_abs_trigger+0x46>
      } else {
        work_not_done = OSEE_FALSE;
      }
    } else {
      /* "Current" belong to next counter-loop */
      if ((when <= counter_value) && (when >= current_when)) {
8000b346:	0b 24 50 21 	ge.u %d2,%d4,%d2
8000b34a:	26 62       	and %d2,%d6
8000b34c:	76 26       	jz %d2,8000b358 <osEE_counter_insert_abs_trigger+0x44>
8000b34e:	60 f3       	mov.a %a3,%d15
        /* (when <= counter_value) => "New" in the next counter-loop.
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
8000b350:	4c f0       	ld.w %d15,[%a15]0
8000b352:	3c 04       	j 8000b35a <osEE_counter_insert_abs_trigger+0x46>
        /* (when >= current_when) => "New" after "current", still in this loop.
           (when <= counter_value) => "New" in next loop. */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000b354:	02 73       	mov %d3,%d7
8000b356:	3c 02       	j 8000b35a <osEE_counter_insert_abs_trigger+0x46>
         * &&
         * (when >= current_when) => "New" after "current" */
        p_previous  = p_current;
        p_current   = p_current->p_trigger_cb->p_next;
      } else {
        work_not_done = OSEE_FALSE;
8000b358:	02 73       	mov %d3,%d7
    work_not_done = OSEE_TRUE;

  /* Update Trigger Status */
  p_trigger_db->p_trigger_cb->when   = when;

  while ((p_current != NULL) && work_not_done) {
8000b35a:	8b 0f 20 22 	ne %d2,%d15,0
8000b35e:	8b 03 20 24 	and.ne %d2,%d3,0
8000b362:	df 02 e6 ff 	jne %d2,0,8000b32e <osEE_counter_insert_abs_trigger+0x1a>
        work_not_done = OSEE_FALSE;
      }
    }
  }

  if (p_previous != NULL) {
8000b366:	bc 34       	jz.a %a3,8000b36e <osEE_counter_insert_abs_trigger+0x5a>
    p_previous->p_trigger_cb->p_next  = p_trigger_db;
8000b368:	cc 30       	ld.a %a15,[%a3]0
8000b36a:	e8 05       	st.a [%a15]0,%a5
8000b36c:	3c 02       	j 8000b370 <osEE_counter_insert_abs_trigger+0x5c>
  } else {
    p_counter_cb->trigger_queue       = p_trigger_db;
8000b36e:	f4 25       	st.a [%a2],%a5
  }

  p_trigger_db->p_trigger_cb->p_next = p_current;
8000b370:	cc 50       	ld.a %a15,[%a5]0
8000b372:	68 0f       	st.w [%a15]0,%d15
8000b374:	00 90       	ret 

8000b376 <osEE_counter_insert_rel_trigger>:
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db,
  VAR(TickType, AUTOMATIC)                       delta
)
{
8000b376:	40 ae       	mov.aa %a14,%sp
{
  VAR(TickType, AUTOMATIC) when;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
8000b378:	19 42 04 00 	ld.w %d2,[%a4]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000b37c:	cc 40       	ld.a %a15,[%a4]0
8000b37e:	4c f1       	ld.w %d15,[%a15]4

  if ((maxallowedvalue - delta) >= value) {
8000b380:	0b 42 80 50 	sub %d5,%d2,%d4
8000b384:	46 02       	not %d2
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
8000b386:	42 f2       	add %d2,%d15
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
8000b388:	12 43       	add %d3,%d15,%d4
8000b38a:	42 24       	add %d4,%d2
8000b38c:	0b f5 30 f1 	lt.u %d15,%d5,%d15
  osEE_counter_insert_abs_trigger(p_counter_db, p_trigger_db,
8000b390:	6a 34       	cmovn %d4,%d15,%d3
8000b392:	6d ff c1 ff 	call 8000b314 <osEE_counter_insert_abs_trigger>
8000b396:	00 90       	ret 

8000b398 <osEE_counter_cancel_trigger>:
  osEE_counter_cancel_trigger
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db,
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_trigger_db
)
{
8000b398:	40 ae       	mov.aa %a14,%sp
8000b39a:	80 53       	mov.d %d3,%a5
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb  = p_counter_db->p_counter_cb;
8000b39c:	cc 40       	ld.a %a15,[%a4]0
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb  = p_trigger_db->p_trigger_cb;
8000b39e:	d4 52       	ld.a %a2,[%a5]
  P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_current     = p_counter_cb->trigger_queue;
8000b3a0:	4c f0       	ld.w %d15,[%a15]0

  if (p_current == p_trigger_db) {
8000b3a2:	7e 34       	jne %d15,%d3,8000b3aa <osEE_counter_cancel_trigger+0x12>
    /* The trigger to be removed is the first one in the queue */
    p_counter_cb->trigger_queue = p_trigger_cb->p_next;
8000b3a4:	4c 20       	ld.w %d15,[%a2]0
8000b3a6:	68 0f       	st.w [%a15]0,%d15
8000b3a8:	00 90       	ret 
  } else {
    P2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA) p_previous;
    do {
      p_previous = p_current;
      p_current  = p_current->p_trigger_cb->p_next;
8000b3aa:	60 f3       	mov.a %a3,%d15
8000b3ac:	cc 30       	ld.a %a15,[%a3]0
8000b3ae:	4c f0       	ld.w %d15,[%a15]0
    } while ((p_current != NULL) && (p_current != p_trigger_db));
8000b3b0:	8b 0f 20 42 	ne %d4,%d15,0
8000b3b4:	0b 3f 10 21 	ne %d2,%d15,%d3
8000b3b8:	8b 0f 20 24 	and.ne %d2,%d15,0
8000b3bc:	df 02 f7 ff 	jne %d2,0,8000b3aa <osEE_counter_cancel_trigger+0x12>

    if (p_current != NULL) {
8000b3c0:	76 43       	jz %d4,8000b3c6 <osEE_counter_cancel_trigger+0x2e>
      /* Remove p_trigger_db from the list */
      p_previous->p_trigger_cb->p_next = p_trigger_cb->p_next;
8000b3c2:	4c 20       	ld.w %d15,[%a2]0
8000b3c4:	68 0f       	st.w [%a15]0,%d15
8000b3c6:	00 90       	ret 

8000b3c8 <osEE_counter_increment>:
FUNC(void, OS_CODE)
  osEE_counter_increment
(
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA) p_counter_db
)
{
8000b3c8:	40 ae       	mov.aa %a14,%sp
8000b3ca:	20 10       	sub.a %sp,16
  CONSTP2VAR(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb = p_counter_db->p_counter_cb;
8000b3cc:	d4 43       	ld.a %a3,[%a4]
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b3ce:	40 95       	mov.aa %a5,%a9
    CONSTP2VAR(OsEE_CDB, AUTOMATIC, OS_APPL_CONST)
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
8000b3d0:	19 34 04 00 	ld.w %d4,[%a3]4
8000b3d4:	4c 41       	ld.w %d15,[%a4]4
8000b3d6:	3f f4 06 80 	jlt.u %d4,%d15,8000b3e2 <osEE_counter_increment+0x1a>
      counter_value       = 0U;
      p_counter_cb->value = 0U;
8000b3da:	82 0f       	mov %d15,0
8000b3dc:	6c 31       	st.w [%a3]4,%d15
      p_cdb = osEE_get_curr_core();

    /* Counter Increment can be done outside lock critical section, since only
       a core is allowed to do that */
    if (p_counter_cb->value >= p_counter_db->info.maxallowedvalue) {
      counter_value       = 0U;
8000b3de:	82 04       	mov %d4,0
8000b3e0:	3c 04       	j 8000b3e8 <osEE_counter_increment+0x20>
      p_counter_cb->value = 0U;
    } else {
      ++p_counter_cb->value;
8000b3e2:	c2 14       	add %d4,1
8000b3e4:	59 34 04 00 	st.w [%a3]4,%d4
 *  \param [in] p_cdb The core to lock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_lock(p_cdb->p_lock);
8000b3e8:	cc 54       	ld.a %a15,[%a5]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b3ea:	82 12       	mov %d2,1
8000b3ec:	82 03       	mov %d3,0
8000b3ee:	0b 23 10 68 	mov %e6,%d3,%d2
8000b3f2:	49 f6 c0 08 	cmpswap.w [%a15]0,%e6
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b3f6:	df 06 fa ff 	jne %d6,0,8000b3ea <osEE_counter_increment+0x22>
            to not have nested critical sections.
            To handle possible races due to cycling triggers a state
            protocol have been implemented. */
    osEE_lock_core(p_cdb);

    p_triggered_db = p_counter_cb->trigger_queue;
8000b3fa:	d4 3c       	ld.a %a12,[%a3]

    if (p_triggered_db != NULL) {
8000b3fc:	bd 0c 89 00 	jz.a %a12,8000b50e <osEE_counter_increment+0x146>
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;

      if (p_triggered_cb->when == counter_value) {
8000b400:	cc c0       	ld.a %a15,[%a12]0
8000b402:	4c f1       	ld.w %d15,[%a15]4
8000b404:	40 c2       	mov.aa %a2,%a12
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000b406:	82 33       	mov %d3,3

    if (p_triggered_db != NULL) {
      P2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
        p_triggered_cb = p_triggered_db->p_trigger_cb;

      if (p_triggered_cb->when == counter_value) {
8000b408:	3e 43       	jeq %d15,%d4,8000b40e <osEE_counter_increment+0x46>
8000b40a:	3c 7c       	j 8000b502 <osEE_counter_increment+0x13a>
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
8000b40c:	40 f2       	mov.aa %a2,%a15
          p_previous;

        do {
          /* Now I will use previous to hold the previous checked alarm */
          CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
            p_current_cb = p_current->p_trigger_cb;
8000b40e:	cc 20       	ld.a %a15,[%a2]0
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
8000b410:	28 83       	st.b [%a15]8,%d3
          p_current = p_current_cb->p_next;
8000b412:	c8 0f       	ld.a %a15,[%a15]0
        } while ((p_current != NULL) &&
          (p_current->p_trigger_cb->when == counter_value));
8000b414:	bc f6       	jz.a %a15,8000b420 <osEE_counter_increment+0x58>
8000b416:	c8 06       	ld.a %a6,[%a15]0
8000b418:	19 62 04 00 	ld.w %d2,[%a6]4
            p_current_cb = p_current->p_trigger_cb;
          p_previous = p_current;
          /* Set this Trigger as Expired */
          p_current_cb->status = OSEE_TRIGGER_EXPIRED;
          p_current = p_current_cb->p_next;
        } while ((p_current != NULL) &&
8000b41c:	5f 2f f8 7f 	jeq %d15,%d2,8000b40c <osEE_counter_increment+0x44>
8000b420:	b5 e4 f4 ff 	st.a [%a14]-12,%a4
          (p_current->p_trigger_cb->when == counter_value));

        /* I set the end of handled queue */
        p_previous->p_trigger_cb->p_next = NULL;
8000b424:	d4 22       	ld.a %a2,[%a2]
8000b426:	82 0f       	mov %d15,0
8000b428:	6c 20       	st.w [%a2]0,%d15
        /* I set the head of the trigger queue to the current value
           (maybe NULL) */
        p_counter_cb->trigger_queue = p_current;
8000b42a:	ec 30       	st.a [%a3]0,%a15
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b42c:	cc 54       	ld.a %a15,[%a5]16
8000b42e:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b432:	68 0f       	st.w [%a15]0,%d15
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000b434:	82 0a       	mov %d10,0
  switch (p_action->type) {
8000b436:	7b 10 00 b8 	movh %d11,32769
8000b43a:	1b 0b 46 bb 	addi %d11,%d11,-19360

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);

      if (p_sn != NULL) {
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000b43e:	91 00 00 f8 	movh.a %a15,32768
8000b442:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
      /* Reinsert the trigger in timer wheel as relative with delta equal to
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
8000b446:	82 2e       	mov %d14,2
8000b448:	82 0c       	mov %d12,0
#endif /* OSEE_HAS_ALARMS || OSEE_HAS_SCHEDULE_TABLES */

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
8000b44a:	d4 c2       	ld.a %a2,[%a12]
8000b44c:	54 2d       	ld.w %d13,[%a2]
  osEE_handle_action
(
  P2VAR(OsEE_action, AUTOMATIC, OS_APPL_CONST) p_action
)
{
  VAR(StatusType, AUTOMATIC) ev = E_OK;
8000b44e:	e9 ea ff ff 	st.b [%a14]-1,%d10
  switch (p_action->type) {
8000b452:	39 cf 18 00 	ld.bu %d15,[%a12]24
8000b456:	ff 4f 32 80 	jge.u %d15,4,8000b4ba <osEE_counter_increment+0xf2>
8000b45a:	60 b3       	mov.a %a3,%d11
8000b45c:	90 32       	addsc.a %a2,%a3,%d15,2
8000b45e:	dc 02       	ji %a2
8000b460:	1d 00 08 00 	j 8000b470 <osEE_counter_increment+0xa8>
8000b464:	1d 00 14 00 	j 8000b48c <osEE_counter_increment+0xc4>
8000b468:	1d 00 20 00 	j 8000b4a8 <osEE_counter_increment+0xe0>
8000b46c:	1d 00 23 00 	j 8000b4b2 <osEE_counter_increment+0xea>
    case OSEE_ACTION_TASK:
    {
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb     = p_action->param.p_tdb;
8000b470:	99 cd 0c 00 	ld.a %a13,[%a12]12

      ev = osEE_task_activated(p_tdb);
8000b474:	40 d4       	mov.aa %a4,%a13
8000b476:	6d ff 22 fd 	call 8000aeba <osEE_task_activated>
8000b47a:	e9 e2 ff ff 	st.b [%a14]-1,%d2
      if (ev == E_OK) {
8000b47e:	df 02 1e 80 	jne %d2,0,8000b4ba <osEE_counter_increment+0xf2>
        (void)osEE_scheduler_task_insert(osEE_get_kernel(), p_tdb);
8000b482:	40 f4       	mov.aa %a4,%a15
8000b484:	40 d5       	mov.aa %a5,%a13
8000b486:	6d ff 11 fe 	call 8000b0a8 <osEE_scheduler_task_insert>
8000b48a:	3c 18       	j 8000b4ba <osEE_counter_increment+0xf2>
      CONSTP2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)
        p_tdb = p_action->param.p_tdb;
      CONST(EventMaskType, AUTOMATIC)
        mask = p_action->param.mask;

      p_sn = osEE_task_event_set_mask(p_tdb, mask, &ev);
8000b48c:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000b490:	19 c4 14 00 	ld.w %d4,[%a12]20
8000b494:	d9 e5 ff ff 	lea %a5,[%a14]-1
8000b498:	6d ff 40 fd 	call 8000af18 <osEE_task_event_set_mask>

      if (p_sn != NULL) {
8000b49c:	bc 2f       	jz.a %a2,8000b4ba <osEE_counter_increment+0xf2>
        /* Release the TASK (and the SN) */
        (void)osEE_scheduler_task_unblocked(osEE_get_kernel(), p_sn);
8000b49e:	40 f4       	mov.aa %a4,%a15
8000b4a0:	40 25       	mov.aa %a5,%a2
8000b4a2:	6d ff 4b fe 	call 8000b138 <osEE_scheduler_task_unblocked>
8000b4a6:	3c 0a       	j 8000b4ba <osEE_counter_increment+0xf2>
      }
    }
    break;
#endif /* OSEE_HAS_EVENTS */
    case OSEE_ACTION_COUNTER:
      osEE_counter_increment(p_action->param.p_counter_db);
8000b4a8:	99 c4 10 00 	ld.a %a4,[%a12]16
8000b4ac:	6d ff 8e ff 	call 8000b3c8 <osEE_counter_increment>
8000b4b0:	3c 05       	j 8000b4ba <osEE_counter_increment+0xf2>
      CONST(OsEE_os_context, AUTOMATIC)
        prev_os_context = p_ccb->os_context;

      p_ccb->os_context = OSEE_ALARMCALLBACK_CTX;
#endif /* OSEE_HAS_CONTEXT */
      p_action->param.f();
8000b4b2:	99 c2 08 00 	ld.a %a2,[%a12]8
8000b4b6:	2d 02 00 00 	calli %a2
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b4ba:	40 9d       	mov.aa %a13,%a9
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE
  osEE_lock_and_get_curr_core(void)
{
  OsEE_CDB * const p_cdb = osEE_get_curr_core();

  osEE_hal_spin_lock(p_cdb->p_lock);
8000b4bc:	99 d2 10 00 	ld.a %a2,[%a13]16 <f0030010 <_SMALL_DATA4_+0x40028010>>
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b4c0:	82 18       	mov %d8,1
8000b4c2:	82 09       	mov %d9,0
8000b4c4:	0b 89 10 28 	mov %e2,%d9,%d8
8000b4c8:	49 22 c0 08 	cmpswap.w [%a2]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b4cc:	df 02 fa ff 	jne %d2,0,8000b4c0 <osEE_counter_increment+0xf8>
  );

  /* Re-enter in critical section to reinsert alarm-trigger if needed */
  p_cdb = osEE_lock_and_get_curr_core();

  p_trigger_to_be_handled_cb = p_trigger_to_be_handled_db->p_trigger_cb;
8000b4d0:	d4 c2       	ld.a %a2,[%a12]

  if (p_trigger_to_be_handled_cb->status == OSEE_TRIGGER_EXPIRED) {
8000b4d2:	0c 28       	ld.bu %d15,[%a2]8
8000b4d4:	5e 3e       	jne %d15,3,8000b4f0 <osEE_counter_increment+0x128>
    CONST(TickType, AUTOMATIC) cycle = osEE_alarm_get_cb(
8000b4d6:	19 24 0c 00 	ld.w %d4,[%a2]12
        osEE_trigger_get_alarm_db(p_trigger_to_be_handled_db)
      )->cycle;
    if (cycle > 0U) {
8000b4da:	76 49       	jz %d4,8000b4ec <osEE_counter_increment+0x124>
      /* Reinsert the trigger in timer wheel as relative with delta equal to
         cycle */
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_ACTIVE;
8000b4dc:	e9 2e 08 00 	st.b [%a2]8,%d14
      osEE_counter_insert_rel_trigger(p_counter_db,
8000b4e0:	99 e4 f4 ff 	ld.a %a4,[%a14]-12
8000b4e4:	40 c5       	mov.aa %a5,%a12
8000b4e6:	6d ff 48 ff 	call 8000b376 <osEE_counter_insert_rel_trigger>
8000b4ea:	3c 03       	j 8000b4f0 <osEE_counter_increment+0x128>
        p_trigger_to_be_handled_db, cycle);
    } else {
      p_trigger_to_be_handled_cb->status = OSEE_TRIGGER_INACTIVE;
8000b4ec:	e9 2a 08 00 	st.b [%a2]8,%d10
 *  \param [in] p_cdb The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core(OsEE_CDB * const p_cdb)
{
  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b4f0:	99 d2 10 00 	ld.a %a2,[%a13]16 <f0030010 <_SMALL_DATA4_+0x40028010>>
8000b4f4:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b4f8:	74 2c       	st.w [%a2],%d12
#endif /* OSEE_HAS_ALARMS || OSEE_HAS_SCHEDULE_TABLES */

          /* Prepare next trigger to be handled here, before actually handle
           * the current one, otherwise cycling triggers will mess with the
           * list of triggers that have to be handled now */
          p_triggered_db = p_triggered_db->p_trigger_cb->p_next;
8000b4fa:	60 dc       	mov.a %a12,%d13
#elif (defined(OSEE_HAS_SCHEDULE_TABLES))
          osEE_counter_handle_st_expiry_point(p_counter_db,
            p_trigger_to_be_handled_db);
#endif /* OSEE_COUNTER_TRIGGER_TYPES elif OSEE_HAS_ALARMS elif
          OSEE_HAS_SCHEDULE_TABLES */
        } while (p_triggered_db != NULL);
8000b4fc:	bd 0c a7 ff 	jnz.a %a12,8000b44a <osEE_counter_increment+0x82>
8000b500:	00 90       	ret 
8000b502:	cc 54       	ld.a %a15,[%a5]16
8000b504:	0d 00 80 04 	dsync 
8000b508:	82 0f       	mov %d15,0
8000b50a:	68 0f       	st.w [%a15]0,%d15
8000b50c:	00 90       	ret 
8000b50e:	cc 54       	ld.a %a15,[%a5]16
8000b510:	0d 00 80 04 	dsync 
8000b514:	82 0f       	mov %d15,0
8000b516:	68 0f       	st.w [%a15]0,%d15
8000b518:	00 90       	ret 
	...

8000b51c <osEE_alarm_set_rel>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      increment,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000b51c:	40 ae       	mov.aa %a14,%sp
8000b51e:	40 4d       	mov.aa %a13,%a4
8000b520:	80 5b       	mov.d %d11,%a5
8000b522:	02 4c       	mov %d12,%d4
8000b524:	02 5d       	mov %d13,%d5
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_alarm_cb;
#else
  return p_alarm_db->p_trigger_cb;
8000b526:	d4 5c       	ld.a %a12,[%a5]
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
8000b528:	79 4a 10 00 	ld.b %d10,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b52c:	02 a4       	mov %d4,%d10
8000b52e:	6d 00 c3 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000b532:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b534:	82 18       	mov %d8,1
8000b536:	82 09       	mov %d9,0
8000b538:	0b 89 10 28 	mov %e2,%d9,%d8
8000b53c:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b540:	df 02 fa ff 	jne %d2,0,8000b534 <osEE_alarm_set_rel+0x18>
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000b544:	0c c8       	ld.bu %d15,[%a12]8
    ev = E_OS_STATE;
8000b546:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
  /* Lock the Core Lock witch the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000b548:	ff 2f 22 80 	jge.u %d15,2,8000b58c <osEE_alarm_set_rel+0x70>
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000b54c:	de 16       	jne %d15,1,8000b578 <osEE_alarm_set_rel+0x5c>
    p_alarm_cb->cycle = cycle;
8000b54e:	59 cd 0c 00 	st.w [%a12]12,%d13
{
  VAR(TickType, AUTOMATIC) when;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
8000b552:	19 d2 04 00 	ld.w %d2,[%a13]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000b556:	cc d0       	ld.a %a15,[%a13]0
8000b558:	4c f1       	ld.w %d15,[%a15]4

  if ((maxallowedvalue - delta) >= value) {
8000b55a:	0b c2 80 40 	sub %d4,%d2,%d12
8000b55e:	46 02       	not %d2
    when = value + delta;
  } else {
    when = delta - (maxallowedvalue - value) - 1U;
8000b560:	42 f2       	add %d2,%d15
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if ((maxallowedvalue - delta) >= value) {
    when = value + delta;
8000b562:	12 c3       	add %d3,%d15,%d12
8000b564:	42 2c       	add %d12,%d2
8000b566:	0b f4 30 f1 	lt.u %d15,%d4,%d15
8000b56a:	2b 3c 40 ff 	sel %d15,%d15,%d12,%d3
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       'here' when based on increment */
    p_trigger_cb->when   = osEE_counter_eval_when(p_counter_db, increment);
8000b56e:	6c c1       	st.w [%a12]4,%d15
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000b570:	82 4f       	mov %d15,4
8000b572:	2c c8       	st.b [%a12]8,%d15

    ev = E_OK;
8000b574:	82 08       	mov %d8,0
8000b576:	3c 0b       	j 8000b58c <osEE_alarm_set_rel+0x70>
  } else {
    p_alarm_cb->cycle = cycle;
8000b578:	59 cd 0c 00 	st.w [%a12]12,%d13
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000b57c:	82 2f       	mov %d15,2
8000b57e:	2c c8       	st.b [%a12]8,%d15
 
    osEE_counter_insert_rel_trigger(
8000b580:	40 d4       	mov.aa %a4,%a13
8000b582:	60 b5       	mov.a %a5,%d11
8000b584:	02 c4       	mov %d4,%d12
8000b586:	6d ff f8 fe 	call 8000b376 <osEE_counter_insert_rel_trigger>
      p_counter_db, p_trigger_db, increment
    );
 
    ev = E_OK;
8000b58a:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b58c:	02 a4       	mov %d4,%d10
8000b58e:	6d 00 93 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b592:	cc 24       	ld.a %a15,[%a2]16
8000b594:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b598:	82 0f       	mov %d15,0
8000b59a:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000b59c:	02 82       	mov %d2,%d8
8000b59e:	00 90       	ret 

8000b5a0 <osEE_alarm_set_abs>:
  P2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)  p_counter_db,
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  VAR(TickType,   AUTOMATIC)                      start,
  VAR(TickType,   AUTOMATIC)                      cycle
)
{
8000b5a0:	40 ae       	mov.aa %a14,%sp
8000b5a2:	80 4b       	mov.d %d11,%a4
8000b5a4:	40 5d       	mov.aa %a13,%a5
8000b5a6:	02 4c       	mov %d12,%d4
8000b5a8:	02 5d       	mov %d13,%d5
)
{
#if (defined(OSEE_COUNTER_TRIGGER_TYPES))
  return p_alarm_db->p_alarm_cb;
#else
  return p_alarm_db->p_trigger_cb;
8000b5aa:	d4 5c       	ld.a %a12,[%a5]
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
8000b5ac:	79 4a 10 00 	ld.b %d10,[%a4]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b5b0:	02 a4       	mov %d4,%d10
8000b5b2:	6d 00 81 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000b5b6:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b5b8:	82 18       	mov %d8,1
8000b5ba:	82 09       	mov %d9,0
8000b5bc:	0b 89 10 28 	mov %e2,%d9,%d8
8000b5c0:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b5c4:	df 02 fa ff 	jne %d2,0,8000b5b8 <osEE_alarm_set_abs+0x18>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000b5c8:	0c c8       	ld.bu %d15,[%a12]8
    ev = E_OS_STATE;
8000b5ca:	82 78       	mov %d8,7
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status > OSEE_TRIGGER_CANCELED) {
8000b5cc:	ff 2f 15 80 	jge.u %d15,2,8000b5f6 <osEE_alarm_set_abs+0x56>
    ev = E_OS_STATE;
  } else if (p_trigger_cb->status == OSEE_TRIGGER_CANCELED) {
8000b5d0:	5e 19       	jne %d15,1,8000b5e2 <osEE_alarm_set_abs+0x42>
    p_alarm_cb->cycle = cycle;
8000b5d2:	59 cd 0c 00 	st.w [%a12]12,%d13
    /* Re-turn on the trigger, that is in handling, since is handling I'll set
       here 'when' based on start */
    p_trigger_cb->when   = start;
8000b5d6:	59 cc 04 00 	st.w [%a12]4,%d12
    p_trigger_cb->status = OSEE_TRIGGER_REENABLED;
8000b5da:	82 4f       	mov %d15,4
8000b5dc:	2c c8       	st.b [%a12]8,%d15

    ev = E_OK;
8000b5de:	82 08       	mov %d8,0
8000b5e0:	3c 0b       	j 8000b5f6 <osEE_alarm_set_abs+0x56>
  } else {
    p_alarm_cb->cycle = cycle;
8000b5e2:	59 cd 0c 00 	st.w [%a12]12,%d13
    /* Turn On the Trigger */
    p_trigger_cb->status = OSEE_TRIGGER_ACTIVE;
8000b5e6:	82 2f       	mov %d15,2
8000b5e8:	2c c8       	st.b [%a12]8,%d15

    osEE_counter_insert_abs_trigger(
8000b5ea:	60 b4       	mov.a %a4,%d11
8000b5ec:	40 d5       	mov.aa %a5,%a13
8000b5ee:	02 c4       	mov %d4,%d12
8000b5f0:	6d ff 92 fe 	call 8000b314 <osEE_counter_insert_abs_trigger>
      p_counter_db, p_trigger_db, start
    );

    ev = E_OK;
8000b5f4:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b5f6:	02 a4       	mov %d4,%d10
8000b5f8:	6d 00 5e 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b5fc:	cc 24       	ld.a %a15,[%a2]16
8000b5fe:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b602:	82 0f       	mov %d15,0
8000b604:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000b606:	02 82       	mov %d2,%d8
8000b608:	00 90       	ret 

8000b60a <osEE_alarm_cancel>:
FUNC(StatusType, OS_CODE)
  osEE_alarm_cancel
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db
)
{
8000b60a:	40 ae       	mov.aa %a14,%sp
8000b60c:	40 4c       	mov.aa %a12,%a4
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2VAR(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000b60e:	d4 4d       	ld.a %a13,[%a4]
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000b610:	19 4b 04 00 	ld.w %d11,[%a4]4
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
8000b614:	60 bf       	mov.a %a15,%d11
8000b616:	79 fa 10 00 	ld.b %d10,[%a15]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b61a:	02 a4       	mov %d4,%d10
8000b61c:	6d 00 4c 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000b620:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b622:	82 18       	mov %d8,1
8000b624:	82 09       	mov %d9,0
8000b626:	0b 89 10 28 	mov %e2,%d9,%d8
8000b62a:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b62e:	df 02 fa ff 	jne %d2,0,8000b622 <osEE_alarm_cancel+0x18>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000b632:	0c d8       	ld.bu %d15,[%a13]8
    ev = E_OS_NOFUNC;
8000b634:	82 58       	mov %d8,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000b636:	bf 2f 0f 80 	jlt.u %d15,2,8000b654 <osEE_alarm_cancel+0x4a>
    ev = E_OS_NOFUNC;
  } else if (p_trigger_cb->status >= OSEE_TRIGGER_EXPIRED) {
8000b63a:	bf 3f 06 80 	jlt.u %d15,3,8000b646 <osEE_alarm_cancel+0x3c>
    p_trigger_cb->status = OSEE_TRIGGER_CANCELED;
8000b63e:	82 1f       	mov %d15,1
8000b640:	2c d8       	st.b [%a13]8,%d15
    ev = E_OK;
8000b642:	82 08       	mov %d8,0
8000b644:	3c 08       	j 8000b654 <osEE_alarm_cancel+0x4a>
  } else {
    p_trigger_cb->status = OSEE_TRIGGER_INACTIVE;
8000b646:	82 0f       	mov %d15,0
8000b648:	2c d8       	st.b [%a13]8,%d15
    osEE_counter_cancel_trigger(p_counter_db, p_trigger_db);
8000b64a:	60 b4       	mov.a %a4,%d11
8000b64c:	40 c5       	mov.aa %a5,%a12
8000b64e:	6d ff a5 fe 	call 8000b398 <osEE_counter_cancel_trigger>
    ev = E_OK;
8000b652:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b654:	02 a4       	mov %d4,%d10
8000b656:	6d 00 2f 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b65a:	cc 24       	ld.a %a15,[%a2]16
8000b65c:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b660:	82 0f       	mov %d15,0
8000b662:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000b664:	02 82       	mov %d2,%d8
8000b666:	00 90       	ret 

8000b668 <osEE_alarm_get>:
  osEE_alarm_get
(
  P2VAR(OsEE_AlarmDB, AUTOMATIC, OS_APPL_DATA)    p_alarm_db,
  P2VAR(TickType, AUTOMATIC, OS_APPL_DATA)        p_tick
)
{
8000b668:	40 ae       	mov.aa %a14,%sp
8000b66a:	80 5b       	mov.d %d11,%a5
  VAR(StatusType, AUTOMATIC) ev;
  CONSTP2VAR(OsEE_TriggerDB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_db = osEE_alarm_get_trigger_db(p_alarm_db);
  CONSTP2CONST(OsEE_TriggerCB, AUTOMATIC, OS_APPL_DATA)
    p_trigger_cb = p_trigger_db->p_trigger_cb;
8000b66c:	d4 4d       	ld.a %a13,[%a4]
  CONSTP2VAR(OsEE_CounterDB, AUTOMATIC, OS_APPL_DATA)
    p_counter_db = p_trigger_db->p_counter_db;
8000b66e:	99 4c 04 00 	ld.a %a12,[%a4]4
#if (!defined(OSEE_SINGLECORE))
  CONST(CoreIdType, AUTOMATIC)
    counter_core_id = p_counter_db->core_id;
8000b672:	79 ca 10 00 	ld.b %d10,[%a12]16
 *  \param [in] core_id The core to lock	
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_lock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b676:	02 a4       	mov %d4,%d10
8000b678:	6d 00 1e 01 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_lock(p_cdb->p_lock);
8000b67c:	cc 24       	ld.a %a15,[%a2]16
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b67e:	82 18       	mov %d8,1
8000b680:	82 09       	mov %d9,0
8000b682:	0b 89 10 28 	mov %e2,%d9,%d8
8000b686:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
/** @brief Acquire a spin-lock, spin inside if the spin-lock is already busy.
    @param p_lock spin-lock to be acquired. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_lock(OsEE_spin_lock * p_lock)
{
  while (osEE_tc_cmpswapw(p_lock, 1U, 0U) != 0U) {
8000b68a:	df 02 fa ff 	jne %d2,0,8000b67e <osEE_alarm_get+0x16>
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000b68e:	0c d8       	ld.bu %d15,[%a13]8
    ev = E_OS_NOFUNC;
8000b690:	82 58       	mov %d8,5
    counter_core_id = p_counter_db->core_id;
/* Lock the Core Lock to whom the counter is tied */
  osEE_lock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */

  if (p_trigger_cb->status <= OSEE_TRIGGER_CANCELED) {
8000b692:	bf 2f 14 80 	jlt.u %d15,2,8000b6ba <osEE_alarm_get+0x52>
    ev = E_OS_NOFUNC;
  } else {
    *p_tick = osEE_counter_eval_delta(p_counter_db, p_trigger_cb->when);
8000b696:	19 d2 04 00 	ld.w %d2,[%a13]4
{
  VAR(TickType, AUTOMATIC) delta;
  CONSTP2CONST(OsEE_CounterCB, AUTOMATIC, OS_APPL_DATA)
    p_counter_cb    = p_counter_db->p_counter_cb;
  CONST(TickType, AUTOMATIC)
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
8000b69a:	19 c3 04 00 	ld.w %d3,[%a12]4
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;
8000b69e:	cc c0       	ld.a %a15,[%a12]0
8000b6a0:	4c f1       	ld.w %d15,[%a15]4
8000b6a2:	42 23       	add %d3,%d2

  if (when > value) {
    delta = when - value;
  } else {
    delta = (maxallowedvalue - value) + when + 1U;
8000b6a4:	c2 13       	add %d3,1
    maxallowedvalue = p_counter_db->info.maxallowedvalue;
  CONST(TickType, AUTOMATIC)
    value           = p_counter_cb->value;

  if (when > value) {
    delta = when - value;
8000b6a6:	0b f2 80 40 	sub %d4,%d2,%d15
8000b6aa:	a2 f3       	sub %d3,%d15
8000b6ac:	0b 2f 50 f1 	ge.u %d15,%d15,%d2
8000b6b0:	2b 43 40 ff 	sel %d15,%d15,%d3,%d4
8000b6b4:	60 bf       	mov.a %a15,%d11
8000b6b6:	68 0f       	st.w [%a15]0,%d15
    ev = E_OK;
8000b6b8:	82 08       	mov %d8,0
 *  \param [in] core_id The core ID to unlock
 */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_unlock_core_id(CoreIdType core_id)
{
  OsEE_CDB * const p_cdb = osEE_get_core(core_id);
8000b6ba:	02 a4       	mov %d4,%d10
8000b6bc:	6d 00 fc 00 	call 8000b8b4 <osEE_get_core>

  osEE_hal_spin_unlock(p_cdb->p_lock);
8000b6c0:	cc 24       	ld.a %a15,[%a2]16
8000b6c2:	0d 00 80 04 	dsync 
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_hal_spin_unlock(OsEE_spin_lock * p_lock)
{
  /* Commit all the changes in memory */
  osEE_tc_dsync();
  (*p_lock) = 0U;
8000b6c6:	82 0f       	mov %d15,0
8000b6c8:	68 0f       	st.w [%a15]0,%d15
  }
#if (!defined(OSEE_SINGLECORE))
  osEE_unlock_core_id(counter_core_id);
#endif /* OSEE_SINGLECORE */
  return ev;
}
8000b6ca:	02 82       	mov %d2,%d8
8000b6cc:	00 90       	ret 

8000b6ce <osEE_change_context_from_running>:
  osEE_change_context_from_running
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000b6ce:	40 ae       	mov.aa %a14,%sp
8000b6d0:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000b6d2:	99 52 0c 00 	ld.a %a2,[%a5]12
8000b6d6:	0c 22       	ld.bu %d15,[%a2]2
8000b6d8:	5e 28       	jne %d15,2,8000b6e8 <osEE_change_context_from_running+0x1a>
    osEE_hal_save_ctx_and_restore_ctx(p_to, p_to->hdb.p_scb,
8000b6da:	40 54       	mov.aa %a4,%a5
8000b6dc:	99 55 04 00 	ld.a %a5,[%a5]4
8000b6e0:	c8 16       	ld.a %a6,[%a15]4
8000b6e2:	6d 00 36 01 	call 8000b94e <osEE_hal_save_ctx_and_restore_ctx>
8000b6e6:	00 90       	ret 
      p_from->hdb.p_scb);
  } else {
    osEE_hal_save_ctx_and_ready2stacked(p_to, p_to->hdb.p_scb,
8000b6e8:	40 54       	mov.aa %a4,%a5
8000b6ea:	99 55 04 00 	ld.a %a5,[%a5]4
8000b6ee:	c8 16       	ld.a %a6,[%a15]4
8000b6f0:	6d 00 4e 01 	call 8000b98c <osEE_hal_save_ctx_and_ready2stacked>
8000b6f4:	00 90       	ret 

8000b6f6 <osEE_change_context_from_task_end>:
  osEE_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_from,
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000b6f6:	40 ae       	mov.aa %a14,%sp
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000b6f8:	cc 53       	ld.a %a15,[%a5]12
8000b6fa:	0c f2       	ld.bu %d15,[%a15]2
8000b6fc:	5e 27       	jne %d15,2,8000b70a <osEE_change_context_from_task_end+0x14>
    osEE_hal_restore_ctx(p_to, p_to->hdb.p_scb);
8000b6fe:	40 54       	mov.aa %a4,%a5
8000b700:	99 55 04 00 	ld.a %a5,[%a5]4
8000b704:	6d 00 37 01 	call 8000b972 <osEE_hal_restore_ctx>
8000b708:	00 90       	ret 
  } else {
    osEE_hal_ready2stacked(p_to, p_to->hdb.p_scb);
8000b70a:	40 54       	mov.aa %a4,%a5
8000b70c:	99 55 04 00 	ld.a %a5,[%a5]4
8000b710:	6d 00 50 01 	call 8000b9b0 <osEE_hal_ready2stacked>
8000b714:	00 90       	ret 

8000b716 <osEE_idle_task_terminate>:
FUNC(void, OS_CODE)
  osEE_idle_task_terminate
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA) p_idle_tdb
)
{
8000b716:	40 ae       	mov.aa %a14,%sp
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_ctx;

  CONSTP2VAR(OsEE_HDB, AUTOMATIC, OS_APPL_DATA) p_idle_hdb  = &p_idle_tdb->hdb;
  CONSTP2VAR(OsEE_SDB, AUTOMATIC, OS_APPL_DATA) p_sdb       = p_idle_hdb->p_sdb;
  CONSTP2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA) p_scb       = p_idle_hdb->p_scb;
8000b718:	99 45 04 00 	ld.a %a5,[%a4]4
  CONSTP2CONST(OsEE_CTX, AUTOMATIC, OS_APPL_DATA) p_bos     = p_sdb->p_bos;
8000b71c:	cc 40       	ld.a %a15,[%a4]0
8000b71e:	48 03       	ld.w %d3,[%a15]0
  P2VAR(OsEE_CTX, AUTOMATIC, OS_APPL_DATA)      p_tos       = p_scb->p_tos;
8000b720:	cc 50       	ld.a %a15,[%a5]0
8000b722:	3c 02       	j 8000b726 <osEE_idle_task_terminate+0x10>

  do {
    p_ctx = p_tos;
    p_tos = p_tos->p_ctx;
8000b724:	60 ff       	mov.a %a15,%d15
8000b726:	4c f0       	ld.w %d15,[%a15]0
  } while ((p_tos != NULL) && (p_tos != p_bos));
8000b728:	8b 0f 20 22 	ne %d2,%d15,0
8000b72c:	0b 3f 10 22 	and.ne %d2,%d15,%d3
8000b730:	df 02 fa ff 	jne %d2,0,8000b724 <osEE_idle_task_terminate+0xe>

  /* Unwind the stack until the last context*/
  p_scb->p_tos = p_ctx;
8000b734:	ec 50       	st.a [%a5]0,%a15

  osEE_hal_restore_ctx(p_idle_tdb, p_scb);
8000b736:	6d 00 1e 01 	call 8000b972 <osEE_hal_restore_ctx>
8000b73a:	00 90       	ret 

8000b73c <osEE_cpu_startos>:
}
#endif /* OSEE_SINGLECORE */
#endif /* OSEE_TC_HAS_ISR1_TO_CONF */

OsEE_bool osEE_cpu_startos(void)
{
8000b73c:	40 ae       	mov.aa %a14,%sp
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000b73e:	4d c0 e1 ff 	mfcr %d15,$core_id
8000b742:	37 0f 48 30 	extr %d3,%d15,0,8
  MemSize tdb_size;
  OsEE_KDB * const p_kdb = osEE_get_kernel();
  CoreIdType const curr_core_id = osEE_get_curr_core_id();

#if (!defined(OSEE_SINGLECORE))
  if (curr_core_id == OS_CORE_ID_0) {
8000b746:	df 03 17 80 	jne %d3,0,8000b774 <osEE_cpu_startos+0x38>
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000b74a:	3b 10 40 20 	mov %d2,1025
8000b74e:	91 40 00 ff 	movh.a %a15,61444
8000b752:	d9 ff 00 09 	lea %a15,[%a15]-28672 <f0039000 <_SMALL_DATA4_+0x40031000>>
8000b756:	68 02       	st.w [%a15]0,%d2
8000b758:	3b 10 c0 20 	mov %d2,3073
8000b75c:	91 40 00 ff 	movh.a %a15,61444
8000b760:	d9 ff 04 09 	lea %a15,[%a15]-28668 <f0039004 <_SMALL_DATA4_+0x40031004>>
8000b764:	68 02       	st.w [%a15]0,%d2
8000b766:	3b 10 40 21 	mov %d2,5121
8000b76a:	91 40 00 ff 	movh.a %a15,61444
8000b76e:	d9 ff 08 09 	lea %a15,[%a15]-28664 <f0039008 <_SMALL_DATA4_+0x40031008>>
8000b772:	68 02       	st.w [%a15]0,%d2
#if (!defined(OSEE_SINGLECORE))
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
8000b774:	91 00 00 f8 	movh.a %a15,32768
8000b778:	d9 ff 28 50 	lea %a15,[%a15]360 <80000168 <osEE_kdb_var>>
8000b77c:	c8 4f       	ld.a %a15,[%a15]16
8000b77e:	b0 ff       	add.a %a15,-1
  for (i = 0U; i < tdb_size; ++i) {
8000b780:	bd 0f 2d 00 	jz.a %a15,8000b7da <osEE_cpu_startos+0x9e>
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000b784:	91 00 00 28 	movh.a %a2,32768
8000b788:	d9 22 28 50 	lea %a2,[%a2]360 <80000168 <osEE_kdb_var>>
8000b78c:	19 24 0c 00 	ld.w %d4,[%a2]12 <8000000c <BootModeHeader0+0xc>>
8000b790:	16 03       	and %d15,3
8000b792:	8f bf 00 50 	sh %d5,%d15,11
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000b796:	bb f0 ff 6f 	mov.u %d6,65535
8000b79a:	82 0f       	mov %d15,0
8000b79c:	b0 ff       	add.a %a15,-1
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
    /* ISR2 initialization */
    OsEE_TDB  * const p_tdb = (*p_kdb->p_tdb_ptr_array)[i];
8000b79e:	60 43       	mov.a %a3,%d4
8000b7a0:	90 32       	addsc.a %a2,%a3,%d15,2
8000b7a2:	d4 22       	ld.a %a2,[%a2]
#if (!defined(OSEE_SINGLECORE))
    if (p_tdb->orig_core_id == curr_core_id) {
8000b7a4:	79 22 1f 00 	ld.b %d2,[%a2]31
8000b7a8:	5f 32 16 80 	jne %d2,%d3,8000b7d4 <osEE_cpu_startos+0x98>
#endif /* !OSEE_SINGLECORE */
      if (p_tdb->task_type == OSEE_TASK_TYPE_ISR2) {
8000b7ac:	39 22 14 00 	ld.bu %d2,[%a2]20
8000b7b0:	df 22 12 80 	jne %d2,2,8000b7d4 <osEE_cpu_startos+0x98>
#if (defined(OSEE_HAS_SYSTEM_TIMER))
        if (p_tdb->task_func == &osEE_tricore_system_timer_handler) {
          osEE_tc_initialize_system_timer(p_tdb);
        } else
#endif /* OSEE_HAS_SYSTEM_TIMER */
        if (p_tdb->hdb.isr2_src != OSEE_TC_SRC_INVALID) {
8000b7b4:	b9 22 08 00 	ld.hu %d2,[%a2]8
8000b7b8:	5f 62 0e 00 	jeq %d2,%d6,8000b7d4 <osEE_cpu_startos+0x98>
8000b7bc:	60 24       	mov.a %a4,%d2
8000b7be:	d9 43 00 08 	lea %a3,[%a4]-32768
8000b7c2:	11 43 00 3f 	addih.a %a3,%a3,61444
}

OSEE_STATIC_INLINE FUNC(uint8_t, OS_CODE) OSEE_ALWAYS_INLINE
OSEE_ISR2_VIRT_TO_HW_PRIO(TaskPrio virt_prio)
{
  return (uint8_t) (((virt_prio) & (~OSEE_ISR2_PRIO_BIT)) + 1U) ;
8000b7c6:	39 22 1c 00 	ld.bu %d2,[%a2]28
8000b7ca:	c2 12       	add %d2,1
8000b7cc:	b7 82 99 23 	insert %d2,%d2,8,7,25
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
      OSEE_TC_SRN_ENABLE | OSEE_TC_SRN_PRIORITY(prio);
8000b7d0:	a6 52       	or %d2,%d5
 *  Service Request Configuration
 *  [0..7] SRPN = Priority
 *  [10] Service Request enable
 *  [11..12] Type Of Service (means which CPU or DMA will handle it)
 */
  OSEE_TC_SRC_REG(src_offset) = OSEE_TC_SRN_TYPE_OF_SERVICE(tos) |
8000b7d2:	74 32       	st.w [%a3],%d2
    osEE_tc_setup_inter_irqs();
}
#endif /* !OSEE_SINGLECORE */

  tdb_size = p_kdb->tdb_array_size - 1U;
  for (i = 0U; i < tdb_size; ++i) {
8000b7d4:	c2 1f       	add %d15,1
8000b7d6:	fd f0 e4 7f 	loop %a15,8000b79e <osEE_cpu_startos+0x62>
  return osEE_get_core(osEE_get_curr_core_id());
}
#else
OSEE_STATIC_INLINE OsEE_CDB * OSEE_ALWAYS_INLINE osEE_get_curr_core(void) {
  OsEE_CDB * p_cdb;
  osEE_tc_getareg(a9, p_cdb);
8000b7da:	40 94       	mov.aa %a4,%a9
8000b7dc:	40 43       	mov.aa %a3,%a4
  {
    OsEE_stack * p_stack;
    OsEE_CDB   * const p_cdb = osEE_get_curr_core();

    /* number of stacks excluded the system stack which is the last one */
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
8000b7de:	99 42 08 00 	ld.a %a2,[%a4]8 <80000008 <BootModeHeader0+0x8>>
8000b7e2:	b0 f2       	add.a %a2,-1
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
8000b7e4:	bd 02 16 00 	jz.a %a2,8000b810 <osEE_cpu_startos+0xd4>
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
      for (j = 0U; j <= stack_words; ++j)
8000b7e8:	82 05       	mov %d5,0
      {
        (*p_stack) = OSEE_FILL_PATTERN;
8000b7ea:	7b 60 5a 3a 	movh %d3,42406
8000b7ee:	1b 53 5a 3a 	addi %d3,%d3,-23131
8000b7f2:	82 04       	mov %d4,0
8000b7f4:	b0 f2       	add.a %a2,-1
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
      MemSize j;
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);
8000b7f6:	cc 30       	ld.a %a15,[%a3]0
8000b7f8:	01 f4 03 f6 	addsc.a %a15,%a15,%d4,3
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
      MemSize j;
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
8000b7fc:	48 12       	ld.w %d2,[%a15]4
8000b7fe:	06 e2       	sh %d2,-2
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
8000b800:	c8 0f       	ld.a %a15,[%a15]0
      for (j = 0U; j <= stack_words; ++j)
8000b802:	02 5f       	mov %d15,%d5
      {
        (*p_stack) = OSEE_FILL_PATTERN;
8000b804:	64 f3       	st.w [%a15+],%d3
      /* number of words to write with the fillpattern */
      MemSize const stack_words =
        (*p_cdb->chdb.p_sdb_array)[i].stack_size / sizeof(OsEE_stack);

      p_stack = (OsEE_stack *)(*p_cdb->chdb.p_sdb_array)[i].p_bos;
      for (j = 0U; j <= stack_words; ++j)
8000b806:	c2 1f       	add %d15,1
8000b808:	7f f2 fe ff 	jge.u %d2,%d15,8000b804 <osEE_cpu_startos+0xc8>
    OsEE_CDB   * const p_cdb = osEE_get_curr_core();

    /* number of stacks excluded the system stack which is the last one */
    MemSize const stack_number = p_cdb->chdb.stack_num - 1U;
    /* Initialize all TASK stacks */
    for (i = 0U; i < stack_number; ++i) {
8000b80c:	c2 14       	add %d4,1
8000b80e:	fc 24       	loop %a2,8000b7f6 <osEE_cpu_startos+0xba>
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000b810:	40 af       	mov.aa %a15,%sp
8000b812:	80 ff       	mov.d %d15,%a15
      }
    }
    /* Initialize System Stack */
    {
      OsEE_stack const * const p_curr_sp = osEE_get_SP();
      p_stack = (OsEE_stack *)
8000b814:	54 42       	ld.w %d2,[%a4]
8000b816:	19 43 08 00 	ld.w %d3,[%a4]8 <80000008 <BootModeHeader0+0x8>>
8000b81a:	60 22       	mov.a %a2,%d2
8000b81c:	01 23 03 f6 	addsc.a %a15,%a2,%d3,3
8000b820:	99 ff f8 ff 	ld.a %a15,[%a15]-8
        (*p_cdb->chdb.p_sdb_array)[(p_cdb->chdb.stack_num - 1U)].p_bos;

      while (p_stack < p_curr_sp) {
8000b824:	80 f2       	mov.d %d2,%a15
8000b826:	7f f2 0a 80 	jge.u %d2,%d15,8000b83a <osEE_cpu_startos+0xfe>
        (*p_stack) = OSEE_FILL_PATTERN;
8000b82a:	7b 60 5a 2a 	movh %d2,42406
8000b82e:	1b 52 5a 2a 	addi %d2,%d2,-23131
8000b832:	64 f2       	st.w [%a15+],%d2
    {
      OsEE_stack const * const p_curr_sp = osEE_get_SP();
      p_stack = (OsEE_stack *)
        (*p_cdb->chdb.p_sdb_array)[(p_cdb->chdb.stack_num - 1U)].p_bos;

      while (p_stack < p_curr_sp) {
8000b834:	80 f3       	mov.d %d3,%a15
8000b836:	3f f3 fe ff 	jlt.u %d3,%d15,8000b832 <osEE_cpu_startos+0xf6>
    }
  }
#endif /* OSEE_HAS_ORTI || OSEE_HAS_STACK_MONITORING */

  return osEE_std_cpu_startos();
}
8000b83a:	82 12       	mov %d2,1
8000b83c:	00 90       	ret 

8000b83e <osEE_hal_sync_barrier>:
#include "ee_internal.h"

#if (!defined(OSEE_SINGLECORE))
void osEE_hal_sync_barrier(OsEE_barrier * p_bar,
  OsEE_reg const volatile * p_wait_mask, OsEE_kernel_cb p_synch_cb)
{
8000b83e:	40 ae       	mov.aa %a14,%sp
8000b840:	40 4f       	mov.aa %a15,%a4
8000b842:	40 5d       	mov.aa %a13,%a5
8000b844:	40 6c       	mov.aa %a12,%a6
  CoreMaskType const exit_mask  = (0xFFFFFFFFU ^
    (((CoreMaskType)0x1U << OS_CORE_ID_ARR_SIZE) - 1U));

  OsEE_reg wait_mask, all_exited;

  if ((p_bar != NULL) && (p_wait_mask != NULL)) {
8000b846:	80 52       	mov.d %d2,%a5
8000b848:	80 43       	mov.d %d3,%a4
8000b84a:	8b 02 20 f2 	ne %d15,%d2,0
8000b84e:	8b 03 20 f4 	and.ne %d15,%d3,0
8000b852:	ee 05       	jnz %d15,8000b85c <osEE_hal_sync_barrier+0x1e>
8000b854:	00 90       	ret 
    /* If not all cores have left the previous use of this barrier
       wait for it. */
    while ((p_bar->value & exit_mask) != 0U) {
      if (p_synch_cb != NULL) {
8000b856:	bc c3       	jz.a %a12,8000b85c <osEE_hal_sync_barrier+0x1e>
        p_synch_cb();
8000b858:	2d 0c 00 00 	calli %a12
  OsEE_reg wait_mask, all_exited;

  if ((p_bar != NULL) && (p_wait_mask != NULL)) {
    /* If not all cores have left the previous use of this barrier
       wait for it. */
    while ((p_bar->value & exit_mask) != 0U) {
8000b85c:	4c f0       	ld.w %d15,[%a15]0
8000b85e:	8f 7f c0 f1 	andn %d15,%d15,7
8000b862:	ee fa       	jnz %d15,8000b856 <osEE_hal_sync_barrier+0x18>
        p_synch_cb();
      }
    }

    /* Set current CPU as entered */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
8000b864:	80 f8       	mov.d %d8,%a15
 *  
 *  \return Returns the current core ID.
 */ 
OSEE_STATIC_INLINE OsEE_core_id OSEE_ALWAYS_INLINE osEE_get_curr_core_id(void)
{
  return (OsEE_core_id)osEE_tc_get_csfr(OSEE_CSFR_CORE_ID);
8000b866:	4d c0 e1 2f 	mfcr %d2,$core_id
8000b86a:	37 02 48 20 	extr %d2,%d2,0,8
/** Insert LDMST instruction. Note that all operands must be word-aligned. */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_imask_ldmst(OsEE_reg volatile * const p_var, OsEE_reg value,
    OsEE_reg offset, OsEE_reg width)
{
  __builtin_tricore_ldmst((volatile void *)p_var, value, offset, width);
8000b86e:	d7 10 21 22 	imask %e2,1,%d2,1
8000b872:	49 f2 40 08 	ldmst [%a15]0,%e2
      (OsEE_reg)osEE_get_curr_core_id(), 1U);

    /* Snapshot of the wait mask */
    wait_mask = (*p_wait_mask);
8000b876:	54 d2       	ld.w %d2,[%a13]
    while ((p_bar->value & wait_mask) != wait_mask) {
8000b878:	4c f0       	ld.w %d15,[%a15]0
8000b87a:	26 2f       	and %d15,%d2
8000b87c:	5f f2 0a 00 	jeq %d2,%d15,8000b890 <osEE_hal_sync_barrier+0x52>
      /* Wait for all other cores/CPUs */
      if (p_synch_cb != NULL) {
8000b880:	bc c3       	jz.a %a12,8000b886 <osEE_hal_sync_barrier+0x48>
        p_synch_cb();
8000b882:	2d 0c 00 00 	calli %a12
      }
      /* Refresh the snapshot of the wait mask */
      wait_mask = (*p_wait_mask);
8000b886:	4c d0       	ld.w %d15,[%a13]0
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
      (OsEE_reg)osEE_get_curr_core_id(), 1U);

    /* Snapshot of the wait mask */
    wait_mask = (*p_wait_mask);
    while ((p_bar->value & wait_mask) != wait_mask) {
8000b888:	48 02       	ld.w %d2,[%a15]0
8000b88a:	26 f2       	and %d2,%d15
8000b88c:	5f f2 fa ff 	jne %d2,%d15,8000b880 <osEE_hal_sync_barrier+0x42>
8000b890:	4d c0 e1 2f 	mfcr %d2,$core_id

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;

    /* Set current CPU as exited */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
      ((OsEE_reg)osEE_get_curr_core_id() + (OsEE_reg)OS_CORE_ID_ARR_SIZE), 1U);
8000b894:	37 02 48 20 	extr %d2,%d2,0,8
    } 

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;

    /* Set current CPU as exited */
    osEE_tc_imask_ldmst(&p_bar->value, 0x1U,
8000b898:	c2 32       	add %d2,3
8000b89a:	d7 10 21 22 	imask %e2,1,%d2,1
8000b89e:	60 8f       	mov.a %a15,%d8
8000b8a0:	49 f2 40 08 	ldmst [%a15]0,%e2
      }
      /* Refresh the snapshot of the wait mask */
      wait_mask = (*p_wait_mask);
    } 

    all_exited = (wait_mask << OS_CORE_ID_ARR_SIZE) | wait_mask;
8000b8a4:	8f 3f 00 40 	sh %d4,%d15,3
#else
OSEE_STATIC_INLINE OsEE_reg OSEE_ALWAYS_INLINE osEE_tc_cmpswapw(
  OsEE_reg volatile * const p_var, OsEE_reg new_val, OsEE_reg expected_val
)
{
  return __builtin_tricore_cmpswapw((volatile void *)p_var, new_val,
8000b8a8:	d2 02       	mov %e2,0
8000b8aa:	0f f4 a0 30 	or %d3,%d4,%d15
8000b8ae:	49 f2 c0 08 	cmpswap.w [%a15]0,%e2
8000b8b2:	00 90       	ret 

8000b8b4 <osEE_get_core>:
    /* Try to reset the barrier */
    (void)osEE_tc_cmpswapw(&p_bar->value, 0U, all_exited);
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
8000b8b4:	40 ae       	mov.aa %a14,%sp
    case OS_CORE_ID_0:
      p_cdb = &osEE_cdb_var_core0;
    break;
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x02U)
    case OS_CORE_ID_1:
      p_cdb = &osEE_cdb_var_core1;
8000b8b6:	91 00 00 28 	movh.a %a2,32768
8000b8ba:	d9 22 38 60 	lea %a2,[%a2]440 <800001b8 <osEE_cdb_var_core1>>
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
  OsEE_CDB * p_cdb;
  switch (core_id) {
8000b8be:	df 14 0f 00 	jeq %d4,1,8000b8dc <osEE_get_core+0x28>
      p_cdb = &osEE_cdb_var_core1;
    break;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x02U */
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x04U)
    case OS_CORE_ID_2:
      p_cdb = &osEE_cdb_var_core2;
8000b8c2:	91 00 00 28 	movh.a %a2,32768
8000b8c6:	d9 22 14 60 	lea %a2,[%a2]404 <80000194 <osEE_cdb_var_core2>>
  }
}

OsEE_CDB * osEE_get_core(CoreIdType core_id) {
  OsEE_CDB * p_cdb;
  switch (core_id) {
8000b8ca:	df 24 09 00 	jeq %d4,2,8000b8dc <osEE_get_core+0x28>
    case OS_CORE_ID_0:
      p_cdb = &osEE_cdb_var_core0;
8000b8ce:	7b 00 00 f8 	movh %d15,32768
      p_cdb = &osEE_cdb_var_core6;
    break;
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
    default:
      /* This can happen when we cycle on cores */
      p_cdb = NULL;
8000b8d2:	1b cf 1d f0 	addi %d15,%d15,476
8000b8d6:	ab 0f a0 f4 	seln %d15,%d4,%d15,0
8000b8da:	60 f2       	mov.a %a2,%d15
    break;
  }

  return p_cdb;
}
8000b8dc:	00 90       	ret 

8000b8de <osEE_hal_start_core>:

void osEE_hal_start_core(CoreIdType core_id) {
8000b8de:	40 ae       	mov.aa %a14,%sp
  switch (core_id) {
8000b8e0:	df 14 05 00 	jeq %d4,1,8000b8ea <osEE_hal_start_core+0xc>
8000b8e4:	df 24 0d 00 	jeq %d4,2,8000b8fe <osEE_hal_start_core+0x20>
8000b8e8:	3c 15       	j 8000b912 <osEE_hal_start_core+0x34>
    case OS_CORE_ID_0:
    /* Nothing to do in this case */
    break;
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x02U)
    case OS_CORE_ID_1:
      OSEE_TC_CORE_PC(OS_CORE_ID_1).reg = (uint32_t)OSEE_CORE1_START_ADDR;
8000b8ea:	91 40 88 ff 	movh.a %a15,63620
8000b8ee:	d9 ff c8 8f 	lea %a15,[%a15]-504 <f883fe08 <_SMALL_DATA4_+0x48837e08>>
8000b8f2:	7b 10 00 f8 	movh %d15,32769
8000b8f6:	1b 6f b0 f8 	addi %d15,%d15,-29946
8000b8fa:	68 0f       	st.w [%a15]0,%d15
    break;
8000b8fc:	3c 0c       	j 8000b914 <osEE_hal_start_core+0x36>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x02U */
#if (defined(OSEE_CORE_ID_VALID_MASK)) && (OSEE_CORE_ID_VALID_MASK & 0x04U)
    case OS_CORE_ID_2:
      OSEE_TC_CORE_PC(OS_CORE_ID_2).reg = (uint32_t)OSEE_CORE2_START_ADDR;
8000b8fe:	91 60 88 ff 	movh.a %a15,63622
8000b902:	d9 ff c8 8f 	lea %a15,[%a15]-504 <f885fe08 <_SMALL_DATA4_+0x48857e08>>
8000b906:	7b 10 00 f8 	movh %d15,32769
8000b90a:	1b 6f e3 f8 	addi %d15,%d15,-29130
8000b90e:	68 0f       	st.w [%a15]0,%d15
    break;
8000b910:	3c 02       	j 8000b914 <osEE_hal_start_core+0x36>
#endif /* OSEE_CORE_ID_VALID_MASK & 0x40U */
    default:
      /* All possible masks have been handled above */
    break;
  }
  if (core_id != OS_CORE_ID_0) {
8000b912:	76 4c       	jz %d4,8000b92a <osEE_hal_start_core+0x4c>
#if (!defined(OSEE_TC_2G))
    OSEE_TC_CORE_DBGSR(core_id).bits.halt = OSEE_TC_DBGSR_RESET_HALT;
8000b914:	8f 14 01 40 	sh %d4,%d4,17
8000b918:	60 42       	mov.a %a2,%d4
8000b91a:	d9 2f c0 4f 	lea %a15,[%a2]-768
8000b91e:	11 2f 88 ff 	addih.a %a15,%a15,63618
8000b922:	4c f0       	ld.w %d15,[%a15]0
8000b924:	b7 2f 82 f0 	insert %d15,%d15,2,1,2
8000b928:	68 0f       	st.w [%a15]0,%d15
8000b92a:	00 90       	ret 

8000b92c <osEE_tc_change_context_from_task_end>:
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000b92c:	99 42 0c 00 	ld.a %a2,[%a4]12
static FUNC(void, OS_CODE) OSEE_NEVER_INLINE
  osEE_tc_change_context_from_task_end
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
8000b930:	40 4f       	mov.aa %a15,%a4
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
8000b932:	0c 22       	ld.bu %d15,[%a2]2
8000b934:	1e 27       	jeq %d15,2,8000b942 <osEE_tc_change_context_from_task_end+0x16>
    osEE_tc_setareg(a4, p_to);
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
    osEE_tc_jump(osEE_hal_restore_ctx);
  } else {
    osEE_tc_setareg(a4, p_to);
8000b936:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000b938:	c8 1f       	ld.a %a15,[%a15]4
8000b93a:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_ready2stacked);
8000b93c:	1d 00 3a 00 	j 8000b9b0 <osEE_hal_ready2stacked>
8000b940:	00 90       	ret 
)
{
  CONSTP2CONST(OsEE_TCB, AUTOMATIC, OS_APPL_DATA) p_to_tcb  = p_to->p_tcb;

  if (p_to_tcb->status == OSEE_TASK_READY_STACKED) {
    osEE_tc_setareg(a4, p_to);
8000b942:	40 f4       	mov.aa %a4,%a15
    osEE_tc_setareg(a5, p_to->hdb.p_scb);
8000b944:	c8 1f       	ld.a %a15,[%a15]4
8000b946:	40 f5       	mov.aa %a5,%a15
    osEE_tc_jump(osEE_hal_restore_ctx);
8000b948:	1d 00 15 00 	j 8000b972 <osEE_hal_restore_ctx>
8000b94c:	00 90       	ret 

8000b94e <osEE_hal_save_ctx_and_restore_ctx>:
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000b94e:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000b950:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000b954:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000b956:	4c 60       	ld.w %d15,[%a6]0
8000b958:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000b95c:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000b960:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000b964:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000b966:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000b96a:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the restore CTX */
  osEE_tc_jump(osEE_hal_restore_ctx);
8000b96c:	1d 00 03 00 	j 8000b972 <osEE_hal_restore_ctx>
8000b970:	00 90       	ret 

8000b972 <osEE_hal_restore_ctx>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to_tdb,
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_to_scb
)
{
  OsEE_CTX  const * const p_ctx = p_to_scb->p_tos;
8000b972:	cc 50       	ld.a %a15,[%a5]0
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000b974:	c8 32       	ld.a %a2,[%a15]12
  OsEE_pcxi const         pcxi  = p_ctx->pcxi;
8000b976:	4c f2       	ld.w %d15,[%a15]8
8000b978:	40 2b       	mov.aa %a11,%a2

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000b97a:	cd 0f e0 0f 	mtcr $pcxi,%d15
8000b97e:	0d 00 c0 04 	isync 
/* Set the return address back */
  osEE_tc_set_RA(p_ctx->ra);
/* Set the PCXI back */
  osEE_tc_csa_set_pcxi(pcxi);
/* Restore the previous Top of Stack */
  p_to_scb->p_tos = p_ctx->p_ctx;
8000b982:	4c f0       	ld.w %d15,[%a15]0
8000b984:	6c 50       	st.w [%a5]0,%d15
/* Jump to Kernel Wrapper: it will be the "ret" inside
   osEE_scheduler_task_wrapper_restore at:
   1) Restore the CSA so the SP,
   2) Return at RA address, that is the address after change context calling
      site */
  osEE_tc_jump(osEE_scheduler_task_wrapper_restore);
8000b986:	1d ff ad f9 	j 8000ace0 <osEE_scheduler_task_wrapper_restore>
8000b98a:	00 90       	ret 

8000b98c <osEE_hal_save_ctx_and_ready2stacked>:
8000b98c:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000b98e:	d9 f2 f0 ff 	lea %a2,[%a15]-16
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000b992:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000b994:	4c 60       	ld.w %d15,[%a6]0
8000b996:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000b99a:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000b99e:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000b9a2:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000b9a4:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000b9a8:	f4 62       	st.a [%a6],%a2
)
{
/* Save the current Context */
  osEE_tc_save_ctx(p_from_scb);
/* Jump to the ready to stacked */
  osEE_tc_jump(osEE_hal_ready2stacked);
8000b9aa:	1d 00 03 00 	j 8000b9b0 <osEE_hal_ready2stacked>
8000b9ae:	00 90       	ret 

8000b9b0 <osEE_hal_ready2stacked>:
/*=============================================================================
                          Stack utilities
 ============================================================================*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_set_SP(OsEE_stack * sp)
{
  __asm__ volatile ("mov.aa %%SP, %0" : : "a"(sp) : "memory");
8000b9b0:	cc 50       	ld.a %a15,[%a5]0
8000b9b2:	40 fa       	mov.aa %sp,%a15
  __asm__ volatile ("isync" : : : "memory");
}

/** The svlcx assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_svlcx(void) {
  __asm__ volatile ("svlcx" : : : "memory");
8000b9b4:	0d 00 00 02 	svlcx 
 */
OSEE_STATIC_INLINE OsEE_stack * OSEE_ALWAYS_INLINE osEE_get_SP(void)
{
  OsEE_stack * sp = NULL;
  /* put the stack pointer in a register in order to return it */
  __asm__ volatile ("mov.aa %0, %%SP" : "=a"(sp));
8000b9b8:	40 af       	mov.aa %a15,%sp
   function (automatically freed memory), since it will be the CSA restoring
   to do that. */
OSEE_STATIC_INLINE OsEE_CTX * OSEE_ALWAYS_INLINE osEE_tc_alloca_ctx(void) {
  OsEE_CTX * sp = (OsEE_CTX *)osEE_get_SP();
/* Stack grows downward, so the following is the actual stack allocation */
  sp -= 1U;
8000b9ba:	d9 f2 f0 ff 	lea %a2,[%a15]-16
8000b9be:	40 2a       	mov.aa %sp,%a2
{
  OsEE_CTX * p_new_ctx;
/* Alloc on the stack the new ERIKA's context */
  p_new_ctx         = osEE_tc_alloca_ctx();
/* Save the previous context */
  p_new_ctx->p_ctx  = p_scb->p_tos;
8000b9c0:	4c 50       	ld.w %d15,[%a5]0
8000b9c2:	59 ff f0 ff 	st.w [%a15]-16,%d15

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000b9c6:	4d 00 e0 ff 	mfcr %d15,$pcxi
/* Save the PCXI */
  p_new_ctx->pcxi   = osEE_tc_csa_get_pcxi();
8000b9ca:	59 ff f8 ff 	st.w [%a15]-8,%d15
 ============================================================================*/
OSEE_STATIC_INLINE OsEE_addr OSEE_ALWAYS_INLINE osEE_tc_get_RA(void)
{
  OsEE_addr ra;
  /* gets the current return address */
  __asm__ volatile ("mov.aa %0, %%a11" : "=a"(ra) : : "memory");
8000b9ce:	40 b3       	mov.aa %a3,%a11
/* Save the RA */
  p_new_ctx->ra     = osEE_tc_get_RA();
8000b9d0:	b5 f3 fc ff 	st.a [%a15]-4,%a3
/* Save the new Top Of Stack */
  p_scb->p_tos = p_new_ctx;
8000b9d4:	f4 52       	st.a [%a5],%a2
   N.B. The RA saved in this context is not useful, but I prefer to use one
        save ctx code for all the cases for code readability, instead using an
        optimized one for this case */
  osEE_tc_save_ctx(p_to_scb);
/* Jump to Kernel Wrapper */
  osEE_tc_jump(osEE_scheduler_task_wrapper_run);
8000b9d6:	1d ff 98 f9 	j 8000ad06 <osEE_scheduler_task_wrapper_run>
8000b9da:	00 90       	ret 

8000b9dc <osEE_tc_change_context_from_isr2_end>:
(
  P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_CONST) p_to
)
{
/* Reset PSW Call Depth Counter, so I can force a RFE */
  osEE_tc_set_csfr(OSEE_CSFR_PSW,
8000b9dc:	4d 40 e0 ff 	mfcr %d15,$psw
8000b9e0:	8f ff c7 f1 	andn %d15,%d15,127
8000b9e4:	cd 4f e0 0f 	mtcr $psw,%d15
8000b9e8:	0d 00 c0 04 	isync 
   but it minimizes the MISRA violation to a single documented point.
*/
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_set_RA(OsEE_addr ra)
{
  /* sets the return address */
  __asm__ volatile ("mov.aa %%a11, %0" : : "a"(ra) : "memory");
8000b9ec:	91 10 00 f8 	movh.a %a15,32769
8000b9f0:	d9 ff ac 4b 	lea %a15,[%a15]-18132 <8000b92c <osEE_tc_change_context_from_task_end>>
8000b9f4:	40 fb       	mov.aa %a11,%a15
  __asm__ volatile ("rslcx" : : : "memory");
}

/** The rfe assembler instruction */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE osEE_tc_rfe(void) {
  __asm__ volatile ("rfe" : : : "memory");
8000b9f6:	00 80       	rfe 
8000b9f8:	00 90       	ret 

8000b9fa <osEE_hal_terminate_ctx>:
  osEE_hal_terminate_ctx
(
  P2VAR(OsEE_SCB, AUTOMATIC, OS_APPL_DATA)  p_term_scb,
  VAR(OsEE_kernel_cb, AUTOMATIC)            kernel_cb
)
{
8000b9fa:	20 08       	sub.a %sp,8

/* Returns the first CSA in the Free Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_fcx(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_FCX);
8000b9fc:	4d 80 e3 2f 	mfcr %d2,$fcx

/* Returns the first CSA in the Previous Context List */
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE osEE_tc_csa_get_pcxi(void)
{
  OsEE_csa_link head;
  head.reg = osEE_tc_get_csfr(OSEE_CSFR_PCXI);
8000ba00:	4d 00 e0 ff 	mfcr %d15,$pcxi
    OsEE_csa_link fcx                 = osEE_tc_csa_get_fcx();
/* Obtain Previous CSA list head, That is the head of the to_free_queue
   (will be new FCX) */
    OsEE_csa_link to_free_queue_head  = osEE_tc_csa_get_pcxi();
/* Get the the of the CSA list to be freed */
    OsEE_csa_link to_free_queue_tail  = p_term_scb->p_tos->pcxi;
8000ba04:	cc 40       	ld.a %a15,[%a4]0
8000ba06:	48 23       	ld.w %d3,[%a15]8
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000ba08:	b9 f4 08 00 	ld.hu %d4,[%a15]8
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000ba0c:	37 03 64 38 	extr.u %d3,%d3,16,4
    ((OsEE_reg)l_csa.bits.pcxo << 6U);
8000ba10:	06 64       	sh %d4,6
 */
OSEE_STATIC_INLINE OsEE_csa * OSEE_ALWAYS_INLINE
  osEE_tc_csa_link_to_pointer(OsEE_csa_link l_csa)
{
  OsEE_reg tmp_csa_addr;
  tmp_csa_addr = ((OsEE_reg)l_csa.bits.pcxs << 28U) |
8000ba12:	8f c3 01 30 	sh %d3,%d3,28
8000ba16:	a6 43       	or %d3,%d4
8000ba18:	60 3f       	mov.a %a15,%d3
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    l_next = p_csa->l_next;
  } else {
    l_next.reg = 0U;
8000ba1a:	82 03       	mov %d3,0
OSEE_STATIC_INLINE OsEE_csa_link OSEE_ALWAYS_INLINE
  osEE_tc_csa_get_next(OsEE_csa_link l_csa_at)
{
  OsEE_csa_link     l_next;
  const OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
8000ba1c:	bc f3       	jz.a %a15,8000ba22 <osEE_hal_terminate_ctx+0x28>
    l_next = p_csa->l_next;
8000ba1e:	48 03       	ld.w %d3,[%a15]0
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_next(OsEE_csa_link l_csa_at, OsEE_csa_link l_next)
{
  OsEE_csa * const  p_csa = osEE_tc_csa_link_to_pointer(l_csa_at);
  if (p_csa != NULL) {
    p_csa->l_next = l_next;
8000ba20:	68 02       	st.w [%a15]0,%d2

/* Set the first CSA in the Free Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_fcx(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_FCX, l_csa.reg);
8000ba22:	cd 8f e3 0f 	mtcr $fcx,%d15
8000ba26:	0d 00 c0 04 	isync 

/* Set the first CSA in the Previous Context List */
OSEE_STATIC_INLINE void OSEE_ALWAYS_INLINE
  osEE_tc_csa_set_pcxi(OsEE_csa_link l_csa)
{
  osEE_tc_set_csfr(OSEE_CSFR_PCXI, l_csa.reg);
8000ba2a:	cd 03 e0 0f 	mtcr $pcxi,%d3
8000ba2e:	0d 00 c0 04 	isync 
   since a TASK, not yet started with higher priority of the stacked ones,
   could have been activated. */
   osEE_tc_set_RA(p_term_scb->p_tos->ra);
#endif /* 0 */
/* Pop ERIKA's context */
   p_term_scb->p_tos = p_term_scb->p_tos->p_ctx;
8000ba32:	cc 40       	ld.a %a15,[%a4]0
8000ba34:	4c f0       	ld.w %d15,[%a15]0
8000ba36:	6c 40       	st.w [%a4]0,%d15
   "osEE_hal_ready2stacked" PCXI. */
  {
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_to;
    P2VAR(OsEE_TDB, AUTOMATIC, OS_APPL_DATA)  p_from;

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);
8000ba38:	91 00 00 48 	movh.a %a4,32768
8000ba3c:	d9 44 28 50 	lea %a4,[%a4]360 <80000168 <osEE_kdb_var>>
8000ba40:	d9 a5 04 00 	lea %a5,[%sp]4 <80000168 <osEE_kdb_var>>
8000ba44:	6d ff cc fb 	call 8000b1dc <osEE_scheduler_task_terminated>

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
8000ba48:	d8 01       	ld.a %a15,[%sp]4
8000ba4a:	39 ff 14 00 	ld.bu %d15,[%a15]20
8000ba4e:	1e 25       	jeq %d15,2,8000ba58 <osEE_hal_terminate_ctx+0x5e>
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
    } else {
/* Prepare to jump to osEE_tc_change_context_from_task_end */
      osEE_tc_setareg(a4, p_to);
8000ba50:	40 24       	mov.aa %a4,%a2
      osEE_tc_jump(osEE_tc_change_context_from_task_end);
8000ba52:	1d ff 6d ff 	j 8000b92c <osEE_tc_change_context_from_task_end>
    }
  }
/* Fake infinite loop: to turn off 'noreturn' function does return warning */
  for(;;) {
    ;
  }
8000ba56:	3c 00       	j 8000ba56 <osEE_hal_terminate_ctx+0x5c>

    p_to = osEE_scheduler_task_terminated(osEE_get_kernel(), &p_from);

    if (p_from->task_type == OSEE_TASK_TYPE_ISR2) {
/* Call osEE_tc_change_context_from_isr2_end to give it a CSA to return from */
      osEE_tc_change_context_from_isr2_end(p_to);
8000ba58:	40 24       	mov.aa %a4,%a2
8000ba5a:	6d ff c1 ff 	call 8000b9dc <osEE_tc_change_context_from_isr2_end>
8000ba5e:	3c fc       	j 8000ba56 <osEE_hal_terminate_ctx+0x5c>

8000ba60 <__lshrdi3>:
8000ba60:	6f 56 0c 80 	jnz.t %d6,5,8000ba78 <__lshrdi3+0x18>
8000ba64:	8b 06 02 71 	rsub %d7,%d6,32
8000ba68:	32 56       	rsub %d6
8000ba6a:	17 45 80 27 	dextr %d2,%d5,%d4,%d7
8000ba6e:	0f 65 00 30 	sh %d3,%d5,%d6
8000ba72:	2b 42 40 26 	sel %d2,%d6,%d2,%d4
8000ba76:	00 90       	ret 
8000ba78:	8b 06 02 60 	add %d6,%d6,32
8000ba7c:	32 56       	rsub %d6
8000ba7e:	0f 65 00 20 	sh %d2,%d5,%d6
8000ba82:	82 03       	mov %d3,0
8000ba84:	00 90       	ret 

8000ba86 <__floatundisf>:
8000ba86:	7b 00 02 20 	movh %d2,32
8000ba8a:	0b 25 30 f1 	lt.u %d15,%d5,%d2
8000ba8e:	02 4a       	mov %d10,%d4
8000ba90:	02 54       	mov %d4,%d5
8000ba92:	ee 08       	jnz %d15,8000baa2 <__floatundisf+0x1c>
8000ba94:	b7 0a 95 f5 	insert %d15,%d10,0,11,21
8000ba98:	6e 05       	jz %d15,8000baa2 <__floatundisf+0x1c>
8000ba9a:	b7 0a 0b a0 	insert %d10,%d10,0,0,11
8000ba9e:	b7 fa 81 a5 	insert %d10,%d10,15,11,1
8000baa2:	6d 00 ea 02 	call 8000c076 <__floatunsidf>
8000baa6:	0b 23 10 48 	mov %e4,%d3,%d2
8000baaa:	82 06       	mov %d6,0
8000baac:	7b 00 1f 74 	movh %d7,16880
8000bab0:	6d 00 34 01 	call 8000bd18 <__muldf3>
8000bab4:	02 a4       	mov %d4,%d10
8000bab6:	0b 23 10 88 	mov %e8,%d3,%d2
8000baba:	6d 00 de 02 	call 8000c076 <__floatunsidf>
8000babe:	0b 89 10 48 	mov %e4,%d9,%d8
8000bac2:	0b 23 10 68 	mov %e6,%d3,%d2
8000bac6:	6d 00 ed 00 	call 8000bca0 <__adddf3>
8000baca:	0b 23 10 48 	mov %e4,%d3,%d2
8000bace:	1d 00 b6 02 	j 8000c03a <__truncdfsf2>

8000bad2 <__extendsfdf2>:
8000bad2:	20 20       	sub.a %sp,32
8000bad4:	d9 a4 20 00 	lea %a4,[%sp]32
8000bad8:	89 44 2c f5 	st.w [+%a4]-20,%d4
8000badc:	d9 a5 10 00 	lea %a5,[%sp]16
8000bae0:	6d 00 f1 02 	call 8000c0c2 <__unpack_f>
8000bae4:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000bae8:	39 a4 10 00 	ld.bu %d4,[%sp]16
8000baec:	8f e2 1f f0 	sh %d15,%d2,-2
8000baf0:	8f e2 01 20 	sh %d2,%d2,30
8000baf4:	74 a2       	st.w [%sp],%d2
8000baf6:	78 01       	st.w [%sp]4,%d15
8000baf8:	19 a5 14 00 	ld.w %d5,[%sp]20
8000bafc:	19 a6 18 00 	ld.w %d6,[%sp]24
8000bb00:	1d 00 8e 02 	j 8000c01c <__make_dp>

8000bb04 <_fpadd_parts>:
8000bb04:	0c 40       	ld.bu %d15,[%a4]0
8000bb06:	40 42       	mov.aa %a2,%a4
8000bb08:	bf 2f cb 80 	jlt.u %d15,2,8000bc9e <_fpadd_parts+0x19a>
8000bb0c:	14 52       	ld.bu %d2,[%a5]
8000bb0e:	40 52       	mov.aa %a2,%a5
8000bb10:	bf 22 c7 80 	jlt.u %d2,2,8000bc9e <_fpadd_parts+0x19a>
8000bb14:	5e 4e       	jne %d15,4,8000bb30 <_fpadd_parts+0x2c>
8000bb16:	40 42       	mov.aa %a2,%a4
8000bb18:	df 42 c3 80 	jne %d2,4,8000bc9e <_fpadd_parts+0x19a>
8000bb1c:	19 42 04 00 	ld.w %d2,[%a4]4
8000bb20:	4c 51       	ld.w %d15,[%a5]4
8000bb22:	5f f2 be 00 	jeq %d2,%d15,8000bc9e <_fpadd_parts+0x19a>
8000bb26:	91 00 00 f8 	movh.a %a15,32768
8000bb2a:	d9 f2 c0 f0 	lea %a2,[%a15]4032 <80000fc0 <__thenan_df>>
8000bb2e:	00 90       	ret 
8000bb30:	40 52       	mov.aa %a2,%a5
8000bb32:	df 42 b6 00 	jeq %d2,4,8000bc9e <_fpadd_parts+0x19a>
8000bb36:	df 22 11 80 	jne %d2,2,8000bb58 <_fpadd_parts+0x54>
8000bb3a:	40 42       	mov.aa %a2,%a4
8000bb3c:	df 2f b1 80 	jne %d15,2,8000bc9e <_fpadd_parts+0x19a>
8000bb40:	40 63       	mov.aa %a3,%a6
8000bb42:	a0 4f       	mov.a %a15,4
8000bb44:	44 4f       	ld.w %d15,[%a4+]
8000bb46:	64 3f       	st.w [%a3+],%d15
8000bb48:	fc fe       	loop %a15,8000bb44 <_fpadd_parts+0x40>
8000bb4a:	4c 21       	ld.w %d15,[%a2]4
8000bb4c:	19 52 04 00 	ld.w %d2,[%a5]4
8000bb50:	40 62       	mov.aa %a2,%a6
8000bb52:	26 2f       	and %d15,%d2
8000bb54:	6c 61       	st.w [%a6]4,%d15
8000bb56:	00 90       	ret 
8000bb58:	40 52       	mov.aa %a2,%a5
8000bb5a:	df 2f a2 00 	jeq %d15,2,8000bc9e <_fpadd_parts+0x19a>
8000bb5e:	4c 42       	ld.w %d15,[%a4]8
8000bb60:	19 52 08 00 	ld.w %d2,[%a5]8
8000bb64:	40 6f       	mov.aa %a15,%a6
8000bb66:	52 23       	sub %d3,%d15,%d2
8000bb68:	0b 30 c0 c1 	abs %d12,%d3
8000bb6c:	8b 0c 84 42 	ge %d4,%d12,64
8000bb70:	40 5c       	mov.aa %a12,%a5
8000bb72:	40 4d       	mov.aa %a13,%a4
8000bb74:	09 4a 4c 09 	ld.d %e10,[%a4]12
8000bb78:	09 58 4c 09 	ld.d %e8,[%a5]12
8000bb7c:	df 04 35 80 	jne %d4,0,8000bbe6 <_fpadd_parts+0xe2>
8000bb80:	bf 13 19 00 	jlt %d3,1,8000bbb2 <_fpadd_parts+0xae>
8000bb84:	0b 89 10 48 	mov %e4,%d9,%d8
8000bb88:	02 c6       	mov %d6,%d12
8000bb8a:	6d ff 6b ff 	call 8000ba60 <__lshrdi3>
8000bb8e:	d2 14       	mov %e4,1
8000bb90:	02 c6       	mov %d6,%d12
8000bb92:	02 2e       	mov %d14,%d2
8000bb94:	02 3d       	mov %d13,%d3
8000bb96:	6d 00 89 02 	call 8000c0a8 <__ashldi3>
8000bb9a:	8b f2 9f 20 	addx %d2,%d2,-1
8000bb9e:	8b f3 bf 30 	addc %d3,%d3,-1
8000bba2:	26 82       	and %d2,%d8
8000bba4:	26 93       	and %d3,%d9
8000bba6:	a6 23       	or %d3,%d2
8000bba8:	02 e8       	mov %d8,%d14
8000bbaa:	8b 03 00 85 	or.ne %d8,%d3,0
8000bbae:	02 d9       	mov %d9,%d13
8000bbb0:	3c 21       	j 8000bbf2 <_fpadd_parts+0xee>
8000bbb2:	df 03 20 00 	jeq %d3,0,8000bbf2 <_fpadd_parts+0xee>
8000bbb6:	0b ab 10 48 	mov %e4,%d11,%d10
8000bbba:	02 c6       	mov %d6,%d12
8000bbbc:	6d ff 52 ff 	call 8000ba60 <__lshrdi3>
8000bbc0:	d2 14       	mov %e4,1
8000bbc2:	02 c6       	mov %d6,%d12
8000bbc4:	02 2e       	mov %d14,%d2
8000bbc6:	02 3d       	mov %d13,%d3
8000bbc8:	6d 00 70 02 	call 8000c0a8 <__ashldi3>
8000bbcc:	8b f2 9f 20 	addx %d2,%d2,-1
8000bbd0:	8b f3 bf 30 	addc %d3,%d3,-1
8000bbd4:	26 a2       	and %d2,%d10
8000bbd6:	26 b3       	and %d3,%d11
8000bbd8:	a6 23       	or %d3,%d2
8000bbda:	02 ea       	mov %d10,%d14
8000bbdc:	42 cf       	add %d15,%d12
8000bbde:	8b 03 00 a5 	or.ne %d10,%d3,0
8000bbe2:	02 db       	mov %d11,%d13
8000bbe4:	3c 07       	j 8000bbf2 <_fpadd_parts+0xee>
8000bbe6:	3f f2 05 00 	jlt %d2,%d15,8000bbf0 <_fpadd_parts+0xec>
8000bbea:	02 2f       	mov %d15,%d2
8000bbec:	d2 0a       	mov %e10,0
8000bbee:	3c 02       	j 8000bbf2 <_fpadd_parts+0xee>
8000bbf0:	d2 08       	mov %e8,0
8000bbf2:	19 d4 04 00 	ld.w %d4,[%a13]4
8000bbf6:	19 c2 04 00 	ld.w %d2,[%a12]4
8000bbfa:	5f 24 34 00 	jeq %d4,%d2,8000bc62 <_fpadd_parts+0x15e>
8000bbfe:	0b 8a c0 20 	subx %d2,%d10,%d8
8000bc02:	0b 9b d0 30 	subc %d3,%d11,%d9
8000bc06:	76 45       	jz %d4,8000bc10 <_fpadd_parts+0x10c>
8000bc08:	0b a8 c0 20 	subx %d2,%d8,%d10
8000bc0c:	0b b9 d0 30 	subc %d3,%d9,%d11
8000bc10:	0e 37       	jltz %d3,8000bc1e <_fpadd_parts+0x11a>
8000bc12:	82 04       	mov %d4,0
8000bc14:	68 14       	st.w [%a15]4,%d4
8000bc16:	68 2f       	st.w [%a15]8,%d15
8000bc18:	89 f2 4c 09 	st.d [%a15]12,%e2
8000bc1c:	3c 0c       	j 8000bc34 <_fpadd_parts+0x130>
8000bc1e:	68 2f       	st.w [%a15]8,%d15
8000bc20:	8b 03 00 f1 	rsub %d15,%d3,0
8000bc24:	82 14       	mov %d4,1
8000bc26:	8b 02 00 31 	rsub %d3,%d2,0
8000bc2a:	ab ff 1f f2 	cadd %d15,%d2,%d15,-1
8000bc2e:	68 14       	st.w [%a15]4,%d4
8000bc30:	68 33       	st.w [%a15]12,%d3
8000bc32:	68 4f       	st.w [%a15]16,%d15
8000bc34:	82 f5       	mov %d5,-1
8000bc36:	06 c5       	sh %d5,-4
8000bc38:	48 32       	ld.w %d2,[%a15]12
8000bc3a:	48 43       	ld.w %d3,[%a15]16
8000bc3c:	8b f2 9f 60 	addx %d6,%d2,-1
8000bc40:	8b f3 bf 40 	addc %d4,%d3,-1
8000bc44:	3a 54       	eq %d15,%d4,%d5
8000bc46:	8b f6 3f f4 	and.ne %d15,%d6,-1
8000bc4a:	0b 54 a0 f2 	or.lt.u %d15,%d4,%d5
8000bc4e:	6e 12       	jz %d15,8000bc72 <_fpadd_parts+0x16e>
8000bc50:	4c f2       	ld.w %d15,[%a15]8
8000bc52:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000bc56:	c2 ff       	add %d15,-1
8000bc58:	06 12       	sh %d2,1
8000bc5a:	68 32       	st.w [%a15]12,%d2
8000bc5c:	68 43       	st.w [%a15]16,%d3
8000bc5e:	68 2f       	st.w [%a15]8,%d15
8000bc60:	3c ec       	j 8000bc38 <_fpadd_parts+0x134>
8000bc62:	0b a8 40 20 	addx %d2,%d8,%d10
8000bc66:	68 2f       	st.w [%a15]8,%d15
8000bc68:	0b b9 50 f0 	addc %d15,%d9,%d11
8000bc6c:	68 14       	st.w [%a15]4,%d4
8000bc6e:	68 32       	st.w [%a15]12,%d2
8000bc70:	68 4f       	st.w [%a15]16,%d15
8000bc72:	82 3f       	mov %d15,3
8000bc74:	28 0f       	st.b [%a15]0,%d15
8000bc76:	4c f4       	ld.w %d15,[%a15]16
8000bc78:	7b 00 00 42 	movh %d4,8192
8000bc7c:	0b 4f 30 31 	lt.u %d3,%d15,%d4
8000bc80:	48 32       	ld.w %d2,[%a15]12
8000bc82:	40 f2       	mov.aa %a2,%a15
8000bc84:	f6 3d       	jnz %d3,8000bc9e <_fpadd_parts+0x19a>
8000bc86:	8f 12 00 31 	and %d3,%d2,1
8000bc8a:	77 2f 80 2f 	dextr %d2,%d15,%d2,31
8000bc8e:	06 ff       	sh %d15,-1
8000bc90:	96 00       	or %d15,0
8000bc92:	68 4f       	st.w [%a15]16,%d15
8000bc94:	4c f2       	ld.w %d15,[%a15]8
8000bc96:	a6 32       	or %d2,%d3
8000bc98:	c2 1f       	add %d15,1
8000bc9a:	68 32       	st.w [%a15]12,%d2
8000bc9c:	68 2f       	st.w [%a15]8,%d15
8000bc9e:	00 90       	ret 

8000bca0 <__adddf3>:
8000bca0:	20 50       	sub.a %sp,80
8000bca2:	d9 a4 04 00 	lea %a4,[%sp]4
8000bca6:	d9 a5 14 00 	lea %a5,[%sp]20
8000bcaa:	89 a4 44 09 	st.d [%sp]4,%e4
8000bcae:	89 a6 4c 09 	st.d [%sp]12,%e6
8000bcb2:	6d 00 d9 02 	call 8000c264 <__unpack_d>
8000bcb6:	d9 a4 0c 00 	lea %a4,[%sp]12
8000bcba:	d9 a5 28 00 	lea %a5,[%sp]40
8000bcbe:	6d 00 d3 02 	call 8000c264 <__unpack_d>
8000bcc2:	d9 a4 14 00 	lea %a4,[%sp]20
8000bcc6:	d9 a5 28 00 	lea %a5,[%sp]40
8000bcca:	d9 a6 3c 00 	lea %a6,[%sp]60
8000bcce:	6d ff 1b ff 	call 8000bb04 <_fpadd_parts>
8000bcd2:	40 24       	mov.aa %a4,%a2
8000bcd4:	1d 00 3f 02 	j 8000c152 <__pack_d>

8000bcd8 <__subdf3>:
8000bcd8:	20 50       	sub.a %sp,80
8000bcda:	d9 a4 04 00 	lea %a4,[%sp]4
8000bcde:	d9 a5 14 00 	lea %a5,[%sp]20
8000bce2:	89 a4 44 09 	st.d [%sp]4,%e4
8000bce6:	89 a6 4c 09 	st.d [%sp]12,%e6
8000bcea:	6d 00 bd 02 	call 8000c264 <__unpack_d>
8000bcee:	d9 a4 0c 00 	lea %a4,[%sp]12
8000bcf2:	d9 a5 28 00 	lea %a5,[%sp]40
8000bcf6:	6d 00 b7 02 	call 8000c264 <__unpack_d>
8000bcfa:	58 0b       	ld.w %d15,[%sp]44
8000bcfc:	d9 a4 14 00 	lea %a4,[%sp]20
8000bd00:	8f 1f 80 f1 	xor %d15,%d15,1
8000bd04:	d9 a5 28 00 	lea %a5,[%sp]40
8000bd08:	d9 a6 3c 00 	lea %a6,[%sp]60
8000bd0c:	78 0b       	st.w [%sp]44,%d15
8000bd0e:	6d ff fb fe 	call 8000bb04 <_fpadd_parts>
8000bd12:	40 24       	mov.aa %a4,%a2
8000bd14:	1d 00 1f 02 	j 8000c152 <__pack_d>

8000bd18 <__muldf3>:
8000bd18:	20 50       	sub.a %sp,80
8000bd1a:	d9 a4 04 00 	lea %a4,[%sp]4
8000bd1e:	d9 a5 14 00 	lea %a5,[%sp]20
8000bd22:	89 a4 44 09 	st.d [%sp]4,%e4
8000bd26:	89 a6 4c 09 	st.d [%sp]12,%e6
8000bd2a:	6d 00 9d 02 	call 8000c264 <__unpack_d>
8000bd2e:	d9 a4 0c 00 	lea %a4,[%sp]12
8000bd32:	d9 a5 28 00 	lea %a5,[%sp]40
8000bd36:	6d 00 97 02 	call 8000c264 <__unpack_d>
8000bd3a:	39 a3 14 00 	ld.bu %d3,[%sp]20
8000bd3e:	ff 23 0c 80 	jge.u %d3,2,8000bd56 <__muldf3+0x3e>
8000bd42:	19 a2 18 00 	ld.w %d2,[%sp]24
8000bd46:	58 0b       	ld.w %d15,[%sp]44
8000bd48:	d9 a4 14 00 	lea %a4,[%sp]20
8000bd4c:	0b f2 10 f1 	ne %d15,%d2,%d15
8000bd50:	78 06       	st.w [%sp]24,%d15
8000bd52:	1d 00 b3 00 	j 8000beb8 <__muldf3+0x1a0>
8000bd56:	39 af 28 00 	ld.bu %d15,[%sp]40
8000bd5a:	ff 2f 0c 80 	jge.u %d15,2,8000bd72 <__muldf3+0x5a>
8000bd5e:	58 0b       	ld.w %d15,[%sp]44
8000bd60:	19 a2 18 00 	ld.w %d2,[%sp]24
8000bd64:	d9 a4 28 00 	lea %a4,[%sp]40
8000bd68:	0b f2 10 f1 	ne %d15,%d2,%d15
8000bd6c:	78 0b       	st.w [%sp]44,%d15
8000bd6e:	1d 00 a5 00 	j 8000beb8 <__muldf3+0x1a0>
8000bd72:	df 43 09 80 	jne %d3,4,8000bd84 <__muldf3+0x6c>
8000bd76:	91 00 00 48 	movh.a %a4,32768
8000bd7a:	d9 44 c0 f0 	lea %a4,[%a4]4032 <80000fc0 <__thenan_df>>
8000bd7e:	df 2f 9d 00 	jeq %d15,2,8000beb8 <__muldf3+0x1a0>
8000bd82:	3c e0       	j 8000bd42 <__muldf3+0x2a>
8000bd84:	5e 48       	jne %d15,4,8000bd94 <__muldf3+0x7c>
8000bd86:	91 00 00 48 	movh.a %a4,32768
8000bd8a:	d9 44 c0 f0 	lea %a4,[%a4]4032 <80000fc0 <__thenan_df>>
8000bd8e:	df 23 95 00 	jeq %d3,2,8000beb8 <__muldf3+0x1a0>
8000bd92:	3c e6       	j 8000bd5e <__muldf3+0x46>
8000bd94:	df 23 d7 7f 	jeq %d3,2,8000bd42 <__muldf3+0x2a>
8000bd98:	df 2f e3 7f 	jeq %d15,2,8000bd5e <__muldf3+0x46>
8000bd9c:	58 08       	ld.w %d15,[%sp]32
8000bd9e:	19 ab 38 00 	ld.w %d11,[%sp]56 <80000008 <BootModeHeader0+0x8>>
8000bda2:	d2 00       	mov %e0,0
8000bda4:	19 a0 34 00 	ld.w %d0,[%sp]52
8000bda8:	73 bf 68 60 	mul.u %e6,%d15,%d11
8000bdac:	82 0c       	mov %d12,0
8000bdae:	73 0f 68 40 	mul.u %e4,%d15,%d0
8000bdb2:	19 aa 24 00 	ld.w %d10,[%sp]36
8000bdb6:	82 02       	mov %d2,0
8000bdb8:	03 cf 0a 77 	madd %d7,%d7,%d15,%d12
8000bdbc:	03 b2 0a 77 	madd %d7,%d7,%d2,%d11
8000bdc0:	03 1f 0a 55 	madd %d5,%d5,%d15,%d1
8000bdc4:	03 02 0a 55 	madd %d5,%d5,%d2,%d0
8000bdc8:	82 0d       	mov %d13,0
8000bdca:	03 a0 68 26 	madd.u %e2,%e6,%d0,%d10
8000bdce:	03 d0 0a 33 	madd %d3,%d3,%d0,%d13
8000bdd2:	03 a1 0a 33 	madd %d3,%d3,%d1,%d10
8000bdd6:	0b 54 10 08 	mov %e0,%d4,%d5
8000bdda:	42 20       	add %d0,%d2
8000bddc:	3a 73       	eq %d15,%d3,%d7
8000bdde:	0b 62 50 f2 	and.ge.u %d15,%d2,%d6
8000bde2:	0b 37 a0 f2 	or.lt.u %d15,%d7,%d3
8000bde6:	8b 0f 00 62 	eq %d6,%d15,0
8000bdea:	3a 50       	eq %d15,%d0,%d5
8000bdec:	0b 41 50 f2 	and.ge.u %d15,%d1,%d4
8000bdf0:	0b 05 a0 f2 	or.lt.u %d15,%d5,%d0
8000bdf4:	ba 0f       	eq %d15,%d15,0
8000bdf6:	53 1f 40 40 	mul.u %e4,%d15,1
8000bdfa:	02 38       	mov %d8,%d3
8000bdfc:	82 09       	mov %d9,0
8000bdfe:	03 ab 68 28 	madd.u %e2,%e8,%d11,%d10
8000be02:	02 5f       	mov %d15,%d5
8000be04:	03 db 0a 33 	madd %d3,%d3,%d11,%d13
8000be08:	42 6f       	add %d15,%d6
8000be0a:	03 ac 0a 33 	madd %d3,%d3,%d12,%d10
8000be0e:	0b 4f 10 68 	mov %e6,%d15,%d4
8000be12:	0b 62 40 40 	addx %d4,%d2,%d6
8000be16:	0b 73 50 20 	addc %d2,%d3,%d7
8000be1a:	58 07       	ld.w %d15,[%sp]28
8000be1c:	19 a3 30 00 	ld.w %d3,[%sp]48
8000be20:	19 a5 18 00 	ld.w %d5,[%sp]24
8000be24:	42 3f       	add %d15,%d3
8000be26:	19 a3 2c 00 	ld.w %d3,[%sp]44
8000be2a:	c2 4f       	add %d15,4
8000be2c:	0b 35 10 31 	ne %d3,%d5,%d3
8000be30:	59 a3 00 10 	st.w [%sp]64,%d3
8000be34:	7b 00 00 52 	movh %d5,8192
8000be38:	0b 52 50 31 	ge.u %d3,%d2,%d5
8000be3c:	df 03 1b 00 	jeq %d3,0,8000be72 <__muldf3+0x15a>
8000be40:	8f 14 00 31 	and %d3,%d4,1
8000be44:	76 37       	jz %d3,8000be52 <__muldf3+0x13a>
8000be46:	8f f0 1f 30 	sh %d3,%d0,-1
8000be4a:	77 10 80 1f 	dextr %d1,%d0,%d1,31
8000be4e:	b7 f3 81 0f 	insert %d0,%d3,15,31,1
8000be52:	77 42 80 4f 	dextr %d4,%d2,%d4,31
8000be56:	c2 1f       	add %d15,1
8000be58:	06 f2       	sh %d2,-1
8000be5a:	3c ed       	j 8000be34 <__muldf3+0x11c>
8000be5c:	77 42 80 20 	dextr %d2,%d2,%d4,1
8000be60:	06 14       	sh %d4,1
8000be62:	ce 04       	jgez %d0,8000be6a <__muldf3+0x152>
8000be64:	8f 14 40 51 	or %d5,%d4,1
8000be68:	02 54       	mov %d4,%d5
8000be6a:	77 10 80 00 	dextr %d0,%d0,%d1,1
8000be6e:	c2 ff       	add %d15,-1
8000be70:	06 11       	sh %d1,1
8000be72:	7b 00 00 51 	movh %d5,4096
8000be76:	0b 52 30 31 	lt.u %d3,%d2,%d5
8000be7a:	df 03 f1 ff 	jne %d3,0,8000be5c <__muldf3+0x144>
8000be7e:	78 11       	st.w [%sp]68,%d15
8000be80:	02 4f       	mov %d15,%d4
8000be82:	16 ff       	and %d15,255
8000be84:	8b 0f 28 f2 	ne %d15,%d15,128
8000be88:	ee 0f       	jnz %d15,8000bea6 <__muldf3+0x18e>
8000be8a:	a6 10       	or %d0,%d1
8000be8c:	77 42 00 fc 	dextr %d15,%d2,%d4,24
8000be90:	8b 00 20 02 	ne %d0,%d0,0
8000be94:	0f f0 e0 00 	andn %d0,%d0,%d15
8000be98:	76 07       	jz %d0,8000bea6 <__muldf3+0x18e>
8000be9a:	8b 04 88 40 	addx %d4,%d4,128
8000be9e:	8b 02 a0 20 	addc %d2,%d2,0
8000bea2:	8f f4 cf 41 	andn %d4,%d4,255
8000bea6:	d9 a4 10 10 	lea %a4,[%sp]80
8000beaa:	82 3f       	mov %d15,3
8000beac:	59 a4 08 10 	st.w [%sp]72,%d4
8000beb0:	59 a2 0c 10 	st.w [%sp]76,%d2
8000beb4:	89 4f 2c f4 	st.b [+%a4]-20 <800003ec <osEE_sdb_array_core2+0xc>>,%d15
8000beb8:	1d 00 4d 01 	j 8000c152 <__pack_d>

8000bebc <__divdf3>:
8000bebc:	20 38       	sub.a %sp,56
8000bebe:	40 a4       	mov.aa %a4,%sp
8000bec0:	d9 a5 10 00 	lea %a5,[%sp]16
8000bec4:	89 a4 40 09 	st.d [%sp],%e4
8000bec8:	89 a6 48 09 	st.d [%sp]8,%e6
8000becc:	6d 00 cc 01 	call 8000c264 <__unpack_d>
8000bed0:	d9 a4 08 00 	lea %a4,[%sp]8
8000bed4:	d9 a5 24 00 	lea %a5,[%sp]36
8000bed8:	6d 00 c6 01 	call 8000c264 <__unpack_d>
8000bedc:	39 a2 10 00 	ld.bu %d2,[%sp]16
8000bee0:	bf 22 76 80 	jlt.u %d2,2,8000bfcc <__divdf3+0x110>
8000bee4:	39 af 24 00 	ld.bu %d15,[%sp]36
8000bee8:	d9 a4 24 00 	lea %a4,[%sp]36
8000beec:	bf 2f 72 80 	jlt.u %d15,2,8000bfd0 <__divdf3+0x114>
8000bef0:	19 a4 14 00 	ld.w %d4,[%sp]20
8000bef4:	19 a3 28 00 	ld.w %d3,[%sp]40
8000bef8:	c6 43       	xor %d3,%d4
8000befa:	59 a3 14 00 	st.w [%sp]20,%d3
8000befe:	1b e2 ff 3f 	addi %d3,%d2,-2
8000bf02:	8f d3 0f 31 	and %d3,%d3,253
8000bf06:	f6 38       	jnz %d3,8000bf16 <__divdf3+0x5a>
8000bf08:	91 00 00 48 	movh.a %a4,32768
8000bf0c:	d9 44 c0 f0 	lea %a4,[%a4]4032 <80000fc0 <__thenan_df>>
8000bf10:	5f f2 5e 80 	jne %d2,%d15,8000bfcc <__divdf3+0x110>
8000bf14:	3c 5e       	j 8000bfd0 <__divdf3+0x114>
8000bf16:	5e 47       	jne %d15,4,8000bf24 <__divdf3+0x68>
8000bf18:	d2 02       	mov %e2,0
8000bf1a:	82 0f       	mov %d15,0
8000bf1c:	89 a2 5c 09 	st.d [%sp]28,%e2
8000bf20:	78 06       	st.w [%sp]24,%d15
8000bf22:	3c 55       	j 8000bfcc <__divdf3+0x110>
8000bf24:	5e 25       	jne %d15,2,8000bf2e <__divdf3+0x72>
8000bf26:	82 4f       	mov %d15,4
8000bf28:	e9 af 10 00 	st.b [%sp]16,%d15
8000bf2c:	3c 50       	j 8000bfcc <__divdf3+0x110>
8000bf2e:	58 06       	ld.w %d15,[%sp]24
8000bf30:	09 a2 5c 09 	ld.d %e2,[%sp]28
8000bf34:	09 a4 70 09 	ld.d %e4,[%sp]48
8000bf38:	19 a6 2c 00 	ld.w %d6,[%sp]44
8000bf3c:	52 66       	sub %d6,%d15,%d6
8000bf3e:	3a 53       	eq %d15,%d3,%d5
8000bf40:	0b 42 50 f2 	and.ge.u %d15,%d2,%d4
8000bf44:	59 a6 18 00 	st.w [%sp]24,%d6
8000bf48:	0b 35 a0 f2 	or.lt.u %d15,%d5,%d3
8000bf4c:	ee 07       	jnz %d15,8000bf5a <__divdf3+0x9e>
8000bf4e:	c2 f6       	add %d6,-1
8000bf50:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000bf54:	59 a6 18 00 	st.w [%sp]24,%d6
8000bf58:	06 12       	sh %d2,1
8000bf5a:	82 01       	mov %d1,0
8000bf5c:	7b 00 00 f1 	movh %d15,4096
8000bf60:	82 00       	mov %d0,0
8000bf62:	82 07       	mov %d7,0
8000bf64:	c5 0f 3c 00 	lea %a15,3c <_.+0x3b>
8000bf68:	0b 53 00 61 	eq %d6,%d3,%d5
8000bf6c:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000bf70:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000bf74:	f6 6b       	jnz %d6,8000bf8a <__divdf3+0xce>
8000bf76:	0f 10 a0 80 	or %d8,%d0,%d1
8000bf7a:	0f f7 a0 60 	or %d6,%d7,%d15
8000bf7e:	0b 42 c0 20 	subx %d2,%d2,%d4
8000bf82:	02 80       	mov %d0,%d8
8000bf84:	02 67       	mov %d7,%d6
8000bf86:	0b 53 d0 30 	subc %d3,%d3,%d5
8000bf8a:	77 1f 80 1f 	dextr %d1,%d15,%d1,31
8000bf8e:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000bf92:	06 ff       	sh %d15,-1
8000bf94:	06 12       	sh %d2,1
8000bf96:	fd f0 e9 7f 	loop %a15,8000bf68 <__divdf3+0xac>
8000bf9a:	02 0f       	mov %d15,%d0
8000bf9c:	16 ff       	and %d15,255
8000bf9e:	8b 0f 28 f2 	ne %d15,%d15,128
8000bfa2:	0b 70 10 48 	mov %e4,%d0,%d7
8000bfa6:	ee 0f       	jnz %d15,8000bfc4 <__divdf3+0x108>
8000bfa8:	a6 32       	or %d2,%d3
8000bfaa:	77 07 00 fc 	dextr %d15,%d7,%d0,24
8000bfae:	8b 02 20 22 	ne %d2,%d2,0
8000bfb2:	0f f2 e0 20 	andn %d2,%d2,%d15
8000bfb6:	76 27       	jz %d2,8000bfc4 <__divdf3+0x108>
8000bfb8:	8b 00 88 00 	addx %d0,%d0,128
8000bfbc:	8b 07 a0 40 	addc %d4,%d7,0
8000bfc0:	8f f0 cf 51 	andn %d5,%d0,255
8000bfc4:	59 a5 1c 00 	st.w [%sp]28,%d5
8000bfc8:	59 a4 20 00 	st.w [%sp]32,%d4
8000bfcc:	d9 a4 10 00 	lea %a4,[%sp]16
8000bfd0:	1d 00 c1 00 	j 8000c152 <__pack_d>

8000bfd4 <__floatsidf>:
8000bfd4:	20 18       	sub.a %sp,24
8000bfd6:	82 3f       	mov %d15,3
8000bfd8:	2c a4       	st.b [%sp]4,%d15
8000bfda:	8f 14 1e f0 	sh %d15,%d4,-31
8000bfde:	78 02       	st.w [%sp]8,%d15
8000bfe0:	f6 44       	jnz %d4,8000bfe8 <__floatsidf+0x14>
8000bfe2:	82 2f       	mov %d15,2
8000bfe4:	2c a4       	st.b [%sp]4,%d15
8000bfe6:	3c 16       	j 8000c012 <__floatsidf+0x3e>
8000bfe8:	6e 09       	jz %d15,8000bffa <__floatsidf+0x26>
8000bfea:	7b 00 00 f8 	movh %d15,32768
8000bfee:	82 02       	mov %d2,0
8000bff0:	7b 00 1e 3c 	movh %d3,49632
8000bff4:	5f f4 13 00 	jeq %d4,%d15,8000c01a <__floatsidf+0x46>
8000bff8:	32 54       	rsub %d4
8000bffa:	0f 04 b0 f1 	clz %d15,%d4
8000bffe:	1b df 01 60 	addi %d6,%d15,29
8000c002:	82 05       	mov %d5,0
8000c004:	6d 00 52 00 	call 8000c0a8 <__ashldi3>
8000c008:	8b ff 01 f1 	rsub %d15,%d15,31
8000c00c:	89 a2 50 09 	st.d [%sp]16,%e2
8000c010:	78 03       	st.w [%sp]12,%d15
8000c012:	d9 a4 04 00 	lea %a4,[%sp]4
8000c016:	6d 00 9e 00 	call 8000c152 <__pack_d>
8000c01a:	00 90       	ret 

8000c01c <__make_dp>:
8000c01c:	20 18       	sub.a %sp,24
8000c01e:	09 a2 58 09 	ld.d %e2,[%sp]24
8000c022:	d9 a4 04 00 	lea %a4,[%sp]4
8000c026:	e9 a4 04 00 	st.b [%sp]4,%d4
8000c02a:	59 a5 08 00 	st.w [%sp]8,%d5
8000c02e:	59 a6 0c 00 	st.w [%sp]12,%d6
8000c032:	89 a2 50 09 	st.d [%sp]16,%e2
8000c036:	1d 00 8e 00 	j 8000c152 <__pack_d>

8000c03a <__truncdfsf2>:
8000c03a:	20 20       	sub.a %sp,32
8000c03c:	d9 a4 20 00 	lea %a4,[%sp]32
8000c040:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000c044:	d9 a5 0c 00 	lea %a5,[%sp]12
8000c048:	6d 00 0e 01 	call 8000c264 <__unpack_d>
8000c04c:	19 a7 18 00 	ld.w %d7,[%sp]24
8000c050:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000c054:	39 a4 0c 00 	ld.bu %d4,[%sp]12
8000c058:	77 72 00 21 	dextr %d2,%d2,%d7,2
8000c05c:	b7 07 02 7f 	insert %d7,%d7,0,30,2
8000c060:	02 23       	mov %d3,%d2
8000c062:	8f 12 40 21 	or %d2,%d2,1
8000c066:	19 a5 10 00 	ld.w %d5,[%sp]16
8000c06a:	19 a6 14 00 	ld.w %d6,[%sp]20
8000c06e:	2b 32 40 77 	sel %d7,%d7,%d2,%d3
8000c072:	1d 00 65 00 	j 8000c13c <__make_fp>

8000c076 <__floatunsidf>:
8000c076:	20 18       	sub.a %sp,24
8000c078:	82 0f       	mov %d15,0
8000c07a:	78 02       	st.w [%sp]8,%d15
8000c07c:	f6 44       	jnz %d4,8000c084 <__floatunsidf+0xe>
8000c07e:	82 2f       	mov %d15,2
8000c080:	2c a4       	st.b [%sp]4,%d15
8000c082:	3c 0f       	j 8000c0a0 <__floatunsidf+0x2a>
8000c084:	82 3f       	mov %d15,3
8000c086:	2c a4       	st.b [%sp]4,%d15
8000c088:	0f 04 b0 f1 	clz %d15,%d4
8000c08c:	1b df 01 60 	addi %d6,%d15,29
8000c090:	82 05       	mov %d5,0
8000c092:	6d 00 0b 00 	call 8000c0a8 <__ashldi3>
8000c096:	8b ff 01 f1 	rsub %d15,%d15,31
8000c09a:	89 a2 50 09 	st.d [%sp]16,%e2
8000c09e:	78 03       	st.w [%sp]12,%d15
8000c0a0:	d9 a4 04 00 	lea %a4,[%sp]4
8000c0a4:	1d 00 57 00 	j 8000c152 <__pack_d>

8000c0a8 <__ashldi3>:
8000c0a8:	6f 56 07 80 	jnz.t %d6,5,8000c0b6 <__ashldi3+0xe>
8000c0ac:	0f 64 00 20 	sh %d2,%d4,%d6
8000c0b0:	17 45 80 36 	dextr %d3,%d5,%d4,%d6
8000c0b4:	00 90       	ret 
8000c0b6:	8b 06 1e 60 	add %d6,%d6,-32
8000c0ba:	82 02       	mov %d2,0
8000c0bc:	0f 64 00 30 	sh %d3,%d4,%d6
8000c0c0:	00 90       	ret 

8000c0c2 <__unpack_f>:
8000c0c2:	54 43       	ld.w %d3,[%a4]
8000c0c4:	37 03 77 f0 	extr.u %d15,%d3,0,23
8000c0c8:	37 03 e8 2b 	extr.u %d2,%d3,23,8
8000c0cc:	8f 13 1e 30 	sh %d3,%d3,-31
8000c0d0:	59 53 04 00 	st.w [%a5]4,%d3
8000c0d4:	df 02 18 80 	jne %d2,0,8000c104 <__unpack_f+0x42>
8000c0d8:	ee 03       	jnz %d15,8000c0de <__unpack_f+0x1c>
8000c0da:	82 2f       	mov %d15,2
8000c0dc:	3c 19       	j 8000c10e <__unpack_f+0x4c>
8000c0de:	3b 20 f8 2f 	mov %d2,-126
8000c0e2:	59 52 08 00 	st.w [%a5]8,%d2
8000c0e6:	82 32       	mov %d2,3
8000c0e8:	34 52       	st.b [%a5],%d2
8000c0ea:	06 7f       	sh %d15,7
8000c0ec:	3b 10 f8 2f 	mov %d2,-127
8000c0f0:	7b 00 00 44 	movh %d4,16384
8000c0f4:	06 1f       	sh %d15,1
8000c0f6:	02 23       	mov %d3,%d2
8000c0f8:	c2 f2       	add %d2,-1
8000c0fa:	3f 4f fd ff 	jlt.u %d15,%d4,8000c0f4 <__unpack_f+0x32>
8000c0fe:	59 53 08 00 	st.w [%a5]8,%d3
8000c102:	3c 1b       	j 8000c138 <__unpack_f+0x76>
8000c104:	8b f2 2f 32 	ne %d3,%d2,255
8000c108:	f6 3f       	jnz %d3,8000c126 <__unpack_f+0x64>
8000c10a:	ee 04       	jnz %d15,8000c112 <__unpack_f+0x50>
8000c10c:	82 4f       	mov %d15,4
8000c10e:	2c 50       	st.b [%a5]0,%d15
8000c110:	00 90       	ret 
8000c112:	7b 00 04 20 	movh %d2,64
8000c116:	26 f2       	and %d2,%d15
8000c118:	76 22       	jz %d2,8000c11c <__unpack_f+0x5a>
8000c11a:	82 12       	mov %d2,1
8000c11c:	b7 0f 01 fb 	insert %d15,%d15,0,22,1
8000c120:	34 52       	st.b [%a5],%d2
8000c122:	06 7f       	sh %d15,7
8000c124:	3c 0a       	j 8000c138 <__unpack_f+0x76>
8000c126:	1b 12 f8 2f 	addi %d2,%d2,-127
8000c12a:	06 7f       	sh %d15,7
8000c12c:	59 52 08 00 	st.w [%a5]8,%d2
8000c130:	b7 ff 01 ff 	insert %d15,%d15,15,30,1
8000c134:	82 32       	mov %d2,3
8000c136:	34 52       	st.b [%a5],%d2
8000c138:	6c 53       	st.w [%a5]12,%d15
8000c13a:	00 90       	ret 

8000c13c <__make_fp>:
8000c13c:	20 10       	sub.a %sp,16
8000c13e:	40 a4       	mov.aa %a4,%sp
8000c140:	34 a4       	st.b [%sp],%d4
8000c142:	59 a5 04 00 	st.w [%sp]4,%d5
8000c146:	59 a6 08 00 	st.w [%sp]8,%d6
8000c14a:	59 a7 0c 00 	st.w [%sp]12,%d7
8000c14e:	1d 00 e1 00 	j 8000c310 <__pack_f>

8000c152 <__pack_d>:
8000c152:	14 42       	ld.bu %d2,[%a4]
8000c154:	19 49 0c 00 	ld.w %d9,[%a4]12
8000c158:	19 48 10 00 	ld.w %d8,[%a4]16
8000c15c:	19 4c 04 00 	ld.w %d12,[%a4]4
8000c160:	ff 22 0b 80 	jge.u %d2,2,8000c176 <__pack_d+0x24>
8000c164:	77 98 00 9c 	dextr %d9,%d8,%d9,24
8000c168:	06 88       	sh %d8,-8
8000c16a:	02 95       	mov %d5,%d9
8000c16c:	b7 18 8d 49 	insert %d4,%d8,1,19,13
8000c170:	3b f0 7f f0 	mov %d15,2047
8000c174:	3c 6f       	j 8000c252 <__pack_d+0x100>
8000c176:	3b f0 7f f0 	mov %d15,2047
8000c17a:	d2 04       	mov %e4,0
8000c17c:	df 42 6b 00 	jeq %d2,4,8000c252 <__pack_d+0x100>
8000c180:	0f 89 a0 f0 	or %d15,%d9,%d8
8000c184:	8b 22 00 32 	eq %d3,%d2,2
8000c188:	8b 0f e0 34 	or.eq %d3,%d15,0
8000c18c:	82 0f       	mov %d15,0
8000c18e:	df 03 62 80 	jne %d3,0,8000c252 <__pack_d+0x100>
8000c192:	19 42 08 00 	ld.w %d2,[%a4]8
8000c196:	3b 20 c0 ff 	mov %d15,-1022
8000c19a:	7f f2 36 00 	jge %d2,%d15,8000c206 <__pack_d+0xb4>
8000c19e:	a2 2f       	sub %d15,%d2
8000c1a0:	8b 9f 83 42 	ge %d4,%d15,57
8000c1a4:	82 02       	mov %d2,0
8000c1a6:	df 04 18 80 	jne %d4,0,8000c1d6 <__pack_d+0x84>
8000c1aa:	0b 98 10 48 	mov %e4,%d8,%d9
8000c1ae:	02 f6       	mov %d6,%d15
8000c1b0:	6d ff 58 fc 	call 8000ba60 <__lshrdi3>
8000c1b4:	d2 14       	mov %e4,1
8000c1b6:	02 f6       	mov %d6,%d15
8000c1b8:	0b 32 10 a8 	mov %e10,%d2,%d3
8000c1bc:	6d ff 76 ff 	call 8000c0a8 <__ashldi3>
8000c1c0:	8b f2 9f 20 	addx %d2,%d2,-1
8000c1c4:	8b f3 bf 30 	addc %d3,%d3,-1
8000c1c8:	26 29       	and %d9,%d2
8000c1ca:	26 38       	and %d8,%d3
8000c1cc:	a6 98       	or %d8,%d9
8000c1ce:	02 b2       	mov %d2,%d11
8000c1d0:	8b 08 00 25 	or.ne %d2,%d8,0
8000c1d4:	02 a3       	mov %d3,%d10
8000c1d6:	02 2f       	mov %d15,%d2
8000c1d8:	16 ff       	and %d15,255
8000c1da:	8b 0f 28 f2 	ne %d15,%d15,128
8000c1de:	ee 07       	jnz %d15,8000c1ec <__pack_d+0x9a>
8000c1e0:	8f 02 10 f1 	and %d15,%d2,256
8000c1e4:	6e 08       	jz %d15,8000c1f4 <__pack_d+0xa2>
8000c1e6:	8b 02 88 20 	addx %d2,%d2,128
8000c1ea:	3c 03       	j 8000c1f0 <__pack_d+0x9e>
8000c1ec:	8b f2 87 20 	addx %d2,%d2,127
8000c1f0:	8b 03 a0 30 	addc %d3,%d3,0
8000c1f4:	7b 00 00 41 	movh %d4,4096
8000c1f8:	0b 43 50 f1 	ge.u %d15,%d3,%d4
8000c1fc:	77 23 00 5c 	dextr %d5,%d3,%d2,24
8000c200:	8f 83 1f 40 	sh %d4,%d3,-8
8000c204:	3c 27       	j 8000c252 <__pack_d+0x100>
8000c206:	3b 00 40 30 	mov %d3,1024
8000c20a:	3b f0 7f f0 	mov %d15,2047
8000c20e:	7f 32 22 00 	jge %d2,%d3,8000c252 <__pack_d+0x100>
8000c212:	02 9f       	mov %d15,%d9
8000c214:	16 ff       	and %d15,255
8000c216:	8b 0f 28 f2 	ne %d15,%d15,128
8000c21a:	ee 07       	jnz %d15,8000c228 <__pack_d+0xd6>
8000c21c:	8f 09 10 f1 	and %d15,%d9,256
8000c220:	6e 08       	jz %d15,8000c230 <__pack_d+0xde>
8000c222:	8b 09 88 90 	addx %d9,%d9,128
8000c226:	3c 03       	j 8000c22c <__pack_d+0xda>
8000c228:	8b f9 87 90 	addx %d9,%d9,127
8000c22c:	8b 08 a0 80 	addc %d8,%d8,0
8000c230:	7b 00 00 32 	movh %d3,8192
8000c234:	0b 38 50 f1 	ge.u %d15,%d8,%d3
8000c238:	ee 04       	jnz %d15,8000c240 <__pack_d+0xee>
8000c23a:	1b f2 3f f0 	addi %d15,%d2,1023
8000c23e:	3c 06       	j 8000c24a <__pack_d+0xf8>
8000c240:	77 98 80 9f 	dextr %d9,%d8,%d9,31
8000c244:	1b 02 40 f0 	addi %d15,%d2,1024
8000c248:	06 f8       	sh %d8,-1
8000c24a:	77 98 00 5c 	dextr %d5,%d8,%d9,24
8000c24e:	8f 88 1f 40 	sh %d4,%d8,-8
8000c252:	d2 02       	mov %e2,0
8000c254:	37 43 14 40 	insert %d4,%d3,%d4,0,20
8000c258:	37 f4 0b fa 	insert %d15,%d4,%d15,20,11
8000c25c:	02 52       	mov %d2,%d5
8000c25e:	37 cf 81 3f 	insert %d3,%d15,%d12,31,1
8000c262:	00 90       	ret 

8000c264 <__unpack_d>:
8000c264:	19 44 04 00 	ld.w %d4,[%a4]4
8000c268:	54 42       	ld.w %d2,[%a4]
8000c26a:	37 04 74 50 	extr.u %d5,%d4,0,20
8000c26e:	37 04 6b fa 	extr.u %d15,%d4,20,11
8000c272:	8f 14 1e 40 	sh %d4,%d4,-31
8000c276:	59 54 04 00 	st.w [%a5]4,%d4
8000c27a:	02 53       	mov %d3,%d5
8000c27c:	ee 21       	jnz %d15,8000c2be <__unpack_d+0x5a>
8000c27e:	0f 25 a0 f0 	or %d15,%d5,%d2
8000c282:	ee 03       	jnz %d15,8000c288 <__unpack_d+0x24>
8000c284:	82 2f       	mov %d15,2
8000c286:	3c 23       	j 8000c2cc <__unpack_d+0x68>
8000c288:	3b 20 c0 ff 	mov %d15,-1022
8000c28c:	6c 52       	st.w [%a5]8,%d15
8000c28e:	82 3f       	mov %d15,3
8000c290:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000c294:	2c 50       	st.b [%a5]0,%d15
8000c296:	8f 82 00 20 	sh %d2,%d2,8
8000c29a:	3b 10 c0 ff 	mov %d15,-1023
8000c29e:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000c2a2:	7b 00 00 61 	movh %d6,4096
8000c2a6:	0b 63 30 51 	lt.u %d5,%d3,%d6
8000c2aa:	02 f4       	mov %d4,%d15
8000c2ac:	06 12       	sh %d2,1
8000c2ae:	c2 ff       	add %d15,-1
8000c2b0:	df 05 f7 ff 	jne %d5,0,8000c29e <__unpack_d+0x3a>
8000c2b4:	59 54 08 00 	st.w [%a5]8,%d4
8000c2b8:	59 52 0c 00 	st.w [%a5]12,%d2
8000c2bc:	3c 27       	j 8000c30a <__unpack_d+0xa6>
8000c2be:	3b f0 7f 40 	mov %d4,2047
8000c2c2:	fe 47       	jne %d15,%d4,8000c2f0 <__unpack_d+0x8c>
8000c2c4:	0f 25 a0 f0 	or %d15,%d5,%d2
8000c2c8:	ee 04       	jnz %d15,8000c2d0 <__unpack_d+0x6c>
8000c2ca:	82 4f       	mov %d15,4
8000c2cc:	2c 50       	st.b [%a5]0,%d15
8000c2ce:	00 90       	ret 
8000c2d0:	7b 80 00 f0 	movh %d15,8
8000c2d4:	26 5f       	and %d15,%d5
8000c2d6:	6e 02       	jz %d15,8000c2da <__unpack_d+0x76>
8000c2d8:	82 1f       	mov %d15,1
8000c2da:	2c 50       	st.b [%a5]0,%d15
8000c2dc:	b7 03 81 f9 	insert %d15,%d3,0,19,1
8000c2e0:	77 2f 00 f4 	dextr %d15,%d15,%d2,8
8000c2e4:	8f 82 00 40 	sh %d4,%d2,8
8000c2e8:	59 54 0c 00 	st.w [%a5]12,%d4
8000c2ec:	6c 54       	st.w [%a5]16,%d15
8000c2ee:	00 90       	ret 
8000c2f0:	1b 1f c0 ff 	addi %d15,%d15,-1023
8000c2f4:	77 25 00 34 	dextr %d3,%d5,%d2,8
8000c2f8:	6c 52       	st.w [%a5]8,%d15
8000c2fa:	8f 82 00 20 	sh %d2,%d2,8
8000c2fe:	82 3f       	mov %d15,3
8000c300:	b7 f3 01 3e 	insert %d3,%d3,15,28,1
8000c304:	2c 50       	st.b [%a5]0,%d15
8000c306:	59 52 0c 00 	st.w [%a5]12,%d2
8000c30a:	59 53 10 00 	st.w [%a5]16,%d3
8000c30e:	00 90       	ret 

8000c310 <__pack_f>:
8000c310:	14 45       	ld.bu %d5,[%a4]
8000c312:	4c 43       	ld.w %d15,[%a4]12
8000c314:	19 47 04 00 	ld.w %d7,[%a4]4
8000c318:	ff 25 09 80 	jge.u %d5,2,8000c32a <__pack_f+0x1a>
8000c31c:	37 0f f6 33 	extr.u %d3,%d15,7,22
8000c320:	b7 f3 01 3b 	insert %d3,%d3,15,22,1
8000c324:	3b f0 0f 40 	mov %d4,255
8000c328:	3c 4f       	j 8000c3c6 <__pack_f+0xb6>
8000c32a:	3b f0 0f 40 	mov %d4,255
8000c32e:	82 03       	mov %d3,0
8000c330:	df 45 4b 00 	jeq %d5,4,8000c3c6 <__pack_f+0xb6>
8000c334:	8b 25 00 62 	eq %d6,%d5,2
8000c338:	8b 0f e0 64 	or.eq %d6,%d15,0
8000c33c:	82 04       	mov %d4,0
8000c33e:	df 06 44 80 	jne %d6,0,8000c3c6 <__pack_f+0xb6>
8000c342:	19 45 08 00 	ld.w %d5,[%a4]8
8000c346:	8b 25 98 42 	ge %d4,%d5,-126
8000c34a:	df 04 24 80 	jne %d4,0,8000c392 <__pack_f+0x82>
8000c34e:	8b 25 18 51 	rsub %d5,%d5,-126
8000c352:	8b a5 81 42 	ge %d4,%d5,26
8000c356:	f6 4c       	jnz %d4,8000c36e <__pack_f+0x5e>
8000c358:	82 12       	mov %d2,1
8000c35a:	0f 52 00 20 	sh %d2,%d2,%d5
8000c35e:	8b 05 00 31 	rsub %d3,%d5,0
8000c362:	c2 f2       	add %d2,-1
8000c364:	0f 3f 00 30 	sh %d3,%d15,%d3
8000c368:	26 2f       	and %d15,%d2
8000c36a:	8b 0f 00 35 	or.ne %d3,%d15,0
8000c36e:	8f f3 07 f1 	and %d15,%d3,127
8000c372:	8b 0f 24 f2 	ne %d15,%d15,64
8000c376:	ee 06       	jnz %d15,8000c382 <__pack_f+0x72>
8000c378:	8f 03 08 f1 	and %d15,%d3,128
8000c37c:	ab 03 04 3f 	cadd %d3,%d15,%d3,64
8000c380:	3c 03       	j 8000c386 <__pack_f+0x76>
8000c382:	1b f3 03 30 	addi %d3,%d3,63
8000c386:	7b 00 00 f4 	movh %d15,16384
8000c38a:	0b f3 50 41 	ge.u %d4,%d3,%d15
8000c38e:	06 93       	sh %d3,-7
8000c390:	3c 1b       	j 8000c3c6 <__pack_f+0xb6>
8000c392:	8b 05 88 62 	ge %d6,%d5,128
8000c396:	3b f0 0f 40 	mov %d4,255
8000c39a:	df 06 16 80 	jne %d6,0,8000c3c6 <__pack_f+0xb6>
8000c39e:	8f ff 07 31 	and %d3,%d15,127
8000c3a2:	8b 03 24 32 	ne %d3,%d3,64
8000c3a6:	f6 36       	jnz %d3,8000c3b2 <__pack_f+0xa2>
8000c3a8:	8f 0f 08 31 	and %d3,%d15,128
8000c3ac:	ab 0f 04 f3 	cadd %d15,%d3,%d15,64
8000c3b0:	3c 03       	j 8000c3b6 <__pack_f+0xa6>
8000c3b2:	1b ff 03 f0 	addi %d15,%d15,63
8000c3b6:	1b f5 07 40 	addi %d4,%d5,127
8000c3ba:	ce f4       	jgez %d15,8000c3c2 <__pack_f+0xb2>
8000c3bc:	06 ff       	sh %d15,-1
8000c3be:	1b 05 08 40 	addi %d4,%d5,128
8000c3c2:	8f 9f 1f 30 	sh %d3,%d15,-7
8000c3c6:	82 02       	mov %d2,0
8000c3c8:	37 32 17 20 	insert %d2,%d2,%d3,0,23
8000c3cc:	37 42 88 2b 	insert %d2,%d2,%d4,23,8
8000c3d0:	37 72 81 2f 	insert %d2,%d2,%d7,31,1
8000c3d4:	00 90       	ret 

8000c3d6 <malloc>:
8000c3d6:	91 00 00 f7 	movh.a %a15,28672
8000c3da:	99 f4 78 00 	ld.a %a4,[%a15]1080 <70000438 <_impure_ptr>>
8000c3de:	1d 00 09 00 	j 8000c3f0 <_malloc_r>

8000c3e2 <free>:
8000c3e2:	91 00 00 f7 	movh.a %a15,28672
8000c3e6:	40 45       	mov.aa %a5,%a4
8000c3e8:	99 f4 78 00 	ld.a %a4,[%a15]1080 <70000438 <_impure_ptr>>
8000c3ec:	1d 00 f7 02 	j 8000c9da <_free_r>

8000c3f0 <_malloc_r>:
8000c3f0:	1b b4 00 f0 	addi %d15,%d4,11
8000c3f4:	8b 7f 61 82 	lt.u %d8,%d15,23
8000c3f8:	8f 7f c0 f1 	andn %d15,%d15,7
8000c3fc:	ab 0f a1 88 	seln %d8,%d8,%d15,16
8000c400:	0b 48 30 41 	lt.u %d4,%d8,%d4
8000c404:	8b 08 20 45 	or.lt %d4,%d8,0
8000c408:	40 4d       	mov.aa %a13,%a4
8000c40a:	76 45       	jz %d4,8000c414 <_malloc_r+0x24>
8000c40c:	da 0c       	mov %d15,12
8000c40e:	6c 40       	st.w [%a4]0,%d15
8000c410:	1d 00 2a 02 	j 8000c864 <_malloc_r+0x474>
8000c414:	91 00 00 f7 	movh.a %a15,28672
8000c418:	8b 88 bf f2 	ge.u %d15,%d8,504
8000c41c:	6d 00 37 02 	call 8000c88a <__malloc_lock>
8000c420:	d9 ff 30 00 	lea %a15,[%a15]48 <70000030 <__malloc_av_>>
8000c424:	ee 19       	jnz %d15,8000c456 <_malloc_r+0x66>
8000c426:	8f d8 1f 20 	sh %d2,%d8,-3
8000c42a:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000c42e:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000c432:	7d 2c 09 80 	jne.a %a12,%a2,8000c444 <_malloc_r+0x54>
8000c436:	d9 c2 08 00 	lea %a2,[%a12]8
8000c43a:	99 cc 14 00 	ld.a %a12,[%a12]20
8000c43e:	c2 22       	add %d2,2
8000c440:	7d 2c 58 00 	jeq.a %a12,%a2,8000c4f0 <_malloc_r+0x100>
8000c444:	cc c3       	ld.a %a15,[%a12]12
8000c446:	99 c2 08 00 	ld.a %a2,[%a12]8
8000c44a:	4c c1       	ld.w %d15,[%a12]4
8000c44c:	ec 23       	st.a [%a2]12,%a15
8000c44e:	8f 3f c0 f1 	andn %d15,%d15,3
8000c452:	e8 22       	st.a [%a15]8,%a2
8000c454:	3c 74       	j 8000c53c <_malloc_r+0x14c>
8000c456:	8f 78 1f f0 	sh %d15,%d8,-9
8000c45a:	3b f0 03 20 	mov %d2,63
8000c45e:	6e 27       	jz %d15,8000c4ac <_malloc_r+0xbc>
8000c460:	8f a8 1f 20 	sh %d2,%d8,-6
8000c464:	1b 82 03 20 	addi %d2,%d2,56
8000c468:	bf 5f 22 80 	jlt.u %d15,5,8000c4ac <_malloc_r+0xbc>
8000c46c:	8b 5f a1 22 	ge.u %d2,%d15,21
8000c470:	f6 24       	jnz %d2,8000c478 <_malloc_r+0x88>
8000c472:	1b bf 05 20 	addi %d2,%d15,91
8000c476:	3c 1b       	j 8000c4ac <_malloc_r+0xbc>
8000c478:	8b 5f a5 22 	ge.u %d2,%d15,85
8000c47c:	f6 26       	jnz %d2,8000c488 <_malloc_r+0x98>
8000c47e:	8f 48 1f 20 	sh %d2,%d8,-12
8000c482:	1b e2 06 20 	addi %d2,%d2,110
8000c486:	3c 13       	j 8000c4ac <_malloc_r+0xbc>
8000c488:	8b 5f b5 22 	ge.u %d2,%d15,341
8000c48c:	f6 26       	jnz %d2,8000c498 <_malloc_r+0xa8>
8000c48e:	8f 18 1f 20 	sh %d2,%d8,-15
8000c492:	1b 72 07 20 	addi %d2,%d2,119
8000c496:	3c 0b       	j 8000c4ac <_malloc_r+0xbc>
8000c498:	3b 50 55 30 	mov %d3,1365
8000c49c:	3b e0 07 20 	mov %d2,126
8000c4a0:	7f 3f 06 80 	jge.u %d15,%d3,8000c4ac <_malloc_r+0xbc>
8000c4a4:	8f e8 1e 20 	sh %d2,%d8,-18
8000c4a8:	1b c2 07 20 	addi %d2,%d2,124
8000c4ac:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000c4b0:	99 2c 0c 00 	ld.a %a12,[%a2]12
8000c4b4:	7d 2c 1d 00 	jeq.a %a12,%a2,8000c4ee <_malloc_r+0xfe>
8000c4b8:	19 c4 04 00 	ld.w %d4,[%a12]4
8000c4bc:	8f 34 c0 41 	andn %d4,%d4,3
8000c4c0:	5a 84       	sub %d15,%d4,%d8
8000c4c2:	8b 0f 41 32 	lt %d3,%d15,16
8000c4c6:	f6 33       	jnz %d3,8000c4cc <_malloc_r+0xdc>
8000c4c8:	c2 f2       	add %d2,-1
8000c4ca:	3c 12       	j 8000c4ee <_malloc_r+0xfe>
8000c4cc:	0e fe       	jltz %d15,8000c4e8 <_malloc_r+0xf8>
8000c4ce:	cc c3       	ld.a %a15,[%a12]12
8000c4d0:	99 c2 08 00 	ld.a %a2,[%a12]8
8000c4d4:	ec 23       	st.a [%a2]12,%a15
8000c4d6:	e8 22       	st.a [%a15]8,%a2
8000c4d8:	01 c4 00 f6 	addsc.a %a15,%a12,%d4,0
8000c4dc:	b7 10 21 20 	imask %e2,1,0,1
8000c4e0:	49 f2 44 08 	ldmst [%a15]4,%e2
8000c4e4:	1d 00 cc 01 	j 8000c87c <_malloc_r+0x48c>
8000c4e8:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000c4ec:	3c e4       	j 8000c4b4 <_malloc_r+0xc4>
8000c4ee:	c2 12       	add %d2,1
8000c4f0:	c8 4c       	ld.a %a12,[%a15]16
8000c4f2:	91 00 00 37 	movh.a %a3,28672
8000c4f6:	d9 33 38 00 	lea %a3,[%a3]56 <70000038 <__malloc_av_+0x8>>
8000c4fa:	7d 3c 83 00 	jeq.a %a12,%a3,8000c600 <_malloc_r+0x210>
8000c4fe:	4c c1       	ld.w %d15,[%a12]4
8000c500:	8f 3f c0 f1 	andn %d15,%d15,3
8000c504:	52 83       	sub %d3,%d15,%d8
8000c506:	8b 03 41 42 	lt %d4,%d3,16
8000c50a:	df 04 16 80 	jne %d4,0,8000c536 <_malloc_r+0x146>
8000c50e:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000c512:	8f 18 40 81 	or %d8,%d8,1
8000c516:	59 c8 04 00 	st.w [%a12]4,%d8
8000c51a:	e8 52       	st.a [%a15]20,%a2
8000c51c:	e8 42       	st.a [%a15]16,%a2
8000c51e:	8f 13 40 f1 	or %d15,%d3,1
8000c522:	b5 23 0c 00 	st.a [%a2]12,%a3
8000c526:	b5 23 08 00 	st.a [%a2]8,%a3
8000c52a:	6c 21       	st.w [%a2]4,%d15
8000c52c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000c530:	74 23       	st.w [%a2],%d3
8000c532:	1d 00 a5 01 	j 8000c87c <_malloc_r+0x48c>
8000c536:	e8 53       	st.a [%a15]20,%a3
8000c538:	e8 43       	st.a [%a15]16,%a3
8000c53a:	0e 33       	jltz %d3,8000c540 <_malloc_r+0x150>
8000c53c:	10 cf       	addsc.a %a15,%a12,%d15,0
8000c53e:	3c cf       	j 8000c4dc <_malloc_r+0xec>
8000c540:	3b 00 20 30 	mov %d3,512
8000c544:	7f 3f 15 80 	jge.u %d15,%d3,8000c56e <_malloc_r+0x17e>
8000c548:	06 df       	sh %d15,-3
8000c54a:	d0 f2       	addsc.a %a2,%a15,%d15,3
8000c54c:	48 14       	ld.w %d4,[%a15]4
8000c54e:	99 24 08 00 	ld.a %a4,[%a2]8
8000c552:	8f ef 3f 30 	sha %d3,%d15,-2
8000c556:	b5 c2 0c 00 	st.a [%a12]12,%a2
8000c55a:	b5 c4 08 00 	st.a [%a12]8,%a4
8000c55e:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000c562:	b5 2c 08 00 	st.a [%a2]8,%a12
8000c566:	68 13       	st.w [%a15]4,%d3
8000c568:	b5 4c 0c 00 	st.a [%a4]12,%a12
8000c56c:	3c 4a       	j 8000c600 <_malloc_r+0x210>
8000c56e:	8f af 1f 40 	sh %d4,%d15,-6
8000c572:	8f 7f 1f 30 	sh %d3,%d15,-9
8000c576:	1b 84 03 40 	addi %d4,%d4,56
8000c57a:	bf 53 22 80 	jlt.u %d3,5,8000c5be <_malloc_r+0x1ce>
8000c57e:	8b 53 a1 42 	ge.u %d4,%d3,21
8000c582:	f6 44       	jnz %d4,8000c58a <_malloc_r+0x19a>
8000c584:	1b b3 05 40 	addi %d4,%d3,91
8000c588:	3c 1b       	j 8000c5be <_malloc_r+0x1ce>
8000c58a:	8b 53 a5 42 	ge.u %d4,%d3,85
8000c58e:	f6 46       	jnz %d4,8000c59a <_malloc_r+0x1aa>
8000c590:	8f 4f 1f 40 	sh %d4,%d15,-12
8000c594:	1b e4 06 40 	addi %d4,%d4,110
8000c598:	3c 13       	j 8000c5be <_malloc_r+0x1ce>
8000c59a:	8b 53 b5 42 	ge.u %d4,%d3,341
8000c59e:	f6 46       	jnz %d4,8000c5aa <_malloc_r+0x1ba>
8000c5a0:	8f 1f 1f 40 	sh %d4,%d15,-15
8000c5a4:	1b 74 07 40 	addi %d4,%d4,119
8000c5a8:	3c 0b       	j 8000c5be <_malloc_r+0x1ce>
8000c5aa:	3b 50 55 50 	mov %d5,1365
8000c5ae:	3b e0 07 40 	mov %d4,126
8000c5b2:	7f 53 06 80 	jge.u %d3,%d5,8000c5be <_malloc_r+0x1ce>
8000c5b6:	8f ef 1e 40 	sh %d4,%d15,-18
8000c5ba:	1b c4 07 40 	addi %d4,%d4,124
8000c5be:	01 f4 03 46 	addsc.a %a4,%a15,%d4,3
8000c5c2:	99 42 08 00 	ld.a %a2,[%a4]8
8000c5c6:	7d 42 0d 80 	jne.a %a2,%a4,8000c5e0 <_malloc_r+0x1f0>
8000c5ca:	4c f1       	ld.w %d15,[%a15]4
8000c5cc:	86 e4       	sha %d4,-2
8000c5ce:	d7 1f 01 44 	insert %d4,%d15,1,%d4,1
8000c5d2:	40 24       	mov.aa %a4,%a2
8000c5d4:	68 14       	st.w [%a15]4,%d4
8000c5d6:	3c 0d       	j 8000c5f0 <_malloc_r+0x200>
8000c5d8:	99 22 08 00 	ld.a %a2,[%a2]8
8000c5dc:	7d 42 08 00 	jeq.a %a2,%a4,8000c5ec <_malloc_r+0x1fc>
8000c5e0:	19 23 04 00 	ld.w %d3,[%a2]4
8000c5e4:	8f 33 c0 31 	andn %d3,%d3,3
8000c5e8:	3f 3f f8 ff 	jlt.u %d15,%d3,8000c5d8 <_malloc_r+0x1e8>
8000c5ec:	99 24 0c 00 	ld.a %a4,[%a2]12
8000c5f0:	b5 c4 0c 00 	st.a [%a12]12,%a4
8000c5f4:	b5 c2 08 00 	st.a [%a12]8,%a2
8000c5f8:	b5 4c 08 00 	st.a [%a4]8,%a12
8000c5fc:	b5 2c 0c 00 	st.a [%a2]12,%a12
8000c600:	8f e2 3f 30 	sha %d3,%d2,-2
8000c604:	82 1f       	mov %d15,1
8000c606:	0f 3f 00 f0 	sh %d15,%d15,%d3
8000c60a:	48 13       	ld.w %d3,[%a15]4
8000c60c:	3f f3 73 80 	jlt.u %d3,%d15,8000c6f2 <_malloc_r+0x302>
8000c610:	0f 3f 80 40 	and %d4,%d15,%d3
8000c614:	f6 49       	jnz %d4,8000c626 <_malloc_r+0x236>
8000c616:	8f 32 c0 21 	andn %d2,%d2,3
8000c61a:	06 1f       	sh %d15,1
8000c61c:	0f 3f 80 40 	and %d4,%d15,%d3
8000c620:	c2 42       	add %d2,4
8000c622:	df 04 fc 7f 	jeq %d4,0,8000c61a <_malloc_r+0x22a>
8000c626:	01 f2 03 26 	addsc.a %a2,%a15,%d2,3
8000c62a:	02 24       	mov %d4,%d2
8000c62c:	40 24       	mov.aa %a4,%a2
8000c62e:	99 4c 0c 00 	ld.a %a12,[%a4]12
8000c632:	7d 4c 3c 00 	jeq.a %a12,%a4,8000c6aa <_malloc_r+0x2ba>
8000c636:	19 c6 04 00 	ld.w %d6,[%a12]4
8000c63a:	8f 36 c0 61 	andn %d6,%d6,3
8000c63e:	0b 86 80 30 	sub %d3,%d6,%d8
8000c642:	8b 03 41 52 	lt %d5,%d3,16
8000c646:	df 05 1d 80 	jne %d5,0,8000c680 <_malloc_r+0x290>
8000c64a:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000c64e:	8f 18 40 81 	or %d8,%d8,1
8000c652:	59 c8 04 00 	st.w [%a12]4,%d8
8000c656:	99 c4 0c 00 	ld.a %a4,[%a12]12
8000c65a:	09 c5 88 05 	ld.a %a5,[+%a12]8
8000c65e:	8f 13 40 f1 	or %d15,%d3,1
8000c662:	b5 54 0c 00 	st.a [%a5]12,%a4
8000c666:	b5 45 08 00 	st.a [%a4]8,%a5
8000c66a:	e8 52       	st.a [%a15]20,%a2
8000c66c:	e8 42       	st.a [%a15]16,%a2
8000c66e:	b5 23 0c 00 	st.a [%a2]12,%a3
8000c672:	b5 23 08 00 	st.a [%a2]8,%a3
8000c676:	6c 21       	st.w [%a2]4,%d15
8000c678:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000c67c:	74 23       	st.w [%a2],%d3
8000c67e:	3c 0e       	j 8000c69a <_malloc_r+0x2aa>
8000c680:	bf 03 12 00 	jlt %d3,0,8000c6a4 <_malloc_r+0x2b4>
8000c684:	01 c6 00 f6 	addsc.a %a15,%a12,%d6,0
8000c688:	b7 10 21 20 	imask %e2,1,0,1
8000c68c:	49 f2 44 08 	ldmst [%a15]4,%e2
8000c690:	cc c3       	ld.a %a15,[%a12]12
8000c692:	09 c2 88 05 	ld.a %a2,[+%a12]8
8000c696:	ec 23       	st.a [%a2]12,%a15
8000c698:	e8 22       	st.a [%a15]8,%a2
8000c69a:	40 d4       	mov.aa %a4,%a13
8000c69c:	6d 00 f8 00 	call 8000c88c <__malloc_unlock>
8000c6a0:	1d 00 f3 00 	j 8000c886 <_malloc_r+0x496>
8000c6a4:	99 cc 0c 00 	ld.a %a12,[%a12]12
8000c6a8:	3c c5       	j 8000c632 <_malloc_r+0x242>
8000c6aa:	c2 14       	add %d4,1
8000c6ac:	8f 34 00 31 	and %d3,%d4,3
8000c6b0:	d9 44 08 00 	lea %a4,[%a4]8
8000c6b4:	df 03 bd ff 	jne %d3,0,8000c62e <_malloc_r+0x23e>
8000c6b8:	8f 32 00 31 	and %d3,%d2,3
8000c6bc:	f6 36       	jnz %d3,8000c6c8 <_malloc_r+0x2d8>
8000c6be:	48 12       	ld.w %d2,[%a15]4
8000c6c0:	0f f2 e0 20 	andn %d2,%d2,%d15
8000c6c4:	68 12       	st.w [%a15]4,%d2
8000c6c6:	3c 07       	j 8000c6d4 <_malloc_r+0x2e4>
8000c6c8:	d9 24 f8 ff 	lea %a4,[%a2]-8
8000c6cc:	d4 22       	ld.a %a2,[%a2]
8000c6ce:	c2 f2       	add %d2,-1
8000c6d0:	7d 42 f4 7f 	jeq.a %a2,%a4,8000c6b8 <_malloc_r+0x2c8>
8000c6d4:	06 1f       	sh %d15,1
8000c6d6:	48 12       	ld.w %d2,[%a15]4
8000c6d8:	8b 0f 20 32 	ne %d3,%d15,0
8000c6dc:	0b f2 50 32 	and.ge.u %d3,%d2,%d15
8000c6e0:	76 39       	jz %d3,8000c6f2 <_malloc_r+0x302>
8000c6e2:	0f 2f 80 30 	and %d3,%d15,%d2
8000c6e6:	f6 34       	jnz %d3,8000c6ee <_malloc_r+0x2fe>
8000c6e8:	c2 44       	add %d4,4
8000c6ea:	06 1f       	sh %d15,1
8000c6ec:	3c fb       	j 8000c6e2 <_malloc_r+0x2f2>
8000c6ee:	02 42       	mov %d2,%d4
8000c6f0:	3c 9b       	j 8000c626 <_malloc_r+0x236>
8000c6f2:	c8 2c       	ld.a %a12,[%a15]8
8000c6f4:	19 ca 04 00 	ld.w %d10,[%a12]4
8000c6f8:	8f 3a c0 a1 	andn %d10,%d10,3
8000c6fc:	5a 8a       	sub %d15,%d10,%d8
8000c6fe:	8b 0f 41 22 	lt %d2,%d15,16
8000c702:	0b 8a a0 22 	or.lt.u %d2,%d10,%d8
8000c706:	df 02 b1 00 	jeq %d2,0,8000c868 <_malloc_r+0x478>
8000c70a:	91 00 00 27 	movh.a %a2,28672
8000c70e:	19 2b 98 d0 	ld.w %d11,[%a2]2904 <70000b58 <__malloc_top_pad>>
8000c712:	91 00 00 27 	movh.a %a2,28672
8000c716:	42 8b       	add %d11,%d8
8000c718:	19 23 28 00 	ld.w %d3,[%a2]40 <70000028 <__malloc_sbrk_base>>
8000c71c:	1b fb 00 f1 	addi %d15,%d11,4111
8000c720:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000c724:	1b 0b 01 20 	addi %d2,%d11,16
8000c728:	8b f3 3f b2 	ne %d11,%d3,-1
8000c72c:	2b 2f 40 bb 	sel %d11,%d11,%d15,%d2
8000c730:	40 d4       	mov.aa %a4,%a13
8000c732:	02 b4       	mov %d4,%d11
8000c734:	80 2c       	mov.d %d12,%a2
8000c736:	6d 00 ac 00 	call 8000c88e <_sbrk_r>
8000c73a:	80 29       	mov.d %d9,%a2
8000c73c:	df f9 86 00 	jeq %d9,-1,8000c848 <_malloc_r+0x458>
8000c740:	80 c2       	mov.d %d2,%a12
8000c742:	80 c3       	mov.d %d3,%a12
8000c744:	42 a2       	add %d2,%d10
8000c746:	80 f4       	mov.d %d4,%a15
8000c748:	0b 29 30 f1 	lt.u %d15,%d9,%d2
8000c74c:	0b 43 10 f2 	and.ne %d15,%d3,%d4
8000c750:	01 fc 10 d4 	ne.a %d13,%a12,%a15
8000c754:	ee 7a       	jnz %d15,8000c848 <_malloc_r+0x458>
8000c756:	91 00 00 e7 	movh.a %a14,28672
8000c75a:	19 e3 a8 c0 	ld.w %d3,[%a14]2856 <70000b28 <__malloc_current_mallinfo>>
8000c75e:	42 b3       	add %d3,%d11
8000c760:	59 e3 a8 c0 	st.w [%a14]2856 <70000b28 <__malloc_current_mallinfo>>,%d3
8000c764:	5f 29 0c 80 	jne %d9,%d2,8000c77c <_malloc_r+0x38c>
8000c768:	b7 09 14 f6 	insert %d15,%d9,0,12,20
8000c76c:	ee 08       	jnz %d15,8000c77c <_malloc_r+0x38c>
8000c76e:	c8 22       	ld.a %a2,[%a15]8
8000c770:	42 ba       	add %d10,%d11
8000c772:	8f 1a 40 a1 	or %d10,%d10,1
8000c776:	59 2a 04 00 	st.w [%a2]4,%d10
8000c77a:	3c 55       	j 8000c824 <_malloc_r+0x434>
8000c77c:	60 c2       	mov.a %a2,%d12
8000c77e:	19 2f 28 00 	ld.w %d15,[%a2]40
8000c782:	5e f6       	jne %d15,-1,8000c78e <_malloc_r+0x39e>
8000c784:	91 00 00 27 	movh.a %a2,28672
8000c788:	59 29 28 00 	st.w [%a2]40 <70000028 <__malloc_sbrk_base>>,%d9
8000c78c:	3c 06       	j 8000c798 <_malloc_r+0x3a8>
8000c78e:	0b 29 80 20 	sub %d2,%d9,%d2
8000c792:	42 23       	add %d3,%d2
8000c794:	59 e3 a8 c0 	st.w [%a14]2856 <70000b28 <__malloc_current_mallinfo>>,%d3
8000c798:	8f 79 00 21 	and %d2,%d9,7
8000c79c:	82 0f       	mov %d15,0
8000c79e:	76 24       	jz %d2,8000c7a6 <_malloc_r+0x3b6>
8000c7a0:	8b 82 00 f1 	rsub %d15,%d2,8
8000c7a4:	42 f9       	add %d9,%d15
8000c7a6:	42 9b       	add %d11,%d9
8000c7a8:	b7 0b 14 b6 	insert %d11,%d11,0,12,20
8000c7ac:	1b 0f 00 21 	addi %d2,%d15,4096
8000c7b0:	5a b2       	sub %d15,%d2,%d11
8000c7b2:	40 d4       	mov.aa %a4,%a13
8000c7b4:	02 f4       	mov %d4,%d15
8000c7b6:	6d 00 6c 00 	call 8000c88e <_sbrk_r>
8000c7ba:	80 22       	mov.d %d2,%a2
8000c7bc:	df f2 04 80 	jne %d2,-1,8000c7c4 <_malloc_r+0x3d4>
8000c7c0:	60 92       	mov.a %a2,%d9
8000c7c2:	82 0f       	mov %d15,0
8000c7c4:	80 2b       	mov.d %d11,%a2
8000c7c6:	19 e2 a8 c0 	ld.w %d2,[%a14]2856 <70000b28 <__malloc_current_mallinfo>>
8000c7ca:	a2 9b       	sub %d11,%d9
8000c7cc:	42 f2       	add %d2,%d15
8000c7ce:	60 92       	mov.a %a2,%d9
8000c7d0:	42 bf       	add %d15,%d11
8000c7d2:	68 29       	st.w [%a15]8,%d9
8000c7d4:	8f 1f 40 31 	or %d3,%d15,1
8000c7d8:	59 e2 a8 c0 	st.w [%a14]2856 <70000b28 <__malloc_current_mallinfo>>,%d2
8000c7dc:	59 23 04 00 	st.w [%a2]4 <70000b28 <__malloc_current_mallinfo>>,%d3
8000c7e0:	df 0d 22 00 	jeq %d13,0,8000c824 <_malloc_r+0x434>
8000c7e4:	8b 0a a1 f2 	ge.u %d15,%d10,16
8000c7e8:	ee 05       	jnz %d15,8000c7f2 <_malloc_r+0x402>
8000c7ea:	82 12       	mov %d2,1
8000c7ec:	59 22 04 00 	st.w [%a2]4,%d2
8000c7f0:	3c 2c       	j 8000c848 <_malloc_r+0x458>
8000c7f2:	1b 4a ff af 	addi %d10,%d10,-12
8000c7f6:	8f 7a c0 f1 	andn %d15,%d10,7
8000c7fa:	10 c2       	addsc.a %a2,%a12,%d15,0
8000c7fc:	82 52       	mov %d2,5
8000c7fe:	59 22 04 00 	st.w [%a2]4,%d2
8000c802:	59 22 08 00 	st.w [%a2]8,%d2
8000c806:	19 c2 04 00 	ld.w %d2,[%a12]4
8000c80a:	8f 12 00 21 	and %d2,%d2,1
8000c80e:	a6 f2       	or %d2,%d15
8000c810:	59 c2 04 00 	st.w [%a12]4,%d2
8000c814:	8b 0f 61 f2 	lt.u %d15,%d15,16
8000c818:	ee 06       	jnz %d15,8000c824 <_malloc_r+0x434>
8000c81a:	40 d4       	mov.aa %a4,%a13
8000c81c:	d9 c5 08 00 	lea %a5,[%a12]8
8000c820:	6d 00 dd 00 	call 8000c9da <_free_r>
8000c824:	91 00 00 27 	movh.a %a2,28672
8000c828:	19 ef a8 c0 	ld.w %d15,[%a14]2856 <70000b28 <__malloc_current_mallinfo>>
8000c82c:	19 22 94 d0 	ld.w %d2,[%a2]2900 <70000b54 <__malloc_max_sbrked_mem>>
8000c830:	7f f2 04 80 	jge.u %d2,%d15,8000c838 <_malloc_r+0x448>
8000c834:	59 2f 94 d0 	st.w [%a2]2900 <70000b54 <__malloc_max_sbrked_mem>>,%d15
8000c838:	91 00 00 27 	movh.a %a2,28672
8000c83c:	19 22 90 d0 	ld.w %d2,[%a2]2896 <70000b50 <__malloc_max_total_mem>>
8000c840:	7f f2 04 80 	jge.u %d2,%d15,8000c848 <_malloc_r+0x458>
8000c844:	59 2f 90 d0 	st.w [%a2]2896 <70000b50 <__malloc_max_total_mem>>,%d15
8000c848:	c8 22       	ld.a %a2,[%a15]8
8000c84a:	19 22 04 00 	ld.w %d2,[%a2]4 <70000b50 <__malloc_max_total_mem>>
8000c84e:	8f 32 c0 21 	andn %d2,%d2,3
8000c852:	5a 82       	sub %d15,%d2,%d8
8000c854:	8b 0f 41 32 	lt %d3,%d15,16
8000c858:	0b 82 a0 32 	or.lt.u %d3,%d2,%d8
8000c85c:	76 36       	jz %d3,8000c868 <_malloc_r+0x478>
8000c85e:	40 d4       	mov.aa %a4,%a13
8000c860:	6d 00 16 00 	call 8000c88c <__malloc_unlock>
8000c864:	a0 0c       	mov.a %a12,0
8000c866:	3c 10       	j 8000c886 <_malloc_r+0x496>
8000c868:	c8 2c       	ld.a %a12,[%a15]8
8000c86a:	8f 18 40 21 	or %d2,%d8,1
8000c86e:	96 01       	or %d15,1
8000c870:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000c874:	59 c2 04 00 	st.w [%a12]4,%d2
8000c878:	e8 22       	st.a [%a15]8,%a2
8000c87a:	6c 21       	st.w [%a2]4,%d15
8000c87c:	40 d4       	mov.aa %a4,%a13
8000c87e:	6d 00 07 00 	call 8000c88c <__malloc_unlock>
8000c882:	d9 cc 08 00 	lea %a12,[%a12]8
8000c886:	40 c2       	mov.aa %a2,%a12
8000c888:	00 90       	ret 

8000c88a <__malloc_lock>:
8000c88a:	00 90       	ret 

8000c88c <__malloc_unlock>:
8000c88c:	00 90       	ret 

8000c88e <_sbrk_r>:
8000c88e:	82 0f       	mov %d15,0
8000c890:	91 00 00 c7 	movh.a %a12,28672
8000c894:	59 cf a0 d0 	st.w [%a12]2912 <70000b60 <errno>>,%d15
8000c898:	40 4f       	mov.aa %a15,%a4
8000c89a:	6d 00 2d 17 	call 8000f6f4 <sbrk>
8000c89e:	80 2f       	mov.d %d15,%a2
8000c8a0:	5e f5       	jne %d15,-1,8000c8aa <_sbrk_r+0x1c>
8000c8a2:	19 cf a0 d0 	ld.w %d15,[%a12]2912 <70000b60 <errno>>
8000c8a6:	6e 02       	jz %d15,8000c8aa <_sbrk_r+0x1c>
8000c8a8:	68 0f       	st.w [%a15]0,%d15
8000c8aa:	00 90       	ret 

8000c8ac <strlen>:
8000c8ac:	80 42       	mov.d %d2,%a4
8000c8ae:	80 4f       	mov.d %d15,%a4
8000c8b0:	60 ff       	mov.a %a15,%d15
8000c8b2:	79 f3 00 00 	ld.b %d3,[%a15]0
8000c8b6:	76 33       	jz %d3,8000c8bc <strlen+0x10>
8000c8b8:	c2 1f       	add %d15,1
8000c8ba:	3c fb       	j 8000c8b0 <strlen+0x4>
8000c8bc:	52 22       	sub %d2,%d15,%d2
8000c8be:	00 90       	ret 

8000c8c0 <_vsnprintf_r>:
8000c8c0:	20 68       	sub.a %sp,104
8000c8c2:	40 4f       	mov.aa %a15,%a4
8000c8c4:	ce 45       	jgez %d4,8000c8ce <_vsnprintf_r+0xe>
8000c8c6:	da 8b       	mov %d15,139
8000c8c8:	6c 40       	st.w [%a4]0,%d15
8000c8ca:	82 f2       	mov %d2,-1
8000c8cc:	00 90       	ret 
8000c8ce:	02 4f       	mov %d15,%d4
8000c8d0:	3b 80 20 20 	mov %d2,520
8000c8d4:	f9 a2 0c 00 	st.h [%sp]12,%d2
8000c8d8:	92 f2       	add %d2,%d15,-1
8000c8da:	ea 02       	cmovn %d2,%d15,0
8000c8dc:	f4 a5       	st.a [%sp],%a5
8000c8de:	b5 a5 10 00 	st.a [%sp]16,%a5
8000c8e2:	59 a2 08 00 	st.w [%sp]8,%d2
8000c8e6:	59 a2 14 00 	st.w [%sp]20,%d2
8000c8ea:	40 a5       	mov.aa %a5,%sp
8000c8ec:	82 f2       	mov %d2,-1
8000c8ee:	f9 a2 0e 00 	st.h [%sp]14,%d2
8000c8f2:	6d 00 4b 01 	call 8000cb88 <_svfprintf_r>
8000c8f6:	ff f2 05 00 	jge %d2,-1,8000c900 <_vsnprintf_r+0x40>
8000c8fa:	3b b0 08 30 	mov %d3,139
8000c8fe:	68 03       	st.w [%a15]0,%d3
8000c900:	6e 04       	jz %d15,8000c908 <_vsnprintf_r+0x48>
8000c902:	d8 00       	ld.a %a15,[%sp]0
8000c904:	82 0f       	mov %d15,0
8000c906:	28 0f       	st.b [%a15]0,%d15
8000c908:	00 90       	ret 

8000c90a <vsnprintf>:
8000c90a:	91 00 00 37 	movh.a %a3,28672
8000c90e:	40 42       	mov.aa %a2,%a4
8000c910:	99 34 78 00 	ld.a %a4,[%a3]1080 <70000438 <_impure_ptr>>
8000c914:	40 5f       	mov.aa %a15,%a5
8000c916:	40 67       	mov.aa %a7,%a6
8000c918:	40 25       	mov.aa %a5,%a2
8000c91a:	40 f6       	mov.aa %a6,%a15
8000c91c:	1d ff d2 ff 	j 8000c8c0 <_vsnprintf_r>

8000c920 <_malloc_trim_r>:
8000c920:	02 4f       	mov %d15,%d4
8000c922:	40 4f       	mov.aa %a15,%a4
8000c924:	6d ff b3 ff 	call 8000c88a <__malloc_lock>
8000c928:	91 00 00 c7 	movh.a %a12,28672
8000c92c:	d9 cc 30 00 	lea %a12,[%a12]48 <70000030 <__malloc_av_>>
8000c930:	99 c2 08 00 	ld.a %a2,[%a12]8 <70000008 <g_vadcChannelIDs>>
8000c934:	3b 00 00 21 	mov %d2,4096
8000c938:	19 28 04 00 	ld.w %d8,[%a2]4
8000c93c:	8f 38 c0 81 	andn %d8,%d8,3
8000c940:	5a f8       	sub %d15,%d8,%d15
8000c942:	1b ff fe f0 	addi %d15,%d15,4079
8000c946:	b7 0f 0c f0 	insert %d15,%d15,0,0,12
8000c94a:	1b 0f 00 ff 	addi %d15,%d15,-4096
8000c94e:	7f 2f 07 00 	jge %d15,%d2,8000c95c <_malloc_trim_r+0x3c>
8000c952:	40 f4       	mov.aa %a4,%a15
8000c954:	6d ff 9c ff 	call 8000c88c <__malloc_unlock>
8000c958:	82 02       	mov %d2,0
8000c95a:	00 90       	ret 
8000c95c:	40 f4       	mov.aa %a4,%a15
8000c95e:	82 04       	mov %d4,0
8000c960:	6d ff 97 ff 	call 8000c88e <_sbrk_r>
8000c964:	99 c3 08 00 	ld.a %a3,[%a12]8
8000c968:	60 84       	mov.a %a4,%d8
8000c96a:	30 43       	add.a %a3,%a4
8000c96c:	7d 32 f3 ff 	jne.a %a2,%a3,8000c952 <_malloc_trim_r+0x32>
8000c970:	40 f4       	mov.aa %a4,%a15
8000c972:	8b 0f 00 41 	rsub %d4,%d15,0
8000c976:	6d ff 8c ff 	call 8000c88e <_sbrk_r>
8000c97a:	80 22       	mov.d %d2,%a2
8000c97c:	df f2 1c 80 	jne %d2,-1,8000c9b4 <_malloc_trim_r+0x94>
8000c980:	40 f4       	mov.aa %a4,%a15
8000c982:	82 04       	mov %d4,0
8000c984:	6d ff 85 ff 	call 8000c88e <_sbrk_r>
8000c988:	99 c3 08 00 	ld.a %a3,[%a12]8
8000c98c:	01 32 20 40 	sub.a %a4,%a2,%a3
8000c990:	80 4f       	mov.d %d15,%a4
8000c992:	8b 0f 41 22 	lt %d2,%d15,16
8000c996:	df 02 de ff 	jne %d2,0,8000c952 <_malloc_trim_r+0x32>
8000c99a:	91 00 00 47 	movh.a %a4,28672
8000c99e:	99 44 28 00 	ld.a %a4,[%a4]40 <70000028 <__malloc_sbrk_base>>
8000c9a2:	96 01       	or %d15,1
8000c9a4:	6c 31       	st.w [%a3]4,%d15
8000c9a6:	01 42 20 20 	sub.a %a2,%a2,%a4
8000c9aa:	91 00 00 47 	movh.a %a4,28672
8000c9ae:	b5 42 a8 c0 	st.a [%a4]2856 <70000b28 <__malloc_current_mallinfo>>,%a2
8000c9b2:	3c d0       	j 8000c952 <_malloc_trim_r+0x32>
8000c9b4:	99 c2 08 00 	ld.a %a2,[%a12]8
8000c9b8:	a2 f8       	sub %d8,%d15
8000c9ba:	8f 18 40 81 	or %d8,%d8,1
8000c9be:	59 28 04 00 	st.w [%a2]4,%d8
8000c9c2:	91 00 00 27 	movh.a %a2,28672
8000c9c6:	19 22 a8 c0 	ld.w %d2,[%a2]2856 <70000b28 <__malloc_current_mallinfo>>
8000c9ca:	40 f4       	mov.aa %a4,%a15
8000c9cc:	5a f2       	sub %d15,%d2,%d15
8000c9ce:	59 2f a8 c0 	st.w [%a2]2856 <70000b28 <__malloc_current_mallinfo>>,%d15
8000c9d2:	6d ff 5d ff 	call 8000c88c <__malloc_unlock>
8000c9d6:	82 12       	mov %d2,1
8000c9d8:	00 90       	ret 

8000c9da <_free_r>:
8000c9da:	40 4d       	mov.aa %a13,%a4
8000c9dc:	bd 05 d4 00 	jz.a %a5,8000cb84 <_free_r+0x1aa>
8000c9e0:	40 5c       	mov.aa %a12,%a5
8000c9e2:	6d ff 54 ff 	call 8000c88a <__malloc_lock>
8000c9e6:	19 c4 fc ff 	ld.w %d4,[%a12]-4
8000c9ea:	d9 cf f8 ff 	lea %a15,[%a12]-8
8000c9ee:	8f 14 c0 f1 	andn %d15,%d4,1
8000c9f2:	91 00 00 27 	movh.a %a2,28672
8000c9f6:	10 f3       	addsc.a %a3,%a15,%d15,0
8000c9f8:	d9 22 30 00 	lea %a2,[%a2]48 <70000030 <__malloc_av_>>
8000c9fc:	99 24 08 00 	ld.a %a4,[%a2]8 <70000008 <g_vadcChannelIDs>>
8000ca00:	19 33 04 00 	ld.w %d3,[%a3]4 <70000008 <g_vadcChannelIDs>>
8000ca04:	8f 14 00 41 	and %d4,%d4,1
8000ca08:	8f 33 c0 31 	andn %d3,%d3,3
8000ca0c:	7d 43 24 80 	jne.a %a3,%a4,8000ca54 <_free_r+0x7a>
8000ca10:	42 3f       	add %d15,%d3
8000ca12:	f6 4d       	jnz %d4,8000ca2c <_free_r+0x52>
8000ca14:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000ca18:	60 23       	mov.a %a3,%d2
8000ca1a:	42 2f       	add %d15,%d2
8000ca1c:	01 3f 20 f0 	sub.a %a15,%a15,%a3
8000ca20:	c8 33       	ld.a %a3,[%a15]12
8000ca22:	c8 24       	ld.a %a4,[%a15]8
8000ca24:	b5 43 0c 00 	st.a [%a4]12,%a3
8000ca28:	b5 34 08 00 	st.a [%a3]8,%a4
8000ca2c:	8f 1f 40 21 	or %d2,%d15,1
8000ca30:	68 12       	st.w [%a15]4,%d2
8000ca32:	ec 22       	st.a [%a2]8,%a15
8000ca34:	91 00 00 f7 	movh.a %a15,28672
8000ca38:	19 f2 2c 00 	ld.w %d2,[%a15]44 <7000002c <__malloc_trim_threshold>>
8000ca3c:	3f 2f 09 80 	jlt.u %d15,%d2,8000ca4e <_free_r+0x74>
8000ca40:	91 00 00 f7 	movh.a %a15,28672
8000ca44:	40 d4       	mov.aa %a4,%a13
8000ca46:	19 f4 98 d0 	ld.w %d4,[%a15]2904 <70000b58 <__malloc_top_pad>>
8000ca4a:	6d ff 6b ff 	call 8000c920 <_malloc_trim_r>
8000ca4e:	40 d4       	mov.aa %a4,%a13
8000ca50:	1d ff 1e ff 	j 8000c88c <__malloc_unlock>
8000ca54:	59 33 04 00 	st.w [%a3]4,%d3
8000ca58:	82 02       	mov %d2,0
8000ca5a:	df 04 16 80 	jne %d4,0,8000ca86 <_free_r+0xac>
8000ca5e:	19 c2 f8 ff 	ld.w %d2,[%a12]-8
8000ca62:	60 24       	mov.a %a4,%d2
8000ca64:	42 2f       	add %d15,%d2
8000ca66:	01 4f 20 f0 	sub.a %a15,%a15,%a4
8000ca6a:	c8 25       	ld.a %a5,[%a15]8
8000ca6c:	91 00 00 47 	movh.a %a4,28672
8000ca70:	d9 44 38 00 	lea %a4,[%a4]56 <70000038 <__malloc_av_+0x8>>
8000ca74:	82 12       	mov %d2,1
8000ca76:	7d 45 08 00 	jeq.a %a5,%a4,8000ca86 <_free_r+0xac>
8000ca7a:	c8 34       	ld.a %a4,[%a15]12
8000ca7c:	82 02       	mov %d2,0
8000ca7e:	b5 54 0c 00 	st.a [%a5]12,%a4
8000ca82:	b5 45 08 00 	st.a [%a4]8,%a5
8000ca86:	01 33 00 46 	addsc.a %a4,%a3,%d3,0
8000ca8a:	19 44 04 00 	ld.w %d4,[%a4]4
8000ca8e:	6f 04 18 80 	jnz.t %d4,0,8000cabe <_free_r+0xe4>
8000ca92:	42 3f       	add %d15,%d3
8000ca94:	99 35 08 00 	ld.a %a5,[%a3]8
8000ca98:	f6 2d       	jnz %d2,8000cab2 <_free_r+0xd8>
8000ca9a:	91 00 00 47 	movh.a %a4,28672
8000ca9e:	d9 44 38 00 	lea %a4,[%a4]56 <70000038 <__malloc_av_+0x8>>
8000caa2:	7d 45 08 80 	jne.a %a5,%a4,8000cab2 <_free_r+0xd8>
8000caa6:	ec 25       	st.a [%a2]20,%a15
8000caa8:	ec 24       	st.a [%a2]16,%a15
8000caaa:	e8 35       	st.a [%a15]12,%a5
8000caac:	e8 25       	st.a [%a15]8,%a5
8000caae:	82 12       	mov %d2,1
8000cab0:	3c 07       	j 8000cabe <_free_r+0xe4>
8000cab2:	99 33 0c 00 	ld.a %a3,[%a3]12
8000cab6:	b5 53 0c 00 	st.a [%a5]12,%a3
8000caba:	b5 35 08 00 	st.a [%a3]8,%a5
8000cabe:	8f 1f 40 31 	or %d3,%d15,1
8000cac2:	10 f3       	addsc.a %a3,%a15,%d15,0
8000cac4:	68 13       	st.w [%a15]4,%d3
8000cac6:	6c 30       	st.w [%a3]0,%d15
8000cac8:	df 02 c3 ff 	jne %d2,0,8000ca4e <_free_r+0x74>
8000cacc:	3b 00 20 20 	mov %d2,512
8000cad0:	7f 2f 12 80 	jge.u %d15,%d2,8000caf4 <_free_r+0x11a>
8000cad4:	19 23 04 00 	ld.w %d3,[%a2]4
8000cad8:	06 df       	sh %d15,-3
8000cada:	8f ef 3f 20 	sha %d2,%d15,-2
8000cade:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
8000cae2:	59 22 04 00 	st.w [%a2]4,%d2
8000cae6:	d0 22       	addsc.a %a2,%a2,%d15,3
8000cae8:	99 23 08 00 	ld.a %a3,[%a2]8
8000caec:	e8 32       	st.a [%a15]12,%a2
8000caee:	e8 23       	st.a [%a15]8,%a3
8000caf0:	ec 22       	st.a [%a2]8,%a15
8000caf2:	3c 46       	j 8000cb7e <_free_r+0x1a4>
8000caf4:	8f af 1f 30 	sh %d3,%d15,-6
8000caf8:	8f 7f 1f 20 	sh %d2,%d15,-9
8000cafc:	1b 83 03 30 	addi %d3,%d3,56
8000cb00:	bf 52 22 80 	jlt.u %d2,5,8000cb44 <_free_r+0x16a>
8000cb04:	8b 52 a1 32 	ge.u %d3,%d2,21
8000cb08:	f6 34       	jnz %d3,8000cb10 <_free_r+0x136>
8000cb0a:	1b b2 05 30 	addi %d3,%d2,91
8000cb0e:	3c 1b       	j 8000cb44 <_free_r+0x16a>
8000cb10:	8b 52 a5 32 	ge.u %d3,%d2,85
8000cb14:	f6 36       	jnz %d3,8000cb20 <_free_r+0x146>
8000cb16:	8f 4f 1f 30 	sh %d3,%d15,-12
8000cb1a:	1b e3 06 30 	addi %d3,%d3,110
8000cb1e:	3c 13       	j 8000cb44 <_free_r+0x16a>
8000cb20:	8b 52 b5 32 	ge.u %d3,%d2,341
8000cb24:	f6 36       	jnz %d3,8000cb30 <_free_r+0x156>
8000cb26:	8f 1f 1f 30 	sh %d3,%d15,-15
8000cb2a:	1b 73 07 30 	addi %d3,%d3,119
8000cb2e:	3c 0b       	j 8000cb44 <_free_r+0x16a>
8000cb30:	3b 50 55 40 	mov %d4,1365
8000cb34:	3b e0 07 30 	mov %d3,126
8000cb38:	7f 42 06 80 	jge.u %d2,%d4,8000cb44 <_free_r+0x16a>
8000cb3c:	8f ef 1e 30 	sh %d3,%d15,-18
8000cb40:	1b c3 07 30 	addi %d3,%d3,124
8000cb44:	01 23 03 66 	addsc.a %a6,%a2,%d3,3
8000cb48:	99 65 08 00 	ld.a %a5,[%a6]8
8000cb4c:	40 53       	mov.aa %a3,%a5
8000cb4e:	7d 65 0d 80 	jne.a %a5,%a6,8000cb68 <_free_r+0x18e>
8000cb52:	4c 21       	ld.w %d15,[%a2]4
8000cb54:	86 e3       	sha %d3,-2
8000cb56:	d7 1f 01 33 	insert %d3,%d15,1,%d3,1
8000cb5a:	59 23 04 00 	st.w [%a2]4,%d3
8000cb5e:	3c 0d       	j 8000cb78 <_free_r+0x19e>
8000cb60:	99 33 08 00 	ld.a %a3,[%a3]8
8000cb64:	7d 63 08 00 	jeq.a %a3,%a6,8000cb74 <_free_r+0x19a>
8000cb68:	19 32 04 00 	ld.w %d2,[%a3]4
8000cb6c:	8f 32 c0 21 	andn %d2,%d2,3
8000cb70:	3f 2f f8 ff 	jlt.u %d15,%d2,8000cb60 <_free_r+0x186>
8000cb74:	99 35 0c 00 	ld.a %a5,[%a3]12
8000cb78:	e8 35       	st.a [%a15]12,%a5
8000cb7a:	e8 23       	st.a [%a15]8,%a3
8000cb7c:	ec 52       	st.a [%a5]8,%a15
8000cb7e:	ec 33       	st.a [%a3]12,%a15
8000cb80:	1d ff 67 ff 	j 8000ca4e <_free_r+0x74>
8000cb84:	00 90       	ret 
	...

8000cb88 <_svfprintf_r>:
8000cb88:	20 d0       	sub.a %sp,208
8000cb8a:	80 5b       	mov.d %d11,%a5
8000cb8c:	80 4c       	mov.d %d12,%a4
8000cb8e:	b5 a6 18 00 	st.a [%sp]24,%a6
8000cb92:	40 7f       	mov.aa %a15,%a7
8000cb94:	6d 00 c4 0f 	call 8000eb1c <_localeconv_r>
8000cb98:	d4 22       	ld.a %a2,[%a2]
8000cb9a:	40 24       	mov.aa %a4,%a2
8000cb9c:	b5 a2 34 00 	st.a [%sp]52,%a2
8000cba0:	6d ff 86 fe 	call 8000c8ac <strlen>
8000cba4:	60 b2       	mov.a %a2,%d11
8000cba6:	59 a2 20 00 	st.w [%sp]32,%d2
8000cbaa:	8c 26       	ld.h %d15,[%a2]12
8000cbac:	6f 7f 16 00 	jz.t %d15,7,8000cbd8 <_svfprintf_r+0x50>
8000cbb0:	4c 24       	ld.w %d15,[%a2]16
8000cbb2:	ee 13       	jnz %d15,8000cbd8 <_svfprintf_r+0x50>
8000cbb4:	60 c4       	mov.a %a4,%d12
8000cbb6:	3b 00 04 40 	mov %d4,64
8000cbba:	6d ff 1b fc 	call 8000c3f0 <_malloc_r>
8000cbbe:	60 b3       	mov.a %a3,%d11
8000cbc0:	f4 32       	st.a [%a3],%a2
8000cbc2:	b5 32 10 00 	st.a [%a3]16,%a2
8000cbc6:	7c 26       	jnz.a %a2,8000cbd2 <_svfprintf_r+0x4a>
8000cbc8:	60 cf       	mov.a %a15,%d12
8000cbca:	da 0c       	mov %d15,12
8000cbcc:	68 0f       	st.w [%a15]0,%d15
8000cbce:	82 f2       	mov %d2,-1
8000cbd0:	00 90       	ret 
8000cbd2:	60 b2       	mov.a %a2,%d11
8000cbd4:	da 40       	mov %d15,64
8000cbd6:	6c 25       	st.w [%a2]20,%d15
8000cbd8:	82 0f       	mov %d15,0
8000cbda:	d9 a2 10 20 	lea %a2,[%sp]144
8000cbde:	a0 03       	mov.a %a3,0
8000cbe0:	b5 a2 1c 10 	st.a [%sp]92,%a2
8000cbe4:	78 19       	st.w [%sp]100,%d15
8000cbe6:	78 18       	st.w [%sp]96,%d15
8000cbe8:	78 05       	st.w [%sp]20,%d15
8000cbea:	78 0b       	st.w [%sp]44,%d15
8000cbec:	78 0c       	st.w [%sp]48,%d15
8000cbee:	b5 a3 3c 00 	st.a [%sp]60,%a3
8000cbf2:	78 0e       	st.w [%sp]56,%d15
8000cbf4:	78 0a       	st.w [%sp]40,%d15
8000cbf6:	40 2e       	mov.aa %a14,%a2
8000cbf8:	99 ac 18 00 	ld.a %a12,[%sp]24
8000cbfc:	79 cf 00 00 	ld.b %d15,[%a12]0
8000cc00:	8b 0f 20 32 	ne %d3,%d15,0
8000cc04:	8b 5f 22 34 	and.ne %d3,%d15,37
8000cc08:	76 33       	jz %d3,8000cc0e <_svfprintf_r+0x86>
8000cc0a:	b0 1c       	add.a %a12,1
8000cc0c:	3c f8       	j 8000cbfc <_svfprintf_r+0x74>
8000cc0e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000cc12:	01 3c 20 30 	sub.a %a3,%a12,%a3
8000cc16:	80 3f       	mov.d %d15,%a3
8000cc18:	6e 23       	jz %d15,8000cc5e <_svfprintf_r+0xd6>
8000cc1a:	19 a3 24 10 	ld.w %d3,[%sp]100
8000cc1e:	99 a3 18 00 	ld.a %a3,[%sp]24
8000cc22:	42 f3       	add %d3,%d15
8000cc24:	59 a3 24 10 	st.w [%sp]100,%d3
8000cc28:	19 a3 20 10 	ld.w %d3,[%sp]96
8000cc2c:	f4 e3       	st.a [%a14],%a3
8000cc2e:	c2 13       	add %d3,1
8000cc30:	6c e1       	st.w [%a14]4,%d15
8000cc32:	59 a3 20 10 	st.w [%sp]96,%d3
8000cc36:	8b 83 80 32 	ge %d3,%d3,8
8000cc3a:	d9 ee 08 00 	lea %a14,[%a14]8
8000cc3e:	76 3b       	jz %d3,8000cc54 <_svfprintf_r+0xcc>
8000cc40:	60 c4       	mov.a %a4,%d12
8000cc42:	60 b5       	mov.a %a5,%d11
8000cc44:	d9 a6 1c 10 	lea %a6,[%sp]92
8000cc48:	6d 00 7d 12 	call 8000f142 <__ssprint_r>
8000cc4c:	df 02 69 88 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000cc50:	d9 ae 10 20 	lea %a14,[%sp]144
8000cc54:	19 a2 28 00 	ld.w %d2,[%sp]40
8000cc58:	42 f2       	add %d2,%d15
8000cc5a:	59 a2 28 00 	st.w [%sp]40,%d2
8000cc5e:	79 cf 00 00 	ld.b %d15,[%a12]0
8000cc62:	df 0f 56 08 	jeq %d15,0,8000dd0e <_svfprintf_r+0x1186>
8000cc66:	82 0f       	mov %d15,0
8000cc68:	82 02       	mov %d2,0
8000cc6a:	e9 af 01 10 	st.b [%sp]65,%d15
8000cc6e:	d9 c2 01 00 	lea %a2,[%a12]1
8000cc72:	82 0f       	mov %d15,0
8000cc74:	82 fe       	mov %d14,-1
8000cc76:	59 a2 1c 00 	st.w [%sp]28,%d2
8000cc7a:	82 0a       	mov %d10,0
8000cc7c:	79 22 00 00 	ld.b %d2,[%a2]0
8000cc80:	d9 23 01 00 	lea %a3,[%a2]1
8000cc84:	b5 a3 18 00 	st.a [%sp]24,%a3
8000cc88:	59 a2 10 00 	st.w [%sp]16,%d2
8000cc8c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000cc90:	1b 02 fe 3f 	addi %d3,%d2,-32
8000cc94:	8b 93 a5 42 	ge.u %d4,%d3,89
8000cc98:	df 04 19 84 	jne %d4,0,8000d4ca <_svfprintf_r+0x942>
8000cc9c:	91 10 00 28 	movh.a %a2,32769
8000cca0:	d9 22 ec 2c 	lea %a2,[%a2]-13140 <8000ccac <_svfprintf_r+0x124>>
8000cca4:	01 23 02 76 	addsc.a %a7,%a2,%d3,2
8000cca8:	dc 07       	ji %a7
8000ccaa:	00 00       	nop 
8000ccac:	1d 00 c3 00 	j 8000ce32 <_svfprintf_r+0x2aa>
8000ccb0:	1d 00 0d 04 	j 8000d4ca <_svfprintf_r+0x942>
8000ccb4:	1d 00 0b 04 	j 8000d4ca <_svfprintf_r+0x942>
8000ccb8:	1d 00 c0 00 	j 8000ce38 <_svfprintf_r+0x2b0>
8000ccbc:	1d 00 07 04 	j 8000d4ca <_svfprintf_r+0x942>
8000ccc0:	1d 00 05 04 	j 8000d4ca <_svfprintf_r+0x942>
8000ccc4:	1d 00 03 04 	j 8000d4ca <_svfprintf_r+0x942>
8000ccc8:	1d 00 01 04 	j 8000d4ca <_svfprintf_r+0x942>
8000cccc:	1d 00 ff 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ccd0:	1d 00 fd 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ccd4:	1d 00 b5 00 	j 8000ce3e <_svfprintf_r+0x2b6>
8000ccd8:	1d 00 9c 00 	j 8000ce10 <_svfprintf_r+0x288>
8000ccdc:	1d 00 f7 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cce0:	1d 00 b8 00 	j 8000ce50 <_svfprintf_r+0x2c8>
8000cce4:	1d 00 b9 00 	j 8000ce56 <_svfprintf_r+0x2ce>
8000cce8:	1d 00 f1 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ccec:	1d 00 de 00 	j 8000cea8 <_svfprintf_r+0x320>
8000ccf0:	1d 00 df 00 	j 8000ceae <_svfprintf_r+0x326>
8000ccf4:	1d 00 dd 00 	j 8000ceae <_svfprintf_r+0x326>
8000ccf8:	1d 00 db 00 	j 8000ceae <_svfprintf_r+0x326>
8000ccfc:	1d 00 d9 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd00:	1d 00 d7 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd04:	1d 00 d5 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd08:	1d 00 d3 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd0c:	1d 00 d1 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd10:	1d 00 cf 00 	j 8000ceae <_svfprintf_r+0x326>
8000cd14:	1d 00 db 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd18:	1d 00 d9 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd1c:	1d 00 d7 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd20:	1d 00 d5 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd24:	1d 00 d3 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd28:	1d 00 d1 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd2c:	1d 00 cf 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd30:	1d 00 cd 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd34:	1d 00 cb 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd38:	1d 00 c9 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd3c:	1d 00 f9 00 	j 8000cf2e <_svfprintf_r+0x3a6>
8000cd40:	1d 00 21 01 	j 8000cf82 <_svfprintf_r+0x3fa>
8000cd44:	1d 00 c3 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd48:	1d 00 1d 01 	j 8000cf82 <_svfprintf_r+0x3fa>
8000cd4c:	1d 00 bf 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd50:	1d 00 bd 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd54:	1d 00 bb 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd58:	1d 00 b9 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd5c:	1d 00 c6 00 	j 8000cee8 <_svfprintf_r+0x360>
8000cd60:	1d 00 b5 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd64:	1d 00 b3 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd68:	1d 00 92 02 	j 8000d28c <_svfprintf_r+0x704>
8000cd6c:	1d 00 af 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd70:	1d 00 ad 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd74:	1d 00 ab 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd78:	1d 00 a9 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd7c:	1d 00 a7 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd80:	1d 00 d0 02 	j 8000d320 <_svfprintf_r+0x798>
8000cd84:	1d 00 a3 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd88:	1d 00 a1 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd8c:	1d 00 4b 00 	j 8000ce22 <_svfprintf_r+0x29a>
8000cd90:	1d 00 9d 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd94:	1d 00 9b 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd98:	1d 00 99 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cd9c:	1d 00 97 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cda0:	1d 00 95 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cda4:	1d 00 93 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cda8:	1d 00 91 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdac:	1d 00 8f 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdb0:	1d 00 8d 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdb4:	1d 00 8b 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdb8:	1d 00 b0 00 	j 8000cf18 <_svfprintf_r+0x390>
8000cdbc:	1d 00 2f 00 	j 8000ce1a <_svfprintf_r+0x292>
8000cdc0:	1d 00 e1 00 	j 8000cf82 <_svfprintf_r+0x3fa>
8000cdc4:	1d 00 df 00 	j 8000cf82 <_svfprintf_r+0x3fa>
8000cdc8:	1d 00 dd 00 	j 8000cf82 <_svfprintf_r+0x3fa>
8000cdcc:	1d 00 91 00 	j 8000ceee <_svfprintf_r+0x366>
8000cdd0:	1d 00 25 00 	j 8000ce1a <_svfprintf_r+0x292>
8000cdd4:	1d 00 7b 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdd8:	1d 00 79 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cddc:	1d 00 8c 00 	j 8000cef4 <_svfprintf_r+0x36c>
8000cde0:	1d 00 75 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cde4:	1d 00 39 02 	j 8000d256 <_svfprintf_r+0x6ce>
8000cde8:	1d 00 54 02 	j 8000d290 <_svfprintf_r+0x708>
8000cdec:	1d 00 66 02 	j 8000d2b8 <_svfprintf_r+0x730>
8000cdf0:	1d 00 90 00 	j 8000cf10 <_svfprintf_r+0x388>
8000cdf4:	1d 00 6b 03 	j 8000d4ca <_svfprintf_r+0x942>
8000cdf8:	1d 00 77 02 	j 8000d2e6 <_svfprintf_r+0x75e>
8000cdfc:	1d 00 67 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ce00:	1d 00 92 02 	j 8000d324 <_svfprintf_r+0x79c>
8000ce04:	1d 00 63 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ce08:	1d 00 61 03 	j 8000d4ca <_svfprintf_r+0x942>
8000ce0c:	1d 00 a0 02 	j 8000d34c <_svfprintf_r+0x7c4>
8000ce10:	da 2b       	mov %d15,43
8000ce12:	99 a2 18 00 	ld.a %a2,[%sp]24
8000ce16:	1d ff 33 ff 	j 8000cc7c <_svfprintf_r+0xf4>
8000ce1a:	e9 af 01 10 	st.b [%sp]65,%d15
8000ce1e:	1d 00 8c 00 	j 8000cf36 <_svfprintf_r+0x3ae>
8000ce22:	e9 af 01 10 	st.b [%sp]65,%d15
8000ce26:	7b 00 00 f8 	movh %d15,32768
8000ce2a:	1b cf fe f0 	addi %d15,%d15,4076
8000ce2e:	1d 00 95 02 	j 8000d358 <_svfprintf_r+0x7d0>
8000ce32:	ab 0f 82 ff 	sel %d15,%d15,%d15,32
8000ce36:	3c ee       	j 8000ce12 <_svfprintf_r+0x28a>
8000ce38:	8f 1a 40 a1 	or %d10,%d10,1
8000ce3c:	3c eb       	j 8000ce12 <_svfprintf_r+0x28a>
8000ce3e:	48 02       	ld.w %d2,[%a15]0
8000ce40:	b0 4f       	add.a %a15,4
8000ce42:	59 a2 1c 00 	st.w [%sp]28,%d2
8000ce46:	ff 02 e6 7f 	jge %d2,0,8000ce12 <_svfprintf_r+0x28a>
8000ce4a:	32 52       	rsub %d2
8000ce4c:	59 a2 1c 00 	st.w [%sp]28,%d2
8000ce50:	8f 4a 40 a1 	or %d10,%d10,4
8000ce54:	3c df       	j 8000ce12 <_svfprintf_r+0x28a>
8000ce56:	99 a3 18 00 	ld.a %a3,[%sp]24
8000ce5a:	99 a2 18 00 	ld.a %a2,[%sp]24
8000ce5e:	79 32 00 00 	ld.b %d2,[%a3]0
8000ce62:	b0 12       	add.a %a2,1
8000ce64:	59 a2 10 00 	st.w [%sp]16,%d2
8000ce68:	8b a2 02 32 	eq %d3,%d2,42
8000ce6c:	f6 33       	jnz %d3,8000ce72 <_svfprintf_r+0x2ea>
8000ce6e:	82 05       	mov %d5,0
8000ce70:	3c 08       	j 8000ce80 <_svfprintf_r+0x2f8>
8000ce72:	48 0e       	ld.w %d14,[%a15]0
8000ce74:	b5 a2 18 00 	st.a [%sp]24,%a2
8000ce78:	b0 4f       	add.a %a15,4
8000ce7a:	8b fe 5f e3 	max %d14,%d14,-1
8000ce7e:	3c ca       	j 8000ce12 <_svfprintf_r+0x28a>
8000ce80:	19 a2 10 00 	ld.w %d2,[%sp]16
8000ce84:	1b 02 fd 3f 	addi %d3,%d2,-48
8000ce88:	ff a3 0a 80 	jge.u %d3,10,8000ce9c <_svfprintf_r+0x314>
8000ce8c:	79 22 00 00 	ld.b %d2,[%a2]0
8000ce90:	13 a5 20 53 	madd %d5,%d3,%d5,10
8000ce94:	59 a2 10 00 	st.w [%sp]16,%d2
8000ce98:	b0 12       	add.a %a2,1
8000ce9a:	3c f3       	j 8000ce80 <_svfprintf_r+0x2f8>
8000ce9c:	8b f5 5f e3 	max %d14,%d5,-1
8000cea0:	b5 a2 18 00 	st.a [%sp]24,%a2
8000cea4:	1d ff f4 fe 	j 8000cc8c <_svfprintf_r+0x104>
8000cea8:	8f 0a 48 a1 	or %d10,%d10,128
8000ceac:	3c b3       	j 8000ce12 <_svfprintf_r+0x28a>
8000ceae:	82 02       	mov %d2,0
8000ceb0:	59 a2 1c 00 	st.w [%sp]28,%d2
8000ceb4:	19 a2 10 00 	ld.w %d2,[%sp]16
8000ceb8:	99 a3 18 00 	ld.a %a3,[%sp]24
8000cebc:	1b 02 fd 4f 	addi %d4,%d2,-48
8000cec0:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000cec4:	99 a2 18 00 	ld.a %a2,[%sp]24
8000cec8:	13 a2 20 24 	madd %d2,%d4,%d2,10
8000cecc:	b0 12       	add.a %a2,1
8000cece:	59 a2 1c 00 	st.w [%sp]28,%d2
8000ced2:	79 32 00 00 	ld.b %d2,[%a3]0
8000ced6:	b5 a2 18 00 	st.a [%sp]24,%a2
8000ceda:	59 a2 10 00 	st.w [%sp]16,%d2
8000cede:	1b 02 fd 4f 	addi %d4,%d2,-48
8000cee2:	bf a4 e9 ff 	jlt.u %d4,10,8000ceb4 <_svfprintf_r+0x32c>
8000cee6:	3c dd       	j 8000cea0 <_svfprintf_r+0x318>
8000cee8:	8f 8a 40 a1 	or %d10,%d10,8
8000ceec:	3c 93       	j 8000ce12 <_svfprintf_r+0x28a>
8000ceee:	8f 0a 44 a1 	or %d10,%d10,64
8000cef2:	3c 90       	j 8000ce12 <_svfprintf_r+0x28a>
8000cef4:	99 a3 18 00 	ld.a %a3,[%sp]24
8000cef8:	79 33 00 00 	ld.b %d3,[%a3]0
8000cefc:	8b c3 26 32 	ne %d3,%d3,108
8000cf00:	f6 35       	jnz %d3,8000cf0a <_svfprintf_r+0x382>
8000cf02:	b0 13       	add.a %a3,1
8000cf04:	b5 a3 18 00 	st.a [%sp]24,%a3
8000cf08:	3c 04       	j 8000cf10 <_svfprintf_r+0x388>
8000cf0a:	8f 0a 41 a1 	or %d10,%d10,16
8000cf0e:	3c 82       	j 8000ce12 <_svfprintf_r+0x28a>
8000cf10:	8f 0a 42 a1 	or %d10,%d10,32
8000cf14:	1d ff 7f ff 	j 8000ce12 <_svfprintf_r+0x28a>
8000cf18:	48 03       	ld.w %d3,[%a15]0
8000cf1a:	d9 fc 04 00 	lea %a12,[%a15]4
8000cf1e:	e9 a3 28 10 	st.b [%sp]104,%d3
8000cf22:	82 03       	mov %d3,0
8000cf24:	e9 a3 01 10 	st.b [%sp]65,%d3
8000cf28:	60 ad       	mov.a %a13,%d10
8000cf2a:	1d 00 dc 02 	j 8000d4e2 <_svfprintf_r+0x95a>
8000cf2e:	e9 af 01 10 	st.b [%sp]65,%d15
8000cf32:	8f 0a 41 a1 	or %d10,%d10,16
8000cf36:	60 ad       	mov.a %a13,%d10
8000cf38:	6f 5a 07 00 	jz.t %d10,5,8000cf46 <_svfprintf_r+0x3be>
8000cf3c:	d9 fc 08 00 	lea %a12,[%a15]8
8000cf40:	09 f8 40 09 	ld.d %e8,[%a15]
8000cf44:	3c 12       	j 8000cf68 <_svfprintf_r+0x3e0>
8000cf46:	d9 f2 04 00 	lea %a2,[%a15]4
8000cf4a:	6f 4a 05 00 	jz.t %d10,4,8000cf54 <_svfprintf_r+0x3cc>
8000cf4e:	40 2c       	mov.aa %a12,%a2
8000cf50:	48 08       	ld.w %d8,[%a15]0
8000cf52:	3c 09       	j 8000cf64 <_svfprintf_r+0x3dc>
8000cf54:	48 03       	ld.w %d3,[%a15]0
8000cf56:	40 2c       	mov.aa %a12,%a2
8000cf58:	0b 30 00 88 	mov %e8,%d3
8000cf5c:	6f 6a 06 00 	jz.t %d10,6,8000cf68 <_svfprintf_r+0x3e0>
8000cf60:	37 03 50 80 	extr %d8,%d3,0,16
8000cf64:	0b 80 00 88 	mov %e8,%d8
8000cf68:	82 13       	mov %d3,1
8000cf6a:	ff 09 1d 02 	jge %d9,0,8000d3a4 <_svfprintf_r+0x81c>
8000cf6e:	32 59       	rsub %d9
8000cf70:	32 58       	rsub %d8
8000cf72:	3b d0 02 70 	mov %d7,45
8000cf76:	ab f9 1f 98 	cadd %d9,%d8,%d9,-1
8000cf7a:	e9 a7 01 10 	st.b [%sp]65,%d7
8000cf7e:	1d 00 13 02 	j 8000d3a4 <_svfprintf_r+0x81c>
8000cf82:	e9 af 01 10 	st.b [%sp]65,%d15
8000cf86:	4c f0       	ld.w %d15,[%a15]0
8000cf88:	d9 fc 08 00 	lea %a12,[%a15]8
8000cf8c:	78 0b       	st.w [%sp]44,%d15
8000cf8e:	4c f1       	ld.w %d15,[%a15]4
8000cf90:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000cf94:	78 0c       	st.w [%sp]48,%d15
8000cf96:	19 a5 30 00 	ld.w %d5,[%sp]48
8000cf9a:	6d 00 b3 10 	call 8000f100 <__fpclassifyd>
8000cf9e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000cfa2:	19 a5 30 00 	ld.w %d5,[%sp]48
8000cfa6:	df 12 18 80 	jne %d2,1,8000cfd6 <_svfprintf_r+0x44e>
8000cfaa:	d2 06       	mov %e6,0
8000cfac:	6d 00 50 14 	call 8000f84c <__ltdf2>
8000cfb0:	ce 25       	jgez %d2,8000cfba <_svfprintf_r+0x432>
8000cfb2:	3b d0 02 30 	mov %d3,45
8000cfb6:	e9 a3 01 10 	st.b [%sp]65,%d3
8000cfba:	58 04       	ld.w %d15,[%sp]16
8000cfbc:	7b 00 00 78 	movh %d7,32768
8000cfc0:	8b 8f 84 32 	ge %d3,%d15,72
8000cfc4:	1b 07 fe d0 	addi %d13,%d7,4064
8000cfc8:	df 03 17 80 	jne %d3,0,8000cff6 <_svfprintf_r+0x46e>
8000cfcc:	7b 00 00 78 	movh %d7,32768
8000cfd0:	1b c7 fd d0 	addi %d13,%d7,4060
8000cfd4:	3c 11       	j 8000cff6 <_svfprintf_r+0x46e>
8000cfd6:	6d 00 95 10 	call 8000f100 <__fpclassifyd>
8000cfda:	58 04       	ld.w %d15,[%sp]16
8000cfdc:	df 02 13 80 	jne %d2,0,8000d002 <_svfprintf_r+0x47a>
8000cfe0:	7b 00 00 78 	movh %d7,32768
8000cfe4:	8b 8f 84 32 	ge %d3,%d15,72
8000cfe8:	1b 87 fe d0 	addi %d13,%d7,4072
8000cfec:	f6 35       	jnz %d3,8000cff6 <_svfprintf_r+0x46e>
8000cfee:	7b 00 00 78 	movh %d7,32768
8000cff2:	1b 47 fe d0 	addi %d13,%d7,4068
8000cff6:	8f 0a c8 a1 	andn %d10,%d10,128
8000cffa:	60 ad       	mov.a %a13,%d10
8000cffc:	82 39       	mov %d9,3
8000cffe:	1d 00 78 02 	j 8000d4ee <_svfprintf_r+0x966>
8000d002:	8f 0f c2 f1 	andn %d15,%d15,32
8000d006:	78 01       	st.w [%sp]4,%d15
8000d008:	df fe 09 00 	jeq %d14,-1,8000d01a <_svfprintf_r+0x492>
8000d00c:	8b 0e 00 72 	eq %d7,%d14,0
8000d010:	8b 7f 04 74 	and.eq %d7,%d15,71
8000d014:	ab 1e a0 e7 	seln %d14,%d7,%d14,1
8000d018:	3c 02       	j 8000d01c <_svfprintf_r+0x494>
8000d01a:	82 6e       	mov %d14,6
8000d01c:	19 a3 30 00 	ld.w %d3,[%sp]48
8000d020:	8f 0a 50 21 	or %d2,%d10,256
8000d024:	60 2d       	mov.a %a13,%d2
8000d026:	d8 0b       	ld.a %a15,[%sp]44
8000d028:	82 0f       	mov %d15,0
8000d02a:	ce 34       	jgez %d3,8000d032 <_svfprintf_r+0x4aa>
8000d02c:	9b 03 00 38 	addih %d3,%d3,32768
8000d030:	da 2d       	mov %d15,45
8000d032:	78 09       	st.w [%sp]36,%d15
8000d034:	58 01       	ld.w %d15,[%sp]4
8000d036:	02 e9       	mov %d9,%d14
8000d038:	8b 6f 04 22 	eq %d2,%d15,70
8000d03c:	82 36       	mov %d6,3
8000d03e:	f6 28       	jnz %d2,8000d04e <_svfprintf_r+0x4c6>
8000d040:	8b 5f 24 12 	ne %d1,%d15,69
8000d044:	1b 1e 00 50 	addi %d5,%d14,1
8000d048:	82 26       	mov %d6,2
8000d04a:	2b e5 50 91 	seln %d9,%d1,%d5,%d14
8000d04e:	60 c4       	mov.a %a4,%d12
8000d050:	80 f4       	mov.d %d4,%a15
8000d052:	02 35       	mov %d5,%d3
8000d054:	02 97       	mov %d7,%d9
8000d056:	d9 a5 04 10 	lea %a5,[%sp]68
8000d05a:	d9 a6 08 10 	lea %a6,[%sp]72
8000d05e:	d9 a7 14 10 	lea %a7,[%sp]84
8000d062:	59 a2 0c 00 	st.w [%sp]12,%d2
8000d066:	59 a3 08 00 	st.w [%sp]8,%d3
8000d06a:	6d 00 ef 06 	call 8000de48 <_dtoa_r>
8000d06e:	58 01       	ld.w %d15,[%sp]4
8000d070:	80 2d       	mov.d %d13,%a2
8000d072:	8b 7f 24 12 	ne %d1,%d15,71
8000d076:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000d07a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d07e:	df 01 11 80 	jne %d1,0,8000d0a0 <_svfprintf_r+0x518>
8000d082:	6f 0a 0f 80 	jnz.t %d10,0,8000d0a0 <_svfprintf_r+0x518>
8000d086:	19 a2 14 10 	ld.w %d2,[%sp]84
8000d08a:	58 01       	ld.w %d15,[%sp]4
8000d08c:	a2 d2       	sub %d2,%d13
8000d08e:	59 a2 14 00 	st.w [%sp]20,%d2
8000d092:	8b 7f 04 42 	eq %d4,%d15,71
8000d096:	19 a5 04 10 	ld.w %d5,[%sp]68
8000d09a:	df 04 36 80 	jne %d4,0,8000d106 <_svfprintf_r+0x57e>
8000d09e:	3c 3e       	j 8000d11a <_svfprintf_r+0x592>
8000d0a0:	0b 9d 00 80 	add %d8,%d13,%d9
8000d0a4:	df 02 1c 00 	jeq %d2,0,8000d0dc <_svfprintf_r+0x554>
8000d0a8:	60 d2       	mov.a %a2,%d13
8000d0aa:	80 f4       	mov.d %d4,%a15
8000d0ac:	79 20 00 00 	ld.b %d0,[%a2]0
8000d0b0:	d2 06       	mov %e6,0
8000d0b2:	02 35       	mov %d5,%d3
8000d0b4:	8b 00 03 f2 	eq %d15,%d0,48
8000d0b8:	59 a3 08 00 	st.w [%sp]8,%d3
8000d0bc:	6d 00 68 13 	call 8000f78c <__nedf2>
8000d0c0:	8b 02 20 22 	ne %d2,%d2,0
8000d0c4:	0f 2f 80 00 	and %d0,%d15,%d2
8000d0c8:	19 a3 08 00 	ld.w %d3,[%sp]8
8000d0cc:	76 05       	jz %d0,8000d0d6 <_svfprintf_r+0x54e>
8000d0ce:	8b 19 00 01 	rsub %d0,%d9,1
8000d0d2:	59 a0 04 10 	st.w [%sp]68,%d0
8000d0d6:	19 a2 04 10 	ld.w %d2,[%sp]68
8000d0da:	42 28       	add %d8,%d2
8000d0dc:	80 f4       	mov.d %d4,%a15
8000d0de:	d2 06       	mov %e6,0
8000d0e0:	02 35       	mov %d5,%d3
8000d0e2:	6d 00 35 13 	call 8000f74c <__eqdf2>
8000d0e6:	f6 23       	jnz %d2,8000d0ec <_svfprintf_r+0x564>
8000d0e8:	59 a8 14 10 	st.w [%sp]84,%d8
8000d0ec:	3b 00 03 00 	mov %d0,48
8000d0f0:	19 a3 14 10 	ld.w %d3,[%sp]84
8000d0f4:	7f 83 c9 ff 	jge.u %d3,%d8,8000d086 <_svfprintf_r+0x4fe>
8000d0f8:	1b 13 00 10 	addi %d1,%d3,1
8000d0fc:	60 32       	mov.a %a2,%d3
8000d0fe:	59 a1 14 10 	st.w [%sp]84,%d1
8000d102:	34 20       	st.b [%a2],%d0
8000d104:	3c f6       	j 8000d0f0 <_svfprintf_r+0x568>
8000d106:	0b 5e 20 31 	lt %d3,%d14,%d5
8000d10a:	8b d5 3f 35 	or.lt %d3,%d5,-3
8000d10e:	df 03 88 00 	jeq %d3,0,8000d21e <_svfprintf_r+0x696>
8000d112:	58 04       	ld.w %d15,[%sp]16
8000d114:	c2 ef       	add %d15,-2
8000d116:	78 04       	st.w [%sp]16,%d15
8000d118:	3c 06       	j 8000d124 <_svfprintf_r+0x59c>
8000d11a:	58 04       	ld.w %d15,[%sp]16
8000d11c:	8b 6f 86 32 	ge %d3,%d15,102
8000d120:	df 03 69 80 	jne %d3,0,8000d1f2 <_svfprintf_r+0x66a>
8000d124:	19 a2 10 00 	ld.w %d2,[%sp]16
8000d128:	9a f5       	add %d15,%d5,-1
8000d12a:	78 11       	st.w [%sp]68,%d15
8000d12c:	e9 a2 0d 10 	st.b [%sp]77,%d2
8000d130:	3b b0 02 30 	mov %d3,43
8000d134:	ce f4       	jgez %d15,8000d13c <_svfprintf_r+0x5b4>
8000d136:	32 5f       	rsub %d15
8000d138:	3b d0 02 30 	mov %d3,45
8000d13c:	e9 a3 0e 10 	st.b [%sp]78,%d3
8000d140:	8b af 40 32 	lt %d3,%d15,10
8000d144:	df 03 3e 80 	jne %d3,0,8000d1c0 <_svfprintf_r+0x638>
8000d148:	82 06       	mov %d6,0
8000d14a:	3b a0 00 00 	mov %d0,10
8000d14e:	4b 0f 01 42 	div %e4,%d15,%d0
8000d152:	8b 66 00 71 	rsub %d7,%d6,6
8000d156:	60 72       	mov.a %a2,%d7
8000d158:	d9 af 14 10 	lea %a15,[%sp]84
8000d15c:	1b 05 03 30 	addi %d3,%d5,48
8000d160:	30 2f       	add.a %a15,%a2
8000d162:	28 03       	st.b [%a15]0,%d3
8000d164:	8b a4 80 32 	ge %d3,%d4,10
8000d168:	02 4f       	mov %d15,%d4
8000d16a:	c2 16       	add %d6,1
8000d16c:	df 03 f1 ff 	jne %d3,0,8000d14e <_svfprintf_r+0x5c6>
8000d170:	60 74       	mov.a %a4,%d7
8000d172:	d9 a2 10 30 	lea %a2,[%sp]208
8000d176:	1b 04 03 f0 	addi %d15,%d4,48
8000d17a:	30 42       	add.a %a2,%a4
8000d17c:	d9 f7 ff ff 	lea %a7,[%a15]-1
8000d180:	e9 ff ff ff 	st.b [%a15]-1,%d15
8000d184:	80 22       	mov.d %d2,%a2
8000d186:	d9 af 1b 10 	lea %a15,[%sp]91
8000d18a:	80 ff       	mov.d %d15,%a15
8000d18c:	1b 32 f8 4f 	addi %d4,%d2,-125
8000d190:	82 03       	mov %d3,0
8000d192:	01 7f 20 30 	sub.a %a3,%a15,%a7
8000d196:	3f 4f 08 80 	jlt.u %d15,%d4,8000d1a6 <_svfprintf_r+0x61e>
8000d19a:	80 a2       	mov.d %d2,%sp
8000d19c:	1b 02 0d 20 	addi %d2,%d2,208
8000d1a0:	8b 52 07 42 	eq %d4,%d2,117
8000d1a4:	76 46       	jz %d4,8000d1b0 <_svfprintf_r+0x628>
8000d1a6:	a0 03       	mov.a %a3,0
8000d1a8:	3c 04       	j 8000d1b0 <_svfprintf_r+0x628>
8000d1aa:	0c 70       	ld.bu %d15,[%a7]0
8000d1ac:	b0 17       	add.a %a7,1
8000d1ae:	28 0f       	st.b [%a15]0,%d15
8000d1b0:	60 3f       	mov.a %a15,%d3
8000d1b2:	d9 a2 0d 10 	lea %a2,[%sp]77
8000d1b6:	b0 2f       	add.a %a15,2
8000d1b8:	30 2f       	add.a %a15,%a2
8000d1ba:	c2 13       	add %d3,1
8000d1bc:	fc 37       	loop %a3,8000d1aa <_svfprintf_r+0x622>
8000d1be:	3c 0b       	j 8000d1d4 <_svfprintf_r+0x64c>
8000d1c0:	3b 00 03 30 	mov %d3,48
8000d1c4:	1b 0f 03 f0 	addi %d15,%d15,48
8000d1c8:	e9 a3 0f 10 	st.b [%sp]79,%d3
8000d1cc:	e9 af 10 10 	st.b [%sp]80,%d15
8000d1d0:	d9 af 11 10 	lea %a15,[%sp]81
8000d1d4:	d9 a7 0d 10 	lea %a7,[%sp]77
8000d1d8:	01 7f 20 70 	sub.a %a7,%a15,%a7
8000d1dc:	80 79       	mov.d %d9,%a7
8000d1de:	58 05       	ld.w %d15,[%sp]20
8000d1e0:	b5 a7 38 00 	st.a [%sp]56,%a7
8000d1e4:	42 f9       	add %d9,%d15
8000d1e6:	ff 2f 04 00 	jge %d15,2,8000d1ee <_svfprintf_r+0x666>
8000d1ea:	6f 0a 2c 00 	jz.t %d10,0,8000d242 <_svfprintf_r+0x6ba>
8000d1ee:	c2 19       	add %d9,1
8000d1f0:	3c 29       	j 8000d242 <_svfprintf_r+0x6ba>
8000d1f2:	58 04       	ld.w %d15,[%sp]16
8000d1f4:	8b 6f 26 42 	ne %d4,%d15,102
8000d1f8:	df 04 15 80 	jne %d4,0,8000d222 <_svfprintf_r+0x69a>
8000d1fc:	02 59       	mov %d9,%d5
8000d1fe:	8e 59       	jlez %d5,8000d210 <_svfprintf_r+0x688>
8000d200:	f6 e3       	jnz %d14,8000d206 <_svfprintf_r+0x67e>
8000d202:	6f 0a 20 00 	jz.t %d10,0,8000d242 <_svfprintf_r+0x6ba>
8000d206:	1b 1e 00 30 	addi %d3,%d14,1
8000d20a:	0b 35 00 90 	add %d9,%d5,%d3
8000d20e:	3c 1a       	j 8000d242 <_svfprintf_r+0x6ba>
8000d210:	f6 e4       	jnz %d14,8000d218 <_svfprintf_r+0x690>
8000d212:	82 19       	mov %d9,1
8000d214:	6f 0a 17 00 	jz.t %d10,0,8000d242 <_svfprintf_r+0x6ba>
8000d218:	1b 2e 00 90 	addi %d9,%d14,2
8000d21c:	3c 13       	j 8000d242 <_svfprintf_r+0x6ba>
8000d21e:	da 67       	mov %d15,103
8000d220:	78 04       	st.w [%sp]16,%d15
8000d222:	58 05       	ld.w %d15,[%sp]20
8000d224:	8f 1a 00 a1 	and %d10,%d10,1
8000d228:	0b a5 00 90 	add %d9,%d5,%d10
8000d22c:	7f f5 0b 00 	jge %d5,%d15,8000d242 <_svfprintf_r+0x6ba>
8000d230:	8b 15 40 92 	lt %d9,%d5,1
8000d234:	8b 25 00 31 	rsub %d3,%d5,2
8000d238:	ab 13 80 39 	sel %d3,%d9,%d3,1
8000d23c:	19 a9 14 00 	ld.w %d9,[%sp]20
8000d240:	42 39       	add %d9,%d3
8000d242:	58 09       	ld.w %d15,[%sp]36
8000d244:	82 0e       	mov %d14,0
8000d246:	df 0f 55 01 	jeq %d15,0,8000d4f0 <_svfprintf_r+0x968>
8000d24a:	3b d0 02 70 	mov %d7,45
8000d24e:	e9 a7 01 10 	st.b [%sp]65,%d7
8000d252:	1d 00 4f 01 	j 8000d4f0 <_svfprintf_r+0x968>
8000d256:	e9 af 01 10 	st.b [%sp]65,%d15
8000d25a:	d9 f2 04 00 	lea %a2,[%a15]4
8000d25e:	6f 5a 09 00 	jz.t %d10,5,8000d270 <_svfprintf_r+0x6e8>
8000d262:	58 0a       	ld.w %d15,[%sp]40
8000d264:	c8 03       	ld.a %a3,[%a15]0
8000d266:	0b f0 00 48 	mov %e4,%d15
8000d26a:	89 34 40 09 	st.d [%a3],%e4
8000d26e:	3c 0c       	j 8000d286 <_svfprintf_r+0x6fe>
8000d270:	6f 4a 08 80 	jnz.t %d10,4,8000d280 <_svfprintf_r+0x6f8>
8000d274:	6f 6a 06 00 	jz.t %d10,6,8000d280 <_svfprintf_r+0x6f8>
8000d278:	c8 03       	ld.a %a3,[%a15]0
8000d27a:	58 0a       	ld.w %d15,[%sp]40
8000d27c:	ac 30       	st.h [%a3]0,%d15
8000d27e:	3c 04       	j 8000d286 <_svfprintf_r+0x6fe>
8000d280:	c8 03       	ld.a %a3,[%a15]0
8000d282:	58 0a       	ld.w %d15,[%sp]40
8000d284:	6c 30       	st.w [%a3]0,%d15
8000d286:	40 2f       	mov.aa %a15,%a2
8000d288:	1d ff b8 fc 	j 8000cbf8 <_svfprintf_r+0x70>
8000d28c:	8f 0a 41 a1 	or %d10,%d10,16
8000d290:	6f 5a 07 00 	jz.t %d10,5,8000d29e <_svfprintf_r+0x716>
8000d294:	d9 fc 08 00 	lea %a12,[%a15]8
8000d298:	09 f8 40 09 	ld.d %e8,[%a15]
8000d29c:	3c 0c       	j 8000d2b4 <_svfprintf_r+0x72c>
8000d29e:	d9 fc 04 00 	lea %a12,[%a15]4
8000d2a2:	6f 4a 07 80 	jnz.t %d10,4,8000d2b0 <_svfprintf_r+0x728>
8000d2a6:	6f 6a 05 00 	jz.t %d10,6,8000d2b0 <_svfprintf_r+0x728>
8000d2aa:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000d2ae:	3c 02       	j 8000d2b2 <_svfprintf_r+0x72a>
8000d2b0:	48 08       	ld.w %d8,[%a15]0
8000d2b2:	82 09       	mov %d9,0
8000d2b4:	82 03       	mov %d3,0
8000d2b6:	3c 73       	j 8000d39c <_svfprintf_r+0x814>
8000d2b8:	3b 00 03 40 	mov %d4,48
8000d2bc:	7b 00 00 f8 	movh %d15,32768
8000d2c0:	1b df ff f0 	addi %d15,%d15,4093
8000d2c4:	e9 a4 02 10 	st.b [%sp]66,%d4
8000d2c8:	3b 80 07 40 	mov %d4,120
8000d2cc:	78 0f       	st.w [%sp]60,%d15
8000d2ce:	02 4f       	mov %d15,%d4
8000d2d0:	d9 fc 04 00 	lea %a12,[%a15]4
8000d2d4:	48 08       	ld.w %d8,[%a15]0
8000d2d6:	82 09       	mov %d9,0
8000d2d8:	8f 2a 40 a1 	or %d10,%d10,2
8000d2dc:	e9 a4 03 10 	st.b [%sp]67,%d4
8000d2e0:	82 23       	mov %d3,2
8000d2e2:	78 04       	st.w [%sp]16,%d15
8000d2e4:	3c 5c       	j 8000d39c <_svfprintf_r+0x814>
8000d2e6:	82 07       	mov %d7,0
8000d2e8:	48 0d       	ld.w %d13,[%a15]0
8000d2ea:	e9 a7 01 10 	st.b [%sp]65,%d7
8000d2ee:	02 e9       	mov %d9,%d14
8000d2f0:	60 ad       	mov.a %a13,%d10
8000d2f2:	d9 fc 04 00 	lea %a12,[%a15]4
8000d2f6:	60 d4       	mov.a %a4,%d13
8000d2f8:	0e ef       	jltz %d14,8000d316 <_svfprintf_r+0x78e>
8000d2fa:	82 04       	mov %d4,0
8000d2fc:	02 e5       	mov %d5,%d14
8000d2fe:	6d 00 14 0c 	call 8000eb26 <memchr>
8000d302:	bd 02 f6 00 	jz.a %a2,8000d4ee <_svfprintf_r+0x966>
8000d306:	60 d4       	mov.a %a4,%d13
8000d308:	01 42 20 30 	sub.a %a3,%a2,%a4
8000d30c:	80 32       	mov.d %d2,%a3
8000d30e:	0b e2 80 91 	min %d9,%d2,%d14
8000d312:	1d 00 ee 00 	j 8000d4ee <_svfprintf_r+0x966>
8000d316:	6d ff cb fa 	call 8000c8ac <strlen>
8000d31a:	02 29       	mov %d9,%d2
8000d31c:	1d 00 e9 00 	j 8000d4ee <_svfprintf_r+0x966>
8000d320:	8f 0a 41 a1 	or %d10,%d10,16
8000d324:	6f 5a 07 00 	jz.t %d10,5,8000d332 <_svfprintf_r+0x7aa>
8000d328:	d9 fc 08 00 	lea %a12,[%a15]8
8000d32c:	09 f8 40 09 	ld.d %e8,[%a15]
8000d330:	3c 0c       	j 8000d348 <_svfprintf_r+0x7c0>
8000d332:	d9 fc 04 00 	lea %a12,[%a15]4
8000d336:	6f 4a 07 80 	jnz.t %d10,4,8000d344 <_svfprintf_r+0x7bc>
8000d33a:	6f 6a 05 00 	jz.t %d10,6,8000d344 <_svfprintf_r+0x7bc>
8000d33e:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000d342:	3c 02       	j 8000d346 <_svfprintf_r+0x7be>
8000d344:	48 08       	ld.w %d8,[%a15]0
8000d346:	82 09       	mov %d9,0
8000d348:	82 13       	mov %d3,1
8000d34a:	3c 29       	j 8000d39c <_svfprintf_r+0x814>
8000d34c:	e9 af 01 10 	st.b [%sp]65,%d15
8000d350:	7b 00 00 f8 	movh %d15,32768
8000d354:	1b df ff f0 	addi %d15,%d15,4093
8000d358:	78 0f       	st.w [%sp]60,%d15
8000d35a:	6f 5a 07 00 	jz.t %d10,5,8000d368 <_svfprintf_r+0x7e0>
8000d35e:	d9 fc 08 00 	lea %a12,[%a15]8
8000d362:	09 f8 40 09 	ld.d %e8,[%a15]
8000d366:	3c 0c       	j 8000d37e <_svfprintf_r+0x7f6>
8000d368:	d9 fc 04 00 	lea %a12,[%a15]4
8000d36c:	6f 4a 07 80 	jnz.t %d10,4,8000d37a <_svfprintf_r+0x7f2>
8000d370:	6f 6a 05 00 	jz.t %d10,6,8000d37a <_svfprintf_r+0x7f2>
8000d374:	b9 f8 00 00 	ld.hu %d8,[%a15]0
8000d378:	3c 02       	j 8000d37c <_svfprintf_r+0x7f4>
8000d37a:	48 08       	ld.w %d8,[%a15]0
8000d37c:	82 09       	mov %d9,0
8000d37e:	82 23       	mov %d3,2
8000d380:	6f 0a 0e 00 	jz.t %d10,0,8000d39c <_svfprintf_r+0x814>
8000d384:	0f 89 a0 40 	or %d4,%d9,%d8
8000d388:	76 4a       	jz %d4,8000d39c <_svfprintf_r+0x814>
8000d38a:	58 04       	ld.w %d15,[%sp]16
8000d38c:	3b 00 03 70 	mov %d7,48
8000d390:	e9 a7 02 10 	st.b [%sp]66,%d7
8000d394:	e9 af 03 10 	st.b [%sp]67,%d15
8000d398:	8f 2a 40 a1 	or %d10,%d10,2
8000d39c:	82 07       	mov %d7,0
8000d39e:	60 ad       	mov.a %a13,%d10
8000d3a0:	e9 a7 01 10 	st.b [%sp]65,%d7
8000d3a4:	80 d2       	mov.d %d2,%a13
8000d3a6:	8b 0e 80 72 	ge %d7,%d14,0
8000d3aa:	8f 02 c8 41 	andn %d4,%d2,128
8000d3ae:	2b 24 40 27 	sel %d2,%d7,%d4,%d2
8000d3b2:	0f 98 a0 60 	or %d6,%d8,%d9
8000d3b6:	8b 0e 20 42 	ne %d4,%d14,0
8000d3ba:	8b 06 00 45 	or.ne %d4,%d6,0
8000d3be:	60 2d       	mov.a %a13,%d2
8000d3c0:	df 04 72 00 	jeq %d4,0,8000d4a4 <_svfprintf_r+0x91c>
8000d3c4:	df 13 06 00 	jeq %d3,1,8000d3d0 <_svfprintf_r+0x848>
8000d3c8:	df 23 57 00 	jeq %d3,2,8000d476 <_svfprintf_r+0x8ee>
8000d3cc:	82 03       	mov %d3,0
8000d3ce:	3c 03       	j 8000d3d4 <_svfprintf_r+0x84c>
8000d3d0:	82 04       	mov %d4,0
8000d3d2:	3c 22       	j 8000d416 <_svfprintf_r+0x88e>
8000d3d4:	8b 73 02 71 	rsub %d7,%d3,39
8000d3d8:	60 72       	mov.a %a2,%d7
8000d3da:	8f 78 00 41 	and %d4,%d8,7
8000d3de:	d9 a3 28 10 	lea %a3,[%sp]104
8000d3e2:	77 89 80 8e 	dextr %d8,%d9,%d8,29
8000d3e6:	30 23       	add.a %a3,%a2
8000d3e8:	1b 04 03 40 	addi %d4,%d4,48
8000d3ec:	06 d9       	sh %d9,-3
8000d3ee:	34 34       	st.b [%a3],%d4
8000d3f0:	0f 89 a0 60 	or %d6,%d9,%d8
8000d3f4:	c2 13       	add %d3,1
8000d3f6:	df 06 ef ff 	jne %d6,0,8000d3d4 <_svfprintf_r+0x84c>
8000d3fa:	80 d2       	mov.d %d2,%a13
8000d3fc:	80 3d       	mov.d %d13,%a3
8000d3fe:	6f 02 61 00 	jz.t %d2,0,8000d4c0 <_svfprintf_r+0x938>
8000d402:	8b 04 03 42 	eq %d4,%d4,48
8000d406:	df 04 5d 80 	jne %d4,0,8000d4c0 <_svfprintf_r+0x938>
8000d40a:	3b 00 03 70 	mov %d7,48
8000d40e:	c2 fd       	add %d13,-1
8000d410:	e9 37 ff ff 	st.b [%a3]-1,%d7
8000d414:	3c 56       	j 8000d4c0 <_svfprintf_r+0x938>
8000d416:	8b 84 02 71 	rsub %d7,%d4,40
8000d41a:	8b 09 00 32 	eq %d3,%d9,0
8000d41e:	60 73       	mov.a %a3,%d7
8000d420:	8b a8 a0 34 	and.ge.u %d3,%d8,10
8000d424:	d9 a7 28 10 	lea %a7,[%sp]104
8000d428:	8b 09 00 35 	or.ne %d3,%d9,0
8000d42c:	30 37       	add.a %a7,%a3
8000d42e:	1b 14 00 d0 	addi %d13,%d4,1
8000d432:	df 03 1b 00 	jeq %d3,0,8000d468 <_svfprintf_r+0x8e0>
8000d436:	8b 74 02 41 	rsub %d4,%d4,39
8000d43a:	60 42       	mov.a %a2,%d4
8000d43c:	fb a0 00 60 	mov %e6,10
8000d440:	0b 89 10 48 	mov %e4,%d9,%d8
8000d444:	d9 af 28 10 	lea %a15,[%sp]104
8000d448:	30 2f       	add.a %a15,%a2
8000d44a:	6d 00 98 12 	call 8000f97a <__umoddi3>
8000d44e:	0b 89 10 48 	mov %e4,%d9,%d8
8000d452:	1b 02 03 20 	addi %d2,%d2,48
8000d456:	fb a0 00 60 	mov %e6,10
8000d45a:	28 02       	st.b [%a15]0,%d2
8000d45c:	6d 00 3f 12 	call 8000f8da <__udivdi3>
8000d460:	02 d4       	mov %d4,%d13
8000d462:	0b 23 10 88 	mov %e8,%d3,%d2
8000d466:	3c d8       	j 8000d416 <_svfprintf_r+0x88e>
8000d468:	80 7d       	mov.d %d13,%a7
8000d46a:	1b 08 03 80 	addi %d8,%d8,48
8000d46e:	c2 fd       	add %d13,-1
8000d470:	e9 78 ff ff 	st.b [%a7]-1,%d8
8000d474:	3c 26       	j 8000d4c0 <_svfprintf_r+0x938>
8000d476:	82 03       	mov %d3,0
8000d478:	d8 0f       	ld.a %a15,[%sp]60
8000d47a:	80 ad       	mov.d %d13,%sp
8000d47c:	8f f8 00 f1 	and %d15,%d8,15
8000d480:	8b 73 02 71 	rsub %d7,%d3,39
8000d484:	1b 8d 06 d0 	addi %d13,%d13,104
8000d488:	10 f7       	addsc.a %a7,%a15,%d15,0
8000d48a:	42 7d       	add %d13,%d7
8000d48c:	77 89 00 8e 	dextr %d8,%d9,%d8,28
8000d490:	0c 70       	ld.bu %d15,[%a7]0
8000d492:	60 d2       	mov.a %a2,%d13
8000d494:	06 c9       	sh %d9,-4
8000d496:	2c 20       	st.b [%a2]0,%d15
8000d498:	0f 89 a0 40 	or %d4,%d9,%d8
8000d49c:	c2 13       	add %d3,1
8000d49e:	df 04 ed ff 	jne %d4,0,8000d478 <_svfprintf_r+0x8f0>
8000d4a2:	3c 0f       	j 8000d4c0 <_svfprintf_r+0x938>
8000d4a4:	80 a2       	mov.d %d2,%sp
8000d4a6:	1b 02 09 d0 	addi %d13,%d2,144
8000d4aa:	f6 3b       	jnz %d3,8000d4c0 <_svfprintf_r+0x938>
8000d4ac:	80 df       	mov.d %d15,%a13
8000d4ae:	2e 09       	jz.t %d15,0,8000d4c0 <_svfprintf_r+0x938>
8000d4b0:	1b 02 0d d0 	addi %d13,%d2,208
8000d4b4:	60 d2       	mov.a %a2,%d13
8000d4b6:	3b 00 03 70 	mov %d7,48
8000d4ba:	89 27 3f e4 	st.b [+%a2]-65,%d7
8000d4be:	80 2d       	mov.d %d13,%a2
8000d4c0:	d9 a3 10 20 	lea %a3,[%sp]144
8000d4c4:	80 39       	mov.d %d9,%a3
8000d4c6:	a2 d9       	sub %d9,%d13
8000d4c8:	3c 14       	j 8000d4f0 <_svfprintf_r+0x968>
8000d4ca:	e9 af 01 10 	st.b [%sp]65,%d15
8000d4ce:	58 04       	ld.w %d15,[%sp]16
8000d4d0:	df 0f 1f 04 	jeq %d15,0,8000dd0e <_svfprintf_r+0x1186>
8000d4d4:	82 03       	mov %d3,0
8000d4d6:	60 ad       	mov.a %a13,%d10
8000d4d8:	e9 af 28 10 	st.b [%sp]104,%d15
8000d4dc:	e9 a3 01 10 	st.b [%sp]65,%d3
8000d4e0:	40 fc       	mov.aa %a12,%a15
8000d4e2:	80 a2       	mov.d %d2,%sp
8000d4e4:	82 19       	mov %d9,1
8000d4e6:	82 0e       	mov %d14,0
8000d4e8:	1b 82 06 d0 	addi %d13,%d2,104
8000d4ec:	3c 02       	j 8000d4f0 <_svfprintf_r+0x968>
8000d4ee:	82 0e       	mov %d14,0
8000d4f0:	79 a7 01 10 	ld.b %d7,[%sp]65
8000d4f4:	80 df       	mov.d %d15,%a13
8000d4f6:	0b e9 a0 a1 	max %d10,%d9,%d14
8000d4fa:	80 d2       	mov.d %d2,%a13
8000d4fc:	16 02       	and %d15,2
8000d4fe:	ab 1a 00 a7 	cadd %d10,%d7,%d10,1
8000d502:	60 ff       	mov.a %a15,%d15
8000d504:	8a 2a       	cadd %d10,%d15,2
8000d506:	8f 42 08 f1 	and %d15,%d2,132
8000d50a:	ee 48       	jnz %d15,8000d59a <_svfprintf_r+0xa12>
8000d50c:	19 a8 1c 00 	ld.w %d8,[%sp]28
8000d510:	a2 a8       	sub %d8,%d10
8000d512:	bf 18 44 00 	jlt %d8,1,8000d59a <_svfprintf_r+0xa12>
8000d516:	91 00 00 28 	movh.a %a2,32768
8000d51a:	d9 22 20 01 	lea %a2,[%a2]4128 <80001020 <blanks.4035>>
8000d51e:	19 a1 24 10 	ld.w %d1,[%sp]100 <80001020 <blanks.4035>>
8000d522:	19 a4 20 10 	ld.w %d4,[%sp]96 <80001020 <blanks.4035>>
8000d526:	8b 18 81 72 	ge %d7,%d8,17
8000d52a:	f4 e2       	st.a [%a14],%a2
8000d52c:	df 07 20 00 	jeq %d7,0,8000d56c <_svfprintf_r+0x9e4>
8000d530:	1b 14 00 00 	addi %d0,%d4,1
8000d534:	3b 00 01 20 	mov %d2,16
8000d538:	1b 01 01 10 	addi %d1,%d1,16
8000d53c:	59 e2 04 00 	st.w [%a14]4,%d2
8000d540:	59 a0 20 10 	st.w [%sp]96,%d0
8000d544:	59 a1 24 10 	st.w [%sp]100,%d1
8000d548:	8b 80 80 02 	ge %d0,%d0,8
8000d54c:	d9 ee 08 00 	lea %a14,[%a14]8
8000d550:	76 0b       	jz %d0,8000d566 <_svfprintf_r+0x9de>
8000d552:	60 c4       	mov.a %a4,%d12
8000d554:	60 b5       	mov.a %a5,%d11
8000d556:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d55a:	6d 00 f4 0d 	call 8000f142 <__ssprint_r>
8000d55e:	df 02 e0 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d562:	d9 ae 10 20 	lea %a14,[%sp]144
8000d566:	1b 08 ff 8f 	addi %d8,%d8,-16
8000d56a:	3c d6       	j 8000d516 <_svfprintf_r+0x98e>
8000d56c:	c2 14       	add %d4,1
8000d56e:	42 81       	add %d1,%d8
8000d570:	59 e8 04 00 	st.w [%a14]4,%d8
8000d574:	59 a4 20 10 	st.w [%sp]96,%d4
8000d578:	59 a1 24 10 	st.w [%sp]100,%d1
8000d57c:	8b 84 80 42 	ge %d4,%d4,8
8000d580:	d9 ee 08 00 	lea %a14,[%a14]8
8000d584:	76 4b       	jz %d4,8000d59a <_svfprintf_r+0xa12>
8000d586:	60 c4       	mov.a %a4,%d12
8000d588:	60 b5       	mov.a %a5,%d11
8000d58a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d58e:	6d 00 da 0d 	call 8000f142 <__ssprint_r>
8000d592:	df 02 c6 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d596:	d9 ae 10 20 	lea %a14,[%sp]144
8000d59a:	79 a4 01 10 	ld.b %d4,[%sp]65
8000d59e:	df 04 21 00 	jeq %d4,0,8000d5e0 <_svfprintf_r+0xa58>
8000d5a2:	19 a4 24 10 	ld.w %d4,[%sp]100
8000d5a6:	d9 a7 01 10 	lea %a7,[%sp]65
8000d5aa:	c2 14       	add %d4,1
8000d5ac:	59 a4 24 10 	st.w [%sp]100,%d4
8000d5b0:	19 a4 20 10 	ld.w %d4,[%sp]96
8000d5b4:	82 17       	mov %d7,1
8000d5b6:	c2 14       	add %d4,1
8000d5b8:	f4 e7       	st.a [%a14],%a7
8000d5ba:	59 e7 04 00 	st.w [%a14]4,%d7
8000d5be:	59 a4 20 10 	st.w [%sp]96,%d4
8000d5c2:	8b 84 80 42 	ge %d4,%d4,8
8000d5c6:	d9 ee 08 00 	lea %a14,[%a14]8
8000d5ca:	76 4b       	jz %d4,8000d5e0 <_svfprintf_r+0xa58>
8000d5cc:	60 c4       	mov.a %a4,%d12
8000d5ce:	60 b5       	mov.a %a5,%d11
8000d5d0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d5d4:	6d 00 b7 0d 	call 8000f142 <__ssprint_r>
8000d5d8:	df 02 a3 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d5dc:	d9 ae 10 20 	lea %a14,[%sp]144
8000d5e0:	bd 0f 21 00 	jz.a %a15,8000d622 <_svfprintf_r+0xa9a>
8000d5e4:	19 a4 24 10 	ld.w %d4,[%sp]100
8000d5e8:	d9 a7 02 10 	lea %a7,[%sp]66
8000d5ec:	c2 24       	add %d4,2
8000d5ee:	59 a4 24 10 	st.w [%sp]100,%d4
8000d5f2:	19 a4 20 10 	ld.w %d4,[%sp]96
8000d5f6:	82 27       	mov %d7,2
8000d5f8:	c2 14       	add %d4,1
8000d5fa:	f4 e7       	st.a [%a14],%a7
8000d5fc:	59 e7 04 00 	st.w [%a14]4,%d7
8000d600:	59 a4 20 10 	st.w [%sp]96,%d4
8000d604:	8b 84 80 42 	ge %d4,%d4,8
8000d608:	d9 ee 08 00 	lea %a14,[%a14]8
8000d60c:	76 4b       	jz %d4,8000d622 <_svfprintf_r+0xa9a>
8000d60e:	60 c4       	mov.a %a4,%d12
8000d610:	60 b5       	mov.a %a5,%d11
8000d612:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d616:	6d 00 96 0d 	call 8000f142 <__ssprint_r>
8000d61a:	df 02 82 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d61e:	d9 ae 10 20 	lea %a14,[%sp]144
8000d622:	8b 0f 28 42 	ne %d4,%d15,128
8000d626:	df 04 48 80 	jne %d4,0,8000d6b6 <_svfprintf_r+0xb2e>
8000d62a:	58 07       	ld.w %d15,[%sp]28
8000d62c:	7b 00 00 28 	movh %d2,32768
8000d630:	60 23       	mov.a %a3,%d2
8000d632:	a2 af       	sub %d15,%d10
8000d634:	d9 3f 10 01 	lea %a15,[%a3]4112
8000d638:	bf 1f 3f 00 	jlt %d15,1,8000d6b6 <_svfprintf_r+0xb2e>
8000d63c:	19 a7 24 10 	ld.w %d7,[%sp]100
8000d640:	19 a4 20 10 	ld.w %d4,[%sp]96
8000d644:	8b 1f 81 82 	ge %d8,%d15,17
8000d648:	ec e0       	st.a [%a14]0,%a15
8000d64a:	df 08 20 00 	jeq %d8,0,8000d68a <_svfprintf_r+0xb02>
8000d64e:	1b 14 00 00 	addi %d0,%d4,1
8000d652:	3b 00 01 20 	mov %d2,16
8000d656:	1b 07 01 10 	addi %d1,%d7,16
8000d65a:	59 e2 04 00 	st.w [%a14]4,%d2
8000d65e:	59 a0 20 10 	st.w [%sp]96,%d0
8000d662:	59 a1 24 10 	st.w [%sp]100,%d1
8000d666:	8b 80 80 02 	ge %d0,%d0,8
8000d66a:	d9 ee 08 00 	lea %a14,[%a14]8
8000d66e:	76 0b       	jz %d0,8000d684 <_svfprintf_r+0xafc>
8000d670:	60 c4       	mov.a %a4,%d12
8000d672:	60 b5       	mov.a %a5,%d11
8000d674:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d678:	6d 00 65 0d 	call 8000f142 <__ssprint_r>
8000d67c:	df 02 51 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d680:	d9 ae 10 20 	lea %a14,[%sp]144
8000d684:	1b 0f ff ff 	addi %d15,%d15,-16
8000d688:	3c da       	j 8000d63c <_svfprintf_r+0xab4>
8000d68a:	c2 14       	add %d4,1
8000d68c:	42 f7       	add %d7,%d15
8000d68e:	6c e1       	st.w [%a14]4,%d15
8000d690:	59 a4 20 10 	st.w [%sp]96,%d4
8000d694:	59 a7 24 10 	st.w [%sp]100,%d7
8000d698:	8b 84 80 42 	ge %d4,%d4,8
8000d69c:	d9 ee 08 00 	lea %a14,[%a14]8
8000d6a0:	76 4b       	jz %d4,8000d6b6 <_svfprintf_r+0xb2e>
8000d6a2:	60 c4       	mov.a %a4,%d12
8000d6a4:	60 b5       	mov.a %a5,%d11
8000d6a6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d6aa:	6d 00 4c 0d 	call 8000f142 <__ssprint_r>
8000d6ae:	df 02 38 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d6b2:	d9 ae 10 20 	lea %a14,[%sp]144
8000d6b6:	7b 00 00 88 	movh %d8,32768
8000d6ba:	a2 9e       	sub %d14,%d9
8000d6bc:	1b 08 01 81 	addi %d8,%d8,4112
8000d6c0:	c5 0f 10 00 	lea %a15,10 <_.+0xf>
8000d6c4:	bf 1e 3c 00 	jlt %d14,1,8000d73c <_svfprintf_r+0xbb4>
8000d6c8:	19 a6 24 10 	ld.w %d6,[%sp]100
8000d6cc:	19 a4 20 10 	ld.w %d4,[%sp]96
8000d6d0:	8b 1e 81 02 	ge %d0,%d14,17
8000d6d4:	74 e8       	st.w [%a14],%d8
8000d6d6:	df 00 1c 00 	jeq %d0,0,8000d70e <_svfprintf_r+0xb86>
8000d6da:	c2 14       	add %d4,1
8000d6dc:	1b 06 01 00 	addi %d0,%d6,16
8000d6e0:	ec e1       	st.a [%a14]4,%a15
8000d6e2:	59 a4 20 10 	st.w [%sp]96,%d4
8000d6e6:	59 a0 24 10 	st.w [%sp]100,%d0
8000d6ea:	8b 84 80 42 	ge %d4,%d4,8
8000d6ee:	d9 ee 08 00 	lea %a14,[%a14]8
8000d6f2:	76 4b       	jz %d4,8000d708 <_svfprintf_r+0xb80>
8000d6f4:	60 c4       	mov.a %a4,%d12
8000d6f6:	60 b5       	mov.a %a5,%d11
8000d6f8:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d6fc:	6d 00 23 0d 	call 8000f142 <__ssprint_r>
8000d700:	df 02 0f 83 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d704:	d9 ae 10 20 	lea %a14,[%sp]144
8000d708:	1b 0e ff ef 	addi %d14,%d14,-16
8000d70c:	3c de       	j 8000d6c8 <_svfprintf_r+0xb40>
8000d70e:	c2 14       	add %d4,1
8000d710:	42 e6       	add %d6,%d14
8000d712:	59 ee 04 00 	st.w [%a14]4,%d14
8000d716:	59 a4 20 10 	st.w [%sp]96,%d4
8000d71a:	59 a6 24 10 	st.w [%sp]100,%d6
8000d71e:	8b 84 80 42 	ge %d4,%d4,8
8000d722:	d9 ee 08 00 	lea %a14,[%a14]8
8000d726:	76 4b       	jz %d4,8000d73c <_svfprintf_r+0xbb4>
8000d728:	60 c4       	mov.a %a4,%d12
8000d72a:	60 b5       	mov.a %a5,%d11
8000d72c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d730:	6d 00 09 0d 	call 8000f142 <__ssprint_r>
8000d734:	df 02 f5 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d738:	d9 ae 10 20 	lea %a14,[%sp]144
8000d73c:	80 df       	mov.d %d15,%a13
8000d73e:	19 ae 24 10 	ld.w %d14,[%sp]100
8000d742:	19 a8 20 10 	ld.w %d8,[%sp]96
8000d746:	6f 8f 1d 80 	jnz.t %d15,8,8000d780 <_svfprintf_r+0xbf8>
8000d74a:	c2 18       	add %d8,1
8000d74c:	59 e9 04 00 	st.w [%a14]4,%d9
8000d750:	42 e9       	add %d9,%d14
8000d752:	59 a8 20 10 	st.w [%sp]96,%d8
8000d756:	74 ed       	st.w [%a14],%d13
8000d758:	59 a9 24 10 	st.w [%sp]100,%d9
8000d75c:	8b 88 80 82 	ge %d8,%d8,8
8000d760:	d9 ef 08 00 	lea %a15,[%a14]8
8000d764:	df 08 79 02 	jeq %d8,0,8000dc56 <_svfprintf_r+0x10ce>
8000d768:	60 c4       	mov.a %a4,%d12
8000d76a:	60 b5       	mov.a %a5,%d11
8000d76c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d770:	6d 00 e9 0c 	call 8000f142 <__ssprint_r>
8000d774:	df 02 d5 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d778:	d9 af 10 20 	lea %a15,[%sp]144
8000d77c:	1d 00 6d 02 	j 8000dc56 <_svfprintf_r+0x10ce>
8000d780:	19 a2 10 00 	ld.w %d2,[%sp]16
8000d784:	8b 62 46 f2 	lt %d15,%d2,102
8000d788:	df 0f be 81 	jne %d15,0,8000db04 <_svfprintf_r+0xf7c>
8000d78c:	d2 06       	mov %e6,0
8000d78e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000d792:	19 a5 30 00 	ld.w %d5,[%sp]48
8000d796:	6d 00 db 0f 	call 8000f74c <__eqdf2>
8000d79a:	df 02 78 80 	jne %d2,0,8000d88a <_svfprintf_r+0xd02>
8000d79e:	7b 00 00 38 	movh %d3,32768
8000d7a2:	1b e3 00 31 	addi %d3,%d3,4110
8000d7a6:	c2 18       	add %d8,1
8000d7a8:	74 e3       	st.w [%a14],%d3
8000d7aa:	1b 1e 00 90 	addi %d9,%d14,1
8000d7ae:	82 13       	mov %d3,1
8000d7b0:	59 a8 20 10 	st.w [%sp]96,%d8
8000d7b4:	59 e3 04 00 	st.w [%a14]4,%d3
8000d7b8:	59 a9 24 10 	st.w [%sp]100,%d9
8000d7bc:	8b 88 80 82 	ge %d8,%d8,8
8000d7c0:	d9 ef 08 00 	lea %a15,[%a14]8
8000d7c4:	76 8b       	jz %d8,8000d7da <_svfprintf_r+0xc52>
8000d7c6:	60 c4       	mov.a %a4,%d12
8000d7c8:	60 b5       	mov.a %a5,%d11
8000d7ca:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d7ce:	6d 00 ba 0c 	call 8000f142 <__ssprint_r>
8000d7d2:	df 02 a6 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d7d6:	d9 af 10 20 	lea %a15,[%sp]144
8000d7da:	58 11       	ld.w %d15,[%sp]68
8000d7dc:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d7e0:	3f 2f 05 00 	jlt %d15,%d2,8000d7ea <_svfprintf_r+0xc62>
8000d7e4:	80 df       	mov.d %d15,%a13
8000d7e6:	6f 0f 38 02 	jz.t %d15,0,8000dc56 <_svfprintf_r+0x10ce>
8000d7ea:	58 08       	ld.w %d15,[%sp]32
8000d7ec:	19 a2 20 00 	ld.w %d2,[%sp]32
8000d7f0:	68 1f       	st.w [%a15]4,%d15
8000d7f2:	58 19       	ld.w %d15,[%sp]100
8000d7f4:	99 a3 34 00 	ld.a %a3,[%sp]52
8000d7f8:	42 2f       	add %d15,%d2
8000d7fa:	78 19       	st.w [%sp]100,%d15
8000d7fc:	58 18       	ld.w %d15,[%sp]96
8000d7fe:	e8 03       	st.a [%a15]0,%a3
8000d800:	c2 1f       	add %d15,1
8000d802:	78 18       	st.w [%sp]96,%d15
8000d804:	8b 8f 80 f2 	ge %d15,%d15,8
8000d808:	d9 ff 08 00 	lea %a15,[%a15]8
8000d80c:	6e 0b       	jz %d15,8000d822 <_svfprintf_r+0xc9a>
8000d80e:	60 c4       	mov.a %a4,%d12
8000d810:	60 b5       	mov.a %a5,%d11
8000d812:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d816:	6d 00 96 0c 	call 8000f142 <__ssprint_r>
8000d81a:	df 02 82 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d81e:	d9 af 10 20 	lea %a15,[%sp]144
8000d822:	58 05       	ld.w %d15,[%sp]20
8000d824:	7b 00 00 88 	movh %d8,32768
8000d828:	c2 ff       	add %d15,-1
8000d82a:	1b 08 01 81 	addi %d8,%d8,4112
8000d82e:	3b 00 01 90 	mov %d9,16
8000d832:	bf 1f 12 02 	jlt %d15,1,8000dc56 <_svfprintf_r+0x10ce>
8000d836:	19 a5 24 10 	ld.w %d5,[%sp]100
8000d83a:	19 a3 20 10 	ld.w %d3,[%sp]96
8000d83e:	8b 1f 81 42 	ge %d4,%d15,17
8000d842:	68 08       	st.w [%a15]0,%d8
8000d844:	df 04 1c 00 	jeq %d4,0,8000d87c <_svfprintf_r+0xcf4>
8000d848:	c2 13       	add %d3,1
8000d84a:	1b 05 01 40 	addi %d4,%d5,16
8000d84e:	68 19       	st.w [%a15]4,%d9
8000d850:	59 a3 20 10 	st.w [%sp]96,%d3
8000d854:	59 a4 24 10 	st.w [%sp]100,%d4
8000d858:	8b 83 80 32 	ge %d3,%d3,8
8000d85c:	d9 ff 08 00 	lea %a15,[%a15]8
8000d860:	76 3b       	jz %d3,8000d876 <_svfprintf_r+0xcee>
8000d862:	60 c4       	mov.a %a4,%d12
8000d864:	60 b5       	mov.a %a5,%d11
8000d866:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d86a:	6d 00 6c 0c 	call 8000f142 <__ssprint_r>
8000d86e:	df 02 58 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d872:	d9 af 10 20 	lea %a15,[%sp]144
8000d876:	1b 0f ff ff 	addi %d15,%d15,-16
8000d87a:	3c de       	j 8000d836 <_svfprintf_r+0xcae>
8000d87c:	12 54       	add %d4,%d15,%d5
8000d87e:	68 1f       	st.w [%a15]4,%d15
8000d880:	59 a4 24 10 	st.w [%sp]100,%d4
8000d884:	9a 13       	add %d15,%d3,1
8000d886:	1d 00 e1 01 	j 8000dc48 <_svfprintf_r+0x10c0>
8000d88a:	19 a3 04 10 	ld.w %d3,[%sp]68
8000d88e:	ff 13 8e 00 	jge %d3,1,8000d9aa <_svfprintf_r+0xe22>
8000d892:	7b 00 00 38 	movh %d3,32768
8000d896:	1b e3 00 31 	addi %d3,%d3,4110
8000d89a:	c2 18       	add %d8,1
8000d89c:	74 e3       	st.w [%a14],%d3
8000d89e:	1b 1e 00 90 	addi %d9,%d14,1
8000d8a2:	82 13       	mov %d3,1
8000d8a4:	59 a8 20 10 	st.w [%sp]96,%d8
8000d8a8:	59 e3 04 00 	st.w [%a14]4,%d3
8000d8ac:	59 a9 24 10 	st.w [%sp]100,%d9
8000d8b0:	8b 88 80 82 	ge %d8,%d8,8
8000d8b4:	d9 ef 08 00 	lea %a15,[%a14]8
8000d8b8:	76 8b       	jz %d8,8000d8ce <_svfprintf_r+0xd46>
8000d8ba:	60 c4       	mov.a %a4,%d12
8000d8bc:	60 b5       	mov.a %a5,%d11
8000d8be:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d8c2:	6d 00 40 0c 	call 8000f142 <__ssprint_r>
8000d8c6:	df 02 2c 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d8ca:	d9 af 10 20 	lea %a15,[%sp]144
8000d8ce:	58 11       	ld.w %d15,[%sp]68
8000d8d0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d8d4:	a6 2f       	or %d15,%d2
8000d8d6:	ee 04       	jnz %d15,8000d8de <_svfprintf_r+0xd56>
8000d8d8:	80 df       	mov.d %d15,%a13
8000d8da:	6f 0f be 01 	jz.t %d15,0,8000dc56 <_svfprintf_r+0x10ce>
8000d8de:	58 08       	ld.w %d15,[%sp]32
8000d8e0:	19 a2 20 00 	ld.w %d2,[%sp]32
8000d8e4:	68 1f       	st.w [%a15]4,%d15
8000d8e6:	58 19       	ld.w %d15,[%sp]100
8000d8e8:	99 a3 34 00 	ld.a %a3,[%sp]52
8000d8ec:	42 2f       	add %d15,%d2
8000d8ee:	78 19       	st.w [%sp]100,%d15
8000d8f0:	58 18       	ld.w %d15,[%sp]96
8000d8f2:	e8 03       	st.a [%a15]0,%a3
8000d8f4:	c2 1f       	add %d15,1
8000d8f6:	78 18       	st.w [%sp]96,%d15
8000d8f8:	8b 8f 80 f2 	ge %d15,%d15,8
8000d8fc:	d9 ff 08 00 	lea %a15,[%a15]8
8000d900:	6e 0b       	jz %d15,8000d916 <_svfprintf_r+0xd8e>
8000d902:	60 c4       	mov.a %a4,%d12
8000d904:	60 b5       	mov.a %a5,%d11
8000d906:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d90a:	6d 00 1c 0c 	call 8000f142 <__ssprint_r>
8000d90e:	df 02 08 82 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d912:	d9 af 10 20 	lea %a15,[%sp]144
8000d916:	58 11       	ld.w %d15,[%sp]68
8000d918:	7b 00 00 88 	movh %d8,32768
8000d91c:	32 5f       	rsub %d15
8000d91e:	1b 08 01 81 	addi %d8,%d8,4112
8000d922:	3b 00 01 90 	mov %d9,16
8000d926:	bf 1f 3a 00 	jlt %d15,1,8000d99a <_svfprintf_r+0xe12>
8000d92a:	19 a5 24 10 	ld.w %d5,[%sp]100
8000d92e:	19 a3 20 10 	ld.w %d3,[%sp]96
8000d932:	8b 1f 81 42 	ge %d4,%d15,17
8000d936:	68 08       	st.w [%a15]0,%d8
8000d938:	df 04 1c 00 	jeq %d4,0,8000d970 <_svfprintf_r+0xde8>
8000d93c:	c2 13       	add %d3,1
8000d93e:	1b 05 01 40 	addi %d4,%d5,16
8000d942:	68 19       	st.w [%a15]4,%d9
8000d944:	59 a3 20 10 	st.w [%sp]96,%d3
8000d948:	59 a4 24 10 	st.w [%sp]100,%d4
8000d94c:	8b 83 80 32 	ge %d3,%d3,8
8000d950:	d9 ff 08 00 	lea %a15,[%a15]8
8000d954:	76 3b       	jz %d3,8000d96a <_svfprintf_r+0xde2>
8000d956:	60 c4       	mov.a %a4,%d12
8000d958:	60 b5       	mov.a %a5,%d11
8000d95a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d95e:	6d 00 f2 0b 	call 8000f142 <__ssprint_r>
8000d962:	df 02 de 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d966:	d9 af 10 20 	lea %a15,[%sp]144
8000d96a:	1b 0f ff ff 	addi %d15,%d15,-16
8000d96e:	3c de       	j 8000d92a <_svfprintf_r+0xda2>
8000d970:	68 1f       	st.w [%a15]4,%d15
8000d972:	12 54       	add %d4,%d15,%d5
8000d974:	9a 13       	add %d15,%d3,1
8000d976:	78 18       	st.w [%sp]96,%d15
8000d978:	59 a4 24 10 	st.w [%sp]100,%d4
8000d97c:	8b 8f 80 f2 	ge %d15,%d15,8
8000d980:	d9 ff 08 00 	lea %a15,[%a15]8
8000d984:	6e 0b       	jz %d15,8000d99a <_svfprintf_r+0xe12>
8000d986:	60 c4       	mov.a %a4,%d12
8000d988:	60 b5       	mov.a %a5,%d11
8000d98a:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d98e:	6d 00 da 0b 	call 8000f142 <__ssprint_r>
8000d992:	df 02 c6 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d996:	d9 af 10 20 	lea %a15,[%sp]144
8000d99a:	58 05       	ld.w %d15,[%sp]20
8000d99c:	68 0d       	st.w [%a15]0,%d13
8000d99e:	68 1f       	st.w [%a15]4,%d15
8000d9a0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d9a4:	58 19       	ld.w %d15,[%sp]100
8000d9a6:	1d 00 4d 01 	j 8000dc40 <_svfprintf_r+0x10b8>
8000d9aa:	58 05       	ld.w %d15,[%sp]20
8000d9ac:	74 ed       	st.w [%a14],%d13
8000d9ae:	3f f3 6a 00 	jlt %d3,%d15,8000da82 <_svfprintf_r+0xefa>
8000d9b2:	02 f9       	mov %d9,%d15
8000d9b4:	c2 18       	add %d8,1
8000d9b6:	42 e9       	add %d9,%d14
8000d9b8:	59 a8 20 10 	st.w [%sp]96,%d8
8000d9bc:	6c e1       	st.w [%a14]4,%d15
8000d9be:	59 a9 24 10 	st.w [%sp]100,%d9
8000d9c2:	8b 88 80 82 	ge %d8,%d8,8
8000d9c6:	d9 ef 08 00 	lea %a15,[%a14]8
8000d9ca:	76 8b       	jz %d8,8000d9e0 <_svfprintf_r+0xe58>
8000d9cc:	60 c4       	mov.a %a4,%d12
8000d9ce:	60 b5       	mov.a %a5,%d11
8000d9d0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000d9d4:	6d 00 b7 0b 	call 8000f142 <__ssprint_r>
8000d9d8:	df 02 a3 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000d9dc:	d9 af 10 20 	lea %a15,[%sp]144
8000d9e0:	58 11       	ld.w %d15,[%sp]68
8000d9e2:	19 a2 14 00 	ld.w %d2,[%sp]20
8000d9e6:	7b 00 00 88 	movh %d8,32768
8000d9ea:	a2 2f       	sub %d15,%d2
8000d9ec:	1b 08 01 81 	addi %d8,%d8,4112
8000d9f0:	3b 00 01 90 	mov %d9,16
8000d9f4:	bf 1f 3a 00 	jlt %d15,1,8000da68 <_svfprintf_r+0xee0>
8000d9f8:	19 a5 24 10 	ld.w %d5,[%sp]100
8000d9fc:	19 a3 20 10 	ld.w %d3,[%sp]96
8000da00:	8b 1f 81 42 	ge %d4,%d15,17
8000da04:	68 08       	st.w [%a15]0,%d8
8000da06:	df 04 1c 00 	jeq %d4,0,8000da3e <_svfprintf_r+0xeb6>
8000da0a:	c2 13       	add %d3,1
8000da0c:	1b 05 01 40 	addi %d4,%d5,16
8000da10:	68 19       	st.w [%a15]4,%d9
8000da12:	59 a3 20 10 	st.w [%sp]96,%d3
8000da16:	59 a4 24 10 	st.w [%sp]100,%d4
8000da1a:	8b 83 80 32 	ge %d3,%d3,8
8000da1e:	d9 ff 08 00 	lea %a15,[%a15]8
8000da22:	76 3b       	jz %d3,8000da38 <_svfprintf_r+0xeb0>
8000da24:	60 c4       	mov.a %a4,%d12
8000da26:	60 b5       	mov.a %a5,%d11
8000da28:	d9 a6 1c 10 	lea %a6,[%sp]92
8000da2c:	6d 00 8b 0b 	call 8000f142 <__ssprint_r>
8000da30:	df 02 77 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000da34:	d9 af 10 20 	lea %a15,[%sp]144
8000da38:	1b 0f ff ff 	addi %d15,%d15,-16
8000da3c:	3c de       	j 8000d9f8 <_svfprintf_r+0xe70>
8000da3e:	68 1f       	st.w [%a15]4,%d15
8000da40:	12 54       	add %d4,%d15,%d5
8000da42:	9a 13       	add %d15,%d3,1
8000da44:	78 18       	st.w [%sp]96,%d15
8000da46:	59 a4 24 10 	st.w [%sp]100,%d4
8000da4a:	8b 8f 80 f2 	ge %d15,%d15,8
8000da4e:	d9 ff 08 00 	lea %a15,[%a15]8
8000da52:	6e 0b       	jz %d15,8000da68 <_svfprintf_r+0xee0>
8000da54:	60 c4       	mov.a %a4,%d12
8000da56:	60 b5       	mov.a %a5,%d11
8000da58:	d9 a6 1c 10 	lea %a6,[%sp]92
8000da5c:	6d 00 73 0b 	call 8000f142 <__ssprint_r>
8000da60:	df 02 5f 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000da64:	d9 af 10 20 	lea %a15,[%sp]144
8000da68:	80 df       	mov.d %d15,%a13
8000da6a:	6f 0f f6 00 	jz.t %d15,0,8000dc56 <_svfprintf_r+0x10ce>
8000da6e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000da72:	58 08       	ld.w %d15,[%sp]32
8000da74:	19 a2 20 00 	ld.w %d2,[%sp]32
8000da78:	68 1f       	st.w [%a15]4,%d15
8000da7a:	e8 03       	st.a [%a15]0,%a3
8000da7c:	58 19       	ld.w %d15,[%sp]100
8000da7e:	1d 00 e1 00 	j 8000dc40 <_svfprintf_r+0x10b8>
8000da82:	c2 18       	add %d8,1
8000da84:	59 e3 04 00 	st.w [%a14]4,%d3
8000da88:	42 e3       	add %d3,%d14
8000da8a:	59 a8 20 10 	st.w [%sp]96,%d8
8000da8e:	59 a3 24 10 	st.w [%sp]100,%d3
8000da92:	8b 88 80 82 	ge %d8,%d8,8
8000da96:	d9 ef 08 00 	lea %a15,[%a14]8
8000da9a:	76 8b       	jz %d8,8000dab0 <_svfprintf_r+0xf28>
8000da9c:	60 c4       	mov.a %a4,%d12
8000da9e:	60 b5       	mov.a %a5,%d11
8000daa0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000daa4:	6d 00 4f 0b 	call 8000f142 <__ssprint_r>
8000daa8:	df 02 3b 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000daac:	d9 af 10 20 	lea %a15,[%sp]144
8000dab0:	58 08       	ld.w %d15,[%sp]32
8000dab2:	19 a2 20 00 	ld.w %d2,[%sp]32
8000dab6:	68 1f       	st.w [%a15]4,%d15
8000dab8:	58 19       	ld.w %d15,[%sp]100
8000daba:	99 a3 34 00 	ld.a %a3,[%sp]52
8000dabe:	42 2f       	add %d15,%d2
8000dac0:	78 19       	st.w [%sp]100,%d15
8000dac2:	58 18       	ld.w %d15,[%sp]96
8000dac4:	99 ae 04 10 	ld.a %a14,[%sp]68
8000dac8:	c2 1f       	add %d15,1
8000daca:	60 d2       	mov.a %a2,%d13
8000dacc:	e8 03       	st.a [%a15]0,%a3
8000dace:	78 18       	st.w [%sp]96,%d15
8000dad0:	8b 8f 80 f2 	ge %d15,%d15,8
8000dad4:	30 2e       	add.a %a14,%a2
8000dad6:	d9 ff 08 00 	lea %a15,[%a15]8
8000dada:	6e 0b       	jz %d15,8000daf0 <_svfprintf_r+0xf68>
8000dadc:	60 c4       	mov.a %a4,%d12
8000dade:	60 b5       	mov.a %a5,%d11
8000dae0:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dae4:	6d 00 2f 0b 	call 8000f142 <__ssprint_r>
8000dae8:	df 02 1b 81 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000daec:	d9 af 10 20 	lea %a15,[%sp]144
8000daf0:	19 a2 14 00 	ld.w %d2,[%sp]20
8000daf4:	58 11       	ld.w %d15,[%sp]68
8000daf6:	e8 0e       	st.a [%a15]0,%a14
8000daf8:	5a f2       	sub %d15,%d2,%d15
8000dafa:	68 1f       	st.w [%a15]4,%d15
8000dafc:	19 a2 24 10 	ld.w %d2,[%sp]100
8000db00:	1d 00 a0 00 	j 8000dc40 <_svfprintf_r+0x10b8>
8000db04:	c2 18       	add %d8,1
8000db06:	82 13       	mov %d3,1
8000db08:	1b 1e 00 90 	addi %d9,%d14,1
8000db0c:	58 05       	ld.w %d15,[%sp]20
8000db0e:	59 a8 20 10 	st.w [%sp]96,%d8
8000db12:	74 ed       	st.w [%a14],%d13
8000db14:	59 e3 04 00 	st.w [%a14]4,%d3
8000db18:	59 a9 24 10 	st.w [%sp]100,%d9
8000db1c:	8b 88 80 82 	ge %d8,%d8,8
8000db20:	ff 2f 05 00 	jge %d15,2,8000db2a <_svfprintf_r+0xfa2>
8000db24:	80 d2       	mov.d %d2,%a13
8000db26:	6f 02 81 00 	jz.t %d2,0,8000dc28 <_svfprintf_r+0x10a0>
8000db2a:	d9 ef 08 00 	lea %a15,[%a14]8
8000db2e:	76 8b       	jz %d8,8000db44 <_svfprintf_r+0xfbc>
8000db30:	60 c4       	mov.a %a4,%d12
8000db32:	60 b5       	mov.a %a5,%d11
8000db34:	d9 a6 1c 10 	lea %a6,[%sp]92
8000db38:	6d 00 05 0b 	call 8000f142 <__ssprint_r>
8000db3c:	df 02 f1 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000db40:	d9 af 10 20 	lea %a15,[%sp]144
8000db44:	58 08       	ld.w %d15,[%sp]32
8000db46:	19 a2 20 00 	ld.w %d2,[%sp]32
8000db4a:	68 1f       	st.w [%a15]4,%d15
8000db4c:	58 19       	ld.w %d15,[%sp]100
8000db4e:	99 a3 34 00 	ld.a %a3,[%sp]52
8000db52:	42 2f       	add %d15,%d2
8000db54:	78 19       	st.w [%sp]100,%d15
8000db56:	58 18       	ld.w %d15,[%sp]96
8000db58:	e8 03       	st.a [%a15]0,%a3
8000db5a:	c2 1f       	add %d15,1
8000db5c:	78 18       	st.w [%sp]96,%d15
8000db5e:	8b 8f 80 f2 	ge %d15,%d15,8
8000db62:	d9 ff 08 00 	lea %a15,[%a15]8
8000db66:	6e 0b       	jz %d15,8000db7c <_svfprintf_r+0xff4>
8000db68:	60 c4       	mov.a %a4,%d12
8000db6a:	60 b5       	mov.a %a5,%d11
8000db6c:	d9 a6 1c 10 	lea %a6,[%sp]92
8000db70:	6d 00 e9 0a 	call 8000f142 <__ssprint_r>
8000db74:	df 02 d5 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000db78:	d9 af 10 20 	lea %a15,[%sp]144
8000db7c:	d2 06       	mov %e6,0
8000db7e:	19 a4 2c 00 	ld.w %d4,[%sp]44
8000db82:	19 a5 30 00 	ld.w %d5,[%sp]48
8000db86:	6d 00 03 0e 	call 8000f78c <__nedf2>
8000db8a:	58 05       	ld.w %d15,[%sp]20
8000db8c:	c2 ff       	add %d15,-1
8000db8e:	76 2c       	jz %d2,8000dba6 <_svfprintf_r+0x101e>
8000db90:	19 a2 24 10 	ld.w %d2,[%sp]100
8000db94:	60 de       	mov.a %a14,%d13
8000db96:	68 1f       	st.w [%a15]4,%d15
8000db98:	42 2f       	add %d15,%d2
8000db9a:	78 19       	st.w [%sp]100,%d15
8000db9c:	58 18       	ld.w %d15,[%sp]96
8000db9e:	b0 1e       	add.a %a14,1
8000dba0:	e8 0e       	st.a [%a15]0,%a14
8000dba2:	c2 1f       	add %d15,1
8000dba4:	3c 31       	j 8000dc06 <_svfprintf_r+0x107e>
8000dba6:	7b 00 00 88 	movh %d8,32768
8000dbaa:	1b 08 01 81 	addi %d8,%d8,4112
8000dbae:	3b 00 01 90 	mov %d9,16
8000dbb2:	bf 1f 3f 00 	jlt %d15,1,8000dc30 <_svfprintf_r+0x10a8>
8000dbb6:	19 a5 24 10 	ld.w %d5,[%sp]100
8000dbba:	19 a3 20 10 	ld.w %d3,[%sp]96
8000dbbe:	8b 1f 81 42 	ge %d4,%d15,17
8000dbc2:	68 08       	st.w [%a15]0,%d8
8000dbc4:	df 04 1c 00 	jeq %d4,0,8000dbfc <_svfprintf_r+0x1074>
8000dbc8:	c2 13       	add %d3,1
8000dbca:	1b 05 01 40 	addi %d4,%d5,16
8000dbce:	68 19       	st.w [%a15]4,%d9
8000dbd0:	59 a3 20 10 	st.w [%sp]96,%d3
8000dbd4:	59 a4 24 10 	st.w [%sp]100,%d4
8000dbd8:	8b 83 80 32 	ge %d3,%d3,8
8000dbdc:	d9 ff 08 00 	lea %a15,[%a15]8
8000dbe0:	76 3b       	jz %d3,8000dbf6 <_svfprintf_r+0x106e>
8000dbe2:	60 c4       	mov.a %a4,%d12
8000dbe4:	60 b5       	mov.a %a5,%d11
8000dbe6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dbea:	6d 00 ac 0a 	call 8000f142 <__ssprint_r>
8000dbee:	df 02 98 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000dbf2:	d9 af 10 20 	lea %a15,[%sp]144
8000dbf6:	1b 0f ff ff 	addi %d15,%d15,-16
8000dbfa:	3c de       	j 8000dbb6 <_svfprintf_r+0x102e>
8000dbfc:	12 54       	add %d4,%d15,%d5
8000dbfe:	68 1f       	st.w [%a15]4,%d15
8000dc00:	59 a4 24 10 	st.w [%sp]100,%d4
8000dc04:	9a 13       	add %d15,%d3,1
8000dc06:	78 18       	st.w [%sp]96,%d15
8000dc08:	8b 8f 80 f2 	ge %d15,%d15,8
8000dc0c:	d9 ff 08 00 	lea %a15,[%a15]8
8000dc10:	6e 10       	jz %d15,8000dc30 <_svfprintf_r+0x10a8>
8000dc12:	60 c4       	mov.a %a4,%d12
8000dc14:	60 b5       	mov.a %a5,%d11
8000dc16:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dc1a:	6d 00 94 0a 	call 8000f142 <__ssprint_r>
8000dc1e:	df 02 80 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000dc22:	d9 af 10 20 	lea %a15,[%sp]144
8000dc26:	3c 05       	j 8000dc30 <_svfprintf_r+0x10a8>
8000dc28:	df 08 f5 ff 	jne %d8,0,8000dc12 <_svfprintf_r+0x108a>
8000dc2c:	d9 ef 08 00 	lea %a15,[%a14]8
8000dc30:	58 0e       	ld.w %d15,[%sp]56
8000dc32:	d9 a3 0d 10 	lea %a3,[%sp]77
8000dc36:	68 1f       	st.w [%a15]4,%d15
8000dc38:	19 a2 38 00 	ld.w %d2,[%sp]56
8000dc3c:	58 19       	ld.w %d15,[%sp]100
8000dc3e:	e8 03       	st.a [%a15]0,%a3
8000dc40:	42 2f       	add %d15,%d2
8000dc42:	78 19       	st.w [%sp]100,%d15
8000dc44:	58 18       	ld.w %d15,[%sp]96
8000dc46:	c2 1f       	add %d15,1
8000dc48:	78 18       	st.w [%sp]96,%d15
8000dc4a:	8b 8f 80 f2 	ge %d15,%d15,8
8000dc4e:	df 0f 8d fd 	jne %d15,0,8000d768 <_svfprintf_r+0xbe0>
8000dc52:	d9 ff 08 00 	lea %a15,[%a15]8
8000dc56:	80 df       	mov.d %d15,%a13
8000dc58:	ae 2d       	jnz.t %d15,2,8000dc72 <_svfprintf_r+0x10ea>
8000dc5a:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000dc5e:	0b 2a a0 f1 	max %d15,%d10,%d2
8000dc62:	19 a2 28 00 	ld.w %d2,[%sp]40
8000dc66:	42 f2       	add %d2,%d15
8000dc68:	58 19       	ld.w %d15,[%sp]100
8000dc6a:	59 a2 28 00 	st.w [%sp]40,%d2
8000dc6e:	6e 49       	jz %d15,8000dd00 <_svfprintf_r+0x1178>
8000dc70:	3c 40       	j 8000dcf0 <_svfprintf_r+0x1168>
8000dc72:	58 07       	ld.w %d15,[%sp]28
8000dc74:	3b 00 01 80 	mov %d8,16
8000dc78:	a2 af       	sub %d15,%d10
8000dc7a:	bf 1f f0 7f 	jlt %d15,1,8000dc5a <_svfprintf_r+0x10d2>
8000dc7e:	91 00 00 28 	movh.a %a2,32768
8000dc82:	d9 22 20 01 	lea %a2,[%a2]4128 <80001020 <blanks.4035>>
8000dc86:	19 a5 24 10 	ld.w %d5,[%sp]100 <80001020 <blanks.4035>>
8000dc8a:	19 a3 20 10 	ld.w %d3,[%sp]96 <80001020 <blanks.4035>>
8000dc8e:	8b 1f 81 42 	ge %d4,%d15,17
8000dc92:	e8 02       	st.a [%a15]0,%a2
8000dc94:	df 04 1c 00 	jeq %d4,0,8000dccc <_svfprintf_r+0x1144>
8000dc98:	c2 13       	add %d3,1
8000dc9a:	1b 05 01 40 	addi %d4,%d5,16
8000dc9e:	68 18       	st.w [%a15]4,%d8
8000dca0:	59 a3 20 10 	st.w [%sp]96,%d3
8000dca4:	59 a4 24 10 	st.w [%sp]100,%d4
8000dca8:	8b 83 80 32 	ge %d3,%d3,8
8000dcac:	d9 ff 08 00 	lea %a15,[%a15]8
8000dcb0:	76 3b       	jz %d3,8000dcc6 <_svfprintf_r+0x113e>
8000dcb2:	60 c4       	mov.a %a4,%d12
8000dcb4:	60 b5       	mov.a %a5,%d11
8000dcb6:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dcba:	6d 00 44 0a 	call 8000f142 <__ssprint_r>
8000dcbe:	df 02 30 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000dcc2:	d9 af 10 20 	lea %a15,[%sp]144
8000dcc6:	1b 0f ff ff 	addi %d15,%d15,-16
8000dcca:	3c da       	j 8000dc7e <_svfprintf_r+0x10f6>
8000dccc:	12 54       	add %d4,%d15,%d5
8000dcce:	68 1f       	st.w [%a15]4,%d15
8000dcd0:	9a 13       	add %d15,%d3,1
8000dcd2:	78 18       	st.w [%sp]96,%d15
8000dcd4:	59 a4 24 10 	st.w [%sp]100,%d4
8000dcd8:	8b 8f 40 f2 	lt %d15,%d15,8
8000dcdc:	ee bf       	jnz %d15,8000dc5a <_svfprintf_r+0x10d2>
8000dcde:	60 c4       	mov.a %a4,%d12
8000dce0:	60 b5       	mov.a %a5,%d11
8000dce2:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dce6:	6d 00 2e 0a 	call 8000f142 <__ssprint_r>
8000dcea:	df 02 b8 7f 	jeq %d2,0,8000dc5a <_svfprintf_r+0x10d2>
8000dcee:	3c 18       	j 8000dd1e <_svfprintf_r+0x1196>
8000dcf0:	60 c4       	mov.a %a4,%d12
8000dcf2:	60 b5       	mov.a %a5,%d11
8000dcf4:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dcf8:	6d 00 25 0a 	call 8000f142 <__ssprint_r>
8000dcfc:	df 02 11 80 	jne %d2,0,8000dd1e <_svfprintf_r+0x1196>
8000dd00:	82 0f       	mov %d15,0
8000dd02:	78 18       	st.w [%sp]96,%d15
8000dd04:	40 cf       	mov.aa %a15,%a12
8000dd06:	d9 ae 10 20 	lea %a14,[%sp]144
8000dd0a:	1d ff 77 f7 	j 8000cbf8 <_svfprintf_r+0x70>
8000dd0e:	58 19       	ld.w %d15,[%sp]100
8000dd10:	6e 07       	jz %d15,8000dd1e <_svfprintf_r+0x1196>
8000dd12:	60 c4       	mov.a %a4,%d12
8000dd14:	60 b5       	mov.a %a5,%d11
8000dd16:	d9 a6 1c 10 	lea %a6,[%sp]92
8000dd1a:	6d 00 14 0a 	call 8000f142 <__ssprint_r>
8000dd1e:	60 b3       	mov.a %a3,%d11
8000dd20:	19 a2 28 00 	ld.w %d2,[%sp]40
8000dd24:	8c 36       	ld.h %d15,[%a3]12
8000dd26:	16 40       	and %d15,64
8000dd28:	aa f2       	cmov %d2,%d15,-1
8000dd2a:	00 90       	ret 

8000dd2c <quorem>:
8000dd2c:	19 58 10 00 	ld.w %d8,[%a5]16
8000dd30:	4c 44       	ld.w %d15,[%a4]16
8000dd32:	82 02       	mov %d2,0
8000dd34:	3f 8f 88 00 	jlt %d15,%d8,8000de44 <quorem+0x118>
8000dd38:	c2 f8       	add %d8,-1
8000dd3a:	80 4f       	mov.d %d15,%a4
8000dd3c:	8f 28 00 20 	sh %d2,%d8,2
8000dd40:	60 2f       	mov.a %a15,%d2
8000dd42:	1b 4f 01 90 	addi %d9,%d15,20
8000dd46:	d9 5c 14 00 	lea %a12,[%a5]20
8000dd4a:	01 fc 10 d0 	add.a %a13,%a12,%a15
8000dd4e:	01 f9 00 f6 	addsc.a %a15,%a15,%d9,0
8000dd52:	54 dc       	ld.w %d12,[%a13]
8000dd54:	4c f0       	ld.w %d15,[%a15]0
8000dd56:	c2 1c       	add %d12,1
8000dd58:	4b cf 11 c2 	div.u %e12,%d15,%d12
8000dd5c:	02 ca       	mov %d10,%d12
8000dd5e:	df 0c 3d 00 	jeq %d12,0,8000ddd8 <quorem+0xac>
8000dd62:	60 96       	mov.a %a6,%d9
8000dd64:	40 c2       	mov.aa %a2,%a12
8000dd66:	82 05       	mov %d5,0
8000dd68:	82 06       	mov %d6,0
8000dd6a:	54 22       	ld.w %d2,[%a2]
8000dd6c:	40 63       	mov.aa %a3,%a6
8000dd6e:	b7 02 10 38 	insert %d3,%d2,0,16,16
8000dd72:	8f 02 1f 20 	sh %d2,%d2,-16
8000dd76:	03 a3 0a 35 	madd %d3,%d5,%d3,%d10
8000dd7a:	b0 42       	add.a %a2,4
8000dd7c:	8f 03 1f 40 	sh %d4,%d3,-16
8000dd80:	03 a2 0a 24 	madd %d2,%d4,%d2,%d10
8000dd84:	44 34       	ld.w %d4,[%a3+]
8000dd86:	b7 03 10 38 	insert %d3,%d3,0,16,16
8000dd8a:	b7 04 10 f8 	insert %d15,%d4,0,16,16
8000dd8e:	8f 02 1f 50 	sh %d5,%d2,-16
8000dd92:	42 f6       	add %d6,%d15
8000dd94:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000dd98:	0b 36 80 30 	sub %d3,%d6,%d3
8000dd9c:	8f 04 1f 40 	sh %d4,%d4,-16
8000dda0:	8f 03 3f f0 	sha %d15,%d3,-16
8000dda4:	0b 24 80 20 	sub %d2,%d4,%d2
8000dda8:	42 f2       	add %d2,%d15
8000ddaa:	37 23 10 38 	insert %d3,%d3,%d2,16,16
8000ddae:	8f 02 3f 60 	sha %d6,%d2,-16
8000ddb2:	80 2f       	mov.d %d15,%a2
8000ddb4:	80 d2       	mov.d %d2,%a13
8000ddb6:	74 63       	st.w [%a6],%d3
8000ddb8:	40 36       	mov.aa %a6,%a3
8000ddba:	7f f2 d8 ff 	jge.u %d2,%d15,8000dd6a <quorem+0x3e>
8000ddbe:	4c f0       	ld.w %d15,[%a15]0
8000ddc0:	ee 0c       	jnz %d15,8000ddd8 <quorem+0xac>
8000ddc2:	b0 cf       	add.a %a15,-4
8000ddc4:	80 f2       	mov.d %d2,%a15
8000ddc6:	3f 29 05 80 	jlt.u %d9,%d2,8000ddd0 <quorem+0xa4>
8000ddca:	59 48 10 00 	st.w [%a4]16,%d8
8000ddce:	3c 05       	j 8000ddd8 <quorem+0xac>
8000ddd0:	4c f0       	ld.w %d15,[%a15]0
8000ddd2:	ee fc       	jnz %d15,8000ddca <quorem+0x9e>
8000ddd4:	c2 f8       	add %d8,-1
8000ddd6:	3c f6       	j 8000ddc2 <quorem+0x96>
8000ddd8:	40 4e       	mov.aa %a14,%a4
8000ddda:	6d 00 b9 08 	call 8000ef4c <__mcmp>
8000ddde:	bf 02 32 00 	jlt %d2,0,8000de42 <quorem+0x116>
8000dde2:	60 92       	mov.a %a2,%d9
8000dde4:	1b 1c 00 a0 	addi %d10,%d12,1
8000dde8:	82 04       	mov %d4,0
8000ddea:	40 2f       	mov.aa %a15,%a2
8000ddec:	44 f3       	ld.w %d3,[%a15+]
8000ddee:	54 c5       	ld.w %d5,[%a12]
8000ddf0:	b7 03 10 28 	insert %d2,%d3,0,16,16
8000ddf4:	8f 05 1f f0 	sh %d15,%d5,-16
8000ddf8:	42 42       	add %d2,%d4
8000ddfa:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000ddfe:	8f 03 1f 30 	sh %d3,%d3,-16
8000de02:	a2 42       	sub %d2,%d4
8000de04:	8f 02 3f 40 	sha %d4,%d2,-16
8000de08:	a2 f3       	sub %d3,%d15
8000de0a:	42 43       	add %d3,%d4
8000de0c:	8f 03 3f 40 	sha %d4,%d3,-16
8000de10:	b0 4c       	add.a %a12,4
8000de12:	37 32 10 38 	insert %d3,%d2,%d3,16,16
8000de16:	80 df       	mov.d %d15,%a13
8000de18:	80 c2       	mov.d %d2,%a12
8000de1a:	74 23       	st.w [%a2],%d3
8000de1c:	40 f2       	mov.aa %a2,%a15
8000de1e:	7f 2f e6 ff 	jge.u %d15,%d2,8000ddea <quorem+0xbe>
8000de22:	60 92       	mov.a %a2,%d9
8000de24:	01 28 02 f6 	addsc.a %a15,%a2,%d8,2
8000de28:	4c f0       	ld.w %d15,[%a15]0
8000de2a:	ee 0c       	jnz %d15,8000de42 <quorem+0x116>
8000de2c:	b0 cf       	add.a %a15,-4
8000de2e:	80 f2       	mov.d %d2,%a15
8000de30:	3f 29 05 80 	jlt.u %d9,%d2,8000de3a <quorem+0x10e>
8000de34:	59 e8 10 00 	st.w [%a14]16,%d8
8000de38:	3c 05       	j 8000de42 <quorem+0x116>
8000de3a:	4c f0       	ld.w %d15,[%a15]0
8000de3c:	ee fc       	jnz %d15,8000de34 <quorem+0x108>
8000de3e:	c2 f8       	add %d8,-1
8000de40:	3c f6       	j 8000de2c <quorem+0x100>
8000de42:	02 a2       	mov %d2,%d10
8000de44:	00 90       	ret 
	...

8000de48 <_dtoa_r>:
8000de48:	20 58       	sub.a %sp,88
8000de4a:	b5 a5 08 10 	st.a [%sp]72,%a5
8000de4e:	99 45 00 10 	ld.a %a5,[%a4]64
8000de52:	59 a6 1c 00 	st.w [%sp]28,%d6
8000de56:	59 a7 28 00 	st.w [%sp]40,%d7
8000de5a:	b5 a7 38 00 	st.a [%sp]56,%a7
8000de5e:	40 4d       	mov.aa %a13,%a4
8000de60:	0b 45 10 88 	mov %e8,%d5,%d4
8000de64:	40 6c       	mov.aa %a12,%a6
8000de66:	0b 45 10 c8 	mov %e12,%d5,%d4
8000de6a:	bc 5e       	jz.a %a5,8000de86 <_dtoa_r+0x3e>
8000de6c:	19 4f 04 10 	ld.w %d15,[%a4]68
8000de70:	82 12       	mov %d2,1
8000de72:	0f f2 00 20 	sh %d2,%d2,%d15
8000de76:	6c 51       	st.w [%a5]4,%d15
8000de78:	59 52 08 00 	st.w [%a5]8,%d2
8000de7c:	82 0f       	mov %d15,0
8000de7e:	6d 00 99 06 	call 8000ebb0 <_Bfree>
8000de82:	59 df 00 10 	st.w [%a13]64,%d15
8000de86:	ce 96       	jgez %d9,8000de92 <_dtoa_r+0x4a>
8000de88:	82 1f       	mov %d15,1
8000de8a:	6c c0       	st.w [%a12]0,%d15
8000de8c:	b7 09 81 df 	insert %d13,%d9,0,31,1
8000de90:	3c 03       	j 8000de96 <_dtoa_r+0x4e>
8000de92:	82 0f       	mov %d15,0
8000de94:	6c c0       	st.w [%a12]0,%d15
8000de96:	7b 00 ff 27 	movh %d2,32752
8000de9a:	26 d2       	and %d2,%d13
8000de9c:	7b 00 ff 37 	movh %d3,32752
8000dea0:	5f 32 22 80 	jne %d2,%d3,8000dee4 <_dtoa_r+0x9c>
8000dea4:	99 a3 08 10 	ld.a %a3,[%sp]72
8000dea8:	3b f0 70 22 	mov %d2,9999
8000deac:	91 00 00 f8 	movh.a %a15,32768
8000deb0:	74 32       	st.w [%a3],%d2
8000deb2:	d9 ff 39 01 	lea %a15,[%a15]4153 <80001039 <blanks.4035+0x19>>
8000deb6:	f6 c8       	jnz %d12,8000dec6 <_dtoa_r+0x7e>
8000deb8:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000debc:	ee 05       	jnz %d15,8000dec6 <_dtoa_r+0x7e>
8000debe:	91 00 00 f8 	movh.a %a15,32768
8000dec2:	d9 ff 30 01 	lea %a15,[%a15]4144 <80001030 <blanks.4035+0x10>>
8000dec6:	99 a3 38 00 	ld.a %a3,[%sp]56 <80001030 <blanks.4035+0x10>>
8000deca:	40 f2       	mov.aa %a2,%a15
8000decc:	bd 03 26 06 	jz.a %a3,8000eb18 <_dtoa_r+0xcd0>
8000ded0:	80 ff       	mov.d %d15,%a15
8000ded2:	79 f3 03 00 	ld.b %d3,[%a15]3 <80000003 <BootModeHeader0+0x3>>
8000ded6:	1b 8f 00 20 	addi %d2,%d15,8
8000deda:	c2 3f       	add %d15,3
8000dedc:	2b 2f 50 f3 	seln %d15,%d3,%d15,%d2
8000dee0:	6c 30       	st.w [%a3]0,%d15
8000dee2:	00 90       	ret 
8000dee4:	0b cd 10 48 	mov %e4,%d13,%d12
8000dee8:	d2 06       	mov %e6,0
8000deea:	0b cd 10 88 	mov %e8,%d13,%d12
8000deee:	6d 00 2f 0c 	call 8000f74c <__eqdf2>
8000def2:	df 02 13 80 	jne %d2,0,8000df18 <_dtoa_r+0xd0>
8000def6:	99 a3 08 10 	ld.a %a3,[%sp]72
8000defa:	d8 0e       	ld.a %a15,[%sp]56
8000defc:	82 1f       	mov %d15,1
8000defe:	91 00 00 28 	movh.a %a2,32768
8000df02:	6c 30       	st.w [%a3]0,%d15
8000df04:	d9 22 3d 01 	lea %a2,[%a2]4157 <8000103d <blanks.4035+0x1d>>
8000df08:	bd 0f 08 06 	jz.a %a15,8000eb18 <_dtoa_r+0xcd0>
8000df0c:	7b 00 00 f8 	movh %d15,32768
8000df10:	1b ef 03 f1 	addi %d15,%d15,4158
8000df14:	68 0f       	st.w [%a15]0,%d15
8000df16:	00 90       	ret 
8000df18:	0b cd 10 48 	mov %e4,%d13,%d12
8000df1c:	40 d4       	mov.aa %a4,%a13
8000df1e:	d9 a5 14 10 	lea %a5,[%sp]84
8000df22:	d9 a6 10 10 	lea %a6,[%sp]80
8000df26:	6d 00 99 08 	call 8000f058 <__d2b>
8000df2a:	37 0d 6b ba 	extr.u %d11,%d13,20,11
8000df2e:	40 2e       	mov.aa %a14,%a2
8000df30:	19 aa 10 10 	ld.w %d10,[%sp]80
8000df34:	76 bd       	jz %d11,8000df4e <_dtoa_r+0x106>
8000df36:	b7 09 0c fa 	insert %d15,%d9,0,20,12
8000df3a:	0b cd 10 48 	mov %e4,%d13,%d12
8000df3e:	7b 00 ff 23 	movh %d2,16368
8000df42:	0f 2f a0 50 	or %d5,%d15,%d2
8000df46:	1b 1b c0 bf 	addi %d11,%d11,-1023
8000df4a:	82 0f       	mov %d15,0
8000df4c:	3c 22       	j 8000df90 <_dtoa_r+0x148>
8000df4e:	19 ab 14 10 	ld.w %d11,[%sp]84
8000df52:	3b e0 be 4f 	mov %d4,-1042
8000df56:	42 ab       	add %d11,%d10
8000df58:	a2 b4       	sub %d4,%d11
8000df5a:	3b f0 be 2f 	mov %d2,-1041
8000df5e:	0f 4c 00 40 	sh %d4,%d12,%d4
8000df62:	3f 2b 0f 00 	jlt %d11,%d2,8000df80 <_dtoa_r+0x138>
8000df66:	1b 2b 41 30 	addi %d3,%d11,1042
8000df6a:	3b e0 c0 4f 	mov %d4,-1010
8000df6e:	a2 b4       	sub %d4,%d11
8000df70:	8b 03 00 21 	rsub %d2,%d3,0
8000df74:	0f 2c 00 20 	sh %d2,%d12,%d2
8000df78:	0f 4d 00 f0 	sh %d15,%d13,%d4
8000df7c:	0f f2 a0 40 	or %d4,%d2,%d15
8000df80:	6d ff 7b f0 	call 8000c076 <__floatunsidf>
8000df84:	0b 23 10 48 	mov %e4,%d3,%d2
8000df88:	9b 03 e1 5f 	addih %d5,%d3,65040
8000df8c:	c2 fb       	add %d11,-1
8000df8e:	82 1f       	mov %d15,1
8000df90:	b7 00 ab 69 	imask %e6,0,19,11
8000df94:	78 13       	st.w [%sp]76,%d15
8000df96:	6d ff a1 ee 	call 8000bcd8 <__subdf3>
8000df9a:	7b 30 fd 73 	movh %d7,16339
8000df9e:	0b 23 10 48 	mov %e4,%d3,%d2
8000dfa2:	7b f0 36 66 	movh %d6,25455
8000dfa6:	1b 77 7a 78 	addi %d7,%d7,-30809
8000dfaa:	1b 16 36 64 	addi %d6,%d6,17249
8000dfae:	6d ff b5 ee 	call 8000bd18 <__muldf3>
8000dfb2:	7b 70 fc 73 	movh %d7,16327
8000dfb6:	0b 23 10 48 	mov %e4,%d3,%d2
8000dfba:	7b 10 b6 68 	movh %d6,35681
8000dfbe:	1b 87 a2 78 	addi %d7,%d7,-30168
8000dfc2:	1b 36 8b 6c 	addi %d6,%d6,-14157
8000dfc6:	6d ff 6d ee 	call 8000bca0 <__adddf3>
8000dfca:	02 b4       	mov %d4,%d11
8000dfcc:	0b 23 10 88 	mov %e8,%d3,%d2
8000dfd0:	6d ff 02 f0 	call 8000bfd4 <__floatsidf>
8000dfd4:	7b 30 fd 73 	movh %d7,16339
8000dfd8:	0b 23 10 48 	mov %e4,%d3,%d2
8000dfdc:	7b f0 09 65 	movh %d6,20639
8000dfe0:	1b 37 41 74 	addi %d7,%d7,17427
8000dfe4:	1b b6 9f 67 	addi %d6,%d6,31227
8000dfe8:	6d ff 98 ee 	call 8000bd18 <__muldf3>
8000dfec:	0b 89 10 48 	mov %e4,%d9,%d8
8000dff0:	0b 23 10 68 	mov %e6,%d3,%d2
8000dff4:	6d ff 56 ee 	call 8000bca0 <__adddf3>
8000dff8:	0b 23 10 48 	mov %e4,%d3,%d2
8000dffc:	0b 23 10 88 	mov %e8,%d3,%d2
8000e000:	6d 00 46 0c 	call 8000f88c <__fixdfsi>
8000e004:	0b 89 10 48 	mov %e4,%d9,%d8
8000e008:	d2 06       	mov %e6,0
8000e00a:	59 a2 08 00 	st.w [%sp]8,%d2
8000e00e:	6d 00 1f 0c 	call 8000f84c <__ltdf2>
8000e012:	ff 02 12 00 	jge %d2,0,8000e036 <_dtoa_r+0x1ee>
8000e016:	19 a4 08 00 	ld.w %d4,[%sp]8
8000e01a:	6d ff dd ef 	call 8000bfd4 <__floatsidf>
8000e01e:	0b 89 10 48 	mov %e4,%d9,%d8
8000e022:	0b 23 10 68 	mov %e6,%d3,%d2
8000e026:	6d 00 b3 0b 	call 8000f78c <__nedf2>
8000e02a:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e02e:	ab f3 1f 32 	cadd %d3,%d2,%d3,-1
8000e032:	59 a3 08 00 	st.w [%sp]8,%d3
8000e036:	19 a2 08 00 	ld.w %d2,[%sp]8
8000e03a:	82 13       	mov %d3,1
8000e03c:	8b 72 a1 f2 	ge.u %d15,%d2,23
8000e040:	59 a3 3c 00 	st.w [%sp]60,%d3
8000e044:	ee 18       	jnz %d15,8000e074 <_dtoa_r+0x22c>
8000e046:	91 00 00 f8 	movh.a %a15,32768
8000e04a:	d9 ff 20 31 	lea %a15,[%a15]4320 <800010e0 <__mprec_tens>>
8000e04e:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000e052:	0b cd 10 68 	mov %e6,%d13,%d12
8000e056:	09 f4 40 09 	ld.d %e4,[%a15]
8000e05a:	6d 00 b9 0b 	call 8000f7cc <__gtdf2>
8000e05e:	8e 28       	jlez %d2,8000e06e <_dtoa_r+0x226>
8000e060:	58 02       	ld.w %d15,[%sp]8
8000e062:	82 02       	mov %d2,0
8000e064:	c2 ff       	add %d15,-1
8000e066:	78 02       	st.w [%sp]8,%d15
8000e068:	59 a2 3c 00 	st.w [%sp]60,%d2
8000e06c:	3c 04       	j 8000e074 <_dtoa_r+0x22c>
8000e06e:	82 03       	mov %d3,0
8000e070:	59 a3 3c 00 	st.w [%sp]60,%d3
8000e074:	0b ba 80 b0 	sub %d11,%d10,%d11
8000e078:	9a fb       	add %d15,%d11,-1
8000e07a:	82 02       	mov %d2,0
8000e07c:	78 06       	st.w [%sp]24,%d15
8000e07e:	59 a2 14 00 	st.w [%sp]20,%d2
8000e082:	ce f6       	jgez %d15,8000e08e <_dtoa_r+0x246>
8000e084:	32 5f       	rsub %d15
8000e086:	82 03       	mov %d3,0
8000e088:	78 05       	st.w [%sp]20,%d15
8000e08a:	59 a3 18 00 	st.w [%sp]24,%d3
8000e08e:	58 02       	ld.w %d15,[%sp]8
8000e090:	0e fa       	jltz %d15,8000e0a4 <_dtoa_r+0x25c>
8000e092:	19 a2 18 00 	ld.w %d2,[%sp]24
8000e096:	78 0d       	st.w [%sp]52,%d15
8000e098:	42 f2       	add %d2,%d15
8000e09a:	82 0f       	mov %d15,0
8000e09c:	59 a2 18 00 	st.w [%sp]24,%d2
8000e0a0:	78 08       	st.w [%sp]32,%d15
8000e0a2:	3c 0d       	j 8000e0bc <_dtoa_r+0x274>
8000e0a4:	19 a2 14 00 	ld.w %d2,[%sp]20
8000e0a8:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e0ac:	82 0f       	mov %d15,0
8000e0ae:	a2 32       	sub %d2,%d3
8000e0b0:	32 53       	rsub %d3
8000e0b2:	59 a2 14 00 	st.w [%sp]20,%d2
8000e0b6:	59 a3 20 00 	st.w [%sp]32,%d3
8000e0ba:	78 0d       	st.w [%sp]52,%d15
8000e0bc:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e0c0:	82 18       	mov %d8,1
8000e0c2:	ff a2 46 80 	jge.u %d2,10,8000e14e <_dtoa_r+0x306>
8000e0c6:	bf 62 06 00 	jlt %d2,6,8000e0d2 <_dtoa_r+0x28a>
8000e0ca:	c2 c2       	add %d2,-4
8000e0cc:	59 a2 1c 00 	st.w [%sp]28,%d2
8000e0d0:	82 08       	mov %d8,0
8000e0d2:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000e0d6:	c2 e3       	add %d3,-2
8000e0d8:	ff 43 4b 80 	jge.u %d3,4,8000e16e <_dtoa_r+0x326>
8000e0dc:	91 10 00 f8 	movh.a %a15,32769
8000e0e0:	d9 ff 2c 3e 	lea %a15,[%a15]-7956 <8000e0ec <_dtoa_r+0x2a4>>
8000e0e4:	01 f3 02 f6 	addsc.a %a15,%a15,%d3,2
8000e0e8:	dc 0f       	ji %a15
8000e0ea:	00 00       	nop 
8000e0ec:	1d 00 08 00 	j 8000e0fc <_dtoa_r+0x2b4>
8000e0f0:	1d 00 1c 00 	j 8000e128 <_dtoa_r+0x2e0>
8000e0f4:	1d 00 08 00 	j 8000e104 <_dtoa_r+0x2bc>
8000e0f8:	1d 00 1c 00 	j 8000e130 <_dtoa_r+0x2e8>
8000e0fc:	82 03       	mov %d3,0
8000e0fe:	59 a3 24 00 	st.w [%sp]36,%d3
8000e102:	3c 03       	j 8000e108 <_dtoa_r+0x2c0>
8000e104:	82 1f       	mov %d15,1
8000e106:	78 09       	st.w [%sp]36,%d15
8000e108:	19 a2 28 00 	ld.w %d2,[%sp]40
8000e10c:	59 a2 2c 00 	st.w [%sp]44,%d2
8000e110:	59 a2 10 00 	st.w [%sp]16,%d2
8000e114:	02 23       	mov %d3,%d2
8000e116:	ff 12 38 00 	jge %d2,1,8000e186 <_dtoa_r+0x33e>
8000e11a:	82 13       	mov %d3,1
8000e11c:	82 1f       	mov %d15,1
8000e11e:	59 a3 2c 00 	st.w [%sp]44,%d3
8000e122:	78 04       	st.w [%sp]16,%d15
8000e124:	82 12       	mov %d2,1
8000e126:	3c 21       	j 8000e168 <_dtoa_r+0x320>
8000e128:	82 03       	mov %d3,0
8000e12a:	59 a3 24 00 	st.w [%sp]36,%d3
8000e12e:	3c 03       	j 8000e134 <_dtoa_r+0x2ec>
8000e130:	82 1f       	mov %d15,1
8000e132:	78 09       	st.w [%sp]36,%d15
8000e134:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e138:	19 a2 28 00 	ld.w %d2,[%sp]40
8000e13c:	42 32       	add %d2,%d3
8000e13e:	59 a2 2c 00 	st.w [%sp]44,%d2
8000e142:	c2 12       	add %d2,1
8000e144:	59 a2 10 00 	st.w [%sp]16,%d2
8000e148:	8b 12 40 33 	max %d3,%d2,1
8000e14c:	3c 1d       	j 8000e186 <_dtoa_r+0x33e>
8000e14e:	82 0f       	mov %d15,0
8000e150:	82 12       	mov %d2,1
8000e152:	82 f3       	mov %d3,-1
8000e154:	78 07       	st.w [%sp]28,%d15
8000e156:	82 ff       	mov %d15,-1
8000e158:	59 a2 24 00 	st.w [%sp]36,%d2
8000e15c:	59 a3 2c 00 	st.w [%sp]44,%d3
8000e160:	78 04       	st.w [%sp]16,%d15
8000e162:	3b 20 01 30 	mov %d3,18
8000e166:	82 02       	mov %d2,0
8000e168:	59 a2 28 00 	st.w [%sp]40,%d2
8000e16c:	3c 0d       	j 8000e186 <_dtoa_r+0x33e>
8000e16e:	82 ff       	mov %d15,-1
8000e170:	82 13       	mov %d3,1
8000e172:	78 0b       	st.w [%sp]44,%d15
8000e174:	82 f2       	mov %d2,-1
8000e176:	82 0f       	mov %d15,0
8000e178:	59 a3 24 00 	st.w [%sp]36,%d3
8000e17c:	59 a2 10 00 	st.w [%sp]16,%d2
8000e180:	3b 20 01 30 	mov %d3,18
8000e184:	78 0a       	st.w [%sp]40,%d15
8000e186:	82 05       	mov %d5,0
8000e188:	59 d5 04 10 	st.w [%a13]68,%d5
8000e18c:	82 45       	mov %d5,4
8000e18e:	1b 45 01 00 	addi %d0,%d5,20
8000e192:	3f 03 09 80 	jlt.u %d3,%d0,8000e1a4 <_dtoa_r+0x35c>
8000e196:	19 d0 04 10 	ld.w %d0,[%a13]68
8000e19a:	06 15       	sh %d5,1
8000e19c:	c2 10       	add %d0,1
8000e19e:	59 d0 04 10 	st.w [%a13]68,%d0
8000e1a2:	3c f6       	j 8000e18e <_dtoa_r+0x346>
8000e1a4:	40 d4       	mov.aa %a4,%a13
8000e1a6:	19 d4 04 10 	ld.w %d4,[%a13]68
8000e1aa:	6d 00 d8 04 	call 8000eb5a <_Balloc>
8000e1ae:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e1b2:	b5 a2 0c 00 	st.a [%sp]12,%a2
8000e1b6:	8b f2 60 32 	lt.u %d3,%d2,15
8000e1ba:	b5 d2 00 10 	st.a [%a13]64,%a2
8000e1be:	26 38       	and %d8,%d3
8000e1c0:	df 08 97 01 	jeq %d8,0,8000e4ee <_dtoa_r+0x6a6>
8000e1c4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e1c8:	89 ac 40 19 	st.d [%sp]64,%e12
8000e1cc:	bf 13 3f 00 	jlt %d3,1,8000e24a <_dtoa_r+0x402>
8000e1d0:	91 00 00 f8 	movh.a %a15,32768
8000e1d4:	8f f3 00 31 	and %d3,%d3,15
8000e1d8:	d9 ff 20 31 	lea %a15,[%a15]4320 <800010e0 <__mprec_tens>>
8000e1dc:	19 ae 08 00 	ld.w %d14,[%sp]8 <800010e0 <__mprec_tens>>
8000e1e0:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000e1e4:	86 ce       	sha %d14,-4
8000e1e6:	09 f8 40 09 	ld.d %e8,[%a15]
8000e1ea:	82 2a       	mov %d10,2
8000e1ec:	6f 4e 11 00 	jz.t %d14,4,8000e20e <_dtoa_r+0x3c6>
8000e1f0:	91 00 00 f8 	movh.a %a15,32768
8000e1f4:	0b cd 10 48 	mov %e4,%d13,%d12
8000e1f8:	d9 ff 38 21 	lea %a15,[%a15]4280 <800010b8 <__mprec_bigtens>>
8000e1fc:	09 f6 60 09 	ld.d %e6,[%a15]32 <80000020 <_start>>
8000e200:	6d ff 5e ee 	call 8000bebc <__divdf3>
8000e204:	0b 23 10 c8 	mov %e12,%d3,%d2
8000e208:	8f fe 00 e1 	and %d14,%d14,15
8000e20c:	82 3a       	mov %d10,3
8000e20e:	7b 00 00 b8 	movh %d11,32768
8000e212:	82 0f       	mov %d15,0
8000e214:	1b 8b 0b b1 	addi %d11,%d11,4280
8000e218:	df 0e 12 00 	jeq %d14,0,8000e23c <_dtoa_r+0x3f4>
8000e21c:	6f 0e 0d 00 	jz.t %d14,0,8000e236 <_dtoa_r+0x3ee>
8000e220:	60 b2       	mov.a %a2,%d11
8000e222:	d0 2f       	addsc.a %a15,%a2,%d15,3
8000e224:	0b 89 10 48 	mov %e4,%d9,%d8
8000e228:	09 f6 40 09 	ld.d %e6,[%a15]
8000e22c:	6d ff 76 ed 	call 8000bd18 <__muldf3>
8000e230:	0b 23 10 88 	mov %e8,%d3,%d2
8000e234:	c2 1a       	add %d10,1
8000e236:	86 fe       	sha %d14,-1
8000e238:	c2 1f       	add %d15,1
8000e23a:	3c ef       	j 8000e218 <_dtoa_r+0x3d0>
8000e23c:	0b cd 10 48 	mov %e4,%d13,%d12
8000e240:	0b 89 10 68 	mov %e6,%d9,%d8
8000e244:	6d ff 3c ee 	call 8000bebc <__divdf3>
8000e248:	3c 2c       	j 8000e2a0 <_dtoa_r+0x458>
8000e24a:	19 a8 08 00 	ld.w %d8,[%sp]8
8000e24e:	82 2a       	mov %d10,2
8000e250:	32 58       	rsub %d8
8000e252:	df 08 29 00 	jeq %d8,0,8000e2a4 <_dtoa_r+0x45c>
8000e256:	91 00 00 f8 	movh.a %a15,32768
8000e25a:	8f f8 00 31 	and %d3,%d8,15
8000e25e:	d9 ff 20 31 	lea %a15,[%a15]4320 <800010e0 <__mprec_tens>>
8000e262:	01 f3 03 f6 	addsc.a %a15,%a15,%d3,3
8000e266:	09 a4 40 19 	ld.d %e4,[%sp]64
8000e26a:	09 f6 40 09 	ld.d %e6,[%a15]
8000e26e:	7b 00 00 c8 	movh %d12,32768
8000e272:	6d ff 53 ed 	call 8000bd18 <__muldf3>
8000e276:	82 09       	mov %d9,0
8000e278:	86 c8       	sha %d8,-4
8000e27a:	1b 8c 0b c1 	addi %d12,%d12,4280
8000e27e:	df 08 11 00 	jeq %d8,0,8000e2a0 <_dtoa_r+0x458>
8000e282:	6f 08 0c 00 	jz.t %d8,0,8000e29a <_dtoa_r+0x452>
8000e286:	60 c3       	mov.a %a3,%d12
8000e288:	01 39 03 f6 	addsc.a %a15,%a3,%d9,3
8000e28c:	0b 23 10 48 	mov %e4,%d3,%d2
8000e290:	09 f6 40 09 	ld.d %e6,[%a15]
8000e294:	c2 1a       	add %d10,1
8000e296:	6d ff 41 ed 	call 8000bd18 <__muldf3>
8000e29a:	86 f8       	sha %d8,-1
8000e29c:	c2 19       	add %d9,1
8000e29e:	3c f0       	j 8000e27e <_dtoa_r+0x436>
8000e2a0:	0b 23 10 c8 	mov %e12,%d3,%d2
8000e2a4:	19 a2 3c 00 	ld.w %d2,[%sp]60
8000e2a8:	df 02 23 00 	jeq %d2,0,8000e2ee <_dtoa_r+0x4a6>
8000e2ac:	0b cd 10 48 	mov %e4,%d13,%d12
8000e2b0:	b7 00 2a 6a 	imask %e6,0,20,10
8000e2b4:	6d 00 cc 0a 	call 8000f84c <__ltdf2>
8000e2b8:	ff 02 20 00 	jge %d2,0,8000e2f8 <_dtoa_r+0x4b0>
8000e2bc:	19 a3 10 00 	ld.w %d3,[%sp]16
8000e2c0:	df 03 21 00 	jeq %d3,0,8000e302 <_dtoa_r+0x4ba>
8000e2c4:	58 0b       	ld.w %d15,[%sp]44
8000e2c6:	bf 1f 12 01 	jlt %d15,1,8000e4ea <_dtoa_r+0x6a2>
8000e2ca:	19 a2 08 00 	ld.w %d2,[%sp]8
8000e2ce:	0b cd 10 48 	mov %e4,%d13,%d12
8000e2d2:	c2 f2       	add %d2,-1
8000e2d4:	82 06       	mov %d6,0
8000e2d6:	7b 40 02 74 	movh %d7,16420
8000e2da:	59 a2 30 00 	st.w [%sp]48,%d2
8000e2de:	6d ff 1d ed 	call 8000bd18 <__muldf3>
8000e2e2:	c2 1a       	add %d10,1
8000e2e4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000e2e8:	99 ac 2c 00 	ld.a %a12,[%sp]44
8000e2ec:	3c 10       	j 8000e30c <_dtoa_r+0x4c4>
8000e2ee:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e2f2:	59 a3 30 00 	st.w [%sp]48,%d3
8000e2f6:	3c 03       	j 8000e2fc <_dtoa_r+0x4b4>
8000e2f8:	58 02       	ld.w %d15,[%sp]8
8000e2fa:	78 0c       	st.w [%sp]48,%d15
8000e2fc:	99 ac 10 00 	ld.a %a12,[%sp]16
8000e300:	3c 06       	j 8000e30c <_dtoa_r+0x4c4>
8000e302:	19 a2 08 00 	ld.w %d2,[%sp]8
8000e306:	a0 0c       	mov.a %a12,0
8000e308:	59 a2 30 00 	st.w [%sp]48,%d2
8000e30c:	02 a4       	mov %d4,%d10
8000e30e:	6d ff 63 ee 	call 8000bfd4 <__floatsidf>
8000e312:	0b cd 10 68 	mov %e6,%d13,%d12
8000e316:	0b 23 10 48 	mov %e4,%d3,%d2
8000e31a:	6d ff ff ec 	call 8000bd18 <__muldf3>
8000e31e:	0b 23 10 48 	mov %e4,%d3,%d2
8000e322:	82 06       	mov %d6,0
8000e324:	7b c0 01 74 	movh %d7,16412
8000e328:	6d ff bc ec 	call 8000bca0 <__adddf3>
8000e32c:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e330:	0b 23 10 e8 	mov %e14,%d3,%d2
8000e334:	60 b2       	mov.a %a2,%d11
8000e336:	11 02 cc ff 	addih.a %a15,%a2,64704
8000e33a:	80 ff       	mov.d %d15,%a15
8000e33c:	bd 0c 1e 80 	jnz.a %a12,8000e378 <_dtoa_r+0x530>
8000e340:	0b cd 10 48 	mov %e4,%d13,%d12
8000e344:	82 06       	mov %d6,0
8000e346:	7b 40 01 74 	movh %d7,16404
8000e34a:	6d ff c7 ec 	call 8000bcd8 <__subdf3>
8000e34e:	80 f7       	mov.d %d7,%a15
8000e350:	0b 23 10 48 	mov %e4,%d3,%d2
8000e354:	02 e6       	mov %d6,%d14
8000e356:	0b 23 10 88 	mov %e8,%d3,%d2
8000e35a:	6d 00 39 0a 	call 8000f7cc <__gtdf2>
8000e35e:	ff 12 8e 02 	jge %d2,1,8000e87a <_dtoa_r+0xa32>
8000e362:	0b 89 10 48 	mov %e4,%d9,%d8
8000e366:	02 e6       	mov %d6,%d14
8000e368:	9b 0b cc 77 	addih %d7,%d11,31936
8000e36c:	6d 00 70 0a 	call 8000f84c <__ltdf2>
8000e370:	bf 02 7d 02 	jlt %d2,0,8000e86a <_dtoa_r+0xa22>
8000e374:	1d 00 bb 00 	j 8000e4ea <_dtoa_r+0x6a2>
8000e378:	80 c5       	mov.d %d5,%a12
8000e37a:	91 00 00 f8 	movh.a %a15,32768
8000e37e:	19 a2 24 00 	ld.w %d2,[%sp]36
8000e382:	d9 ff 20 31 	lea %a15,[%a15]4320 <800010e0 <__mprec_tens>>
8000e386:	c2 f5       	add %d5,-1
8000e388:	01 f5 03 f6 	addsc.a %a15,%a15,%d5,3
8000e38c:	df 02 57 00 	jeq %d2,0,8000e43a <_dtoa_r+0x5f2>
8000e390:	b7 00 a9 4a 	imask %e4,0,21,9
8000e394:	09 f6 40 09 	ld.d %e6,[%a15]
8000e398:	6d ff 92 ed 	call 8000bebc <__divdf3>
8000e39c:	0b ef 10 68 	mov %e6,%d15,%d14
8000e3a0:	0b 23 10 48 	mov %e4,%d3,%d2
8000e3a4:	6d ff 9a ec 	call 8000bcd8 <__subdf3>
8000e3a8:	d8 03       	ld.a %a15,[%sp]12
8000e3aa:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e3ae:	0b cd 10 48 	mov %e4,%d13,%d12
8000e3b2:	80 fe       	mov.d %d14,%a15
8000e3b4:	6d 00 6c 0a 	call 8000f88c <__fixdfsi>
8000e3b8:	02 24       	mov %d4,%d2
8000e3ba:	02 2f       	mov %d15,%d2
8000e3bc:	6d ff 0c ee 	call 8000bfd4 <__floatsidf>
8000e3c0:	0b cd 10 48 	mov %e4,%d13,%d12
8000e3c4:	0b 23 10 68 	mov %e6,%d3,%d2
8000e3c8:	c2 1e       	add %d14,1
8000e3ca:	6d ff 87 ec 	call 8000bcd8 <__subdf3>
8000e3ce:	1b 0f 03 50 	addi %d5,%d15,48
8000e3d2:	28 05       	st.b [%a15]0,%d5
8000e3d4:	0b ab 10 68 	mov %e6,%d11,%d10
8000e3d8:	0b 23 10 48 	mov %e4,%d3,%d2
8000e3dc:	0b 23 10 88 	mov %e8,%d3,%d2
8000e3e0:	6d 00 36 0a 	call 8000f84c <__ltdf2>
8000e3e4:	bf 02 86 03 	jlt %d2,0,8000eaf0 <_dtoa_r+0xca8>
8000e3e8:	b7 00 2a 4a 	imask %e4,0,20,10
8000e3ec:	0b 89 10 68 	mov %e6,%d9,%d8
8000e3f0:	6d ff 74 ec 	call 8000bcd8 <__subdf3>
8000e3f4:	0b ab 10 68 	mov %e6,%d11,%d10
8000e3f8:	0b 23 10 48 	mov %e4,%d3,%d2
8000e3fc:	6d 00 28 0a 	call 8000f84c <__ltdf2>
8000e400:	bf 02 ea 00 	jlt %d2,0,8000e5d4 <_dtoa_r+0x78c>
8000e404:	19 a3 0c 00 	ld.w %d3,[%sp]12
8000e408:	02 e5       	mov %d5,%d14
8000e40a:	80 cf       	mov.d %d15,%a12
8000e40c:	a2 35       	sub %d5,%d3
8000e40e:	7f f5 6e 00 	jge %d5,%d15,8000e4ea <_dtoa_r+0x6a2>
8000e412:	0b ab 10 48 	mov %e4,%d11,%d10
8000e416:	82 06       	mov %d6,0
8000e418:	7b 40 02 74 	movh %d7,16420
8000e41c:	6d ff 7e ec 	call 8000bd18 <__muldf3>
8000e420:	0b 89 10 48 	mov %e4,%d9,%d8
8000e424:	82 06       	mov %d6,0
8000e426:	7b 40 02 74 	movh %d7,16420
8000e42a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e42e:	6d ff 75 ec 	call 8000bd18 <__muldf3>
8000e432:	60 ef       	mov.a %a15,%d14
8000e434:	0b 23 10 c8 	mov %e12,%d3,%d2
8000e438:	3c bb       	j 8000e3ae <_dtoa_r+0x566>
8000e43a:	0b ef 10 68 	mov %e6,%d15,%d14
8000e43e:	09 f4 40 09 	ld.d %e4,[%a15]
8000e442:	6d ff 6b ec 	call 8000bd18 <__muldf3>
8000e446:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000e44a:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e44e:	30 c3       	add.a %a3,%a12
8000e450:	99 ac 0c 00 	ld.a %a12,[%sp]12
8000e454:	80 3e       	mov.d %d14,%a3
8000e456:	0b cd 10 48 	mov %e4,%d13,%d12
8000e45a:	d9 cf 01 00 	lea %a15,[%a12]1
8000e45e:	6d 00 17 0a 	call 8000f88c <__fixdfsi>
8000e462:	02 24       	mov %d4,%d2
8000e464:	02 2f       	mov %d15,%d2
8000e466:	6d ff b7 ed 	call 8000bfd4 <__floatsidf>
8000e46a:	0b cd 10 48 	mov %e4,%d13,%d12
8000e46e:	0b 23 10 68 	mov %e6,%d3,%d2
8000e472:	6d ff 33 ec 	call 8000bcd8 <__subdf3>
8000e476:	1b 0f 03 50 	addi %d5,%d15,48
8000e47a:	0b 23 10 88 	mov %e8,%d3,%d2
8000e47e:	80 f2       	mov.d %d2,%a15
8000e480:	34 c5       	st.b [%a12],%d5
8000e482:	5f e2 29 80 	jne %d2,%d14,8000e4d4 <_dtoa_r+0x68c>
8000e486:	0b ab 10 48 	mov %e4,%d11,%d10
8000e48a:	b7 00 a9 6a 	imask %e6,0,21,9
8000e48e:	6d ff 09 ec 	call 8000bca0 <__adddf3>
8000e492:	0b 89 10 48 	mov %e4,%d9,%d8
8000e496:	0b 23 10 68 	mov %e6,%d3,%d2
8000e49a:	6d 00 99 09 	call 8000f7cc <__gtdf2>
8000e49e:	ff 12 9b 00 	jge %d2,1,8000e5d4 <_dtoa_r+0x78c>
8000e4a2:	b7 00 a9 4a 	imask %e4,0,21,9
8000e4a6:	0b ab 10 68 	mov %e6,%d11,%d10
8000e4aa:	6d ff 17 ec 	call 8000bcd8 <__subdf3>
8000e4ae:	0b 89 10 48 	mov %e4,%d9,%d8
8000e4b2:	0b 23 10 68 	mov %e6,%d3,%d2
8000e4b6:	6d 00 cb 09 	call 8000f84c <__ltdf2>
8000e4ba:	ff 02 18 00 	jge %d2,0,8000e4ea <_dtoa_r+0x6a2>
8000e4be:	60 e2       	mov.a %a2,%d14
8000e4c0:	60 ef       	mov.a %a15,%d14
8000e4c2:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000e4c6:	b0 ff       	add.a %a15,-1
8000e4c8:	8b 0f 03 f2 	eq %d15,%d15,48
8000e4cc:	df 0f 12 03 	jeq %d15,0,8000eaf0 <_dtoa_r+0xca8>
8000e4d0:	80 fe       	mov.d %d14,%a15
8000e4d2:	3c f6       	j 8000e4be <_dtoa_r+0x676>
8000e4d4:	0b 89 10 48 	mov %e4,%d9,%d8
8000e4d8:	82 06       	mov %d6,0
8000e4da:	7b 40 02 74 	movh %d7,16420
8000e4de:	6d ff 1d ec 	call 8000bd18 <__muldf3>
8000e4e2:	40 fc       	mov.aa %a12,%a15
8000e4e4:	0b 23 10 c8 	mov %e12,%d3,%d2
8000e4e8:	3c b7       	j 8000e456 <_dtoa_r+0x60e>
8000e4ea:	09 ac 40 19 	ld.d %e12,[%sp]64
8000e4ee:	19 a3 14 10 	ld.w %d3,[%sp]84
8000e4f2:	19 a2 08 00 	ld.w %d2,[%sp]8
8000e4f6:	8b 03 80 52 	ge %d5,%d3,0
8000e4fa:	8b f2 40 54 	and.lt %d5,%d2,15
8000e4fe:	df 05 9e 00 	jeq %d5,0,8000e63a <_dtoa_r+0x7f2>
8000e502:	91 00 00 f8 	movh.a %a15,32768
8000e506:	d9 ff 20 31 	lea %a15,[%a15]4320 <800010e0 <__mprec_tens>>
8000e50a:	19 a3 10 00 	ld.w %d3,[%sp]16 <800010e0 <__mprec_tens>>
8000e50e:	01 f2 03 f6 	addsc.a %a15,%a15,%d2,3
8000e512:	19 a2 28 00 	ld.w %d2,[%sp]40
8000e516:	fa 13       	lt %d15,%d3,1
8000e518:	87 f2 1f f0 	and.t %d15,%d2,31,%d15,0
8000e51c:	09 f8 40 09 	ld.d %e8,[%a15]
8000e520:	6e 16       	jz %d15,8000e54c <_dtoa_r+0x704>
8000e522:	df 03 a4 81 	jne %d3,0,8000e86a <_dtoa_r+0xa22>
8000e526:	0b 89 10 48 	mov %e4,%d9,%d8
8000e52a:	82 06       	mov %d6,0
8000e52c:	7b 40 01 74 	movh %d7,16404
8000e530:	6d ff f4 eb 	call 8000bd18 <__muldf3>
8000e534:	0b cd 10 68 	mov %e6,%d13,%d12
8000e538:	0b 23 10 48 	mov %e4,%d3,%d2
8000e53c:	a0 0c       	mov.a %a12,0
8000e53e:	6d 00 67 09 	call 8000f80c <__gedf2>
8000e542:	a0 0f       	mov.a %a15,0
8000e544:	ff 02 95 01 	jge %d2,0,8000e86e <_dtoa_r+0xa26>
8000e548:	1d 00 9d 01 	j 8000e882 <_dtoa_r+0xa3a>
8000e54c:	d8 03       	ld.a %a15,[%sp]12
8000e54e:	0b cd 10 a8 	mov %e10,%d13,%d12
8000e552:	0b 89 10 68 	mov %e6,%d9,%d8
8000e556:	0b ab 10 48 	mov %e4,%d11,%d10
8000e55a:	80 fe       	mov.d %d14,%a15
8000e55c:	6d ff b0 ec 	call 8000bebc <__divdf3>
8000e560:	0b 23 10 48 	mov %e4,%d3,%d2
8000e564:	c2 1e       	add %d14,1
8000e566:	6d 00 93 09 	call 8000f88c <__fixdfsi>
8000e56a:	02 24       	mov %d4,%d2
8000e56c:	02 2f       	mov %d15,%d2
8000e56e:	6d ff 33 ed 	call 8000bfd4 <__floatsidf>
8000e572:	0b 89 10 68 	mov %e6,%d9,%d8
8000e576:	0b 23 10 48 	mov %e4,%d3,%d2
8000e57a:	6d ff cf eb 	call 8000bd18 <__muldf3>
8000e57e:	0b ab 10 48 	mov %e4,%d11,%d10
8000e582:	0b 23 10 68 	mov %e6,%d3,%d2
8000e586:	6d ff a9 eb 	call 8000bcd8 <__subdf3>
8000e58a:	0b 23 10 48 	mov %e4,%d3,%d2
8000e58e:	1b 0f 03 30 	addi %d3,%d15,48
8000e592:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000e596:	28 03       	st.b [%a15]0,%d3
8000e598:	02 e3       	mov %d3,%d14
8000e59a:	a2 23       	sub %d3,%d2
8000e59c:	19 a2 10 00 	ld.w %d2,[%sp]16
8000e5a0:	5f 23 3c 80 	jne %d3,%d2,8000e618 <_dtoa_r+0x7d0>
8000e5a4:	0b 45 10 68 	mov %e6,%d5,%d4
8000e5a8:	6d ff 7c eb 	call 8000bca0 <__adddf3>
8000e5ac:	0b 89 10 68 	mov %e6,%d9,%d8
8000e5b0:	0b 23 10 48 	mov %e4,%d3,%d2
8000e5b4:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e5b8:	6d 00 0a 09 	call 8000f7cc <__gtdf2>
8000e5bc:	4e 2e       	jgtz %d2,8000e5d8 <_dtoa_r+0x790>
8000e5be:	0b ab 10 48 	mov %e4,%d11,%d10
8000e5c2:	0b 89 10 68 	mov %e6,%d9,%d8
8000e5c6:	6d 00 c3 08 	call 8000f74c <__eqdf2>
8000e5ca:	df 02 95 82 	jne %d2,0,8000eaf4 <_dtoa_r+0xcac>
8000e5ce:	ae 05       	jnz.t %d15,0,8000e5d8 <_dtoa_r+0x790>
8000e5d0:	1d 00 92 02 	j 8000eaf4 <_dtoa_r+0xcac>
8000e5d4:	58 0c       	ld.w %d15,[%sp]48
8000e5d6:	78 02       	st.w [%sp]8,%d15
8000e5d8:	58 03       	ld.w %d15,[%sp]12
8000e5da:	a2 ef       	sub %d15,%d14
8000e5dc:	46 0f       	not %d15
8000e5de:	60 e2       	mov.a %a2,%d14
8000e5e0:	60 ef       	mov.a %a15,%d14
8000e5e2:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000e5e6:	b0 ff       	add.a %a15,-1
8000e5e8:	8b 93 03 32 	eq %d3,%d3,57
8000e5ec:	df 03 11 00 	jeq %d3,0,8000e60e <_dtoa_r+0x7c6>
8000e5f0:	9f 0f 0d 80 	jned %d15,0,8000e60a <_dtoa_r+0x7c2>
8000e5f4:	19 a3 08 00 	ld.w %d3,[%sp]8
8000e5f8:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000e5fc:	c2 13       	add %d3,1
8000e5fe:	da 30       	mov %d15,48
8000e600:	59 a3 08 00 	st.w [%sp]8,%d3
8000e604:	2c 30       	st.b [%a3]0,%d15
8000e606:	40 3f       	mov.aa %a15,%a3
8000e608:	3c 03       	j 8000e60e <_dtoa_r+0x7c6>
8000e60a:	80 fe       	mov.d %d14,%a15
8000e60c:	3c e9       	j 8000e5de <_dtoa_r+0x796>
8000e60e:	0c f0       	ld.bu %d15,[%a15]0
8000e610:	c2 1f       	add %d15,1
8000e612:	28 0f       	st.b [%a15]0,%d15
8000e614:	1d 00 70 02 	j 8000eaf4 <_dtoa_r+0xcac>
8000e618:	82 06       	mov %d6,0
8000e61a:	7b 40 02 74 	movh %d7,16420
8000e61e:	6d ff 7d eb 	call 8000bd18 <__muldf3>
8000e622:	d2 06       	mov %e6,0
8000e624:	0b 23 10 48 	mov %e4,%d3,%d2
8000e628:	0b 23 10 a8 	mov %e10,%d3,%d2
8000e62c:	60 ef       	mov.a %a15,%d14
8000e62e:	6d 00 8f 08 	call 8000f74c <__eqdf2>
8000e632:	df 02 90 ff 	jne %d2,0,8000e552 <_dtoa_r+0x70a>
8000e636:	1d 00 5f 02 	j 8000eaf4 <_dtoa_r+0xcac>
8000e63a:	19 a2 24 00 	ld.w %d2,[%sp]36
8000e63e:	58 08       	ld.w %d15,[%sp]32
8000e640:	19 a8 14 00 	ld.w %d8,[%sp]20
8000e644:	a0 0f       	mov.a %a15,0
8000e646:	df 02 3b 00 	jeq %d2,0,8000e6bc <_dtoa_r+0x874>
8000e64a:	58 07       	ld.w %d15,[%sp]28
8000e64c:	ff 2f 10 00 	jge %d15,2,8000e66c <_dtoa_r+0x824>
8000e650:	58 13       	ld.w %d15,[%sp]76
8000e652:	6e 05       	jz %d15,8000e65c <_dtoa_r+0x814>
8000e654:	1b 33 43 30 	addi %d3,%d3,1075
8000e658:	58 08       	ld.w %d15,[%sp]32
8000e65a:	3c 22       	j 8000e69e <_dtoa_r+0x856>
8000e65c:	19 a3 10 10 	ld.w %d3,[%sp]80
8000e660:	58 08       	ld.w %d15,[%sp]32
8000e662:	8b 63 03 31 	rsub %d3,%d3,54
8000e666:	19 a8 14 00 	ld.w %d8,[%sp]20
8000e66a:	3c 1a       	j 8000e69e <_dtoa_r+0x856>
8000e66c:	58 04       	ld.w %d15,[%sp]16
8000e66e:	19 a2 20 00 	ld.w %d2,[%sp]32
8000e672:	c2 ff       	add %d15,-1
8000e674:	3f f2 04 00 	jlt %d2,%d15,8000e67c <_dtoa_r+0x834>
8000e678:	5a f2       	sub %d15,%d2,%d15
8000e67a:	3c 0b       	j 8000e690 <_dtoa_r+0x848>
8000e67c:	19 a3 20 00 	ld.w %d3,[%sp]32
8000e680:	78 08       	st.w [%sp]32,%d15
8000e682:	52 32       	sub %d2,%d15,%d3
8000e684:	19 a3 34 00 	ld.w %d3,[%sp]52
8000e688:	82 0f       	mov %d15,0
8000e68a:	42 23       	add %d3,%d2
8000e68c:	59 a3 34 00 	st.w [%sp]52,%d3
8000e690:	19 a3 10 00 	ld.w %d3,[%sp]16
8000e694:	19 a8 14 00 	ld.w %d8,[%sp]20
8000e698:	ce 33       	jgez %d3,8000e69e <_dtoa_r+0x856>
8000e69a:	a2 38       	sub %d8,%d3
8000e69c:	82 03       	mov %d3,0
8000e69e:	19 a2 14 00 	ld.w %d2,[%sp]20
8000e6a2:	40 d4       	mov.aa %a4,%a13
8000e6a4:	42 32       	add %d2,%d3
8000e6a6:	59 a2 14 00 	st.w [%sp]20,%d2
8000e6aa:	19 a2 18 00 	ld.w %d2,[%sp]24
8000e6ae:	82 14       	mov %d4,1
8000e6b0:	42 32       	add %d2,%d3
8000e6b2:	59 a2 18 00 	st.w [%sp]24,%d2
8000e6b6:	6d 00 1b 03 	call 8000ecec <__i2b>
8000e6ba:	40 2f       	mov.aa %a15,%a2
8000e6bc:	19 a2 18 00 	ld.w %d2,[%sp]24
8000e6c0:	8b 18 80 32 	ge %d3,%d8,1
8000e6c4:	8b 12 80 34 	and.ge %d3,%d2,1
8000e6c8:	76 3e       	jz %d3,8000e6e4 <_dtoa_r+0x89c>
8000e6ca:	0b 82 80 31 	min %d3,%d2,%d8
8000e6ce:	19 a2 14 00 	ld.w %d2,[%sp]20
8000e6d2:	a2 38       	sub %d8,%d3
8000e6d4:	a2 32       	sub %d2,%d3
8000e6d6:	59 a2 14 00 	st.w [%sp]20,%d2
8000e6da:	19 a2 18 00 	ld.w %d2,[%sp]24
8000e6de:	a2 32       	sub %d2,%d3
8000e6e0:	59 a2 18 00 	st.w [%sp]24,%d2
8000e6e4:	19 a3 20 00 	ld.w %d3,[%sp]32
8000e6e8:	bf 13 27 00 	jlt %d3,1,8000e736 <_dtoa_r+0x8ee>
8000e6ec:	19 a2 24 00 	ld.w %d2,[%sp]36
8000e6f0:	df 02 1c 00 	jeq %d2,0,8000e728 <_dtoa_r+0x8e0>
8000e6f4:	bf 1f 13 00 	jlt %d15,1,8000e71a <_dtoa_r+0x8d2>
8000e6f8:	40 f5       	mov.aa %a5,%a15
8000e6fa:	02 f4       	mov %d4,%d15
8000e6fc:	40 d4       	mov.aa %a4,%a13
8000e6fe:	6d 00 8c 03 	call 8000ee16 <__pow5mult>
8000e702:	40 e6       	mov.aa %a6,%a14
8000e704:	40 d4       	mov.aa %a4,%a13
8000e706:	40 25       	mov.aa %a5,%a2
8000e708:	40 2f       	mov.aa %a15,%a2
8000e70a:	6d 00 f9 02 	call 8000ecfc <__multiply>
8000e70e:	40 e5       	mov.aa %a5,%a14
8000e710:	40 2c       	mov.aa %a12,%a2
8000e712:	40 d4       	mov.aa %a4,%a13
8000e714:	6d 00 4e 02 	call 8000ebb0 <_Bfree>
8000e718:	40 ce       	mov.aa %a14,%a12
8000e71a:	19 a4 20 00 	ld.w %d4,[%sp]32
8000e71e:	40 d4       	mov.aa %a4,%a13
8000e720:	a2 f4       	sub %d4,%d15
8000e722:	40 e5       	mov.aa %a5,%a14
8000e724:	76 49       	jz %d4,8000e736 <_dtoa_r+0x8ee>
8000e726:	3c 05       	j 8000e730 <_dtoa_r+0x8e8>
8000e728:	19 a4 20 00 	ld.w %d4,[%sp]32
8000e72c:	40 d4       	mov.aa %a4,%a13
8000e72e:	40 e5       	mov.aa %a5,%a14
8000e730:	6d 00 73 03 	call 8000ee16 <__pow5mult>
8000e734:	40 2e       	mov.aa %a14,%a2
8000e736:	40 d4       	mov.aa %a4,%a13
8000e738:	82 14       	mov %d4,1
8000e73a:	6d 00 d9 02 	call 8000ecec <__i2b>
8000e73e:	19 a3 34 00 	ld.w %d3,[%sp]52
8000e742:	40 2c       	mov.aa %a12,%a2
8000e744:	8e 3c       	jlez %d3,8000e75c <_dtoa_r+0x914>
8000e746:	40 d4       	mov.aa %a4,%a13
8000e748:	40 25       	mov.aa %a5,%a2
8000e74a:	02 34       	mov %d4,%d3
8000e74c:	6d 00 65 03 	call 8000ee16 <__pow5mult>
8000e750:	58 07       	ld.w %d15,[%sp]28
8000e752:	40 2c       	mov.aa %a12,%a2
8000e754:	82 09       	mov %d9,0
8000e756:	ff 2f 1f 00 	jge %d15,2,8000e794 <_dtoa_r+0x94c>
8000e75a:	3c 06       	j 8000e766 <_dtoa_r+0x91e>
8000e75c:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e760:	82 09       	mov %d9,0
8000e762:	ff 22 15 00 	jge %d2,2,8000e78c <_dtoa_r+0x944>
8000e766:	82 09       	mov %d9,0
8000e768:	df 0c 12 80 	jne %d12,0,8000e78c <_dtoa_r+0x944>
8000e76c:	b7 0d 0c fa 	insert %d15,%d13,0,20,12
8000e770:	ee 0e       	jnz %d15,8000e78c <_dtoa_r+0x944>
8000e772:	7b 00 ff f7 	movh %d15,32752
8000e776:	26 df       	and %d15,%d13
8000e778:	6e 0a       	jz %d15,8000e78c <_dtoa_r+0x944>
8000e77a:	19 a3 14 00 	ld.w %d3,[%sp]20
8000e77e:	58 06       	ld.w %d15,[%sp]24
8000e780:	c2 13       	add %d3,1
8000e782:	c2 1f       	add %d15,1
8000e784:	59 a3 14 00 	st.w [%sp]20,%d3
8000e788:	78 06       	st.w [%sp]24,%d15
8000e78a:	82 19       	mov %d9,1
8000e78c:	19 a3 34 00 	ld.w %d3,[%sp]52
8000e790:	82 12       	mov %d2,1
8000e792:	76 39       	jz %d3,8000e7a4 <_dtoa_r+0x95c>
8000e794:	4c c4       	ld.w %d15,[%a12]16
8000e796:	90 c3       	addsc.a %a3,%a12,%d15,2
8000e798:	19 34 10 00 	ld.w %d4,[%a3]16
8000e79c:	6d 00 54 02 	call 8000ec44 <__hi0bits>
8000e7a0:	8b 02 02 21 	rsub %d2,%d2,32
8000e7a4:	58 06       	ld.w %d15,[%sp]24
8000e7a6:	42 2f       	add %d15,%d2
8000e7a8:	16 1f       	and %d15,31
8000e7aa:	6e 0a       	jz %d15,8000e7be <_dtoa_r+0x976>
8000e7ac:	8b 0f 02 31 	rsub %d3,%d15,32
8000e7b0:	8b cf 01 f1 	rsub %d15,%d15,28
8000e7b4:	ff 53 07 00 	jge %d3,5,8000e7c2 <_dtoa_r+0x97a>
8000e7b8:	df 43 10 00 	jeq %d3,4,8000e7d8 <_dtoa_r+0x990>
8000e7bc:	02 3f       	mov %d15,%d3
8000e7be:	1b cf 01 f0 	addi %d15,%d15,28
8000e7c2:	19 a2 14 00 	ld.w %d2,[%sp]20
8000e7c6:	19 a3 18 00 	ld.w %d3,[%sp]24
8000e7ca:	42 f2       	add %d2,%d15
8000e7cc:	42 f3       	add %d3,%d15
8000e7ce:	59 a2 14 00 	st.w [%sp]20,%d2
8000e7d2:	42 f8       	add %d8,%d15
8000e7d4:	59 a3 18 00 	st.w [%sp]24,%d3
8000e7d8:	58 05       	ld.w %d15,[%sp]20
8000e7da:	8e f7       	jlez %d15,8000e7e8 <_dtoa_r+0x9a0>
8000e7dc:	40 e5       	mov.aa %a5,%a14
8000e7de:	40 d4       	mov.aa %a4,%a13
8000e7e0:	02 f4       	mov %d4,%d15
8000e7e2:	6d 00 58 03 	call 8000ee92 <__lshift>
8000e7e6:	40 2e       	mov.aa %a14,%a2
8000e7e8:	19 a2 18 00 	ld.w %d2,[%sp]24
8000e7ec:	8e 27       	jlez %d2,8000e7fa <_dtoa_r+0x9b2>
8000e7ee:	40 c5       	mov.aa %a5,%a12
8000e7f0:	40 d4       	mov.aa %a4,%a13
8000e7f2:	02 24       	mov %d4,%d2
8000e7f4:	6d 00 4f 03 	call 8000ee92 <__lshift>
8000e7f8:	40 2c       	mov.aa %a12,%a2
8000e7fa:	19 a3 3c 00 	ld.w %d3,[%sp]60
8000e7fe:	df 03 20 00 	jeq %d3,0,8000e83e <_dtoa_r+0x9f6>
8000e802:	40 e4       	mov.aa %a4,%a14
8000e804:	40 c5       	mov.aa %a5,%a12
8000e806:	6d 00 a3 03 	call 8000ef4c <__mcmp>
8000e80a:	ff 02 1a 00 	jge %d2,0,8000e83e <_dtoa_r+0x9f6>
8000e80e:	58 02       	ld.w %d15,[%sp]8
8000e810:	40 e5       	mov.aa %a5,%a14
8000e812:	c2 ff       	add %d15,-1
8000e814:	40 d4       	mov.aa %a4,%a13
8000e816:	fb a0 00 40 	mov %e4,10
8000e81a:	78 02       	st.w [%sp]8,%d15
8000e81c:	6d 00 d3 01 	call 8000ebc2 <__multadd>
8000e820:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000e824:	19 a3 24 00 	ld.w %d3,[%sp]36
8000e828:	59 a2 10 00 	st.w [%sp]16,%d2
8000e82c:	40 2e       	mov.aa %a14,%a2
8000e82e:	76 38       	jz %d3,8000e83e <_dtoa_r+0x9f6>
8000e830:	40 f5       	mov.aa %a5,%a15
8000e832:	40 d4       	mov.aa %a4,%a13
8000e834:	fb a0 00 40 	mov %e4,10
8000e838:	6d 00 c5 01 	call 8000ebc2 <__multadd>
8000e83c:	40 2f       	mov.aa %a15,%a2
8000e83e:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e842:	19 a3 10 00 	ld.w %d3,[%sp]16
8000e846:	8b 32 80 f2 	ge %d15,%d2,3
8000e84a:	8b 13 40 f4 	and.lt %d15,%d3,1
8000e84e:	6e 2a       	jz %d15,8000e8a2 <_dtoa_r+0xa5a>
8000e850:	f6 3f       	jnz %d3,8000e86e <_dtoa_r+0xa26>
8000e852:	40 c5       	mov.aa %a5,%a12
8000e854:	40 d4       	mov.aa %a4,%a13
8000e856:	d2 54       	mov %e4,5
8000e858:	6d 00 b5 01 	call 8000ebc2 <__multadd>
8000e85c:	40 e4       	mov.aa %a4,%a14
8000e85e:	40 25       	mov.aa %a5,%a2
8000e860:	40 2c       	mov.aa %a12,%a2
8000e862:	6d 00 75 03 	call 8000ef4c <__mcmp>
8000e866:	4e 2e       	jgtz %d2,8000e882 <_dtoa_r+0xa3a>
8000e868:	3c 03       	j 8000e86e <_dtoa_r+0xa26>
8000e86a:	a0 0c       	mov.a %a12,0
8000e86c:	a0 0f       	mov.a %a15,0
8000e86e:	58 0a       	ld.w %d15,[%sp]40
8000e870:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000e874:	46 0f       	not %d15
8000e876:	78 02       	st.w [%sp]8,%d15
8000e878:	3c 11       	j 8000e89a <_dtoa_r+0xa52>
8000e87a:	58 0c       	ld.w %d15,[%sp]48
8000e87c:	a0 0c       	mov.a %a12,0
8000e87e:	78 02       	st.w [%sp]8,%d15
8000e880:	a0 0f       	mov.a %a15,0
8000e882:	19 a2 08 00 	ld.w %d2,[%sp]8
8000e886:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000e88a:	19 ae 0c 00 	ld.w %d14,[%sp]12
8000e88e:	da 31       	mov %d15,49
8000e890:	c2 12       	add %d2,1
8000e892:	c2 1e       	add %d14,1
8000e894:	2c 30       	st.b [%a3]0,%d15
8000e896:	59 a2 08 00 	st.w [%sp]8,%d2
8000e89a:	80 f8       	mov.d %d8,%a15
8000e89c:	a0 0f       	mov.a %a15,0
8000e89e:	1d 00 14 01 	j 8000eac6 <_dtoa_r+0xc7e>
8000e8a2:	19 a3 24 00 	ld.w %d3,[%sp]36
8000e8a6:	f6 35       	jnz %d3,8000e8b0 <_dtoa_r+0xa68>
8000e8a8:	19 a8 0c 00 	ld.w %d8,[%sp]12
8000e8ac:	1d 00 c2 00 	j 8000ea30 <_dtoa_r+0xbe8>
8000e8b0:	8e 87       	jlez %d8,8000e8be <_dtoa_r+0xa76>
8000e8b2:	40 f5       	mov.aa %a5,%a15
8000e8b4:	40 d4       	mov.aa %a4,%a13
8000e8b6:	02 84       	mov %d4,%d8
8000e8b8:	6d 00 ed 02 	call 8000ee92 <__lshift>
8000e8bc:	40 2f       	mov.aa %a15,%a2
8000e8be:	80 f8       	mov.d %d8,%a15
8000e8c0:	df 09 16 00 	jeq %d9,0,8000e8ec <_dtoa_r+0xaa4>
8000e8c4:	40 d4       	mov.aa %a4,%a13
8000e8c6:	48 14       	ld.w %d4,[%a15]4
8000e8c8:	6d 00 49 01 	call 8000eb5a <_Balloc>
8000e8cc:	48 44       	ld.w %d4,[%a15]16
8000e8ce:	d9 24 0c 00 	lea %a4,[%a2]12
8000e8d2:	c2 24       	add %d4,2
8000e8d4:	d9 f5 0c 00 	lea %a5,[%a15]12
8000e8d8:	06 24       	sh %d4,2
8000e8da:	80 2f       	mov.d %d15,%a2
8000e8dc:	6d 00 31 01 	call 8000eb3e <memcpy>
8000e8e0:	60 f5       	mov.a %a5,%d15
8000e8e2:	40 d4       	mov.aa %a4,%a13
8000e8e4:	82 14       	mov %d4,1
8000e8e6:	6d 00 d6 02 	call 8000ee92 <__lshift>
8000e8ea:	80 28       	mov.d %d8,%a2
8000e8ec:	19 a9 0c 00 	ld.w %d9,[%sp]12
8000e8f0:	8f 1c 00 a1 	and %d10,%d12,1
8000e8f4:	40 e4       	mov.aa %a4,%a14
8000e8f6:	40 c5       	mov.aa %a5,%a12
8000e8f8:	6d ff 1a fa 	call 8000dd2c <quorem>
8000e8fc:	40 e4       	mov.aa %a4,%a14
8000e8fe:	40 f5       	mov.aa %a5,%a15
8000e900:	02 2e       	mov %d14,%d2
8000e902:	1b 02 03 f0 	addi %d15,%d2,48
8000e906:	6d 00 23 03 	call 8000ef4c <__mcmp>
8000e90a:	60 86       	mov.a %a6,%d8
8000e90c:	40 d4       	mov.aa %a4,%a13
8000e90e:	40 c5       	mov.aa %a5,%a12
8000e910:	02 2b       	mov %d11,%d2
8000e912:	6d 00 3e 03 	call 8000ef8e <__mdiff>
8000e916:	19 22 0c 00 	ld.w %d2,[%a2]12
8000e91a:	80 2d       	mov.d %d13,%a2
8000e91c:	82 1c       	mov %d12,1
8000e91e:	f6 26       	jnz %d2,8000e92a <_dtoa_r+0xae2>
8000e920:	40 e4       	mov.aa %a4,%a14
8000e922:	40 25       	mov.aa %a5,%a2
8000e924:	6d 00 14 03 	call 8000ef4c <__mcmp>
8000e928:	02 2c       	mov %d12,%d2
8000e92a:	60 d5       	mov.a %a5,%d13
8000e92c:	40 d4       	mov.aa %a4,%a13
8000e92e:	6d 00 41 01 	call 8000ebb0 <_Bfree>
8000e932:	19 a3 1c 00 	ld.w %d3,[%sp]28
8000e936:	1b 19 00 d0 	addi %d13,%d9,1
8000e93a:	a6 c3       	or %d3,%d12
8000e93c:	f6 3f       	jnz %d3,8000e95a <_dtoa_r+0xb12>
8000e93e:	f6 ae       	jnz %d10,8000e95a <_dtoa_r+0xb12>
8000e940:	8b 9f 03 32 	eq %d3,%d15,57
8000e944:	40 e2       	mov.aa %a2,%a14
8000e946:	df 03 3a 80 	jne %d3,0,8000e9ba <_dtoa_r+0xb72>
8000e94a:	1b 1e 03 20 	addi %d2,%d14,49
8000e94e:	8b 1b 80 b2 	ge %d11,%d11,1
8000e952:	2b f2 40 fb 	sel %d15,%d11,%d2,%d15
8000e956:	02 de       	mov %d14,%d13
8000e958:	3c 37       	j 8000e9c6 <_dtoa_r+0xb7e>
8000e95a:	ce b5       	jgez %d11,8000e964 <_dtoa_r+0xb1c>
8000e95c:	02 fa       	mov %d10,%d15
8000e95e:	40 e2       	mov.aa %a2,%a14
8000e960:	4e ca       	jgtz %d12,8000e974 <_dtoa_r+0xb2c>
8000e962:	3c 1e       	j 8000e99e <_dtoa_r+0xb56>
8000e964:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000e968:	a6 2b       	or %d11,%d2
8000e96a:	df 0b 20 80 	jne %d11,0,8000e9aa <_dtoa_r+0xb62>
8000e96e:	df 0a 1e 80 	jne %d10,0,8000e9aa <_dtoa_r+0xb62>
8000e972:	3c f5       	j 8000e95c <_dtoa_r+0xb14>
8000e974:	40 d4       	mov.aa %a4,%a13
8000e976:	40 e5       	mov.aa %a5,%a14
8000e978:	82 14       	mov %d4,1
8000e97a:	6d 00 8c 02 	call 8000ee92 <__lshift>
8000e97e:	40 c5       	mov.aa %a5,%a12
8000e980:	40 24       	mov.aa %a4,%a2
8000e982:	b5 a2 04 00 	st.a [%sp]4,%a2
8000e986:	6d 00 e3 02 	call 8000ef4c <__mcmp>
8000e98a:	99 a2 04 00 	ld.a %a2,[%sp]4
8000e98e:	4e 23       	jgtz %d2,8000e994 <_dtoa_r+0xb4c>
8000e990:	f6 27       	jnz %d2,8000e99e <_dtoa_r+0xb56>
8000e992:	2e 06       	jz.t %d15,0,8000e99e <_dtoa_r+0xb56>
8000e994:	8b 9f 03 32 	eq %d3,%d15,57
8000e998:	df 03 11 80 	jne %d3,0,8000e9ba <_dtoa_r+0xb72>
8000e99c:	92 1a       	add %d10,%d15,1
8000e99e:	60 93       	mov.a %a3,%d9
8000e9a0:	02 de       	mov %d14,%d13
8000e9a2:	34 3a       	st.b [%a3],%d10
8000e9a4:	40 2e       	mov.aa %a14,%a2
8000e9a6:	1d 00 90 00 	j 8000eac6 <_dtoa_r+0xc7e>
8000e9aa:	bf 1c 11 00 	jlt %d12,1,8000e9cc <_dtoa_r+0xb84>
8000e9ae:	8b 9f 23 32 	ne %d3,%d15,57
8000e9b2:	40 e2       	mov.aa %a2,%a14
8000e9b4:	02 de       	mov %d14,%d13
8000e9b6:	c2 1f       	add %d15,1
8000e9b8:	f6 37       	jnz %d3,8000e9c6 <_dtoa_r+0xb7e>
8000e9ba:	60 93       	mov.a %a3,%d9
8000e9bc:	da 39       	mov %d15,57
8000e9be:	02 de       	mov %d14,%d13
8000e9c0:	2c 30       	st.b [%a3]0,%d15
8000e9c2:	40 2e       	mov.aa %a14,%a2
8000e9c4:	3c 5d       	j 8000ea7e <_dtoa_r+0xc36>
8000e9c6:	60 92       	mov.a %a2,%d9
8000e9c8:	2c 20       	st.b [%a2]0,%d15
8000e9ca:	3c 7e       	j 8000eac6 <_dtoa_r+0xc7e>
8000e9cc:	60 93       	mov.a %a3,%d9
8000e9ce:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000e9d2:	02 d5       	mov %d5,%d13
8000e9d4:	19 a3 10 00 	ld.w %d3,[%sp]16
8000e9d8:	2c 30       	st.b [%a3]0,%d15
8000e9da:	a2 25       	sub %d5,%d2
8000e9dc:	02 de       	mov %d14,%d13
8000e9de:	5f 35 41 00 	jeq %d5,%d3,8000ea60 <_dtoa_r+0xc18>
8000e9e2:	40 e5       	mov.aa %a5,%a14
8000e9e4:	40 d4       	mov.aa %a4,%a13
8000e9e6:	fb a0 00 40 	mov %e4,10
8000e9ea:	6d 00 ec 00 	call 8000ebc2 <__multadd>
8000e9ee:	80 ff       	mov.d %d15,%a15
8000e9f0:	40 2e       	mov.aa %a14,%a2
8000e9f2:	40 d4       	mov.aa %a4,%a13
8000e9f4:	40 f5       	mov.aa %a5,%a15
8000e9f6:	fb a0 00 40 	mov %e4,10
8000e9fa:	7e 86       	jne %d15,%d8,8000ea06 <_dtoa_r+0xbbe>
8000e9fc:	6d 00 e3 00 	call 8000ebc2 <__multadd>
8000ea00:	40 2f       	mov.aa %a15,%a2
8000ea02:	80 28       	mov.d %d8,%a2
8000ea04:	3c 0b       	j 8000ea1a <_dtoa_r+0xbd2>
8000ea06:	6d 00 de 00 	call 8000ebc2 <__multadd>
8000ea0a:	60 85       	mov.a %a5,%d8
8000ea0c:	40 d4       	mov.aa %a4,%a13
8000ea0e:	fb a0 00 40 	mov %e4,10
8000ea12:	40 2f       	mov.aa %a15,%a2
8000ea14:	6d 00 d7 00 	call 8000ebc2 <__multadd>
8000ea18:	80 28       	mov.d %d8,%a2
8000ea1a:	02 d9       	mov %d9,%d13
8000ea1c:	1d ff 6c ff 	j 8000e8f4 <_dtoa_r+0xaac>
8000ea20:	40 e5       	mov.aa %a5,%a14
8000ea22:	40 d4       	mov.aa %a4,%a13
8000ea24:	fb a0 00 40 	mov %e4,10
8000ea28:	6d 00 cd 00 	call 8000ebc2 <__multadd>
8000ea2c:	02 98       	mov %d8,%d9
8000ea2e:	40 2e       	mov.aa %a14,%a2
8000ea30:	40 e4       	mov.aa %a4,%a14
8000ea32:	40 c5       	mov.aa %a5,%a12
8000ea34:	6d ff 7c f9 	call 8000dd2c <quorem>
8000ea38:	1b 18 00 90 	addi %d9,%d8,1
8000ea3c:	1b 02 03 f0 	addi %d15,%d2,48
8000ea40:	60 82       	mov.a %a2,%d8
8000ea42:	19 a2 0c 00 	ld.w %d2,[%sp]12
8000ea46:	02 95       	mov %d5,%d9
8000ea48:	19 a3 10 00 	ld.w %d3,[%sp]16
8000ea4c:	2c 20       	st.b [%a2]0,%d15
8000ea4e:	a2 25       	sub %d5,%d2
8000ea50:	3f 35 e8 7f 	jlt %d5,%d3,8000ea20 <_dtoa_r+0xbd8>
8000ea54:	8b 13 40 33 	max %d3,%d3,1
8000ea58:	02 2e       	mov %d14,%d2
8000ea5a:	80 f8       	mov.d %d8,%a15
8000ea5c:	42 3e       	add %d14,%d3
8000ea5e:	a0 0f       	mov.a %a15,0
8000ea60:	40 e5       	mov.aa %a5,%a14
8000ea62:	40 d4       	mov.aa %a4,%a13
8000ea64:	82 14       	mov %d4,1
8000ea66:	6d 00 16 02 	call 8000ee92 <__lshift>
8000ea6a:	40 c5       	mov.aa %a5,%a12
8000ea6c:	40 2e       	mov.aa %a14,%a2
8000ea6e:	40 24       	mov.aa %a4,%a2
8000ea70:	6d 00 6e 02 	call 8000ef4c <__mcmp>
8000ea74:	4e 25       	jgtz %d2,8000ea7e <_dtoa_r+0xc36>
8000ea76:	df 02 1e 80 	jne %d2,0,8000eab2 <_dtoa_r+0xc6a>
8000ea7a:	6f 0f 1c 00 	jz.t %d15,0,8000eab2 <_dtoa_r+0xc6a>
8000ea7e:	58 03       	ld.w %d15,[%sp]12
8000ea80:	a2 ef       	sub %d15,%d14
8000ea82:	46 0f       	not %d15
8000ea84:	60 e2       	mov.a %a2,%d14
8000ea86:	60 e3       	mov.a %a3,%d14
8000ea88:	79 23 ff ff 	ld.b %d3,[%a2]-1
8000ea8c:	b0 f3       	add.a %a3,-1
8000ea8e:	8b 93 03 52 	eq %d5,%d3,57
8000ea92:	76 5d       	jz %d5,8000eaac <_dtoa_r+0xc64>
8000ea94:	9f 0f 0a 80 	jned %d15,0,8000eaa8 <_dtoa_r+0xc60>
8000ea98:	58 02       	ld.w %d15,[%sp]8
8000ea9a:	99 a3 0c 00 	ld.a %a3,[%sp]12
8000ea9e:	c2 1f       	add %d15,1
8000eaa0:	78 02       	st.w [%sp]8,%d15
8000eaa2:	da 31       	mov %d15,49
8000eaa4:	2c 30       	st.b [%a3]0,%d15
8000eaa6:	3c 10       	j 8000eac6 <_dtoa_r+0xc7e>
8000eaa8:	80 3e       	mov.d %d14,%a3
8000eaaa:	3c ed       	j 8000ea84 <_dtoa_r+0xc3c>
8000eaac:	c2 13       	add %d3,1
8000eaae:	34 33       	st.b [%a3],%d3
8000eab0:	3c 0b       	j 8000eac6 <_dtoa_r+0xc7e>
8000eab2:	60 e2       	mov.a %a2,%d14
8000eab4:	60 e3       	mov.a %a3,%d14
8000eab6:	79 2f ff ff 	ld.b %d15,[%a2]-1
8000eaba:	b0 f3       	add.a %a3,-1
8000eabc:	8b 0f 03 f2 	eq %d15,%d15,48
8000eac0:	6e 03       	jz %d15,8000eac6 <_dtoa_r+0xc7e>
8000eac2:	80 3e       	mov.d %d14,%a3
8000eac4:	3c f7       	j 8000eab2 <_dtoa_r+0xc6a>
8000eac6:	40 d4       	mov.aa %a4,%a13
8000eac8:	40 c5       	mov.aa %a5,%a12
8000eaca:	6d 00 73 00 	call 8000ebb0 <_Bfree>
8000eace:	df 08 13 00 	jeq %d8,0,8000eaf4 <_dtoa_r+0xcac>
8000ead2:	80 f2       	mov.d %d2,%a15
8000ead4:	8b 02 20 f2 	ne %d15,%d2,0
8000ead8:	0b 82 10 f2 	and.ne %d15,%d2,%d8
8000eadc:	6e 05       	jz %d15,8000eae6 <_dtoa_r+0xc9e>
8000eade:	40 d4       	mov.aa %a4,%a13
8000eae0:	40 f5       	mov.aa %a5,%a15
8000eae2:	6d 00 67 00 	call 8000ebb0 <_Bfree>
8000eae6:	60 85       	mov.a %a5,%d8
8000eae8:	40 d4       	mov.aa %a4,%a13
8000eaea:	6d 00 63 00 	call 8000ebb0 <_Bfree>
8000eaee:	3c 03       	j 8000eaf4 <_dtoa_r+0xcac>
8000eaf0:	58 0c       	ld.w %d15,[%sp]48
8000eaf2:	78 02       	st.w [%sp]8,%d15
8000eaf4:	40 d4       	mov.aa %a4,%a13
8000eaf6:	40 e5       	mov.aa %a5,%a14
8000eaf8:	6d 00 5c 00 	call 8000ebb0 <_Bfree>
8000eafc:	60 e2       	mov.a %a2,%d14
8000eafe:	19 a2 08 00 	ld.w %d2,[%sp]8
8000eb02:	99 a3 08 10 	ld.a %a3,[%sp]72
8000eb06:	82 0f       	mov %d15,0
8000eb08:	d8 0e       	ld.a %a15,[%sp]56
8000eb0a:	2c 20       	st.b [%a2]0,%d15
8000eb0c:	c2 12       	add %d2,1
8000eb0e:	74 32       	st.w [%a3],%d2
8000eb10:	99 a2 0c 00 	ld.a %a2,[%sp]12
8000eb14:	bc f2       	jz.a %a15,8000eb18 <_dtoa_r+0xcd0>
8000eb16:	68 0e       	st.w [%a15]0,%d14
8000eb18:	00 90       	ret 
	...

8000eb1c <_localeconv_r>:
8000eb1c:	91 00 00 28 	movh.a %a2,32768
8000eb20:	d9 22 0c 11 	lea %a2,[%a2]4172 <8000104c <lconv>>
8000eb24:	00 90       	ret 

8000eb26 <memchr>:
8000eb26:	8f f4 0f 41 	and %d4,%d4,255
8000eb2a:	9f 05 04 80 	jned %d5,0,8000eb32 <memchr+0xc>
8000eb2e:	a0 02       	mov.a %a2,0
8000eb30:	00 90       	ret 
8000eb32:	0c 40       	ld.bu %d15,[%a4]0
8000eb34:	3e 43       	jeq %d15,%d4,8000eb3a <memchr+0x14>
8000eb36:	b0 14       	add.a %a4,1
8000eb38:	3c f9       	j 8000eb2a <memchr+0x4>
8000eb3a:	40 42       	mov.aa %a2,%a4
8000eb3c:	00 90       	ret 

8000eb3e <memcpy>:
8000eb3e:	40 42       	mov.aa %a2,%a4
8000eb40:	a0 0f       	mov.a %a15,0
8000eb42:	01 f2 10 40 	add.a %a4,%a2,%a15
8000eb46:	01 f5 10 30 	add.a %a3,%a5,%a15
8000eb4a:	9f 04 03 80 	jned %d4,0,8000eb50 <memcpy+0x12>
8000eb4e:	00 90       	ret 
8000eb50:	79 3f 00 00 	ld.b %d15,[%a3]0
8000eb54:	b0 1f       	add.a %a15,1
8000eb56:	2c 40       	st.b [%a4]0,%d15
8000eb58:	3c f5       	j 8000eb42 <memcpy+0x4>

8000eb5a <_Balloc>:
8000eb5a:	19 42 0c 10 	ld.w %d2,[%a4]76
8000eb5e:	40 4f       	mov.aa %a15,%a4
8000eb60:	02 4f       	mov %d15,%d4
8000eb62:	76 29       	jz %d2,8000eb74 <_Balloc+0x1a>
8000eb64:	99 f3 0c 10 	ld.a %a3,[%a15]76
8000eb68:	90 33       	addsc.a %a3,%a3,%d15,2
8000eb6a:	d4 32       	ld.a %a2,[%a3]
8000eb6c:	bc 2f       	jz.a %a2,8000eb8a <_Balloc+0x30>
8000eb6e:	4c 20       	ld.w %d15,[%a2]0
8000eb70:	6c 30       	st.w [%a3]0,%d15
8000eb72:	3c 1b       	j 8000eba8 <_Balloc+0x4e>
8000eb74:	82 44       	mov %d4,4
8000eb76:	3b 10 02 50 	mov %d5,33
8000eb7a:	6d 00 5c 03 	call 8000f232 <_calloc_r>
8000eb7e:	b5 f2 0c 10 	st.a [%a15]76,%a2
8000eb82:	bd 02 f1 ff 	jnz.a %a2,8000eb64 <_Balloc+0xa>
8000eb86:	a0 02       	mov.a %a2,0
8000eb88:	00 90       	ret 
8000eb8a:	82 18       	mov %d8,1
8000eb8c:	0f f8 00 80 	sh %d8,%d8,%d15
8000eb90:	1b 58 00 50 	addi %d5,%d8,5
8000eb94:	40 f4       	mov.aa %a4,%a15
8000eb96:	82 14       	mov %d4,1
8000eb98:	06 25       	sh %d5,2
8000eb9a:	6d 00 4c 03 	call 8000f232 <_calloc_r>
8000eb9e:	bd 02 f4 7f 	jz.a %a2,8000eb86 <_Balloc+0x2c>
8000eba2:	6c 21       	st.w [%a2]4,%d15
8000eba4:	59 28 08 00 	st.w [%a2]8,%d8
8000eba8:	82 0f       	mov %d15,0
8000ebaa:	6c 24       	st.w [%a2]16,%d15
8000ebac:	6c 23       	st.w [%a2]12,%d15
8000ebae:	00 90       	ret 

8000ebb0 <_Bfree>:
8000ebb0:	bc 58       	jz.a %a5,8000ebc0 <_Bfree+0x10>
8000ebb2:	99 4f 0c 10 	ld.a %a15,[%a4]76
8000ebb6:	4c 51       	ld.w %d15,[%a5]4
8000ebb8:	90 ff       	addsc.a %a15,%a15,%d15,2
8000ebba:	4c f0       	ld.w %d15,[%a15]0
8000ebbc:	6c 50       	st.w [%a5]0,%d15
8000ebbe:	e8 05       	st.a [%a15]0,%a5
8000ebc0:	00 90       	ret 

8000ebc2 <__multadd>:
8000ebc2:	19 59 10 00 	ld.w %d9,[%a5]16
8000ebc6:	40 4c       	mov.aa %a12,%a4
8000ebc8:	9a f9       	add %d15,%d9,-1
8000ebca:	8b 19 80 22 	ge %d2,%d9,1
8000ebce:	40 5f       	mov.aa %a15,%a5
8000ebd0:	02 58       	mov %d8,%d5
8000ebd2:	d9 53 14 00 	lea %a3,[%a5]20
8000ebd6:	ab 0f 80 22 	sel %d2,%d2,%d15,0
8000ebda:	40 32       	mov.aa %a2,%a3
8000ebdc:	44 25       	ld.w %d5,[%a2+]
8000ebde:	b7 05 10 38 	insert %d3,%d5,0,16,16
8000ebe2:	8f 05 1f f0 	sh %d15,%d5,-16
8000ebe6:	03 43 0a 38 	madd %d3,%d8,%d3,%d4
8000ebea:	8f 03 1f 60 	sh %d6,%d3,-16
8000ebee:	03 4f 0a f6 	madd %d15,%d6,%d15,%d4
8000ebf2:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000ebf6:	8f 0f 1f 80 	sh %d8,%d15,-16
8000ebfa:	74 33       	st.w [%a3],%d3
8000ebfc:	40 23       	mov.aa %a3,%a2
8000ebfe:	9f 02 ee ff 	jned %d2,0,8000ebda <__multadd+0x18>
8000ec02:	df 08 1f 00 	jeq %d8,0,8000ec40 <__multadd+0x7e>
8000ec06:	4c f2       	ld.w %d15,[%a15]8
8000ec08:	3f f9 16 00 	jlt %d9,%d15,8000ec34 <__multadd+0x72>
8000ec0c:	48 14       	ld.w %d4,[%a15]4
8000ec0e:	40 c4       	mov.aa %a4,%a12
8000ec10:	c2 14       	add %d4,1
8000ec12:	6d ff a4 ff 	call 8000eb5a <_Balloc>
8000ec16:	48 44       	ld.w %d4,[%a15]16
8000ec18:	d9 f5 0c 00 	lea %a5,[%a15]12
8000ec1c:	c2 24       	add %d4,2
8000ec1e:	d9 24 0c 00 	lea %a4,[%a2]12
8000ec22:	06 24       	sh %d4,2
8000ec24:	40 2d       	mov.aa %a13,%a2
8000ec26:	6d ff 8c ff 	call 8000eb3e <memcpy>
8000ec2a:	40 f5       	mov.aa %a5,%a15
8000ec2c:	40 c4       	mov.aa %a4,%a12
8000ec2e:	6d ff c1 ff 	call 8000ebb0 <_Bfree>
8000ec32:	40 df       	mov.aa %a15,%a13
8000ec34:	01 f9 02 26 	addsc.a %a2,%a15,%d9,2
8000ec38:	c2 19       	add %d9,1
8000ec3a:	59 28 14 00 	st.w [%a2]20,%d8
8000ec3e:	68 49       	st.w [%a15]16,%d9
8000ec40:	40 f2       	mov.aa %a2,%a15
8000ec42:	00 90       	ret 

8000ec44 <__hi0bits>:
8000ec44:	b7 04 10 f0 	insert %d15,%d4,0,0,16
8000ec48:	82 02       	mov %d2,0
8000ec4a:	ee 05       	jnz %d15,8000ec54 <__hi0bits+0x10>
8000ec4c:	8f 04 01 40 	sh %d4,%d4,16
8000ec50:	3b 00 01 20 	mov %d2,16
8000ec54:	b7 04 18 f0 	insert %d15,%d4,0,0,24
8000ec58:	ee 05       	jnz %d15,8000ec62 <__hi0bits+0x1e>
8000ec5a:	1b 82 00 20 	addi %d2,%d2,8
8000ec5e:	8f 84 00 40 	sh %d4,%d4,8
8000ec62:	b7 04 1c f0 	insert %d15,%d4,0,0,28
8000ec66:	ee 03       	jnz %d15,8000ec6c <__hi0bits+0x28>
8000ec68:	c2 42       	add %d2,4
8000ec6a:	06 44       	sh %d4,4
8000ec6c:	b7 04 1e f0 	insert %d15,%d4,0,0,30
8000ec70:	ee 03       	jnz %d15,8000ec76 <__hi0bits+0x32>
8000ec72:	c2 22       	add %d2,2
8000ec74:	06 24       	sh %d4,2
8000ec76:	0e 47       	jltz %d4,8000ec84 <__hi0bits+0x40>
8000ec78:	7b 00 00 f4 	movh %d15,16384
8000ec7c:	26 f4       	and %d4,%d15
8000ec7e:	c2 12       	add %d2,1
8000ec80:	ab 02 82 24 	sel %d2,%d4,%d2,32
8000ec84:	00 90       	ret 

8000ec86 <__lo0bits>:
8000ec86:	54 43       	ld.w %d3,[%a4]
8000ec88:	8f 73 00 f1 	and %d15,%d3,7
8000ec8c:	6e 0e       	jz %d15,8000eca8 <__lo0bits+0x22>
8000ec8e:	82 02       	mov %d2,0
8000ec90:	6f 03 2d 80 	jnz.t %d3,0,8000ecea <__lo0bits+0x64>
8000ec94:	6f 13 06 00 	jz.t %d3,1,8000eca0 <__lo0bits+0x1a>
8000ec98:	06 f3       	sh %d3,-1
8000ec9a:	74 43       	st.w [%a4],%d3
8000ec9c:	82 12       	mov %d2,1
8000ec9e:	00 90       	ret 
8000eca0:	06 e3       	sh %d3,-2
8000eca2:	74 43       	st.w [%a4],%d3
8000eca4:	82 22       	mov %d2,2
8000eca6:	00 90       	ret 
8000eca8:	b7 03 10 f8 	insert %d15,%d3,0,16,16
8000ecac:	82 04       	mov %d4,0
8000ecae:	ee 05       	jnz %d15,8000ecb8 <__lo0bits+0x32>
8000ecb0:	8f 03 1f 30 	sh %d3,%d3,-16
8000ecb4:	3b 00 01 40 	mov %d4,16
8000ecb8:	02 3f       	mov %d15,%d3
8000ecba:	16 ff       	and %d15,255
8000ecbc:	ee 04       	jnz %d15,8000ecc4 <__lo0bits+0x3e>
8000ecbe:	1b 84 00 40 	addi %d4,%d4,8
8000ecc2:	06 83       	sh %d3,-8
8000ecc4:	8f f3 00 f1 	and %d15,%d3,15
8000ecc8:	ee 03       	jnz %d15,8000ecce <__lo0bits+0x48>
8000ecca:	c2 44       	add %d4,4
8000eccc:	06 c3       	sh %d3,-4
8000ecce:	8f 33 00 f1 	and %d15,%d3,3
8000ecd2:	ee 03       	jnz %d15,8000ecd8 <__lo0bits+0x52>
8000ecd4:	c2 24       	add %d4,2
8000ecd6:	06 e3       	sh %d3,-2
8000ecd8:	6f 03 07 80 	jnz.t %d3,0,8000ece6 <__lo0bits+0x60>
8000ecdc:	06 f3       	sh %d3,-1
8000ecde:	3b 00 02 20 	mov %d2,32
8000ece2:	76 34       	jz %d3,8000ecea <__lo0bits+0x64>
8000ece4:	c2 14       	add %d4,1
8000ece6:	74 43       	st.w [%a4],%d3
8000ece8:	02 42       	mov %d2,%d4
8000ecea:	00 90       	ret 

8000ecec <__i2b>:
8000ecec:	02 4f       	mov %d15,%d4
8000ecee:	82 14       	mov %d4,1
8000ecf0:	6d ff 35 ff 	call 8000eb5a <_Balloc>
8000ecf4:	6c 25       	st.w [%a2]20,%d15
8000ecf6:	82 1f       	mov %d15,1
8000ecf8:	6c 24       	st.w [%a2]16,%d15
8000ecfa:	00 90       	ret 

8000ecfc <__multiply>:
8000ecfc:	19 52 10 00 	ld.w %d2,[%a5]16
8000ed00:	4c 64       	ld.w %d15,[%a6]16
8000ed02:	40 5f       	mov.aa %a15,%a5
8000ed04:	40 6c       	mov.aa %a12,%a6
8000ed06:	7f f2 04 00 	jge %d2,%d15,8000ed0e <__multiply+0x12>
8000ed0a:	40 6f       	mov.aa %a15,%a6
8000ed0c:	40 5c       	mov.aa %a12,%a5
8000ed0e:	48 4a       	ld.w %d10,[%a15]16
8000ed10:	19 c9 10 00 	ld.w %d9,[%a12]16
8000ed14:	4c f2       	ld.w %d15,[%a15]8
8000ed16:	0b 9a 00 80 	add %d8,%d10,%d9
8000ed1a:	48 12       	ld.w %d2,[%a15]4
8000ed1c:	0b 8f 20 41 	lt %d4,%d15,%d8
8000ed20:	42 24       	add %d4,%d2
8000ed22:	6d ff 1c ff 	call 8000eb5a <_Balloc>
8000ed26:	d9 23 14 00 	lea %a3,[%a2]20
8000ed2a:	01 38 02 d6 	addsc.a %a13,%a3,%d8,2
8000ed2e:	40 34       	mov.aa %a4,%a3
8000ed30:	82 0f       	mov %d15,0
8000ed32:	80 43       	mov.d %d3,%a4
8000ed34:	80 d2       	mov.d %d2,%a13
8000ed36:	7f 23 04 80 	jge.u %d3,%d2,8000ed3e <__multiply+0x42>
8000ed3a:	64 4f       	st.w [%a4+],%d15
8000ed3c:	3c fb       	j 8000ed32 <__multiply+0x36>
8000ed3e:	d9 ff 14 00 	lea %a15,[%a15]20
8000ed42:	d9 cc 14 00 	lea %a12,[%a12]20
8000ed46:	80 f3       	mov.d %d3,%a15
8000ed48:	80 cf       	mov.d %d15,%a12
8000ed4a:	13 4a 20 43 	madd %d4,%d3,%d10,4
8000ed4e:	13 49 20 0f 	madd %d0,%d15,%d9,4
8000ed52:	80 c2       	mov.d %d2,%a12
8000ed54:	7f 02 54 80 	jge.u %d2,%d0,8000edfc <__multiply+0x100>
8000ed58:	b9 c2 00 00 	ld.hu %d2,[%a12]0
8000ed5c:	40 34       	mov.aa %a4,%a3
8000ed5e:	40 f6       	mov.aa %a6,%a15
8000ed60:	82 03       	mov %d3,0
8000ed62:	df 02 21 00 	jeq %d2,0,8000eda4 <__multiply+0xa8>
8000ed66:	40 45       	mov.aa %a5,%a4
8000ed68:	44 67       	ld.w %d7,[%a6+]
8000ed6a:	44 56       	ld.w %d6,[%a5+]
8000ed6c:	b7 07 10 18 	insert %d1,%d7,0,16,16
8000ed70:	b7 06 10 58 	insert %d5,%d6,0,16,16
8000ed74:	8f 07 1f 70 	sh %d7,%d7,-16
8000ed78:	03 21 0a 55 	madd %d5,%d5,%d1,%d2
8000ed7c:	8f 06 1f 60 	sh %d6,%d6,-16
8000ed80:	03 27 0a 66 	madd %d6,%d6,%d7,%d2
8000ed84:	42 35       	add %d5,%d3
8000ed86:	8f 05 1f 30 	sh %d3,%d5,-16
8000ed8a:	1a 36       	add %d15,%d6,%d3
8000ed8c:	37 f5 10 58 	insert %d5,%d5,%d15,16,16
8000ed90:	8f 0f 1f 30 	sh %d3,%d15,-16
8000ed94:	80 6f       	mov.d %d15,%a6
8000ed96:	74 45       	st.w [%a4],%d5
8000ed98:	7f 4f 04 80 	jge.u %d15,%d4,8000eda0 <__multiply+0xa4>
8000ed9c:	40 54       	mov.aa %a4,%a5
8000ed9e:	3c e4       	j 8000ed66 <__multiply+0x6a>
8000eda0:	59 43 04 00 	st.w [%a4]4,%d3
8000eda4:	b9 c2 02 00 	ld.hu %d2,[%a12]2
8000eda8:	df 02 27 00 	jeq %d2,0,8000edf6 <__multiply+0xfa>
8000edac:	54 33       	ld.w %d3,[%a3]
8000edae:	40 34       	mov.aa %a4,%a3
8000edb0:	40 f5       	mov.aa %a5,%a15
8000edb2:	82 07       	mov %d7,0
8000edb4:	40 56       	mov.aa %a6,%a5
8000edb6:	44 66       	ld.w %d6,[%a6+]
8000edb8:	40 47       	mov.aa %a7,%a4
8000edba:	44 75       	ld.w %d5,[%a7+]
8000edbc:	b7 06 10 68 	insert %d6,%d6,0,16,16
8000edc0:	8f 05 1f 50 	sh %d5,%d5,-16
8000edc4:	03 26 0a f5 	madd %d15,%d5,%d6,%d2
8000edc8:	42 7f       	add %d15,%d7
8000edca:	37 f3 10 38 	insert %d3,%d3,%d15,16,16
8000edce:	8f 0f 1f f0 	sh %d15,%d15,-16
8000edd2:	74 43       	st.w [%a4],%d3
8000edd4:	b9 55 02 00 	ld.hu %d5,[%a5]2
8000edd8:	b9 43 04 00 	ld.hu %d3,[%a4]4
8000eddc:	40 65       	mov.aa %a5,%a6
8000edde:	03 25 0a 33 	madd %d3,%d3,%d5,%d2
8000ede2:	42 f3       	add %d3,%d15
8000ede4:	80 6f       	mov.d %d15,%a6
8000ede6:	8f 03 1f 70 	sh %d7,%d3,-16
8000edea:	7f 4f 04 80 	jge.u %d15,%d4,8000edf2 <__multiply+0xf6>
8000edee:	40 74       	mov.aa %a4,%a7
8000edf0:	3c e2       	j 8000edb4 <__multiply+0xb8>
8000edf2:	59 43 04 00 	st.w [%a4]4,%d3
8000edf6:	b0 4c       	add.a %a12,4
8000edf8:	b0 43       	add.a %a3,4
8000edfa:	3c ac       	j 8000ed52 <__multiply+0x56>
8000edfc:	8b 08 40 f3 	max %d15,%d8,0
8000ee00:	9f 0f 05 80 	jned %d15,0,8000ee0a <__multiply+0x10e>
8000ee04:	59 28 10 00 	st.w [%a2]16,%d8
8000ee08:	00 90       	ret 
8000ee0a:	09 d2 3c f5 	ld.w %d2,[+%a13]-4
8000ee0e:	df 02 fb ff 	jne %d2,0,8000ee04 <__multiply+0x108>
8000ee12:	c2 f8       	add %d8,-1
8000ee14:	3c f6       	j 8000ee00 <__multiply+0x104>

8000ee16 <__pow5mult>:
8000ee16:	8f 34 00 21 	and %d2,%d4,3
8000ee1a:	40 4c       	mov.aa %a12,%a4
8000ee1c:	40 5d       	mov.aa %a13,%a5
8000ee1e:	02 4f       	mov %d15,%d4
8000ee20:	76 2d       	jz %d2,8000ee3a <__pow5mult+0x24>
8000ee22:	91 00 00 f8 	movh.a %a15,32768
8000ee26:	d9 ff 04 21 	lea %a15,[%a15]4228 <80001084 <p05.2553>>
8000ee2a:	01 f2 02 f6 	addsc.a %a15,%a15,%d2,2
8000ee2e:	82 05       	mov %d5,0
8000ee30:	19 f4 fc ff 	ld.w %d4,[%a15]-4
8000ee34:	6d ff c7 fe 	call 8000ebc2 <__multadd>
8000ee38:	40 2d       	mov.aa %a13,%a2
8000ee3a:	86 ef       	sha %d15,-2
8000ee3c:	6e 29       	jz %d15,8000ee8e <__pow5mult+0x78>
8000ee3e:	99 cf 08 10 	ld.a %a15,[%a12]72
8000ee42:	7c fb       	jnz.a %a15,8000ee58 <__pow5mult+0x42>
8000ee44:	40 c4       	mov.aa %a4,%a12
8000ee46:	3b 10 27 40 	mov %d4,625
8000ee4a:	6d ff 51 ff 	call 8000ecec <__i2b>
8000ee4e:	82 02       	mov %d2,0
8000ee50:	b5 c2 08 10 	st.a [%a12]72,%a2
8000ee54:	40 2f       	mov.aa %a15,%a2
8000ee56:	74 22       	st.w [%a2],%d2
8000ee58:	82 08       	mov %d8,0
8000ee5a:	2e 0c       	jz.t %d15,0,8000ee72 <__pow5mult+0x5c>
8000ee5c:	40 d5       	mov.aa %a5,%a13
8000ee5e:	40 c4       	mov.aa %a4,%a12
8000ee60:	40 f6       	mov.aa %a6,%a15
8000ee62:	6d ff 4d ff 	call 8000ecfc <__multiply>
8000ee66:	40 d5       	mov.aa %a5,%a13
8000ee68:	40 2e       	mov.aa %a14,%a2
8000ee6a:	40 c4       	mov.aa %a4,%a12
8000ee6c:	6d ff a2 fe 	call 8000ebb0 <_Bfree>
8000ee70:	40 ed       	mov.aa %a13,%a14
8000ee72:	86 ff       	sha %d15,-1
8000ee74:	6e 0d       	jz %d15,8000ee8e <__pow5mult+0x78>
8000ee76:	c8 02       	ld.a %a2,[%a15]0
8000ee78:	bc 23       	jz.a %a2,8000ee7e <__pow5mult+0x68>
8000ee7a:	40 2f       	mov.aa %a15,%a2
8000ee7c:	3c ef       	j 8000ee5a <__pow5mult+0x44>
8000ee7e:	40 c4       	mov.aa %a4,%a12
8000ee80:	40 f5       	mov.aa %a5,%a15
8000ee82:	40 f6       	mov.aa %a6,%a15
8000ee84:	6d ff 3c ff 	call 8000ecfc <__multiply>
8000ee88:	e8 02       	st.a [%a15]0,%a2
8000ee8a:	74 28       	st.w [%a2],%d8
8000ee8c:	3c f7       	j 8000ee7a <__pow5mult+0x64>
8000ee8e:	40 d2       	mov.aa %a2,%a13
8000ee90:	00 90       	ret 

8000ee92 <__lshift>:
8000ee92:	19 5b 10 00 	ld.w %d11,[%a5]16
8000ee96:	8f b4 3f 80 	sha %d8,%d4,-5
8000ee9a:	02 4a       	mov %d10,%d4
8000ee9c:	42 8b       	add %d11,%d8
8000ee9e:	19 54 04 00 	ld.w %d4,[%a5]4
8000eea2:	4c 52       	ld.w %d15,[%a5]8
8000eea4:	40 4e       	mov.aa %a14,%a4
8000eea6:	40 5c       	mov.aa %a12,%a5
8000eea8:	1b 1b 00 90 	addi %d9,%d11,1
8000eeac:	7f 9f 05 00 	jge %d15,%d9,8000eeb6 <__lshift+0x24>
8000eeb0:	c2 14       	add %d4,1
8000eeb2:	06 1f       	sh %d15,1
8000eeb4:	3c fc       	j 8000eeac <__lshift+0x1a>
8000eeb6:	40 e4       	mov.aa %a4,%a14
8000eeb8:	6d ff 51 fe 	call 8000eb5a <_Balloc>
8000eebc:	8b 08 40 f3 	max %d15,%d8,0
8000eec0:	40 2d       	mov.aa %a13,%a2
8000eec2:	d9 2f 14 00 	lea %a15,[%a2]20
8000eec6:	d2 02       	mov %e2,0
8000eec8:	01 f2 02 26 	addsc.a %a2,%a15,%d2,2
8000eecc:	9f 0f 03 80 	jned %d15,0,8000eed2 <__lshift+0x40>
8000eed0:	3c 04       	j 8000eed8 <__lshift+0x46>
8000eed2:	74 23       	st.w [%a2],%d3
8000eed4:	c2 12       	add %d2,1
8000eed6:	3c f9       	j 8000eec8 <__lshift+0x36>
8000eed8:	8b 08 40 83 	max %d8,%d8,0
8000eedc:	01 f8 02 36 	addsc.a %a3,%a15,%d8,2
8000eee0:	d9 cf 14 00 	lea %a15,[%a12]20
8000eee4:	19 c2 10 00 	ld.w %d2,[%a12]16
8000eee8:	80 f3       	mov.d %d3,%a15
8000eeea:	8f fa 01 41 	and %d4,%d10,31
8000eeee:	13 42 20 23 	madd %d2,%d3,%d2,4
8000eef2:	8b 04 02 51 	rsub %d5,%d4,32
8000eef6:	82 0f       	mov %d15,0
8000eef8:	df 04 1a 00 	jeq %d4,0,8000ef2c <__lshift+0x9a>
8000eefc:	40 f5       	mov.aa %a5,%a15
8000eefe:	44 53       	ld.w %d3,[%a5+]
8000ef00:	d9 32 04 00 	lea %a2,[%a3]4
8000ef04:	0f 43 00 30 	sh %d3,%d3,%d4
8000ef08:	a6 3f       	or %d15,%d3
8000ef0a:	6c 30       	st.w [%a3]0,%d15
8000ef0c:	4c f0       	ld.w %d15,[%a15]0
8000ef0e:	8b 05 00 31 	rsub %d3,%d5,0
8000ef12:	0f 3f 00 30 	sh %d3,%d15,%d3
8000ef16:	02 3f       	mov %d15,%d3
8000ef18:	80 53       	mov.d %d3,%a5
8000ef1a:	40 5f       	mov.aa %a15,%a5
8000ef1c:	7f 23 04 80 	jge.u %d3,%d2,8000ef24 <__lshift+0x92>
8000ef20:	40 23       	mov.aa %a3,%a2
8000ef22:	3c ed       	j 8000eefc <__lshift+0x6a>
8000ef24:	c2 2b       	add %d11,2
8000ef26:	6c 31       	st.w [%a3]4,%d15
8000ef28:	2a b9       	cmov %d9,%d15,%d11
8000ef2a:	3c 08       	j 8000ef3a <__lshift+0xa8>
8000ef2c:	4c f0       	ld.w %d15,[%a15]0
8000ef2e:	b0 4f       	add.a %a15,4
8000ef30:	80 f3       	mov.d %d3,%a15
8000ef32:	6c 30       	st.w [%a3]0,%d15
8000ef34:	b0 43       	add.a %a3,4
8000ef36:	3f 23 fb ff 	jlt.u %d3,%d2,8000ef2c <__lshift+0x9a>
8000ef3a:	c2 f9       	add %d9,-1
8000ef3c:	59 d9 10 00 	st.w [%a13]16,%d9
8000ef40:	40 e4       	mov.aa %a4,%a14
8000ef42:	40 c5       	mov.aa %a5,%a12
8000ef44:	6d ff 36 fe 	call 8000ebb0 <_Bfree>
8000ef48:	40 d2       	mov.aa %a2,%a13
8000ef4a:	00 90       	ret 

8000ef4c <__mcmp>:
8000ef4c:	4c 54       	ld.w %d15,[%a5]16
8000ef4e:	19 42 10 00 	ld.w %d2,[%a4]16
8000ef52:	a2 f2       	sub %d2,%d15
8000ef54:	df 02 1c 80 	jne %d2,0,8000ef8c <__mcmp+0x40>
8000ef58:	80 42       	mov.d %d2,%a4
8000ef5a:	06 2f       	sh %d15,2
8000ef5c:	60 f2       	mov.a %a2,%d15
8000ef5e:	1b 42 01 30 	addi %d3,%d2,20
8000ef62:	d9 55 14 00 	lea %a5,[%a5]20
8000ef66:	01 23 00 f6 	addsc.a %a15,%a2,%d3,0
8000ef6a:	30 25       	add.a %a5,%a2
8000ef6c:	09 f2 3c f5 	ld.w %d2,[+%a15]-4
8000ef70:	09 5f 3c f5 	ld.w %d15,[+%a5]-4
8000ef74:	5f f2 08 00 	jeq %d2,%d15,8000ef84 <__mcmp+0x38>
8000ef78:	0b f2 30 21 	lt.u %d2,%d2,%d15
8000ef7c:	82 f3       	mov %d3,-1
8000ef7e:	ab 13 80 22 	sel %d2,%d2,%d3,1
8000ef82:	00 90       	ret 
8000ef84:	80 ff       	mov.d %d15,%a15
8000ef86:	3f f3 f3 ff 	jlt.u %d3,%d15,8000ef6c <__mcmp+0x20>
8000ef8a:	82 02       	mov %d2,0
8000ef8c:	00 90       	ret 

8000ef8e <__mdiff>:
8000ef8e:	40 4d       	mov.aa %a13,%a4
8000ef90:	40 5f       	mov.aa %a15,%a5
8000ef92:	40 54       	mov.aa %a4,%a5
8000ef94:	40 65       	mov.aa %a5,%a6
8000ef96:	40 6c       	mov.aa %a12,%a6
8000ef98:	6d ff da ff 	call 8000ef4c <__mcmp>
8000ef9c:	02 2f       	mov %d15,%d2
8000ef9e:	f6 2a       	jnz %d2,8000efb2 <__mdiff+0x24>
8000efa0:	40 d4       	mov.aa %a4,%a13
8000efa2:	82 04       	mov %d4,0
8000efa4:	6d ff db fd 	call 8000eb5a <_Balloc>
8000efa8:	82 12       	mov %d2,1
8000efaa:	59 22 10 00 	st.w [%a2]16,%d2
8000efae:	6c 25       	st.w [%a2]20,%d15
8000efb0:	00 90       	ret 
8000efb2:	82 08       	mov %d8,0
8000efb4:	ce 25       	jgez %d2,8000efbe <__mdiff+0x30>
8000efb6:	40 f2       	mov.aa %a2,%a15
8000efb8:	82 18       	mov %d8,1
8000efba:	40 cf       	mov.aa %a15,%a12
8000efbc:	40 2c       	mov.aa %a12,%a2
8000efbe:	40 d4       	mov.aa %a4,%a13
8000efc0:	48 14       	ld.w %d4,[%a15]4
8000efc2:	6d ff cc fd 	call 8000eb5a <_Balloc>
8000efc6:	48 42       	ld.w %d2,[%a15]16
8000efc8:	d9 ff 14 00 	lea %a15,[%a15]20
8000efcc:	80 ff       	mov.d %d15,%a15
8000efce:	d9 c4 14 00 	lea %a4,[%a12]20
8000efd2:	13 42 20 7f 	madd %d7,%d15,%d2,4
8000efd6:	19 c0 10 00 	ld.w %d0,[%a12]16
8000efda:	80 4f       	mov.d %d15,%a4
8000efdc:	59 28 0c 00 	st.w [%a2]12,%d8
8000efe0:	13 40 20 0f 	madd %d0,%d15,%d0,4
8000efe4:	d9 25 14 00 	lea %a5,[%a2]20
8000efe8:	82 03       	mov %d3,0
8000efea:	44 f6       	ld.w %d6,[%a15+]
8000efec:	44 45       	ld.w %d5,[%a4+]
8000efee:	b7 06 10 48 	insert %d4,%d6,0,16,16
8000eff2:	b7 05 10 18 	insert %d1,%d5,0,16,16
8000eff6:	42 34       	add %d4,%d3
8000eff8:	a2 14       	sub %d4,%d1
8000effa:	8f 06 1f 60 	sh %d6,%d6,-16
8000effe:	8f 05 1f 50 	sh %d5,%d5,-16
8000f002:	8f 04 3f 30 	sha %d3,%d4,-16
8000f006:	0b 56 80 50 	sub %d5,%d6,%d5
8000f00a:	1a 35       	add %d15,%d5,%d3
8000f00c:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000f010:	8f 0f 3f 30 	sha %d3,%d15,-16
8000f014:	80 4f       	mov.d %d15,%a4
8000f016:	d9 53 04 00 	lea %a3,[%a5]4
8000f01a:	74 54       	st.w [%a5],%d4
8000f01c:	40 35       	mov.aa %a5,%a3
8000f01e:	3f 0f e6 ff 	jlt.u %d15,%d0,8000efea <__mdiff+0x5c>
8000f022:	80 ff       	mov.d %d15,%a15
8000f024:	7f 7f 12 80 	jge.u %d15,%d7,8000f048 <__mdiff+0xba>
8000f028:	44 f5       	ld.w %d5,[%a15+]
8000f02a:	b7 05 10 48 	insert %d4,%d5,0,16,16
8000f02e:	8f 05 1f 50 	sh %d5,%d5,-16
8000f032:	42 34       	add %d4,%d3
8000f034:	8f 04 3f f0 	sha %d15,%d4,-16
8000f038:	42 5f       	add %d15,%d5
8000f03a:	37 f4 10 48 	insert %d4,%d4,%d15,16,16
8000f03e:	8f 0f 3f 30 	sha %d3,%d15,-16
8000f042:	74 34       	st.w [%a3],%d4
8000f044:	b0 43       	add.a %a3,4
8000f046:	3c ee       	j 8000f022 <__mdiff+0x94>
8000f048:	09 3f 3c f5 	ld.w %d15,[+%a3]-4
8000f04c:	ee 03       	jnz %d15,8000f052 <__mdiff+0xc4>
8000f04e:	c2 f2       	add %d2,-1
8000f050:	3c fc       	j 8000f048 <__mdiff+0xba>
8000f052:	59 22 10 00 	st.w [%a2]16,%d2
8000f056:	00 90       	ret 

8000f058 <__d2b>:
8000f058:	20 08       	sub.a %sp,8
8000f05a:	02 48       	mov %d8,%d4
8000f05c:	82 14       	mov %d4,1
8000f05e:	02 59       	mov %d9,%d5
8000f060:	40 5d       	mov.aa %a13,%a5
8000f062:	40 6c       	mov.aa %a12,%a6
8000f064:	6d ff 7b fd 	call 8000eb5a <_Balloc>
8000f068:	b7 09 0c 2a 	insert %d2,%d9,0,20,12
8000f06c:	37 09 6b 9a 	extr.u %d9,%d9,20,11
8000f070:	40 2f       	mov.aa %a15,%a2
8000f072:	76 93       	jz %d9,8000f078 <__d2b+0x20>
8000f074:	b7 f2 01 2a 	insert %d2,%d2,15,20,1
8000f078:	59 a2 04 00 	st.w [%sp]4,%d2
8000f07c:	df 08 20 00 	jeq %d8,0,8000f0bc <__d2b+0x64>
8000f080:	d9 a4 08 00 	lea %a4,[%sp]8
8000f084:	89 48 38 f5 	st.w [+%a4]-8,%d8
8000f088:	40 a4       	mov.aa %a4,%sp
8000f08a:	6d ff fe fd 	call 8000ec86 <__lo0bits>
8000f08e:	58 00       	ld.w %d15,[%sp]0
8000f090:	76 2f       	jz %d2,8000f0ae <__d2b+0x56>
8000f092:	19 a4 04 00 	ld.w %d4,[%sp]4
8000f096:	8b 02 02 31 	rsub %d3,%d2,32
8000f09a:	0f 34 00 30 	sh %d3,%d4,%d3
8000f09e:	a6 3f       	or %d15,%d3
8000f0a0:	68 5f       	st.w [%a15]20,%d15
8000f0a2:	8b 02 00 f1 	rsub %d15,%d2,0
8000f0a6:	0f f4 00 f0 	sh %d15,%d4,%d15
8000f0aa:	78 01       	st.w [%sp]4,%d15
8000f0ac:	3c 02       	j 8000f0b0 <__d2b+0x58>
8000f0ae:	68 5f       	st.w [%a15]20,%d15
8000f0b0:	58 01       	ld.w %d15,[%sp]4
8000f0b2:	82 28       	mov %d8,2
8000f0b4:	ea 18       	cmovn %d8,%d15,1
8000f0b6:	68 6f       	st.w [%a15]24,%d15
8000f0b8:	68 48       	st.w [%a15]16,%d8
8000f0ba:	3c 0c       	j 8000f0d2 <__d2b+0x7a>
8000f0bc:	d9 a4 04 00 	lea %a4,[%sp]4
8000f0c0:	6d ff e3 fd 	call 8000ec86 <__lo0bits>
8000f0c4:	58 01       	ld.w %d15,[%sp]4
8000f0c6:	1b 02 02 20 	addi %d2,%d2,32
8000f0ca:	68 5f       	st.w [%a15]20,%d15
8000f0cc:	82 1f       	mov %d15,1
8000f0ce:	68 4f       	st.w [%a15]16,%d15
8000f0d0:	82 18       	mov %d8,1
8000f0d2:	76 98       	jz %d9,8000f0e2 <__d2b+0x8a>
8000f0d4:	1b d9 bc 9f 	addi %d9,%d9,-1075
8000f0d8:	42 29       	add %d9,%d2
8000f0da:	74 d9       	st.w [%a13],%d9
8000f0dc:	8b 52 03 21 	rsub %d2,%d2,53
8000f0e0:	3c 0d       	j 8000f0fa <__d2b+0xa2>
8000f0e2:	01 f8 02 26 	addsc.a %a2,%a15,%d8,2
8000f0e6:	1b e2 bc 2f 	addi %d2,%d2,-1074
8000f0ea:	74 d2       	st.w [%a13],%d2
8000f0ec:	19 24 10 00 	ld.w %d4,[%a2]16
8000f0f0:	6d ff aa fd 	call 8000ec44 <__hi0bits>
8000f0f4:	06 58       	sh %d8,5
8000f0f6:	0b 28 80 20 	sub %d2,%d8,%d2
8000f0fa:	74 c2       	st.w [%a12],%d2
8000f0fc:	40 f2       	mov.aa %a2,%a15
8000f0fe:	00 90       	ret 

8000f100 <__fpclassifyd>:
8000f100:	0f 45 a0 f0 	or %d15,%d5,%d4
8000f104:	82 22       	mov %d2,2
8000f106:	6e 1d       	jz %d15,8000f140 <__fpclassifyd+0x40>
8000f108:	7b 00 00 38 	movh %d3,32768
8000f10c:	3a 53       	eq %d15,%d3,%d5
8000f10e:	8b 04 00 f4 	and.eq %d15,%d4,0
8000f112:	8b 04 00 62 	eq %d6,%d4,0
8000f116:	ee 15       	jnz %d15,8000f140 <__fpclassifyd+0x40>
8000f118:	b7 05 81 5f 	insert %d5,%d5,0,31,1
8000f11c:	7b 00 fe f7 	movh %d15,32736
8000f120:	9b 05 ff 3f 	addih %d3,%d5,65520
8000f124:	82 42       	mov %d2,4
8000f126:	3f f3 0d 80 	jlt.u %d3,%d15,8000f140 <__fpclassifyd+0x40>
8000f12a:	7b 00 01 f0 	movh %d15,16
8000f12e:	82 32       	mov %d2,3
8000f130:	3f f5 08 80 	jlt.u %d5,%d15,8000f140 <__fpclassifyd+0x40>
8000f134:	7b 00 ff 27 	movh %d2,32752
8000f138:	0b 25 00 51 	eq %d5,%d5,%d2
8000f13c:	0f 56 80 20 	and %d2,%d6,%d5
8000f140:	00 90       	ret 

8000f142 <__ssprint_r>:
8000f142:	4c 62       	ld.w %d15,[%a6]8
8000f144:	20 08       	sub.a %sp,8
8000f146:	40 4e       	mov.aa %a14,%a4
8000f148:	40 5f       	mov.aa %a15,%a5
8000f14a:	40 6c       	mov.aa %a12,%a6
8000f14c:	54 6c       	ld.w %d12,[%a6]
8000f14e:	6e 30       	jz %d15,8000f1ae <__ssprint_r+0x6c>
8000f150:	a0 02       	mov.a %a2,0
8000f152:	b5 a2 04 00 	st.a [%sp]4,%a2
8000f156:	82 09       	mov %d9,0
8000f158:	3b 00 48 e0 	mov %d14,1152
8000f15c:	3b f0 b7 df 	mov %d13,-1153
8000f160:	3c 0a       	j 8000f174 <__ssprint_r+0x32>
8000f162:	60 c2       	mov.a %a2,%d12
8000f164:	d4 22       	ld.a %a2,[%a2]
8000f166:	b5 a2 04 00 	st.a [%sp]4,%a2
8000f16a:	60 c2       	mov.a %a2,%d12
8000f16c:	1b 8c 00 c0 	addi %d12,%d12,8
8000f170:	19 29 04 00 	ld.w %d9,[%a2]4
8000f174:	df 09 f7 7f 	jeq %d9,0,8000f162 <__ssprint_r+0x20>
8000f178:	48 28       	ld.w %d8,[%a15]8
8000f17a:	3f 89 5a 80 	jlt.u %d9,%d8,8000f22e <__ssprint_r+0xec>
8000f17e:	88 62       	ld.h %d2,[%a15]12
8000f180:	0f e2 80 f0 	and %d15,%d2,%d14
8000f184:	ee 19       	jnz %d15,8000f1b6 <__ssprint_r+0x74>
8000f186:	3f 89 54 80 	jlt.u %d9,%d8,8000f22e <__ssprint_r+0xec>
8000f18a:	c8 04       	ld.a %a4,[%a15]0
8000f18c:	99 a5 04 00 	ld.a %a5,[%sp]4
8000f190:	02 84       	mov %d4,%d8
8000f192:	6d 00 81 00 	call 8000f294 <memmove>
8000f196:	4c f2       	ld.w %d15,[%a15]8
8000f198:	a2 8f       	sub %d15,%d8
8000f19a:	68 2f       	st.w [%a15]8,%d15
8000f19c:	4c f0       	ld.w %d15,[%a15]0
8000f19e:	42 f8       	add %d8,%d15
8000f1a0:	4c c2       	ld.w %d15,[%a12]8
8000f1a2:	68 08       	st.w [%a15]0,%d8
8000f1a4:	52 99       	sub %d9,%d15,%d9
8000f1a6:	59 c9 08 00 	st.w [%a12]8,%d9
8000f1aa:	df 09 dc ff 	jne %d9,0,8000f162 <__ssprint_r+0x20>
8000f1ae:	82 0f       	mov %d15,0
8000f1b0:	6c c1       	st.w [%a12]4,%d15
8000f1b2:	82 02       	mov %d2,0
8000f1b4:	00 90       	ret 
8000f1b6:	c8 45       	ld.a %a5,[%a15]16
8000f1b8:	48 5a       	ld.w %d10,[%a15]20
8000f1ba:	4c f0       	ld.w %d15,[%a15]0
8000f1bc:	80 53       	mov.d %d3,%a5
8000f1be:	53 3a 20 a0 	mul %d10,%d10,3
8000f1c2:	a2 3f       	sub %d15,%d3
8000f1c4:	82 23       	mov %d3,2
8000f1c6:	4b 3a 01 a2 	div %e10,%d10,%d3
8000f1ca:	92 13       	add %d3,%d15,1
8000f1cc:	42 93       	add %d3,%d9
8000f1ce:	0b 3a b0 a1 	max.u %d10,%d10,%d3
8000f1d2:	40 e4       	mov.aa %a4,%a14
8000f1d4:	02 a4       	mov %d4,%d10
8000f1d6:	6f a2 12 00 	jz.t %d2,10,8000f1fa <__ssprint_r+0xb8>
8000f1da:	6d ff 0b e9 	call 8000c3f0 <_malloc_r>
8000f1de:	40 2d       	mov.aa %a13,%a2
8000f1e0:	bd 02 15 00 	jz.a %a2,8000f20a <__ssprint_r+0xc8>
8000f1e4:	c8 45       	ld.a %a5,[%a15]16
8000f1e6:	40 24       	mov.aa %a4,%a2
8000f1e8:	02 f4       	mov %d4,%d15
8000f1ea:	6d ff aa fc 	call 8000eb3e <memcpy>
8000f1ee:	88 62       	ld.h %d2,[%a15]12
8000f1f0:	26 d2       	and %d2,%d13
8000f1f2:	8f 02 48 21 	or %d2,%d2,128
8000f1f6:	a8 62       	st.h [%a15]12,%d2
8000f1f8:	3c 13       	j 8000f21e <__ssprint_r+0xdc>
8000f1fa:	6d 00 7d 00 	call 8000f2f4 <_realloc_r>
8000f1fe:	40 2d       	mov.aa %a13,%a2
8000f200:	7c 2f       	jnz.a %a2,8000f21e <__ssprint_r+0xdc>
8000f202:	c8 45       	ld.a %a5,[%a15]16
8000f204:	40 e4       	mov.aa %a4,%a14
8000f206:	6d ff ea eb 	call 8000c9da <_free_r>
8000f20a:	da 0c       	mov %d15,12
8000f20c:	6c e0       	st.w [%a14]0,%d15
8000f20e:	8c f6       	ld.h %d15,[%a15]12
8000f210:	82 f2       	mov %d2,-1
8000f212:	96 40       	or %d15,64
8000f214:	a8 6f       	st.h [%a15]12,%d15
8000f216:	82 0f       	mov %d15,0
8000f218:	6c c2       	st.w [%a12]8,%d15
8000f21a:	6c c1       	st.w [%a12]4,%d15
8000f21c:	00 90       	ret 
8000f21e:	e8 4d       	st.a [%a15]16,%a13
8000f220:	10 dd       	addsc.a %a13,%a13,%d15,0
8000f222:	68 5a       	st.w [%a15]20,%d10
8000f224:	a2 fa       	sub %d10,%d15
8000f226:	e8 0d       	st.a [%a15]0,%a13
8000f228:	02 98       	mov %d8,%d9
8000f22a:	68 2a       	st.w [%a15]8,%d10
8000f22c:	3c ad       	j 8000f186 <__ssprint_r+0x44>
8000f22e:	02 98       	mov %d8,%d9
8000f230:	3c ad       	j 8000f18a <__ssprint_r+0x48>

8000f232 <_calloc_r>:
8000f232:	e2 54       	mul %d4,%d5
8000f234:	6d ff de e8 	call 8000c3f0 <_malloc_r>
8000f238:	40 2f       	mov.aa %a15,%a2
8000f23a:	a0 02       	mov.a %a2,0
8000f23c:	bd 0f 2b 00 	jz.a %a15,8000f292 <_calloc_r+0x60>
8000f240:	19 f5 fc ff 	ld.w %d5,[%a15]-4
8000f244:	8f 35 c0 51 	andn %d5,%d5,3
8000f248:	c2 c5       	add %d5,-4
8000f24a:	8b 55 a2 f2 	ge.u %d15,%d5,37
8000f24e:	ee 1d       	jnz %d15,8000f288 <_calloc_r+0x56>
8000f250:	8b 45 61 f2 	lt.u %d15,%d5,20
8000f254:	40 f2       	mov.aa %a2,%a15
8000f256:	ee 14       	jnz %d15,8000f27e <_calloc_r+0x4c>
8000f258:	82 0f       	mov %d15,0
8000f25a:	68 0f       	st.w [%a15]0,%d15
8000f25c:	68 1f       	st.w [%a15]4,%d15
8000f25e:	8b c5 a1 22 	ge.u %d2,%d5,28
8000f262:	d9 f2 08 00 	lea %a2,[%a15]8
8000f266:	76 2c       	jz %d2,8000f27e <_calloc_r+0x4c>
8000f268:	68 2f       	st.w [%a15]8,%d15
8000f26a:	68 3f       	st.w [%a15]12,%d15
8000f26c:	8b 45 02 52 	eq %d5,%d5,36
8000f270:	d9 f2 10 00 	lea %a2,[%a15]16
8000f274:	76 55       	jz %d5,8000f27e <_calloc_r+0x4c>
8000f276:	68 4f       	st.w [%a15]16,%d15
8000f278:	d9 f2 18 00 	lea %a2,[%a15]24
8000f27c:	68 5f       	st.w [%a15]20,%d15
8000f27e:	82 0f       	mov %d15,0
8000f280:	6c 20       	st.w [%a2]0,%d15
8000f282:	6c 21       	st.w [%a2]4,%d15
8000f284:	6c 22       	st.w [%a2]8,%d15
8000f286:	3c 05       	j 8000f290 <_calloc_r+0x5e>
8000f288:	40 f4       	mov.aa %a4,%a15
8000f28a:	82 04       	mov %d4,0
8000f28c:	6d 00 2c 00 	call 8000f2e4 <memset>
8000f290:	40 f2       	mov.aa %a2,%a15
8000f292:	00 90       	ret 

8000f294 <memmove>:
8000f294:	80 46       	mov.d %d6,%a4
8000f296:	80 52       	mov.d %d2,%a5
8000f298:	7f 62 16 80 	jge.u %d2,%d6,8000f2c4 <memmove+0x30>
8000f29c:	0b 42 00 50 	add %d5,%d2,%d4
8000f2a0:	7f 56 12 80 	jge.u %d6,%d5,8000f2c4 <memmove+0x30>
8000f2a4:	60 4f       	mov.a %a15,%d4
8000f2a6:	02 42       	mov %d2,%d4
8000f2a8:	c2 f2       	add %d2,-1
8000f2aa:	fd f0 03 00 	loop %a15,8000f2b0 <memmove+0x1c>
8000f2ae:	3c 19       	j 8000f2e0 <memmove+0x4c>
8000f2b0:	5a 42       	sub %d15,%d2,%d4
8000f2b2:	60 f2       	mov.a %a2,%d15
8000f2b4:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
8000f2b8:	1a 62       	add %d15,%d2,%d6
8000f2ba:	79 23 00 00 	ld.b %d3,[%a2]0
8000f2be:	60 f2       	mov.a %a2,%d15
8000f2c0:	34 23       	st.b [%a2],%d3
8000f2c2:	3c f3       	j 8000f2a8 <memmove+0x14>
8000f2c4:	60 4f       	mov.a %a15,%d4
8000f2c6:	a0 02       	mov.a %a2,0
8000f2c8:	01 26 00 46 	addsc.a %a4,%a2,%d6,0
8000f2cc:	01 22 00 36 	addsc.a %a3,%a2,%d2,0
8000f2d0:	fd f0 03 00 	loop %a15,8000f2d6 <memmove+0x42>
8000f2d4:	3c 06       	j 8000f2e0 <memmove+0x4c>
8000f2d6:	79 33 00 00 	ld.b %d3,[%a3]0
8000f2da:	b0 12       	add.a %a2,1
8000f2dc:	34 43       	st.b [%a4],%d3
8000f2de:	3c f5       	j 8000f2c8 <memmove+0x34>
8000f2e0:	60 62       	mov.a %a2,%d6
8000f2e2:	00 90       	ret 

8000f2e4 <memset>:
8000f2e4:	40 42       	mov.aa %a2,%a4
8000f2e6:	40 4f       	mov.aa %a15,%a4
8000f2e8:	9f 05 03 80 	jned %d5,0,8000f2ee <memset+0xa>
8000f2ec:	00 90       	ret 
8000f2ee:	28 04       	st.b [%a15]0,%d4
8000f2f0:	b0 1f       	add.a %a15,1
8000f2f2:	3c fb       	j 8000f2e8 <memset+0x4>

8000f2f4 <_realloc_r>:
8000f2f4:	40 4d       	mov.aa %a13,%a4
8000f2f6:	40 5f       	mov.aa %a15,%a5
8000f2f8:	02 49       	mov %d9,%d4
8000f2fa:	7c 53       	jnz.a %a5,8000f300 <_realloc_r+0xc>
8000f2fc:	1d ff 7a e8 	j 8000c3f0 <_malloc_r>
8000f300:	6d ff c5 ea 	call 8000c88a <__malloc_lock>
8000f304:	1b b9 00 20 	addi %d2,%d9,11
8000f308:	8b 72 61 f2 	lt.u %d15,%d2,23
8000f30c:	8f 72 c0 21 	andn %d2,%d2,7
8000f310:	ab 02 a1 ff 	seln %d15,%d15,%d2,16
8000f314:	19 f3 fc ff 	ld.w %d3,[%a15]-4
8000f318:	0b 9f 30 21 	lt.u %d2,%d15,%d9
8000f31c:	8b 0f 20 25 	or.lt %d2,%d15,0
8000f320:	d9 fe f8 ff 	lea %a14,[%a15]-8
8000f324:	8f 33 c0 81 	andn %d8,%d3,3
8000f328:	76 25       	jz %d2,8000f332 <_realloc_r+0x3e>
8000f32a:	da 0c       	mov %d15,12
8000f32c:	6c d0       	st.w [%a13]0,%d15
8000f32e:	1d 00 56 01 	j 8000f5da <_realloc_r+0x2e6>
8000f332:	7f f8 ac 01 	jge %d8,%d15,8000f68a <_realloc_r+0x396>
8000f336:	7b 00 00 c7 	movh %d12,28672
8000f33a:	60 c3       	mov.a %a3,%d12
8000f33c:	01 e8 00 26 	addsc.a %a2,%a14,%d8,0
8000f340:	d9 34 30 00 	lea %a4,[%a3]48
8000f344:	99 43 08 00 	ld.a %a3,[%a4]8
8000f348:	80 4c       	mov.d %d12,%a4
8000f34a:	19 2b 04 00 	ld.w %d11,[%a2]4
8000f34e:	7d 32 0a 00 	jeq.a %a2,%a3,8000f362 <_realloc_r+0x6e>
8000f352:	8f 1b c0 21 	andn %d2,%d11,1
8000f356:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
8000f35a:	19 42 04 00 	ld.w %d2,[%a4]4
8000f35e:	6f 02 2b 80 	jnz.t %d2,0,8000f3b4 <_realloc_r+0xc0>
8000f362:	8f 3b c0 b1 	andn %d11,%d11,3
8000f366:	0b 8b 00 20 	add %d2,%d11,%d8
8000f36a:	7d 32 1b 80 	jne.a %a2,%a3,8000f3a0 <_realloc_r+0xac>
8000f36e:	1b 0f 01 40 	addi %d4,%d15,16
8000f372:	3f 42 23 00 	jlt %d2,%d4,8000f3b8 <_realloc_r+0xc4>
8000f376:	10 ee       	addsc.a %a14,%a14,%d15,0
8000f378:	60 c2       	mov.a %a2,%d12
8000f37a:	a2 f2       	sub %d2,%d15
8000f37c:	b5 2e 08 00 	st.a [%a2]8,%a14
8000f380:	8f 12 40 21 	or %d2,%d2,1
8000f384:	59 e2 04 00 	st.w [%a14]4,%d2
8000f388:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000f38c:	40 d4       	mov.aa %a4,%a13
8000f38e:	8f 12 00 21 	and %d2,%d2,1
8000f392:	a6 2f       	or %d15,%d2
8000f394:	59 ff fc ff 	st.w [%a15]-4,%d15
8000f398:	6d ff 7a ea 	call 8000c88c <__malloc_unlock>
8000f39c:	40 f2       	mov.aa %a2,%a15
8000f39e:	00 90       	ret 
8000f3a0:	3f f2 0c 00 	jlt %d2,%d15,8000f3b8 <_realloc_r+0xc4>
8000f3a4:	cc 23       	ld.a %a15,[%a2]12
8000f3a6:	99 22 08 00 	ld.a %a2,[%a2]8
8000f3aa:	02 28       	mov %d8,%d2
8000f3ac:	ec 23       	st.a [%a2]12,%a15
8000f3ae:	e8 22       	st.a [%a15]8,%a2
8000f3b0:	1d 00 6d 01 	j 8000f68a <_realloc_r+0x396>
8000f3b4:	82 0b       	mov %d11,0
8000f3b6:	a0 02       	mov.a %a2,0
8000f3b8:	6f 03 08 81 	jnz.t %d3,0,8000f5c8 <_realloc_r+0x2d4>
8000f3bc:	99 fc f8 ff 	ld.a %a12,[%a15]-8
8000f3c0:	01 ce 20 c0 	sub.a %a12,%a14,%a12
8000f3c4:	19 ca 04 00 	ld.w %d10,[%a12]4
8000f3c8:	8f 3a c0 a1 	andn %d10,%d10,3
8000f3cc:	42 8a       	add %d10,%d8
8000f3ce:	bd 02 b3 00 	jz.a %a2,8000f534 <_realloc_r+0x240>
8000f3d2:	42 ab       	add %d11,%d10
8000f3d4:	7d 32 5f 80 	jne.a %a2,%a3,8000f492 <_realloc_r+0x19e>
8000f3d8:	1b 0f 01 20 	addi %d2,%d15,16
8000f3dc:	3f 2b ac 00 	jlt %d11,%d2,8000f534 <_realloc_r+0x240>
8000f3e0:	40 ce       	mov.aa %a14,%a12
8000f3e2:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000f3e6:	09 e3 88 05 	ld.a %a3,[+%a14]8
8000f3ea:	1b c8 ff 4f 	addi %d4,%d8,-4
8000f3ee:	8b 54 a2 22 	ge.u %d2,%d4,37
8000f3f2:	b5 32 0c 00 	st.a [%a3]12,%a2
8000f3f6:	b5 23 08 00 	st.a [%a2]8,%a3
8000f3fa:	df 02 36 80 	jne %d2,0,8000f466 <_realloc_r+0x172>
8000f3fe:	8b 44 61 22 	lt.u %d2,%d4,20
8000f402:	40 e3       	mov.aa %a3,%a14
8000f404:	df 02 28 80 	jne %d2,0,8000f454 <_realloc_r+0x160>
8000f408:	48 02       	ld.w %d2,[%a15]0
8000f40a:	59 c2 08 00 	st.w [%a12]8,%d2
8000f40e:	48 13       	ld.w %d3,[%a15]4
8000f410:	8b c4 a1 22 	ge.u %d2,%d4,28
8000f414:	59 c3 0c 00 	st.w [%a12]12,%d3
8000f418:	f6 26       	jnz %d2,8000f424 <_realloc_r+0x130>
8000f41a:	d9 c3 10 00 	lea %a3,[%a12]16
8000f41e:	d9 ff 08 00 	lea %a15,[%a15]8
8000f422:	3c 19       	j 8000f454 <_realloc_r+0x160>
8000f424:	48 22       	ld.w %d2,[%a15]8
8000f426:	8b 44 02 82 	eq %d8,%d4,36
8000f42a:	59 c2 10 00 	st.w [%a12]16,%d2
8000f42e:	48 33       	ld.w %d3,[%a15]12
8000f430:	59 c3 14 00 	st.w [%a12]20,%d3
8000f434:	f6 86       	jnz %d8,8000f440 <_realloc_r+0x14c>
8000f436:	d9 c3 18 00 	lea %a3,[%a12]24
8000f43a:	d9 ff 10 00 	lea %a15,[%a15]16
8000f43e:	3c 0b       	j 8000f454 <_realloc_r+0x160>
8000f440:	48 42       	ld.w %d2,[%a15]16
8000f442:	d9 c3 20 00 	lea %a3,[%a12]32
8000f446:	59 c2 18 00 	st.w [%a12]24,%d2
8000f44a:	48 53       	ld.w %d3,[%a15]20
8000f44c:	d9 ff 18 00 	lea %a15,[%a15]24
8000f450:	59 c3 1c 00 	st.w [%a12]28,%d3
8000f454:	48 02       	ld.w %d2,[%a15]0
8000f456:	74 32       	st.w [%a3],%d2
8000f458:	48 13       	ld.w %d3,[%a15]4
8000f45a:	59 33 04 00 	st.w [%a3]4,%d3
8000f45e:	48 22       	ld.w %d2,[%a15]8
8000f460:	59 32 08 00 	st.w [%a3]8,%d2
8000f464:	3c 05       	j 8000f46e <_realloc_r+0x17a>
8000f466:	40 e4       	mov.aa %a4,%a14
8000f468:	40 f5       	mov.aa %a5,%a15
8000f46a:	6d ff 15 ff 	call 8000f294 <memmove>
8000f46e:	10 cf       	addsc.a %a15,%a12,%d15,0
8000f470:	60 c2       	mov.a %a2,%d12
8000f472:	a2 fb       	sub %d11,%d15
8000f474:	ec 22       	st.a [%a2]8,%a15
8000f476:	8f 1b 40 b1 	or %d11,%d11,1
8000f47a:	68 1b       	st.w [%a15]4,%d11
8000f47c:	19 c2 04 00 	ld.w %d2,[%a12]4
8000f480:	40 d4       	mov.aa %a4,%a13
8000f482:	8f 12 00 21 	and %d2,%d2,1
8000f486:	a6 2f       	or %d15,%d2
8000f488:	6c c1       	st.w [%a12]4,%d15
8000f48a:	6d ff 01 ea 	call 8000c88c <__malloc_unlock>
8000f48e:	40 e2       	mov.aa %a2,%a14
8000f490:	00 90       	ret 
8000f492:	3f fb 51 00 	jlt %d11,%d15,8000f534 <_realloc_r+0x240>
8000f496:	99 23 0c 00 	ld.a %a3,[%a2]12
8000f49a:	99 22 08 00 	ld.a %a2,[%a2]8
8000f49e:	40 c4       	mov.aa %a4,%a12
8000f4a0:	1b c8 ff 4f 	addi %d4,%d8,-4
8000f4a4:	b5 23 0c 00 	st.a [%a2]12,%a3
8000f4a8:	b5 32 08 00 	st.a [%a3]8,%a2
8000f4ac:	09 43 88 05 	ld.a %a3,[+%a4]8
8000f4b0:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000f4b4:	8b 54 a2 22 	ge.u %d2,%d4,37
8000f4b8:	b5 32 0c 00 	st.a [%a3]12,%a2
8000f4bc:	b5 23 08 00 	st.a [%a2]8,%a3
8000f4c0:	df 02 35 80 	jne %d2,0,8000f52a <_realloc_r+0x236>
8000f4c4:	8b 44 61 22 	lt.u %d2,%d4,20
8000f4c8:	df 02 28 80 	jne %d2,0,8000f518 <_realloc_r+0x224>
8000f4cc:	48 02       	ld.w %d2,[%a15]0
8000f4ce:	59 c2 08 00 	st.w [%a12]8,%d2
8000f4d2:	48 13       	ld.w %d3,[%a15]4
8000f4d4:	8b c4 a1 22 	ge.u %d2,%d4,28
8000f4d8:	59 c3 0c 00 	st.w [%a12]12,%d3
8000f4dc:	f6 26       	jnz %d2,8000f4e8 <_realloc_r+0x1f4>
8000f4de:	d9 c4 10 00 	lea %a4,[%a12]16
8000f4e2:	d9 ff 08 00 	lea %a15,[%a15]8
8000f4e6:	3c 19       	j 8000f518 <_realloc_r+0x224>
8000f4e8:	48 22       	ld.w %d2,[%a15]8
8000f4ea:	8b 44 02 82 	eq %d8,%d4,36
8000f4ee:	59 c2 10 00 	st.w [%a12]16,%d2
8000f4f2:	48 33       	ld.w %d3,[%a15]12
8000f4f4:	59 c3 14 00 	st.w [%a12]20,%d3
8000f4f8:	f6 86       	jnz %d8,8000f504 <_realloc_r+0x210>
8000f4fa:	d9 c4 18 00 	lea %a4,[%a12]24
8000f4fe:	d9 ff 10 00 	lea %a15,[%a15]16
8000f502:	3c 0b       	j 8000f518 <_realloc_r+0x224>
8000f504:	48 42       	ld.w %d2,[%a15]16
8000f506:	d9 c4 20 00 	lea %a4,[%a12]32
8000f50a:	59 c2 18 00 	st.w [%a12]24,%d2
8000f50e:	48 53       	ld.w %d3,[%a15]20
8000f510:	d9 ff 18 00 	lea %a15,[%a15]24
8000f514:	59 c3 1c 00 	st.w [%a12]28,%d3
8000f518:	48 02       	ld.w %d2,[%a15]0
8000f51a:	74 42       	st.w [%a4],%d2
8000f51c:	48 13       	ld.w %d3,[%a15]4
8000f51e:	59 43 04 00 	st.w [%a4]4,%d3
8000f522:	48 22       	ld.w %d2,[%a15]8
8000f524:	59 42 08 00 	st.w [%a4]8,%d2
8000f528:	3c 04       	j 8000f530 <_realloc_r+0x23c>
8000f52a:	40 f5       	mov.aa %a5,%a15
8000f52c:	6d ff b4 fe 	call 8000f294 <memmove>
8000f530:	02 b8       	mov %d8,%d11
8000f532:	3c 45       	j 8000f5bc <_realloc_r+0x2c8>
8000f534:	3f fa 4a 00 	jlt %d10,%d15,8000f5c8 <_realloc_r+0x2d4>
8000f538:	40 c4       	mov.aa %a4,%a12
8000f53a:	99 c2 0c 00 	ld.a %a2,[%a12]12
8000f53e:	09 43 88 05 	ld.a %a3,[+%a4]8
8000f542:	1b c8 ff 4f 	addi %d4,%d8,-4
8000f546:	8b 54 a2 22 	ge.u %d2,%d4,37
8000f54a:	b5 32 0c 00 	st.a [%a3]12,%a2
8000f54e:	b5 23 08 00 	st.a [%a2]8,%a3
8000f552:	df 02 37 80 	jne %d2,0,8000f5c0 <_realloc_r+0x2cc>
8000f556:	8b 44 61 22 	lt.u %d2,%d4,20
8000f55a:	df 02 28 80 	jne %d2,0,8000f5aa <_realloc_r+0x2b6>
8000f55e:	48 03       	ld.w %d3,[%a15]0
8000f560:	59 c3 08 00 	st.w [%a12]8,%d3
8000f564:	48 12       	ld.w %d2,[%a15]4
8000f566:	59 c2 0c 00 	st.w [%a12]12,%d2
8000f56a:	8b c4 a1 22 	ge.u %d2,%d4,28
8000f56e:	f6 26       	jnz %d2,8000f57a <_realloc_r+0x286>
8000f570:	d9 c4 10 00 	lea %a4,[%a12]16
8000f574:	d9 ff 08 00 	lea %a15,[%a15]8
8000f578:	3c 19       	j 8000f5aa <_realloc_r+0x2b6>
8000f57a:	48 23       	ld.w %d3,[%a15]8
8000f57c:	8b 44 02 82 	eq %d8,%d4,36
8000f580:	59 c3 10 00 	st.w [%a12]16,%d3
8000f584:	48 32       	ld.w %d2,[%a15]12
8000f586:	59 c2 14 00 	st.w [%a12]20,%d2
8000f58a:	f6 86       	jnz %d8,8000f596 <_realloc_r+0x2a2>
8000f58c:	d9 c4 18 00 	lea %a4,[%a12]24
8000f590:	d9 ff 10 00 	lea %a15,[%a15]16
8000f594:	3c 0b       	j 8000f5aa <_realloc_r+0x2b6>
8000f596:	48 43       	ld.w %d3,[%a15]16
8000f598:	d9 c4 20 00 	lea %a4,[%a12]32
8000f59c:	59 c3 18 00 	st.w [%a12]24,%d3
8000f5a0:	48 52       	ld.w %d2,[%a15]20
8000f5a2:	d9 ff 18 00 	lea %a15,[%a15]24
8000f5a6:	59 c2 1c 00 	st.w [%a12]28,%d2
8000f5aa:	48 03       	ld.w %d3,[%a15]0
8000f5ac:	74 43       	st.w [%a4],%d3
8000f5ae:	48 12       	ld.w %d2,[%a15]4
8000f5b0:	59 42 04 00 	st.w [%a4]4,%d2
8000f5b4:	48 23       	ld.w %d3,[%a15]8
8000f5b6:	59 43 08 00 	st.w [%a4]8,%d3
8000f5ba:	02 a8       	mov %d8,%d10
8000f5bc:	40 ce       	mov.aa %a14,%a12
8000f5be:	3c 66       	j 8000f68a <_realloc_r+0x396>
8000f5c0:	40 f5       	mov.aa %a5,%a15
8000f5c2:	6d ff 69 fe 	call 8000f294 <memmove>
8000f5c6:	3c fa       	j 8000f5ba <_realloc_r+0x2c6>
8000f5c8:	40 d4       	mov.aa %a4,%a13
8000f5ca:	02 94       	mov %d4,%d9
8000f5cc:	6d ff 12 e7 	call 8000c3f0 <_malloc_r>
8000f5d0:	40 2c       	mov.aa %a12,%a2
8000f5d2:	7c 26       	jnz.a %a2,8000f5de <_realloc_r+0x2ea>
8000f5d4:	40 d4       	mov.aa %a4,%a13
8000f5d6:	6d ff 5b e9 	call 8000c88c <__malloc_unlock>
8000f5da:	a0 02       	mov.a %a2,0
8000f5dc:	00 90       	ret 
8000f5de:	19 f2 fc ff 	ld.w %d2,[%a15]-4
8000f5e2:	d9 23 f8 ff 	lea %a3,[%a2]-8
8000f5e6:	8f 12 c0 21 	andn %d2,%d2,1
8000f5ea:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
8000f5ee:	80 32       	mov.d %d2,%a3
8000f5f0:	80 23       	mov.d %d3,%a2
8000f5f2:	5f 32 08 80 	jne %d2,%d3,8000f602 <_realloc_r+0x30e>
8000f5f6:	19 c2 fc ff 	ld.w %d2,[%a12]-4
8000f5fa:	8f 32 c0 21 	andn %d2,%d2,3
8000f5fe:	42 28       	add %d8,%d2
8000f600:	3c 45       	j 8000f68a <_realloc_r+0x396>
8000f602:	1b c8 ff 4f 	addi %d4,%d8,-4
8000f606:	8b 54 a2 f2 	ge.u %d15,%d4,37
8000f60a:	ee 33       	jnz %d15,8000f670 <_realloc_r+0x37c>
8000f60c:	8b 44 61 f2 	lt.u %d15,%d4,20
8000f610:	40 c3       	mov.aa %a3,%a12
8000f612:	40 f2       	mov.aa %a2,%a15
8000f614:	ee 23       	jnz %d15,8000f65a <_realloc_r+0x366>
8000f616:	4c f0       	ld.w %d15,[%a15]0
8000f618:	d9 c3 08 00 	lea %a3,[%a12]8
8000f61c:	6c c0       	st.w [%a12]0,%d15
8000f61e:	48 12       	ld.w %d2,[%a15]4
8000f620:	8b c4 a1 f2 	ge.u %d15,%d4,28
8000f624:	59 c2 04 00 	st.w [%a12]4,%d2
8000f628:	d9 f2 08 00 	lea %a2,[%a15]8
8000f62c:	6e 17       	jz %d15,8000f65a <_realloc_r+0x366>
8000f62e:	48 23       	ld.w %d3,[%a15]8
8000f630:	8b 44 02 82 	eq %d8,%d4,36
8000f634:	59 c3 08 00 	st.w [%a12]8,%d3
8000f638:	4c f3       	ld.w %d15,[%a15]12
8000f63a:	d9 c3 10 00 	lea %a3,[%a12]16
8000f63e:	6c c3       	st.w [%a12]12,%d15
8000f640:	d9 f2 10 00 	lea %a2,[%a15]16
8000f644:	76 8b       	jz %d8,8000f65a <_realloc_r+0x366>
8000f646:	48 42       	ld.w %d2,[%a15]16
8000f648:	d9 c3 18 00 	lea %a3,[%a12]24
8000f64c:	59 c2 10 00 	st.w [%a12]16,%d2
8000f650:	48 53       	ld.w %d3,[%a15]20
8000f652:	d9 f2 18 00 	lea %a2,[%a15]24
8000f656:	59 c3 14 00 	st.w [%a12]20,%d3
8000f65a:	4c 20       	ld.w %d15,[%a2]0
8000f65c:	6c 30       	st.w [%a3]0,%d15
8000f65e:	19 22 04 00 	ld.w %d2,[%a2]4
8000f662:	59 32 04 00 	st.w [%a3]4,%d2
8000f666:	19 23 08 00 	ld.w %d3,[%a2]8
8000f66a:	59 33 08 00 	st.w [%a3]8,%d3
8000f66e:	3c 05       	j 8000f678 <_realloc_r+0x384>
8000f670:	40 c4       	mov.aa %a4,%a12
8000f672:	40 f5       	mov.aa %a5,%a15
8000f674:	6d ff 10 fe 	call 8000f294 <memmove>
8000f678:	40 d4       	mov.aa %a4,%a13
8000f67a:	40 f5       	mov.aa %a5,%a15
8000f67c:	6d ff af e9 	call 8000c9da <_free_r>
8000f680:	40 d4       	mov.aa %a4,%a13
8000f682:	6d ff 05 e9 	call 8000c88c <__malloc_unlock>
8000f686:	40 c2       	mov.aa %a2,%a12
8000f688:	00 90       	ret 
8000f68a:	0b f8 80 20 	sub %d2,%d8,%d15
8000f68e:	8b 02 61 42 	lt.u %d4,%d2,16
8000f692:	19 e3 04 00 	ld.w %d3,[%a14]4
8000f696:	df 04 16 80 	jne %d4,0,8000f6c2 <_realloc_r+0x3ce>
8000f69a:	8f 13 00 31 	and %d3,%d3,1
8000f69e:	10 e5       	addsc.a %a5,%a14,%d15,0
8000f6a0:	a6 3f       	or %d15,%d3
8000f6a2:	6c e1       	st.w [%a14]4,%d15
8000f6a4:	01 52 00 f6 	addsc.a %a15,%a5,%d2,0
8000f6a8:	8f 12 40 f1 	or %d15,%d2,1
8000f6ac:	b7 10 21 20 	imask %e2,1,0,1
8000f6b0:	6c 51       	st.w [%a5]4,%d15
8000f6b2:	49 f2 44 08 	ldmst [%a15]4,%e2
8000f6b6:	40 d4       	mov.aa %a4,%a13
8000f6b8:	d9 55 08 00 	lea %a5,[%a5]8
8000f6bc:	6d ff 8f e9 	call 8000c9da <_free_r>
8000f6c0:	3c 0c       	j 8000f6d8 <_realloc_r+0x3e4>
8000f6c2:	8f 13 00 31 	and %d3,%d3,1
8000f6c6:	a6 83       	or %d3,%d8
8000f6c8:	59 e3 04 00 	st.w [%a14]4,%d3
8000f6cc:	01 e8 00 f6 	addsc.a %a15,%a14,%d8,0
8000f6d0:	b7 10 21 20 	imask %e2,1,0,1
8000f6d4:	49 f2 44 08 	ldmst [%a15]4,%e2
8000f6d8:	40 d4       	mov.aa %a4,%a13
8000f6da:	6d ff d9 e8 	call 8000c88c <__malloc_unlock>
8000f6de:	d9 e2 08 00 	lea %a2,[%a14]8
8000f6e2:	00 90       	ret 

8000f6e4 <_exit>:
8000f6e4:	76 43       	jz %d4,8000f6ea <_exit+0x6>
8000f6e6:	60 4e       	mov.a %a14,%d4
8000f6e8:	3c 04       	j 8000f6f0 <_exit+0xc>
8000f6ea:	bb d0 00 f9 	mov.u %d15,36877
8000f6ee:	60 fe       	mov.a %a14,%d15
8000f6f0:	00 a0       	debug 
8000f6f2:	3c 00       	j 8000f6f2 <_exit+0xe>

8000f6f4 <sbrk>:
8000f6f4:	91 00 00 f7 	movh.a %a15,28672
8000f6f8:	19 ff a0 10 	ld.w %d15,[%a15]2144 <70000860 <heap_top.2289>>
8000f6fc:	7b 00 00 27 	movh %d2,28672
8000f700:	42 f4       	add %d4,%d15
8000f702:	1b 02 b7 20 	addi %d2,%d2,2928
8000f706:	7f 42 09 80 	jge.u %d2,%d4,8000f718 <sbrk+0x24>
8000f70a:	6d 00 13 00 	call 8000f730 <__errno>
8000f70e:	da 0c       	mov %d15,12
8000f710:	6c 20       	st.w [%a2]0,%d15
8000f712:	a0 02       	mov.a %a2,0
8000f714:	b0 f2       	add.a %a2,-1
8000f716:	00 90       	ret 
8000f718:	7b 00 00 27 	movh %d2,28672
8000f71c:	1b 02 b7 20 	addi %d2,%d2,2928
8000f720:	7f 24 04 80 	jge.u %d4,%d2,8000f728 <sbrk+0x34>
8000f724:	6d 00 0b 00 	call 8000f73a <abort>
8000f728:	59 f4 a0 10 	st.w [%a15]2144,%d4
8000f72c:	60 f2       	mov.a %a2,%d15
8000f72e:	00 90       	ret 

8000f730 <__errno>:
8000f730:	91 00 00 27 	movh.a %a2,28672
8000f734:	d9 22 a8 d0 	lea %a2,[%a2]2920 <70000b68 <_my_errno>>
8000f738:	00 90       	ret 

8000f73a <abort>:
8000f73a:	00 a0       	debug 
8000f73c:	7b e0 ea fd 	movh %d15,57006
8000f740:	1b ff ee fb 	addi %d15,%d15,-16657
8000f744:	60 fe       	mov.a %a14,%d15
8000f746:	1d ff cf ff 	j 8000f6e4 <_exit>
8000f74a:	3c 00       	j 8000f74a <abort+0x10>

8000f74c <__eqdf2>:
8000f74c:	20 38       	sub.a %sp,56
8000f74e:	40 a4       	mov.aa %a4,%sp
8000f750:	d9 a5 10 00 	lea %a5,[%sp]16
8000f754:	89 a4 40 09 	st.d [%sp],%e4
8000f758:	89 a6 48 09 	st.d [%sp]8,%e6
8000f75c:	6d ff 84 e5 	call 8000c264 <__unpack_d>
8000f760:	d9 a4 08 00 	lea %a4,[%sp]8
8000f764:	d9 a5 24 00 	lea %a5,[%sp]36
8000f768:	6d ff 7e e5 	call 8000c264 <__unpack_d>
8000f76c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000f770:	82 12       	mov %d2,1
8000f772:	bf 2f 0c 80 	jlt.u %d15,2,8000f78a <__eqdf2+0x3e>
8000f776:	39 af 24 00 	ld.bu %d15,[%sp]36
8000f77a:	bf 2f 08 80 	jlt.u %d15,2,8000f78a <__eqdf2+0x3e>
8000f77e:	d9 a4 10 00 	lea %a4,[%sp]16
8000f782:	d9 a5 24 00 	lea %a5,[%sp]36
8000f786:	6d 00 0d 01 	call 8000f9a0 <__fpcmp_parts_d>
8000f78a:	00 90       	ret 

8000f78c <__nedf2>:
8000f78c:	20 38       	sub.a %sp,56
8000f78e:	40 a4       	mov.aa %a4,%sp
8000f790:	d9 a5 10 00 	lea %a5,[%sp]16
8000f794:	89 a4 40 09 	st.d [%sp],%e4
8000f798:	89 a6 48 09 	st.d [%sp]8,%e6
8000f79c:	6d ff 64 e5 	call 8000c264 <__unpack_d>
8000f7a0:	d9 a4 08 00 	lea %a4,[%sp]8
8000f7a4:	d9 a5 24 00 	lea %a5,[%sp]36
8000f7a8:	6d ff 5e e5 	call 8000c264 <__unpack_d>
8000f7ac:	39 af 10 00 	ld.bu %d15,[%sp]16
8000f7b0:	82 12       	mov %d2,1
8000f7b2:	bf 2f 0c 80 	jlt.u %d15,2,8000f7ca <__nedf2+0x3e>
8000f7b6:	39 af 24 00 	ld.bu %d15,[%sp]36
8000f7ba:	bf 2f 08 80 	jlt.u %d15,2,8000f7ca <__nedf2+0x3e>
8000f7be:	d9 a4 10 00 	lea %a4,[%sp]16
8000f7c2:	d9 a5 24 00 	lea %a5,[%sp]36
8000f7c6:	6d 00 ed 00 	call 8000f9a0 <__fpcmp_parts_d>
8000f7ca:	00 90       	ret 

8000f7cc <__gtdf2>:
8000f7cc:	20 38       	sub.a %sp,56
8000f7ce:	40 a4       	mov.aa %a4,%sp
8000f7d0:	d9 a5 10 00 	lea %a5,[%sp]16
8000f7d4:	89 a4 40 09 	st.d [%sp],%e4
8000f7d8:	89 a6 48 09 	st.d [%sp]8,%e6
8000f7dc:	6d ff 44 e5 	call 8000c264 <__unpack_d>
8000f7e0:	d9 a4 08 00 	lea %a4,[%sp]8
8000f7e4:	d9 a5 24 00 	lea %a5,[%sp]36
8000f7e8:	6d ff 3e e5 	call 8000c264 <__unpack_d>
8000f7ec:	39 af 10 00 	ld.bu %d15,[%sp]16
8000f7f0:	82 f2       	mov %d2,-1
8000f7f2:	bf 2f 0c 80 	jlt.u %d15,2,8000f80a <__gtdf2+0x3e>
8000f7f6:	39 af 24 00 	ld.bu %d15,[%sp]36
8000f7fa:	bf 2f 08 80 	jlt.u %d15,2,8000f80a <__gtdf2+0x3e>
8000f7fe:	d9 a4 10 00 	lea %a4,[%sp]16
8000f802:	d9 a5 24 00 	lea %a5,[%sp]36
8000f806:	6d 00 cd 00 	call 8000f9a0 <__fpcmp_parts_d>
8000f80a:	00 90       	ret 

8000f80c <__gedf2>:
8000f80c:	20 38       	sub.a %sp,56
8000f80e:	40 a4       	mov.aa %a4,%sp
8000f810:	d9 a5 10 00 	lea %a5,[%sp]16
8000f814:	89 a4 40 09 	st.d [%sp],%e4
8000f818:	89 a6 48 09 	st.d [%sp]8,%e6
8000f81c:	6d ff 24 e5 	call 8000c264 <__unpack_d>
8000f820:	d9 a4 08 00 	lea %a4,[%sp]8
8000f824:	d9 a5 24 00 	lea %a5,[%sp]36
8000f828:	6d ff 1e e5 	call 8000c264 <__unpack_d>
8000f82c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000f830:	82 f2       	mov %d2,-1
8000f832:	bf 2f 0c 80 	jlt.u %d15,2,8000f84a <__gedf2+0x3e>
8000f836:	39 af 24 00 	ld.bu %d15,[%sp]36
8000f83a:	bf 2f 08 80 	jlt.u %d15,2,8000f84a <__gedf2+0x3e>
8000f83e:	d9 a4 10 00 	lea %a4,[%sp]16
8000f842:	d9 a5 24 00 	lea %a5,[%sp]36
8000f846:	6d 00 ad 00 	call 8000f9a0 <__fpcmp_parts_d>
8000f84a:	00 90       	ret 

8000f84c <__ltdf2>:
8000f84c:	20 38       	sub.a %sp,56
8000f84e:	40 a4       	mov.aa %a4,%sp
8000f850:	d9 a5 10 00 	lea %a5,[%sp]16
8000f854:	89 a4 40 09 	st.d [%sp],%e4
8000f858:	89 a6 48 09 	st.d [%sp]8,%e6
8000f85c:	6d ff 04 e5 	call 8000c264 <__unpack_d>
8000f860:	d9 a4 08 00 	lea %a4,[%sp]8
8000f864:	d9 a5 24 00 	lea %a5,[%sp]36
8000f868:	6d ff fe e4 	call 8000c264 <__unpack_d>
8000f86c:	39 af 10 00 	ld.bu %d15,[%sp]16
8000f870:	82 12       	mov %d2,1
8000f872:	bf 2f 0c 80 	jlt.u %d15,2,8000f88a <__ltdf2+0x3e>
8000f876:	39 af 24 00 	ld.bu %d15,[%sp]36
8000f87a:	bf 2f 08 80 	jlt.u %d15,2,8000f88a <__ltdf2+0x3e>
8000f87e:	d9 a4 10 00 	lea %a4,[%sp]16
8000f882:	d9 a5 24 00 	lea %a5,[%sp]36
8000f886:	6d 00 8d 00 	call 8000f9a0 <__fpcmp_parts_d>
8000f88a:	00 90       	ret 

8000f88c <__fixdfsi>:
8000f88c:	20 20       	sub.a %sp,32
8000f88e:	d9 a4 20 00 	lea %a4,[%sp]32
8000f892:	89 44 64 f5 	st.d [+%a4]-28,%e4
8000f896:	d9 a5 0c 00 	lea %a5,[%sp]12
8000f89a:	6d ff e5 e4 	call 8000c264 <__unpack_d>
8000f89e:	0c ac       	ld.bu %d15,[%sp]12
8000f8a0:	82 02       	mov %d2,0
8000f8a2:	bf 3f 1b 80 	jlt.u %d15,3,8000f8d8 <__fixdfsi+0x4c>
8000f8a6:	5e 48       	jne %d15,4,8000f8b6 <__fixdfsi+0x2a>
8000f8a8:	7b 00 00 28 	movh %d2,32768
8000f8ac:	58 04       	ld.w %d15,[%sp]16
8000f8ae:	1b f2 ff 3f 	addi %d3,%d2,-1
8000f8b2:	6a 32       	cmovn %d2,%d15,%d3
8000f8b4:	00 90       	ret 
8000f8b6:	19 a6 14 00 	ld.w %d6,[%sp]20
8000f8ba:	82 02       	mov %d2,0
8000f8bc:	0e 6e       	jltz %d6,8000f8d8 <__fixdfsi+0x4c>
8000f8be:	8b f6 81 f2 	ge %d15,%d6,31
8000f8c2:	ee f3       	jnz %d15,8000f8a8 <__fixdfsi+0x1c>
8000f8c4:	09 a4 58 09 	ld.d %e4,[%sp]24
8000f8c8:	8b c6 03 61 	rsub %d6,%d6,60
8000f8cc:	6d ff ca e0 	call 8000ba60 <__lshrdi3>
8000f8d0:	58 04       	ld.w %d15,[%sp]16
8000f8d2:	8b 02 00 41 	rsub %d4,%d2,0
8000f8d6:	2a 42       	cmov %d2,%d15,%d4
8000f8d8:	00 90       	ret 

8000f8da <__udivdi3>:
8000f8da:	0f 67 a0 20 	or %d2,%d7,%d6
8000f8de:	0b 45 10 a8 	mov %e10,%d5,%d4
8000f8e2:	02 6f       	mov %d15,%d6
8000f8e4:	02 7c       	mov %d12,%d7
8000f8e6:	d2 f8       	mov %e8,-1
8000f8e8:	df 02 46 00 	jeq %d2,0,8000f974 <__udivdi3+0x9a>
8000f8ec:	8f 07 40 21 	or %d2,%d7,0
8000f8f0:	f6 2d       	jnz %d2,8000f90a <__udivdi3+0x30>
8000f8f2:	4b 6b 11 82 	div.u %e8,%d11,%d6
8000f8f6:	d2 04       	mov %e4,0
8000f8f8:	02 a4       	mov %d4,%d10
8000f8fa:	42 95       	add %d5,%d9
8000f8fc:	6d 00 a5 00 	call 8000fa46 <__udiv6432>
8000f900:	82 04       	mov %d4,0
8000f902:	02 85       	mov %d5,%d8
8000f904:	13 12 40 84 	madd.u %e8,%e4,%d2,1
8000f908:	3c 36       	j 8000f974 <__udivdi3+0x9a>
8000f90a:	0b 7b 00 21 	eq %d2,%d11,%d7
8000f90e:	0b 64 30 22 	and.lt.u %d2,%d4,%d6
8000f912:	0b 7b a0 22 	or.lt.u %d2,%d11,%d7
8000f916:	d2 08       	mov %e8,0
8000f918:	df 02 2e 80 	jne %d2,0,8000f974 <__udivdi3+0x9a>
8000f91c:	77 4b 80 5f 	dextr %d5,%d11,%d4,31
8000f920:	0f 07 b0 d1 	clz %d13,%d7
8000f924:	60 5f       	mov.a %a15,%d5
8000f926:	0b 67 10 48 	mov %e4,%d7,%d6
8000f92a:	02 d6       	mov %d6,%d13
8000f92c:	6d ff be e3 	call 8000c0a8 <__ashldi3>
8000f930:	8f fb 1f e0 	sh %d14,%d11,-1
8000f934:	80 f4       	mov.d %d4,%a15
8000f936:	02 36       	mov %d6,%d3
8000f938:	02 e5       	mov %d5,%d14
8000f93a:	6d 00 86 00 	call 8000fa46 <__udiv6432>
8000f93e:	8b fd 01 d1 	rsub %d13,%d13,31
8000f942:	8b 0d 00 31 	rsub %d3,%d13,0
8000f946:	0f 32 00 30 	sh %d3,%d2,%d3
8000f94a:	02 32       	mov %d2,%d3
8000f94c:	8b f2 9f 80 	addx %d8,%d2,-1
8000f950:	23 f8 68 aa 	msub.u %e10,%e10,%d8,%d15
8000f954:	82 03       	mov %d3,0
8000f956:	8b f3 bf 90 	addc %d9,%d3,-1
8000f95a:	23 c8 0a bb 	msub %d11,%d11,%d8,%d12
8000f95e:	23 f9 0a bb 	msub %d11,%d11,%d9,%d15
8000f962:	0b cb 00 41 	eq %d4,%d11,%d12
8000f966:	0b fa 30 42 	and.lt.u %d4,%d10,%d15
8000f96a:	0b cb a0 42 	or.lt.u %d4,%d11,%d12
8000f96e:	f6 43       	jnz %d4,8000f974 <__udivdi3+0x9a>
8000f970:	0b 23 10 88 	mov %e8,%d3,%d2
8000f974:	0b 89 10 28 	mov %e2,%d9,%d8
8000f978:	00 90       	ret 

8000f97a <__umoddi3>:
8000f97a:	0f 67 a0 90 	or %d9,%d7,%d6
8000f97e:	02 6f       	mov %d15,%d6
8000f980:	d2 00       	mov %e0,0
8000f982:	76 9c       	jz %d9,8000f99a <__umoddi3+0x20>
8000f984:	02 7a       	mov %d10,%d7
8000f986:	0b 45 10 88 	mov %e8,%d5,%d4
8000f98a:	6d ff a8 ff 	call 8000f8da <__udivdi3>
8000f98e:	23 f2 68 08 	msub.u %e0,%e8,%d2,%d15
8000f992:	23 a2 0a 11 	msub %d1,%d1,%d2,%d10
8000f996:	23 f3 0a 11 	msub %d1,%d1,%d3,%d15
8000f99a:	0b 01 10 28 	mov %e2,%d1,%d0
8000f99e:	00 90       	ret 

8000f9a0 <__fpcmp_parts_d>:
8000f9a0:	14 43       	ld.bu %d3,[%a4]
8000f9a2:	82 12       	mov %d2,1
8000f9a4:	bf 23 50 80 	jlt.u %d3,2,8000fa44 <__fpcmp_parts_d+0xa4>
8000f9a8:	0c 50       	ld.bu %d15,[%a5]0
8000f9aa:	bf 2f 4d 80 	jlt.u %d15,2,8000fa44 <__fpcmp_parts_d+0xa4>
8000f9ae:	8b 43 00 42 	eq %d4,%d3,4
8000f9b2:	8b 4f 00 22 	eq %d2,%d15,4
8000f9b6:	0f 24 80 50 	and %d5,%d4,%d2
8000f9ba:	76 56       	jz %d5,8000f9c6 <__fpcmp_parts_d+0x26>
8000f9bc:	19 52 04 00 	ld.w %d2,[%a5]4
8000f9c0:	4c 41       	ld.w %d15,[%a4]4
8000f9c2:	a2 f2       	sub %d2,%d15
8000f9c4:	00 90       	ret 
8000f9c6:	76 47       	jz %d4,8000f9d4 <__fpcmp_parts_d+0x34>
8000f9c8:	19 42 04 00 	ld.w %d2,[%a4]4
8000f9cc:	82 1f       	mov %d15,1
8000f9ce:	ab ff bf 22 	seln %d2,%d2,%d15,-1
8000f9d2:	00 90       	ret 
8000f9d4:	76 27       	jz %d2,8000f9e2 <__fpcmp_parts_d+0x42>
8000f9d6:	19 52 04 00 	ld.w %d2,[%a5]4
8000f9da:	82 ff       	mov %d15,-1
8000f9dc:	ab 1f a0 22 	seln %d2,%d2,%d15,1
8000f9e0:	00 90       	ret 
8000f9e2:	df 23 06 80 	jne %d3,2,8000f9ee <__fpcmp_parts_d+0x4e>
8000f9e6:	82 02       	mov %d2,0
8000f9e8:	df 2f f7 ff 	jne %d15,2,8000f9d6 <__fpcmp_parts_d+0x36>
8000f9ec:	00 90       	ret 
8000f9ee:	df 2f ed 7f 	jeq %d15,2,8000f9c8 <__fpcmp_parts_d+0x28>
8000f9f2:	19 45 04 00 	ld.w %d5,[%a4]4
8000f9f6:	4c 51       	ld.w %d15,[%a5]4
8000f9f8:	5f f5 19 80 	jne %d5,%d15,8000fa2a <__fpcmp_parts_d+0x8a>
8000f9fc:	19 42 08 00 	ld.w %d2,[%a4]8
8000fa00:	4c 52       	ld.w %d15,[%a5]8
8000fa02:	3f 2f 14 00 	jlt %d15,%d2,8000fa2a <__fpcmp_parts_d+0x8a>
8000fa06:	3f f2 1c 00 	jlt %d2,%d15,8000fa3e <__fpcmp_parts_d+0x9e>
8000fa0a:	19 43 10 00 	ld.w %d3,[%a4]16
8000fa0e:	19 54 10 00 	ld.w %d4,[%a5]16
8000fa12:	19 47 0c 00 	ld.w %d7,[%a4]12
8000fa16:	19 56 0c 00 	ld.w %d6,[%a5]12
8000fa1a:	0b 43 00 21 	eq %d2,%d3,%d4
8000fa1e:	0b 76 50 22 	and.ge.u %d2,%d6,%d7
8000fa22:	0b 43 a0 22 	or.lt.u %d2,%d3,%d4
8000fa26:	3a 43       	eq %d15,%d3,%d4
8000fa28:	f6 25       	jnz %d2,8000fa32 <__fpcmp_parts_d+0x92>
8000fa2a:	82 12       	mov %d2,1
8000fa2c:	ab f2 bf 25 	seln %d2,%d5,%d2,-1
8000fa30:	00 90       	ret 
8000fa32:	0b 67 50 f2 	and.ge.u %d15,%d7,%d6
8000fa36:	0b 34 a0 f2 	or.lt.u %d15,%d4,%d3
8000fa3a:	82 02       	mov %d2,0
8000fa3c:	ee 04       	jnz %d15,8000fa44 <__fpcmp_parts_d+0xa4>
8000fa3e:	82 f2       	mov %d2,-1
8000fa40:	ab 12 a0 25 	seln %d2,%d5,%d2,1
8000fa44:	00 90       	ret 

8000fa46 <__udiv6432>:
8000fa46:	02 53       	mov %d3,%d5
8000fa48:	82 f2       	mov %d2,-1
8000fa4a:	7f 65 4b 80 	jge.u %d5,%d6,8000fae0 <__udiv6432+0x9a>
8000fa4e:	0f 06 b0 21 	clz %d2,%d6
8000fa52:	0f 26 00 60 	sh %d6,%d6,%d2
8000fa56:	17 45 80 52 	dextr %d5,%d5,%d4,%d2
8000fa5a:	2b 35 40 32 	sel %d3,%d2,%d5,%d3
8000fa5e:	8f 06 1f 70 	sh %d7,%d6,-16
8000fa62:	4b 73 11 02 	div.u %e0,%d3,%d7
8000fa66:	b7 06 10 88 	insert %d8,%d6,0,16,16
8000fa6a:	0f 24 00 20 	sh %d2,%d4,%d2
8000fa6e:	02 05       	mov %d5,%d0
8000fa70:	23 07 0a 13 	msub %d1,%d3,%d7,%d0
8000fa74:	e2 80       	mul %d0,%d8
8000fa76:	8f 02 1f b0 	sh %d11,%d2,-16
8000fa7a:	b7 02 10 28 	insert %d2,%d2,0,16,16
8000fa7e:	82 0c       	mov %d12,0
8000fa80:	7b 10 00 90 	movh %d9,1
8000fa84:	7f 95 09 80 	jge.u %d5,%d9,8000fa96 <__udiv6432+0x50>
8000fa88:	8f 01 01 f0 	sh %d15,%d1,16
8000fa8c:	0b 0c 00 a0 	add %d10,%d12,%d0
8000fa90:	42 bf       	add %d15,%d11
8000fa92:	7f af 07 80 	jge.u %d15,%d10,8000faa0 <__udiv6432+0x5a>
8000fa96:	42 71       	add %d1,%d7
8000fa98:	c2 f5       	add %d5,-1
8000fa9a:	a2 8c       	sub %d12,%d8
8000fa9c:	3f 91 f4 ff 	jlt.u %d1,%d9,8000fa84 <__udiv6432+0x3e>
8000faa0:	8f 03 01 30 	sh %d3,%d3,16
8000faa4:	42 3b       	add %d11,%d3
8000faa6:	23 65 0a 6b 	msub %d6,%d11,%d5,%d6
8000faaa:	82 0a       	mov %d10,0
8000faac:	4b 76 11 02 	div.u %e0,%d6,%d7
8000fab0:	7b 10 00 10 	movh %d1,1
8000fab4:	02 03       	mov %d3,%d0
8000fab6:	23 07 0a 66 	msub %d6,%d6,%d7,%d0
8000faba:	e2 80       	mul %d0,%d8
8000fabc:	7f 13 09 80 	jge.u %d3,%d1,8000face <__udiv6432+0x88>
8000fac0:	8f 06 01 f0 	sh %d15,%d6,16
8000fac4:	0b 0a 00 90 	add %d9,%d10,%d0
8000fac8:	42 2f       	add %d15,%d2
8000faca:	7f 9f 07 80 	jge.u %d15,%d9,8000fad8 <__udiv6432+0x92>
8000face:	42 76       	add %d6,%d7
8000fad0:	c2 f3       	add %d3,-1
8000fad2:	a2 8a       	sub %d10,%d8
8000fad4:	3f 16 f4 ff 	jlt.u %d6,%d1,8000fabc <__udiv6432+0x76>
8000fad8:	8f 05 01 50 	sh %d5,%d5,16
8000fadc:	0b 53 00 20 	add %d2,%d3,%d5
8000fae0:	00 90       	ret 
8000fae2:	00 00       	nop 
8000fae4:	00 00       	nop 
	...

Disassembly of section .inttab_cpu1:

80010000 <__INTTAB1>:
	...

80010020 <osEE_tc_core1_isr2_entry_1>:
80010020:	0d 00 00 02 	svlcx 
80010024:	82 f4       	mov %d4,-1
80010026:	1d ff 08 cb 	j 80009636 <osEE_tc_isr2_wrapper>
	...

80010040 <osEE_tc_core1_isr_dummy_entry_2>:
80010040:	3c 00       	j 80010040 <osEE_tc_core1_isr_dummy_entry_2>
	...

80010060 <osEE_tc_core1_isr_dummy_entry_3>:
80010060:	3c 00       	j 80010060 <osEE_tc_core1_isr_dummy_entry_3>
	...

80010080 <osEE_tc_core1_isr_dummy_entry_4>:
80010080:	3c 00       	j 80010080 <osEE_tc_core1_isr_dummy_entry_4>
	...

800100a0 <osEE_tc_core1_isr_dummy_entry_5>:
800100a0:	3c 00       	j 800100a0 <osEE_tc_core1_isr_dummy_entry_5>
	...

800100c0 <osEE_tc_core1_isr_dummy_entry_6>:
800100c0:	3c 00       	j 800100c0 <osEE_tc_core1_isr_dummy_entry_6>
	...

800100e0 <osEE_tc_core1_isr_dummy_entry_7>:
800100e0:	3c 00       	j 800100e0 <osEE_tc_core1_isr_dummy_entry_7>
	...

80010100 <osEE_tc_core1_isr_dummy_entry_8>:
80010100:	3c 00       	j 80010100 <osEE_tc_core1_isr_dummy_entry_8>
	...

80010120 <osEE_tc_core1_isr_dummy_entry_9>:
80010120:	3c 00       	j 80010120 <osEE_tc_core1_isr_dummy_entry_9>
	...

80010140 <osEE_tc_core1_isr_dummy_entry_10>:
80010140:	3c 00       	j 80010140 <osEE_tc_core1_isr_dummy_entry_10>
	...

80010160 <osEE_tc_core1_isr_dummy_entry_11>:
80010160:	3c 00       	j 80010160 <osEE_tc_core1_isr_dummy_entry_11>
	...

80010180 <osEE_tc_core1_isr_dummy_entry_12>:
80010180:	3c 00       	j 80010180 <osEE_tc_core1_isr_dummy_entry_12>
	...

800101a0 <osEE_tc_core1_isr_dummy_entry_13>:
800101a0:	3c 00       	j 800101a0 <osEE_tc_core1_isr_dummy_entry_13>
	...

800101c0 <osEE_tc_core1_isr_dummy_entry_14>:
800101c0:	3c 00       	j 800101c0 <osEE_tc_core1_isr_dummy_entry_14>
	...

800101e0 <osEE_tc_core1_isr_dummy_entry_15>:
800101e0:	3c 00       	j 800101e0 <osEE_tc_core1_isr_dummy_entry_15>
	...

80010200 <osEE_tc_core1_isr_dummy_entry_16>:
80010200:	3c 00       	j 80010200 <osEE_tc_core1_isr_dummy_entry_16>
	...

80010220 <osEE_tc_core1_isr_dummy_entry_17>:
80010220:	3c 00       	j 80010220 <osEE_tc_core1_isr_dummy_entry_17>
	...

80010240 <osEE_tc_core1_isr_dummy_entry_18>:
80010240:	3c 00       	j 80010240 <osEE_tc_core1_isr_dummy_entry_18>
	...

80010260 <osEE_tc_core1_isr_dummy_entry_19>:
80010260:	3c 00       	j 80010260 <osEE_tc_core1_isr_dummy_entry_19>
	...

80010280 <osEE_tc_core1_isr_dummy_entry_20>:
80010280:	3c 00       	j 80010280 <osEE_tc_core1_isr_dummy_entry_20>
	...

800102a0 <osEE_tc_core1_isr_dummy_entry_21>:
800102a0:	3c 00       	j 800102a0 <osEE_tc_core1_isr_dummy_entry_21>
	...

800102c0 <osEE_tc_core1_isr_dummy_entry_22>:
800102c0:	3c 00       	j 800102c0 <osEE_tc_core1_isr_dummy_entry_22>
	...

800102e0 <osEE_tc_core1_isr_dummy_entry_23>:
800102e0:	3c 00       	j 800102e0 <osEE_tc_core1_isr_dummy_entry_23>
	...

80010300 <osEE_tc_core1_isr_dummy_entry_24>:
80010300:	3c 00       	j 80010300 <osEE_tc_core1_isr_dummy_entry_24>
	...

80010320 <osEE_tc_core1_isr_dummy_entry_25>:
80010320:	3c 00       	j 80010320 <osEE_tc_core1_isr_dummy_entry_25>
	...

80010340 <osEE_tc_core1_isr_dummy_entry_26>:
80010340:	3c 00       	j 80010340 <osEE_tc_core1_isr_dummy_entry_26>
	...

80010360 <osEE_tc_core1_isr_dummy_entry_27>:
80010360:	3c 00       	j 80010360 <osEE_tc_core1_isr_dummy_entry_27>
	...

80010380 <osEE_tc_core1_isr_dummy_entry_28>:
80010380:	3c 00       	j 80010380 <osEE_tc_core1_isr_dummy_entry_28>
	...

800103a0 <osEE_tc_core1_isr_dummy_entry_29>:
800103a0:	3c 00       	j 800103a0 <osEE_tc_core1_isr_dummy_entry_29>
	...

800103c0 <osEE_tc_core1_isr_dummy_entry_30>:
800103c0:	3c 00       	j 800103c0 <osEE_tc_core1_isr_dummy_entry_30>
	...

800103e0 <osEE_tc_core1_isr_dummy_entry_31>:
800103e0:	3c 00       	j 800103e0 <osEE_tc_core1_isr_dummy_entry_31>
	...

80010400 <osEE_tc_core1_isr_dummy_entry_32>:
80010400:	3c 00       	j 80010400 <osEE_tc_core1_isr_dummy_entry_32>
	...

80010420 <osEE_tc_core1_isr_dummy_entry_33>:
80010420:	3c 00       	j 80010420 <osEE_tc_core1_isr_dummy_entry_33>
	...

80010440 <osEE_tc_core1_isr_dummy_entry_34>:
80010440:	3c 00       	j 80010440 <osEE_tc_core1_isr_dummy_entry_34>
	...

80010460 <osEE_tc_core1_isr_dummy_entry_35>:
80010460:	3c 00       	j 80010460 <osEE_tc_core1_isr_dummy_entry_35>
	...

80010480 <osEE_tc_core1_isr_dummy_entry_36>:
80010480:	3c 00       	j 80010480 <osEE_tc_core1_isr_dummy_entry_36>
	...

800104a0 <osEE_tc_core1_isr_dummy_entry_37>:
800104a0:	3c 00       	j 800104a0 <osEE_tc_core1_isr_dummy_entry_37>
	...

800104c0 <osEE_tc_core1_isr_dummy_entry_38>:
800104c0:	3c 00       	j 800104c0 <osEE_tc_core1_isr_dummy_entry_38>
	...

800104e0 <osEE_tc_core1_isr_dummy_entry_39>:
800104e0:	3c 00       	j 800104e0 <osEE_tc_core1_isr_dummy_entry_39>
	...

80010500 <osEE_tc_core1_isr_dummy_entry_40>:
80010500:	3c 00       	j 80010500 <osEE_tc_core1_isr_dummy_entry_40>
	...

80010520 <osEE_tc_core1_isr_dummy_entry_41>:
80010520:	3c 00       	j 80010520 <osEE_tc_core1_isr_dummy_entry_41>
	...

80010540 <osEE_tc_core1_isr_dummy_entry_42>:
80010540:	3c 00       	j 80010540 <osEE_tc_core1_isr_dummy_entry_42>
	...

80010560 <osEE_tc_core1_isr_dummy_entry_43>:
80010560:	3c 00       	j 80010560 <osEE_tc_core1_isr_dummy_entry_43>
	...

80010580 <osEE_tc_core1_isr_dummy_entry_44>:
80010580:	3c 00       	j 80010580 <osEE_tc_core1_isr_dummy_entry_44>
	...

800105a0 <osEE_tc_core1_isr_dummy_entry_45>:
800105a0:	3c 00       	j 800105a0 <osEE_tc_core1_isr_dummy_entry_45>
	...

800105c0 <osEE_tc_core1_isr_dummy_entry_46>:
800105c0:	3c 00       	j 800105c0 <osEE_tc_core1_isr_dummy_entry_46>
	...

800105e0 <osEE_tc_core1_isr_dummy_entry_47>:
800105e0:	3c 00       	j 800105e0 <osEE_tc_core1_isr_dummy_entry_47>
	...

80010600 <osEE_tc_core1_isr_dummy_entry_48>:
80010600:	3c 00       	j 80010600 <osEE_tc_core1_isr_dummy_entry_48>
	...

80010620 <osEE_tc_core1_isr_dummy_entry_49>:
80010620:	3c 00       	j 80010620 <osEE_tc_core1_isr_dummy_entry_49>
	...

80010640 <osEE_tc_core1_isr_dummy_entry_50>:
80010640:	3c 00       	j 80010640 <osEE_tc_core1_isr_dummy_entry_50>
	...

80010660 <osEE_tc_core1_isr_dummy_entry_51>:
80010660:	3c 00       	j 80010660 <osEE_tc_core1_isr_dummy_entry_51>
	...

80010680 <osEE_tc_core1_isr_dummy_entry_52>:
80010680:	3c 00       	j 80010680 <osEE_tc_core1_isr_dummy_entry_52>
	...

800106a0 <osEE_tc_core1_isr_dummy_entry_53>:
800106a0:	3c 00       	j 800106a0 <osEE_tc_core1_isr_dummy_entry_53>
	...

800106c0 <osEE_tc_core1_isr_dummy_entry_54>:
800106c0:	3c 00       	j 800106c0 <osEE_tc_core1_isr_dummy_entry_54>
	...

800106e0 <osEE_tc_core1_isr_dummy_entry_55>:
800106e0:	3c 00       	j 800106e0 <osEE_tc_core1_isr_dummy_entry_55>
	...

80010700 <osEE_tc_core1_isr_dummy_entry_56>:
80010700:	3c 00       	j 80010700 <osEE_tc_core1_isr_dummy_entry_56>
	...

80010720 <osEE_tc_core1_isr_dummy_entry_57>:
80010720:	3c 00       	j 80010720 <osEE_tc_core1_isr_dummy_entry_57>
	...

80010740 <osEE_tc_core1_isr_dummy_entry_58>:
80010740:	3c 00       	j 80010740 <osEE_tc_core1_isr_dummy_entry_58>
	...

80010760 <osEE_tc_core1_isr_dummy_entry_59>:
80010760:	3c 00       	j 80010760 <osEE_tc_core1_isr_dummy_entry_59>
	...

80010780 <osEE_tc_core1_isr_dummy_entry_60>:
80010780:	3c 00       	j 80010780 <osEE_tc_core1_isr_dummy_entry_60>
	...

800107a0 <osEE_tc_core1_isr_dummy_entry_61>:
800107a0:	3c 00       	j 800107a0 <osEE_tc_core1_isr_dummy_entry_61>
	...

800107c0 <osEE_tc_core1_isr_dummy_entry_62>:
800107c0:	3c 00       	j 800107c0 <osEE_tc_core1_isr_dummy_entry_62>
	...

800107e0 <osEE_tc_core1_isr_dummy_entry_63>:
800107e0:	3c 00       	j 800107e0 <osEE_tc_core1_isr_dummy_entry_63>
	...

80010800 <osEE_tc_core1_isr_dummy_entry_64>:
80010800:	3c 00       	j 80010800 <osEE_tc_core1_isr_dummy_entry_64>
	...

80010820 <osEE_tc_core1_isr_dummy_entry_65>:
80010820:	3c 00       	j 80010820 <osEE_tc_core1_isr_dummy_entry_65>
	...

80010840 <osEE_tc_core1_isr_dummy_entry_66>:
80010840:	3c 00       	j 80010840 <osEE_tc_core1_isr_dummy_entry_66>
	...

80010860 <osEE_tc_core1_isr_dummy_entry_67>:
80010860:	3c 00       	j 80010860 <osEE_tc_core1_isr_dummy_entry_67>
	...

80010880 <osEE_tc_core1_isr_dummy_entry_68>:
80010880:	3c 00       	j 80010880 <osEE_tc_core1_isr_dummy_entry_68>
	...

800108a0 <osEE_tc_core1_isr_dummy_entry_69>:
800108a0:	3c 00       	j 800108a0 <osEE_tc_core1_isr_dummy_entry_69>
	...

800108c0 <osEE_tc_core1_isr_dummy_entry_70>:
800108c0:	3c 00       	j 800108c0 <osEE_tc_core1_isr_dummy_entry_70>
	...

800108e0 <osEE_tc_core1_isr_dummy_entry_71>:
800108e0:	3c 00       	j 800108e0 <osEE_tc_core1_isr_dummy_entry_71>
	...

80010900 <osEE_tc_core1_isr_dummy_entry_72>:
80010900:	3c 00       	j 80010900 <osEE_tc_core1_isr_dummy_entry_72>
	...

80010920 <osEE_tc_core1_isr_dummy_entry_73>:
80010920:	3c 00       	j 80010920 <osEE_tc_core1_isr_dummy_entry_73>
	...

80010940 <osEE_tc_core1_isr_dummy_entry_74>:
80010940:	3c 00       	j 80010940 <osEE_tc_core1_isr_dummy_entry_74>
	...

80010960 <osEE_tc_core1_isr_dummy_entry_75>:
80010960:	3c 00       	j 80010960 <osEE_tc_core1_isr_dummy_entry_75>
	...

80010980 <osEE_tc_core1_isr_dummy_entry_76>:
80010980:	3c 00       	j 80010980 <osEE_tc_core1_isr_dummy_entry_76>
	...

800109a0 <osEE_tc_core1_isr_dummy_entry_77>:
800109a0:	3c 00       	j 800109a0 <osEE_tc_core1_isr_dummy_entry_77>
	...

800109c0 <osEE_tc_core1_isr_dummy_entry_78>:
800109c0:	3c 00       	j 800109c0 <osEE_tc_core1_isr_dummy_entry_78>
	...

800109e0 <osEE_tc_core1_isr_dummy_entry_79>:
800109e0:	3c 00       	j 800109e0 <osEE_tc_core1_isr_dummy_entry_79>
	...

80010a00 <osEE_tc_core1_isr_dummy_entry_80>:
80010a00:	3c 00       	j 80010a00 <osEE_tc_core1_isr_dummy_entry_80>
	...

80010a20 <osEE_tc_core1_isr_dummy_entry_81>:
80010a20:	3c 00       	j 80010a20 <osEE_tc_core1_isr_dummy_entry_81>
	...

80010a40 <osEE_tc_core1_isr_dummy_entry_82>:
80010a40:	3c 00       	j 80010a40 <osEE_tc_core1_isr_dummy_entry_82>
	...

80010a60 <osEE_tc_core1_isr_dummy_entry_83>:
80010a60:	3c 00       	j 80010a60 <osEE_tc_core1_isr_dummy_entry_83>
	...

80010a80 <osEE_tc_core1_isr_dummy_entry_84>:
80010a80:	3c 00       	j 80010a80 <osEE_tc_core1_isr_dummy_entry_84>
	...

80010aa0 <osEE_tc_core1_isr_dummy_entry_85>:
80010aa0:	3c 00       	j 80010aa0 <osEE_tc_core1_isr_dummy_entry_85>
	...

80010ac0 <osEE_tc_core1_isr_dummy_entry_86>:
80010ac0:	3c 00       	j 80010ac0 <osEE_tc_core1_isr_dummy_entry_86>
	...

80010ae0 <osEE_tc_core1_isr_dummy_entry_87>:
80010ae0:	3c 00       	j 80010ae0 <osEE_tc_core1_isr_dummy_entry_87>
	...

80010b00 <osEE_tc_core1_isr_dummy_entry_88>:
80010b00:	3c 00       	j 80010b00 <osEE_tc_core1_isr_dummy_entry_88>
	...

80010b20 <osEE_tc_core1_isr_dummy_entry_89>:
80010b20:	3c 00       	j 80010b20 <osEE_tc_core1_isr_dummy_entry_89>
	...

80010b40 <osEE_tc_core1_isr_dummy_entry_90>:
80010b40:	3c 00       	j 80010b40 <osEE_tc_core1_isr_dummy_entry_90>
	...

80010b60 <osEE_tc_core1_isr_dummy_entry_91>:
80010b60:	3c 00       	j 80010b60 <osEE_tc_core1_isr_dummy_entry_91>
	...

80010b80 <osEE_tc_core1_isr_dummy_entry_92>:
80010b80:	3c 00       	j 80010b80 <osEE_tc_core1_isr_dummy_entry_92>
	...

80010ba0 <osEE_tc_core1_isr_dummy_entry_93>:
80010ba0:	3c 00       	j 80010ba0 <osEE_tc_core1_isr_dummy_entry_93>
	...

80010bc0 <osEE_tc_core1_isr_dummy_entry_94>:
80010bc0:	3c 00       	j 80010bc0 <osEE_tc_core1_isr_dummy_entry_94>
	...

80010be0 <osEE_tc_core1_isr_dummy_entry_95>:
80010be0:	3c 00       	j 80010be0 <osEE_tc_core1_isr_dummy_entry_95>
	...

80010c00 <osEE_tc_core1_isr_dummy_entry_96>:
80010c00:	3c 00       	j 80010c00 <osEE_tc_core1_isr_dummy_entry_96>
	...

80010c20 <osEE_tc_core1_isr_dummy_entry_97>:
80010c20:	3c 00       	j 80010c20 <osEE_tc_core1_isr_dummy_entry_97>
	...

80010c40 <osEE_tc_core1_isr_dummy_entry_98>:
80010c40:	3c 00       	j 80010c40 <osEE_tc_core1_isr_dummy_entry_98>
	...

80010c60 <osEE_tc_core1_isr_dummy_entry_99>:
80010c60:	3c 00       	j 80010c60 <osEE_tc_core1_isr_dummy_entry_99>
	...

80010c80 <osEE_tc_core1_isr_dummy_entry_100>:
80010c80:	3c 00       	j 80010c80 <osEE_tc_core1_isr_dummy_entry_100>
	...

80010ca0 <osEE_tc_core1_isr_dummy_entry_101>:
80010ca0:	3c 00       	j 80010ca0 <osEE_tc_core1_isr_dummy_entry_101>
	...

80010cc0 <osEE_tc_core1_isr_dummy_entry_102>:
80010cc0:	3c 00       	j 80010cc0 <osEE_tc_core1_isr_dummy_entry_102>
	...

80010ce0 <osEE_tc_core1_isr_dummy_entry_103>:
80010ce0:	3c 00       	j 80010ce0 <osEE_tc_core1_isr_dummy_entry_103>
	...

80010d00 <osEE_tc_core1_isr_dummy_entry_104>:
80010d00:	3c 00       	j 80010d00 <osEE_tc_core1_isr_dummy_entry_104>
	...

80010d20 <osEE_tc_core1_isr_dummy_entry_105>:
80010d20:	3c 00       	j 80010d20 <osEE_tc_core1_isr_dummy_entry_105>
	...

80010d40 <osEE_tc_core1_isr_dummy_entry_106>:
80010d40:	3c 00       	j 80010d40 <osEE_tc_core1_isr_dummy_entry_106>
	...

80010d60 <osEE_tc_core1_isr_dummy_entry_107>:
80010d60:	3c 00       	j 80010d60 <osEE_tc_core1_isr_dummy_entry_107>
	...

80010d80 <osEE_tc_core1_isr_dummy_entry_108>:
80010d80:	3c 00       	j 80010d80 <osEE_tc_core1_isr_dummy_entry_108>
	...

80010da0 <osEE_tc_core1_isr_dummy_entry_109>:
80010da0:	3c 00       	j 80010da0 <osEE_tc_core1_isr_dummy_entry_109>
	...

80010dc0 <osEE_tc_core1_isr_dummy_entry_110>:
80010dc0:	3c 00       	j 80010dc0 <osEE_tc_core1_isr_dummy_entry_110>
	...

80010de0 <osEE_tc_core1_isr_dummy_entry_111>:
80010de0:	3c 00       	j 80010de0 <osEE_tc_core1_isr_dummy_entry_111>
	...

80010e00 <osEE_tc_core1_isr_dummy_entry_112>:
80010e00:	3c 00       	j 80010e00 <osEE_tc_core1_isr_dummy_entry_112>
	...

80010e20 <osEE_tc_core1_isr_dummy_entry_113>:
80010e20:	3c 00       	j 80010e20 <osEE_tc_core1_isr_dummy_entry_113>
	...

80010e40 <osEE_tc_core1_isr_dummy_entry_114>:
80010e40:	3c 00       	j 80010e40 <osEE_tc_core1_isr_dummy_entry_114>
	...

80010e60 <osEE_tc_core1_isr_dummy_entry_115>:
80010e60:	3c 00       	j 80010e60 <osEE_tc_core1_isr_dummy_entry_115>
	...

80010e80 <osEE_tc_core1_isr_dummy_entry_116>:
80010e80:	3c 00       	j 80010e80 <osEE_tc_core1_isr_dummy_entry_116>
	...

80010ea0 <osEE_tc_core1_isr_dummy_entry_117>:
80010ea0:	3c 00       	j 80010ea0 <osEE_tc_core1_isr_dummy_entry_117>
	...

80010ec0 <osEE_tc_core1_isr_dummy_entry_118>:
80010ec0:	3c 00       	j 80010ec0 <osEE_tc_core1_isr_dummy_entry_118>
	...

80010ee0 <osEE_tc_core1_isr_dummy_entry_119>:
80010ee0:	3c 00       	j 80010ee0 <osEE_tc_core1_isr_dummy_entry_119>
	...

80010f00 <osEE_tc_core1_isr_dummy_entry_120>:
80010f00:	3c 00       	j 80010f00 <osEE_tc_core1_isr_dummy_entry_120>
	...

80010f20 <osEE_tc_core1_isr_dummy_entry_121>:
80010f20:	3c 00       	j 80010f20 <osEE_tc_core1_isr_dummy_entry_121>
	...

80010f40 <osEE_tc_core1_isr_dummy_entry_122>:
80010f40:	3c 00       	j 80010f40 <osEE_tc_core1_isr_dummy_entry_122>
	...

80010f60 <osEE_tc_core1_isr_dummy_entry_123>:
80010f60:	3c 00       	j 80010f60 <osEE_tc_core1_isr_dummy_entry_123>
	...

80010f80 <osEE_tc_core1_isr_dummy_entry_124>:
80010f80:	3c 00       	j 80010f80 <osEE_tc_core1_isr_dummy_entry_124>
	...

80010fa0 <osEE_tc_core1_isr_dummy_entry_125>:
80010fa0:	3c 00       	j 80010fa0 <osEE_tc_core1_isr_dummy_entry_125>
	...

80010fc0 <osEE_tc_core1_isr_dummy_entry_126>:
80010fc0:	3c 00       	j 80010fc0 <osEE_tc_core1_isr_dummy_entry_126>
	...

80010fe0 <osEE_tc_core1_isr_dummy_entry_127>:
80010fe0:	3c 00       	j 80010fe0 <osEE_tc_core1_isr_dummy_entry_127>
	...

80011000 <osEE_tc_core1_isr_dummy_entry_128>:
80011000:	3c 00       	j 80011000 <osEE_tc_core1_isr_dummy_entry_128>
	...

80011020 <osEE_tc_core1_isr_dummy_entry_129>:
80011020:	3c 00       	j 80011020 <osEE_tc_core1_isr_dummy_entry_129>
	...

80011040 <osEE_tc_core1_isr_dummy_entry_130>:
80011040:	3c 00       	j 80011040 <osEE_tc_core1_isr_dummy_entry_130>
	...

80011060 <osEE_tc_core1_isr_dummy_entry_131>:
80011060:	3c 00       	j 80011060 <osEE_tc_core1_isr_dummy_entry_131>
	...

80011080 <osEE_tc_core1_isr_dummy_entry_132>:
80011080:	3c 00       	j 80011080 <osEE_tc_core1_isr_dummy_entry_132>
	...

800110a0 <osEE_tc_core1_isr_dummy_entry_133>:
800110a0:	3c 00       	j 800110a0 <osEE_tc_core1_isr_dummy_entry_133>
	...

800110c0 <osEE_tc_core1_isr_dummy_entry_134>:
800110c0:	3c 00       	j 800110c0 <osEE_tc_core1_isr_dummy_entry_134>
	...

800110e0 <osEE_tc_core1_isr_dummy_entry_135>:
800110e0:	3c 00       	j 800110e0 <osEE_tc_core1_isr_dummy_entry_135>
	...

80011100 <osEE_tc_core1_isr_dummy_entry_136>:
80011100:	3c 00       	j 80011100 <osEE_tc_core1_isr_dummy_entry_136>
	...

80011120 <osEE_tc_core1_isr_dummy_entry_137>:
80011120:	3c 00       	j 80011120 <osEE_tc_core1_isr_dummy_entry_137>
	...

80011140 <osEE_tc_core1_isr_dummy_entry_138>:
80011140:	3c 00       	j 80011140 <osEE_tc_core1_isr_dummy_entry_138>
	...

80011160 <osEE_tc_core1_isr_dummy_entry_139>:
80011160:	3c 00       	j 80011160 <osEE_tc_core1_isr_dummy_entry_139>
	...

80011180 <osEE_tc_core1_isr_dummy_entry_140>:
80011180:	3c 00       	j 80011180 <osEE_tc_core1_isr_dummy_entry_140>
	...

800111a0 <osEE_tc_core1_isr_dummy_entry_141>:
800111a0:	3c 00       	j 800111a0 <osEE_tc_core1_isr_dummy_entry_141>
	...

800111c0 <osEE_tc_core1_isr_dummy_entry_142>:
800111c0:	3c 00       	j 800111c0 <osEE_tc_core1_isr_dummy_entry_142>
	...

800111e0 <osEE_tc_core1_isr_dummy_entry_143>:
800111e0:	3c 00       	j 800111e0 <osEE_tc_core1_isr_dummy_entry_143>
	...

80011200 <osEE_tc_core1_isr_dummy_entry_144>:
80011200:	3c 00       	j 80011200 <osEE_tc_core1_isr_dummy_entry_144>
	...

80011220 <osEE_tc_core1_isr_dummy_entry_145>:
80011220:	3c 00       	j 80011220 <osEE_tc_core1_isr_dummy_entry_145>
	...

80011240 <osEE_tc_core1_isr_dummy_entry_146>:
80011240:	3c 00       	j 80011240 <osEE_tc_core1_isr_dummy_entry_146>
	...

80011260 <osEE_tc_core1_isr_dummy_entry_147>:
80011260:	3c 00       	j 80011260 <osEE_tc_core1_isr_dummy_entry_147>
	...

80011280 <osEE_tc_core1_isr_dummy_entry_148>:
80011280:	3c 00       	j 80011280 <osEE_tc_core1_isr_dummy_entry_148>
	...

800112a0 <osEE_tc_core1_isr_dummy_entry_149>:
800112a0:	3c 00       	j 800112a0 <osEE_tc_core1_isr_dummy_entry_149>
	...

800112c0 <osEE_tc_core1_isr_dummy_entry_150>:
800112c0:	3c 00       	j 800112c0 <osEE_tc_core1_isr_dummy_entry_150>
	...

800112e0 <osEE_tc_core1_isr_dummy_entry_151>:
800112e0:	3c 00       	j 800112e0 <osEE_tc_core1_isr_dummy_entry_151>
	...

80011300 <osEE_tc_core1_isr_dummy_entry_152>:
80011300:	3c 00       	j 80011300 <osEE_tc_core1_isr_dummy_entry_152>
	...

80011320 <osEE_tc_core1_isr_dummy_entry_153>:
80011320:	3c 00       	j 80011320 <osEE_tc_core1_isr_dummy_entry_153>
	...

80011340 <osEE_tc_core1_isr_dummy_entry_154>:
80011340:	3c 00       	j 80011340 <osEE_tc_core1_isr_dummy_entry_154>
	...

80011360 <osEE_tc_core1_isr_dummy_entry_155>:
80011360:	3c 00       	j 80011360 <osEE_tc_core1_isr_dummy_entry_155>
	...

80011380 <osEE_tc_core1_isr_dummy_entry_156>:
80011380:	3c 00       	j 80011380 <osEE_tc_core1_isr_dummy_entry_156>
	...

800113a0 <osEE_tc_core1_isr_dummy_entry_157>:
800113a0:	3c 00       	j 800113a0 <osEE_tc_core1_isr_dummy_entry_157>
	...

800113c0 <osEE_tc_core1_isr_dummy_entry_158>:
800113c0:	3c 00       	j 800113c0 <osEE_tc_core1_isr_dummy_entry_158>
	...

800113e0 <osEE_tc_core1_isr_dummy_entry_159>:
800113e0:	3c 00       	j 800113e0 <osEE_tc_core1_isr_dummy_entry_159>
	...

80011400 <osEE_tc_core1_isr_dummy_entry_160>:
80011400:	3c 00       	j 80011400 <osEE_tc_core1_isr_dummy_entry_160>
	...

80011420 <osEE_tc_core1_isr_dummy_entry_161>:
80011420:	3c 00       	j 80011420 <osEE_tc_core1_isr_dummy_entry_161>
	...

80011440 <osEE_tc_core1_isr_dummy_entry_162>:
80011440:	3c 00       	j 80011440 <osEE_tc_core1_isr_dummy_entry_162>
	...

80011460 <osEE_tc_core1_isr_dummy_entry_163>:
80011460:	3c 00       	j 80011460 <osEE_tc_core1_isr_dummy_entry_163>
	...

80011480 <osEE_tc_core1_isr_dummy_entry_164>:
80011480:	3c 00       	j 80011480 <osEE_tc_core1_isr_dummy_entry_164>
	...

800114a0 <osEE_tc_core1_isr_dummy_entry_165>:
800114a0:	3c 00       	j 800114a0 <osEE_tc_core1_isr_dummy_entry_165>
	...

800114c0 <osEE_tc_core1_isr_dummy_entry_166>:
800114c0:	3c 00       	j 800114c0 <osEE_tc_core1_isr_dummy_entry_166>
	...

800114e0 <osEE_tc_core1_isr_dummy_entry_167>:
800114e0:	3c 00       	j 800114e0 <osEE_tc_core1_isr_dummy_entry_167>
	...

80011500 <osEE_tc_core1_isr_dummy_entry_168>:
80011500:	3c 00       	j 80011500 <osEE_tc_core1_isr_dummy_entry_168>
	...

80011520 <osEE_tc_core1_isr_dummy_entry_169>:
80011520:	3c 00       	j 80011520 <osEE_tc_core1_isr_dummy_entry_169>
	...

80011540 <osEE_tc_core1_isr_dummy_entry_170>:
80011540:	3c 00       	j 80011540 <osEE_tc_core1_isr_dummy_entry_170>
	...

80011560 <osEE_tc_core1_isr_dummy_entry_171>:
80011560:	3c 00       	j 80011560 <osEE_tc_core1_isr_dummy_entry_171>
	...

80011580 <osEE_tc_core1_isr_dummy_entry_172>:
80011580:	3c 00       	j 80011580 <osEE_tc_core1_isr_dummy_entry_172>
	...

800115a0 <osEE_tc_core1_isr_dummy_entry_173>:
800115a0:	3c 00       	j 800115a0 <osEE_tc_core1_isr_dummy_entry_173>
	...

800115c0 <osEE_tc_core1_isr_dummy_entry_174>:
800115c0:	3c 00       	j 800115c0 <osEE_tc_core1_isr_dummy_entry_174>
	...

800115e0 <osEE_tc_core1_isr_dummy_entry_175>:
800115e0:	3c 00       	j 800115e0 <osEE_tc_core1_isr_dummy_entry_175>
	...

80011600 <osEE_tc_core1_isr_dummy_entry_176>:
80011600:	3c 00       	j 80011600 <osEE_tc_core1_isr_dummy_entry_176>
	...

80011620 <osEE_tc_core1_isr_dummy_entry_177>:
80011620:	3c 00       	j 80011620 <osEE_tc_core1_isr_dummy_entry_177>
	...

80011640 <osEE_tc_core1_isr_dummy_entry_178>:
80011640:	3c 00       	j 80011640 <osEE_tc_core1_isr_dummy_entry_178>
	...

80011660 <osEE_tc_core1_isr_dummy_entry_179>:
80011660:	3c 00       	j 80011660 <osEE_tc_core1_isr_dummy_entry_179>
	...

80011680 <osEE_tc_core1_isr_dummy_entry_180>:
80011680:	3c 00       	j 80011680 <osEE_tc_core1_isr_dummy_entry_180>
	...

800116a0 <osEE_tc_core1_isr_dummy_entry_181>:
800116a0:	3c 00       	j 800116a0 <osEE_tc_core1_isr_dummy_entry_181>
	...

800116c0 <osEE_tc_core1_isr_dummy_entry_182>:
800116c0:	3c 00       	j 800116c0 <osEE_tc_core1_isr_dummy_entry_182>
	...

800116e0 <osEE_tc_core1_isr_dummy_entry_183>:
800116e0:	3c 00       	j 800116e0 <osEE_tc_core1_isr_dummy_entry_183>
	...

80011700 <osEE_tc_core1_isr_dummy_entry_184>:
80011700:	3c 00       	j 80011700 <osEE_tc_core1_isr_dummy_entry_184>
	...

80011720 <osEE_tc_core1_isr_dummy_entry_185>:
80011720:	3c 00       	j 80011720 <osEE_tc_core1_isr_dummy_entry_185>
	...

80011740 <osEE_tc_core1_isr_dummy_entry_186>:
80011740:	3c 00       	j 80011740 <osEE_tc_core1_isr_dummy_entry_186>
	...

80011760 <osEE_tc_core1_isr_dummy_entry_187>:
80011760:	3c 00       	j 80011760 <osEE_tc_core1_isr_dummy_entry_187>
	...

80011780 <osEE_tc_core1_isr_dummy_entry_188>:
80011780:	3c 00       	j 80011780 <osEE_tc_core1_isr_dummy_entry_188>
	...

800117a0 <osEE_tc_core1_isr_dummy_entry_189>:
800117a0:	3c 00       	j 800117a0 <osEE_tc_core1_isr_dummy_entry_189>
	...

800117c0 <osEE_tc_core1_isr_dummy_entry_190>:
800117c0:	3c 00       	j 800117c0 <osEE_tc_core1_isr_dummy_entry_190>
	...

800117e0 <osEE_tc_core1_isr_dummy_entry_191>:
800117e0:	3c 00       	j 800117e0 <osEE_tc_core1_isr_dummy_entry_191>
	...

80011800 <osEE_tc_core1_isr_dummy_entry_192>:
80011800:	3c 00       	j 80011800 <osEE_tc_core1_isr_dummy_entry_192>
	...

80011820 <osEE_tc_core1_isr_dummy_entry_193>:
80011820:	3c 00       	j 80011820 <osEE_tc_core1_isr_dummy_entry_193>
	...

80011840 <osEE_tc_core1_isr_dummy_entry_194>:
80011840:	3c 00       	j 80011840 <osEE_tc_core1_isr_dummy_entry_194>
	...

80011860 <osEE_tc_core1_isr_dummy_entry_195>:
80011860:	3c 00       	j 80011860 <osEE_tc_core1_isr_dummy_entry_195>
	...

80011880 <osEE_tc_core1_isr_dummy_entry_196>:
80011880:	3c 00       	j 80011880 <osEE_tc_core1_isr_dummy_entry_196>
	...

800118a0 <osEE_tc_core1_isr_dummy_entry_197>:
800118a0:	3c 00       	j 800118a0 <osEE_tc_core1_isr_dummy_entry_197>
	...

800118c0 <osEE_tc_core1_isr_dummy_entry_198>:
800118c0:	3c 00       	j 800118c0 <osEE_tc_core1_isr_dummy_entry_198>
	...

800118e0 <osEE_tc_core1_isr_dummy_entry_199>:
800118e0:	3c 00       	j 800118e0 <osEE_tc_core1_isr_dummy_entry_199>
	...

80011900 <osEE_tc_core1_isr_dummy_entry_200>:
80011900:	3c 00       	j 80011900 <osEE_tc_core1_isr_dummy_entry_200>
	...

80011920 <osEE_tc_core1_isr_dummy_entry_201>:
80011920:	3c 00       	j 80011920 <osEE_tc_core1_isr_dummy_entry_201>
	...

80011940 <osEE_tc_core1_isr_dummy_entry_202>:
80011940:	3c 00       	j 80011940 <osEE_tc_core1_isr_dummy_entry_202>
	...

80011960 <osEE_tc_core1_isr_dummy_entry_203>:
80011960:	3c 00       	j 80011960 <osEE_tc_core1_isr_dummy_entry_203>
	...

80011980 <osEE_tc_core1_isr_dummy_entry_204>:
80011980:	3c 00       	j 80011980 <osEE_tc_core1_isr_dummy_entry_204>
	...

800119a0 <osEE_tc_core1_isr_dummy_entry_205>:
800119a0:	3c 00       	j 800119a0 <osEE_tc_core1_isr_dummy_entry_205>
	...

800119c0 <osEE_tc_core1_isr_dummy_entry_206>:
800119c0:	3c 00       	j 800119c0 <osEE_tc_core1_isr_dummy_entry_206>
	...

800119e0 <osEE_tc_core1_isr_dummy_entry_207>:
800119e0:	3c 00       	j 800119e0 <osEE_tc_core1_isr_dummy_entry_207>
	...

80011a00 <osEE_tc_core1_isr_dummy_entry_208>:
80011a00:	3c 00       	j 80011a00 <osEE_tc_core1_isr_dummy_entry_208>
	...

80011a20 <osEE_tc_core1_isr_dummy_entry_209>:
80011a20:	3c 00       	j 80011a20 <osEE_tc_core1_isr_dummy_entry_209>
	...

80011a40 <osEE_tc_core1_isr_dummy_entry_210>:
80011a40:	3c 00       	j 80011a40 <osEE_tc_core1_isr_dummy_entry_210>
	...

80011a60 <osEE_tc_core1_isr_dummy_entry_211>:
80011a60:	3c 00       	j 80011a60 <osEE_tc_core1_isr_dummy_entry_211>
	...

80011a80 <osEE_tc_core1_isr_dummy_entry_212>:
80011a80:	3c 00       	j 80011a80 <osEE_tc_core1_isr_dummy_entry_212>
	...

80011aa0 <osEE_tc_core1_isr_dummy_entry_213>:
80011aa0:	3c 00       	j 80011aa0 <osEE_tc_core1_isr_dummy_entry_213>
	...

80011ac0 <osEE_tc_core1_isr_dummy_entry_214>:
80011ac0:	3c 00       	j 80011ac0 <osEE_tc_core1_isr_dummy_entry_214>
	...

80011ae0 <osEE_tc_core1_isr_dummy_entry_215>:
80011ae0:	3c 00       	j 80011ae0 <osEE_tc_core1_isr_dummy_entry_215>
	...

80011b00 <osEE_tc_core1_isr_dummy_entry_216>:
80011b00:	3c 00       	j 80011b00 <osEE_tc_core1_isr_dummy_entry_216>
	...

80011b20 <osEE_tc_core1_isr_dummy_entry_217>:
80011b20:	3c 00       	j 80011b20 <osEE_tc_core1_isr_dummy_entry_217>
	...

80011b40 <osEE_tc_core1_isr_dummy_entry_218>:
80011b40:	3c 00       	j 80011b40 <osEE_tc_core1_isr_dummy_entry_218>
	...

80011b60 <osEE_tc_core1_isr_dummy_entry_219>:
80011b60:	3c 00       	j 80011b60 <osEE_tc_core1_isr_dummy_entry_219>
	...

80011b80 <osEE_tc_core1_isr_dummy_entry_220>:
80011b80:	3c 00       	j 80011b80 <osEE_tc_core1_isr_dummy_entry_220>
	...

80011ba0 <osEE_tc_core1_isr_dummy_entry_221>:
80011ba0:	3c 00       	j 80011ba0 <osEE_tc_core1_isr_dummy_entry_221>
	...

80011bc0 <osEE_tc_core1_isr_dummy_entry_222>:
80011bc0:	3c 00       	j 80011bc0 <osEE_tc_core1_isr_dummy_entry_222>
	...

80011be0 <osEE_tc_core1_isr_dummy_entry_223>:
80011be0:	3c 00       	j 80011be0 <osEE_tc_core1_isr_dummy_entry_223>
	...

80011c00 <osEE_tc_core1_isr_dummy_entry_224>:
80011c00:	3c 00       	j 80011c00 <osEE_tc_core1_isr_dummy_entry_224>
	...

80011c20 <osEE_tc_core1_isr_dummy_entry_225>:
80011c20:	3c 00       	j 80011c20 <osEE_tc_core1_isr_dummy_entry_225>
	...

80011c40 <osEE_tc_core1_isr_dummy_entry_226>:
80011c40:	3c 00       	j 80011c40 <osEE_tc_core1_isr_dummy_entry_226>
	...

80011c60 <osEE_tc_core1_isr_dummy_entry_227>:
80011c60:	3c 00       	j 80011c60 <osEE_tc_core1_isr_dummy_entry_227>
	...

80011c80 <osEE_tc_core1_isr_dummy_entry_228>:
80011c80:	3c 00       	j 80011c80 <osEE_tc_core1_isr_dummy_entry_228>
	...

80011ca0 <osEE_tc_core1_isr_dummy_entry_229>:
80011ca0:	3c 00       	j 80011ca0 <osEE_tc_core1_isr_dummy_entry_229>
	...

80011cc0 <osEE_tc_core1_isr_dummy_entry_230>:
80011cc0:	3c 00       	j 80011cc0 <osEE_tc_core1_isr_dummy_entry_230>
	...

80011ce0 <osEE_tc_core1_isr_dummy_entry_231>:
80011ce0:	3c 00       	j 80011ce0 <osEE_tc_core1_isr_dummy_entry_231>
	...

80011d00 <osEE_tc_core1_isr_dummy_entry_232>:
80011d00:	3c 00       	j 80011d00 <osEE_tc_core1_isr_dummy_entry_232>
	...

80011d20 <osEE_tc_core1_isr_dummy_entry_233>:
80011d20:	3c 00       	j 80011d20 <osEE_tc_core1_isr_dummy_entry_233>
	...

80011d40 <osEE_tc_core1_isr_dummy_entry_234>:
80011d40:	3c 00       	j 80011d40 <osEE_tc_core1_isr_dummy_entry_234>
	...

80011d60 <osEE_tc_core1_isr_dummy_entry_235>:
80011d60:	3c 00       	j 80011d60 <osEE_tc_core1_isr_dummy_entry_235>
	...

80011d80 <osEE_tc_core1_isr_dummy_entry_236>:
80011d80:	3c 00       	j 80011d80 <osEE_tc_core1_isr_dummy_entry_236>
	...

80011da0 <osEE_tc_core1_isr_dummy_entry_237>:
80011da0:	3c 00       	j 80011da0 <osEE_tc_core1_isr_dummy_entry_237>
	...

80011dc0 <osEE_tc_core1_isr_dummy_entry_238>:
80011dc0:	3c 00       	j 80011dc0 <osEE_tc_core1_isr_dummy_entry_238>
	...

80011de0 <osEE_tc_core1_isr_dummy_entry_239>:
80011de0:	3c 00       	j 80011de0 <osEE_tc_core1_isr_dummy_entry_239>
	...

80011e00 <osEE_tc_core1_isr_dummy_entry_240>:
80011e00:	3c 00       	j 80011e00 <osEE_tc_core1_isr_dummy_entry_240>
	...

80011e20 <osEE_tc_core1_isr_dummy_entry_241>:
80011e20:	3c 00       	j 80011e20 <osEE_tc_core1_isr_dummy_entry_241>
	...

80011e40 <osEE_tc_core1_isr_dummy_entry_242>:
80011e40:	3c 00       	j 80011e40 <osEE_tc_core1_isr_dummy_entry_242>
	...

80011e60 <osEE_tc_core1_isr_dummy_entry_243>:
80011e60:	3c 00       	j 80011e60 <osEE_tc_core1_isr_dummy_entry_243>
	...

80011e80 <osEE_tc_core1_isr_dummy_entry_244>:
80011e80:	3c 00       	j 80011e80 <osEE_tc_core1_isr_dummy_entry_244>
	...

80011ea0 <osEE_tc_core1_isr_dummy_entry_245>:
80011ea0:	3c 00       	j 80011ea0 <osEE_tc_core1_isr_dummy_entry_245>
	...

80011ec0 <osEE_tc_core1_isr_dummy_entry_246>:
80011ec0:	3c 00       	j 80011ec0 <osEE_tc_core1_isr_dummy_entry_246>
	...

80011ee0 <osEE_tc_core1_isr_dummy_entry_247>:
80011ee0:	3c 00       	j 80011ee0 <osEE_tc_core1_isr_dummy_entry_247>
	...

80011f00 <osEE_tc_core1_isr_dummy_entry_248>:
80011f00:	3c 00       	j 80011f00 <osEE_tc_core1_isr_dummy_entry_248>
	...

80011f20 <osEE_tc_core1_isr_dummy_entry_249>:
80011f20:	3c 00       	j 80011f20 <osEE_tc_core1_isr_dummy_entry_249>
	...

80011f40 <osEE_tc_core1_isr_dummy_entry_250>:
80011f40:	3c 00       	j 80011f40 <osEE_tc_core1_isr_dummy_entry_250>
	...

80011f60 <osEE_tc_core1_isr_dummy_entry_251>:
80011f60:	3c 00       	j 80011f60 <osEE_tc_core1_isr_dummy_entry_251>
	...

80011f80 <osEE_tc_core1_isr_dummy_entry_252>:
80011f80:	3c 00       	j 80011f80 <osEE_tc_core1_isr_dummy_entry_252>
	...

80011fa0 <osEE_tc_core1_isr_dummy_entry_253>:
80011fa0:	3c 00       	j 80011fa0 <osEE_tc_core1_isr_dummy_entry_253>
	...

80011fc0 <osEE_tc_core1_isr_dummy_entry_254>:
80011fc0:	3c 00       	j 80011fc0 <osEE_tc_core1_isr_dummy_entry_254>
	...

80011fe0 <osEE_tc_core1_isr_dummy_entry_255>:
80011fe0:	3c 00       	j 80011fe0 <osEE_tc_core1_isr_dummy_entry_255>
	...

Disassembly of section .inttab_cpu2:

80012000 <__INTTAB2>:
	...

80012020 <osEE_tc_core2_isr2_entry_1>:
80012020:	0d 00 00 02 	svlcx 
80012024:	82 f4       	mov %d4,-1
80012026:	1d ff 08 bb 	j 80009636 <osEE_tc_isr2_wrapper>
	...

80012040 <osEE_tc_core2_isr_dummy_entry_2>:
80012040:	3c 00       	j 80012040 <osEE_tc_core2_isr_dummy_entry_2>
	...

80012060 <osEE_tc_core2_isr_dummy_entry_3>:
80012060:	3c 00       	j 80012060 <osEE_tc_core2_isr_dummy_entry_3>
	...

80012080 <osEE_tc_core2_isr_dummy_entry_4>:
80012080:	3c 00       	j 80012080 <osEE_tc_core2_isr_dummy_entry_4>
	...

800120a0 <osEE_tc_core2_isr_dummy_entry_5>:
800120a0:	3c 00       	j 800120a0 <osEE_tc_core2_isr_dummy_entry_5>
	...

800120c0 <osEE_tc_core2_isr_dummy_entry_6>:
800120c0:	3c 00       	j 800120c0 <osEE_tc_core2_isr_dummy_entry_6>
	...

800120e0 <osEE_tc_core2_isr_dummy_entry_7>:
800120e0:	3c 00       	j 800120e0 <osEE_tc_core2_isr_dummy_entry_7>
	...

80012100 <osEE_tc_core2_isr_dummy_entry_8>:
80012100:	3c 00       	j 80012100 <osEE_tc_core2_isr_dummy_entry_8>
	...

80012120 <osEE_tc_core2_isr_dummy_entry_9>:
80012120:	3c 00       	j 80012120 <osEE_tc_core2_isr_dummy_entry_9>
	...

80012140 <osEE_tc_core2_isr_dummy_entry_10>:
80012140:	3c 00       	j 80012140 <osEE_tc_core2_isr_dummy_entry_10>
	...

80012160 <osEE_tc_core2_isr_dummy_entry_11>:
80012160:	3c 00       	j 80012160 <osEE_tc_core2_isr_dummy_entry_11>
	...

80012180 <osEE_tc_core2_isr_dummy_entry_12>:
80012180:	3c 00       	j 80012180 <osEE_tc_core2_isr_dummy_entry_12>
	...

800121a0 <osEE_tc_core2_isr_dummy_entry_13>:
800121a0:	3c 00       	j 800121a0 <osEE_tc_core2_isr_dummy_entry_13>
	...

800121c0 <osEE_tc_core2_isr_dummy_entry_14>:
800121c0:	3c 00       	j 800121c0 <osEE_tc_core2_isr_dummy_entry_14>
	...

800121e0 <osEE_tc_core2_isr_dummy_entry_15>:
800121e0:	3c 00       	j 800121e0 <osEE_tc_core2_isr_dummy_entry_15>
	...

80012200 <osEE_tc_core2_isr_dummy_entry_16>:
80012200:	3c 00       	j 80012200 <osEE_tc_core2_isr_dummy_entry_16>
	...

80012220 <osEE_tc_core2_isr_dummy_entry_17>:
80012220:	3c 00       	j 80012220 <osEE_tc_core2_isr_dummy_entry_17>
	...

80012240 <osEE_tc_core2_isr_dummy_entry_18>:
80012240:	3c 00       	j 80012240 <osEE_tc_core2_isr_dummy_entry_18>
	...

80012260 <osEE_tc_core2_isr_dummy_entry_19>:
80012260:	3c 00       	j 80012260 <osEE_tc_core2_isr_dummy_entry_19>
	...

80012280 <osEE_tc_core2_isr_dummy_entry_20>:
80012280:	3c 00       	j 80012280 <osEE_tc_core2_isr_dummy_entry_20>
	...

800122a0 <osEE_tc_core2_isr_dummy_entry_21>:
800122a0:	3c 00       	j 800122a0 <osEE_tc_core2_isr_dummy_entry_21>
	...

800122c0 <osEE_tc_core2_isr_dummy_entry_22>:
800122c0:	3c 00       	j 800122c0 <osEE_tc_core2_isr_dummy_entry_22>
	...

800122e0 <osEE_tc_core2_isr_dummy_entry_23>:
800122e0:	3c 00       	j 800122e0 <osEE_tc_core2_isr_dummy_entry_23>
	...

80012300 <osEE_tc_core2_isr_dummy_entry_24>:
80012300:	3c 00       	j 80012300 <osEE_tc_core2_isr_dummy_entry_24>
	...

80012320 <osEE_tc_core2_isr_dummy_entry_25>:
80012320:	3c 00       	j 80012320 <osEE_tc_core2_isr_dummy_entry_25>
	...

80012340 <osEE_tc_core2_isr_dummy_entry_26>:
80012340:	3c 00       	j 80012340 <osEE_tc_core2_isr_dummy_entry_26>
	...

80012360 <osEE_tc_core2_isr_dummy_entry_27>:
80012360:	3c 00       	j 80012360 <osEE_tc_core2_isr_dummy_entry_27>
	...

80012380 <osEE_tc_core2_isr_dummy_entry_28>:
80012380:	3c 00       	j 80012380 <osEE_tc_core2_isr_dummy_entry_28>
	...

800123a0 <osEE_tc_core2_isr_dummy_entry_29>:
800123a0:	3c 00       	j 800123a0 <osEE_tc_core2_isr_dummy_entry_29>
	...

800123c0 <osEE_tc_core2_isr_dummy_entry_30>:
800123c0:	3c 00       	j 800123c0 <osEE_tc_core2_isr_dummy_entry_30>
	...

800123e0 <osEE_tc_core2_isr_dummy_entry_31>:
800123e0:	3c 00       	j 800123e0 <osEE_tc_core2_isr_dummy_entry_31>
	...

80012400 <osEE_tc_core2_isr_dummy_entry_32>:
80012400:	3c 00       	j 80012400 <osEE_tc_core2_isr_dummy_entry_32>
	...

80012420 <osEE_tc_core2_isr_dummy_entry_33>:
80012420:	3c 00       	j 80012420 <osEE_tc_core2_isr_dummy_entry_33>
	...

80012440 <osEE_tc_core2_isr_dummy_entry_34>:
80012440:	3c 00       	j 80012440 <osEE_tc_core2_isr_dummy_entry_34>
	...

80012460 <osEE_tc_core2_isr_dummy_entry_35>:
80012460:	3c 00       	j 80012460 <osEE_tc_core2_isr_dummy_entry_35>
	...

80012480 <osEE_tc_core2_isr_dummy_entry_36>:
80012480:	3c 00       	j 80012480 <osEE_tc_core2_isr_dummy_entry_36>
	...

800124a0 <osEE_tc_core2_isr_dummy_entry_37>:
800124a0:	3c 00       	j 800124a0 <osEE_tc_core2_isr_dummy_entry_37>
	...

800124c0 <osEE_tc_core2_isr_dummy_entry_38>:
800124c0:	3c 00       	j 800124c0 <osEE_tc_core2_isr_dummy_entry_38>
	...

800124e0 <osEE_tc_core2_isr_dummy_entry_39>:
800124e0:	3c 00       	j 800124e0 <osEE_tc_core2_isr_dummy_entry_39>
	...

80012500 <osEE_tc_core2_isr_dummy_entry_40>:
80012500:	3c 00       	j 80012500 <osEE_tc_core2_isr_dummy_entry_40>
	...

80012520 <osEE_tc_core2_isr_dummy_entry_41>:
80012520:	3c 00       	j 80012520 <osEE_tc_core2_isr_dummy_entry_41>
	...

80012540 <osEE_tc_core2_isr_dummy_entry_42>:
80012540:	3c 00       	j 80012540 <osEE_tc_core2_isr_dummy_entry_42>
	...

80012560 <osEE_tc_core2_isr_dummy_entry_43>:
80012560:	3c 00       	j 80012560 <osEE_tc_core2_isr_dummy_entry_43>
	...

80012580 <osEE_tc_core2_isr_dummy_entry_44>:
80012580:	3c 00       	j 80012580 <osEE_tc_core2_isr_dummy_entry_44>
	...

800125a0 <osEE_tc_core2_isr_dummy_entry_45>:
800125a0:	3c 00       	j 800125a0 <osEE_tc_core2_isr_dummy_entry_45>
	...

800125c0 <osEE_tc_core2_isr_dummy_entry_46>:
800125c0:	3c 00       	j 800125c0 <osEE_tc_core2_isr_dummy_entry_46>
	...

800125e0 <osEE_tc_core2_isr_dummy_entry_47>:
800125e0:	3c 00       	j 800125e0 <osEE_tc_core2_isr_dummy_entry_47>
	...

80012600 <osEE_tc_core2_isr_dummy_entry_48>:
80012600:	3c 00       	j 80012600 <osEE_tc_core2_isr_dummy_entry_48>
	...

80012620 <osEE_tc_core2_isr_dummy_entry_49>:
80012620:	3c 00       	j 80012620 <osEE_tc_core2_isr_dummy_entry_49>
	...

80012640 <osEE_tc_core2_isr_dummy_entry_50>:
80012640:	3c 00       	j 80012640 <osEE_tc_core2_isr_dummy_entry_50>
	...

80012660 <osEE_tc_core2_isr_dummy_entry_51>:
80012660:	3c 00       	j 80012660 <osEE_tc_core2_isr_dummy_entry_51>
	...

80012680 <osEE_tc_core2_isr_dummy_entry_52>:
80012680:	3c 00       	j 80012680 <osEE_tc_core2_isr_dummy_entry_52>
	...

800126a0 <osEE_tc_core2_isr_dummy_entry_53>:
800126a0:	3c 00       	j 800126a0 <osEE_tc_core2_isr_dummy_entry_53>
	...

800126c0 <osEE_tc_core2_isr_dummy_entry_54>:
800126c0:	3c 00       	j 800126c0 <osEE_tc_core2_isr_dummy_entry_54>
	...

800126e0 <osEE_tc_core2_isr_dummy_entry_55>:
800126e0:	3c 00       	j 800126e0 <osEE_tc_core2_isr_dummy_entry_55>
	...

80012700 <osEE_tc_core2_isr_dummy_entry_56>:
80012700:	3c 00       	j 80012700 <osEE_tc_core2_isr_dummy_entry_56>
	...

80012720 <osEE_tc_core2_isr_dummy_entry_57>:
80012720:	3c 00       	j 80012720 <osEE_tc_core2_isr_dummy_entry_57>
	...

80012740 <osEE_tc_core2_isr_dummy_entry_58>:
80012740:	3c 00       	j 80012740 <osEE_tc_core2_isr_dummy_entry_58>
	...

80012760 <osEE_tc_core2_isr_dummy_entry_59>:
80012760:	3c 00       	j 80012760 <osEE_tc_core2_isr_dummy_entry_59>
	...

80012780 <osEE_tc_core2_isr_dummy_entry_60>:
80012780:	3c 00       	j 80012780 <osEE_tc_core2_isr_dummy_entry_60>
	...

800127a0 <osEE_tc_core2_isr_dummy_entry_61>:
800127a0:	3c 00       	j 800127a0 <osEE_tc_core2_isr_dummy_entry_61>
	...

800127c0 <osEE_tc_core2_isr_dummy_entry_62>:
800127c0:	3c 00       	j 800127c0 <osEE_tc_core2_isr_dummy_entry_62>
	...

800127e0 <osEE_tc_core2_isr_dummy_entry_63>:
800127e0:	3c 00       	j 800127e0 <osEE_tc_core2_isr_dummy_entry_63>
	...

80012800 <osEE_tc_core2_isr_dummy_entry_64>:
80012800:	3c 00       	j 80012800 <osEE_tc_core2_isr_dummy_entry_64>
	...

80012820 <osEE_tc_core2_isr_dummy_entry_65>:
80012820:	3c 00       	j 80012820 <osEE_tc_core2_isr_dummy_entry_65>
	...

80012840 <osEE_tc_core2_isr_dummy_entry_66>:
80012840:	3c 00       	j 80012840 <osEE_tc_core2_isr_dummy_entry_66>
	...

80012860 <osEE_tc_core2_isr_dummy_entry_67>:
80012860:	3c 00       	j 80012860 <osEE_tc_core2_isr_dummy_entry_67>
	...

80012880 <osEE_tc_core2_isr_dummy_entry_68>:
80012880:	3c 00       	j 80012880 <osEE_tc_core2_isr_dummy_entry_68>
	...

800128a0 <osEE_tc_core2_isr_dummy_entry_69>:
800128a0:	3c 00       	j 800128a0 <osEE_tc_core2_isr_dummy_entry_69>
	...

800128c0 <osEE_tc_core2_isr_dummy_entry_70>:
800128c0:	3c 00       	j 800128c0 <osEE_tc_core2_isr_dummy_entry_70>
	...

800128e0 <osEE_tc_core2_isr_dummy_entry_71>:
800128e0:	3c 00       	j 800128e0 <osEE_tc_core2_isr_dummy_entry_71>
	...

80012900 <osEE_tc_core2_isr_dummy_entry_72>:
80012900:	3c 00       	j 80012900 <osEE_tc_core2_isr_dummy_entry_72>
	...

80012920 <osEE_tc_core2_isr_dummy_entry_73>:
80012920:	3c 00       	j 80012920 <osEE_tc_core2_isr_dummy_entry_73>
	...

80012940 <osEE_tc_core2_isr_dummy_entry_74>:
80012940:	3c 00       	j 80012940 <osEE_tc_core2_isr_dummy_entry_74>
	...

80012960 <osEE_tc_core2_isr_dummy_entry_75>:
80012960:	3c 00       	j 80012960 <osEE_tc_core2_isr_dummy_entry_75>
	...

80012980 <osEE_tc_core2_isr_dummy_entry_76>:
80012980:	3c 00       	j 80012980 <osEE_tc_core2_isr_dummy_entry_76>
	...

800129a0 <osEE_tc_core2_isr_dummy_entry_77>:
800129a0:	3c 00       	j 800129a0 <osEE_tc_core2_isr_dummy_entry_77>
	...

800129c0 <osEE_tc_core2_isr_dummy_entry_78>:
800129c0:	3c 00       	j 800129c0 <osEE_tc_core2_isr_dummy_entry_78>
	...

800129e0 <osEE_tc_core2_isr_dummy_entry_79>:
800129e0:	3c 00       	j 800129e0 <osEE_tc_core2_isr_dummy_entry_79>
	...

80012a00 <osEE_tc_core2_isr_dummy_entry_80>:
80012a00:	3c 00       	j 80012a00 <osEE_tc_core2_isr_dummy_entry_80>
	...

80012a20 <osEE_tc_core2_isr_dummy_entry_81>:
80012a20:	3c 00       	j 80012a20 <osEE_tc_core2_isr_dummy_entry_81>
	...

80012a40 <osEE_tc_core2_isr_dummy_entry_82>:
80012a40:	3c 00       	j 80012a40 <osEE_tc_core2_isr_dummy_entry_82>
	...

80012a60 <osEE_tc_core2_isr_dummy_entry_83>:
80012a60:	3c 00       	j 80012a60 <osEE_tc_core2_isr_dummy_entry_83>
	...

80012a80 <osEE_tc_core2_isr_dummy_entry_84>:
80012a80:	3c 00       	j 80012a80 <osEE_tc_core2_isr_dummy_entry_84>
	...

80012aa0 <osEE_tc_core2_isr_dummy_entry_85>:
80012aa0:	3c 00       	j 80012aa0 <osEE_tc_core2_isr_dummy_entry_85>
	...

80012ac0 <osEE_tc_core2_isr_dummy_entry_86>:
80012ac0:	3c 00       	j 80012ac0 <osEE_tc_core2_isr_dummy_entry_86>
	...

80012ae0 <osEE_tc_core2_isr_dummy_entry_87>:
80012ae0:	3c 00       	j 80012ae0 <osEE_tc_core2_isr_dummy_entry_87>
	...

80012b00 <osEE_tc_core2_isr_dummy_entry_88>:
80012b00:	3c 00       	j 80012b00 <osEE_tc_core2_isr_dummy_entry_88>
	...

80012b20 <osEE_tc_core2_isr_dummy_entry_89>:
80012b20:	3c 00       	j 80012b20 <osEE_tc_core2_isr_dummy_entry_89>
	...

80012b40 <osEE_tc_core2_isr_dummy_entry_90>:
80012b40:	3c 00       	j 80012b40 <osEE_tc_core2_isr_dummy_entry_90>
	...

80012b60 <osEE_tc_core2_isr_dummy_entry_91>:
80012b60:	3c 00       	j 80012b60 <osEE_tc_core2_isr_dummy_entry_91>
	...

80012b80 <osEE_tc_core2_isr_dummy_entry_92>:
80012b80:	3c 00       	j 80012b80 <osEE_tc_core2_isr_dummy_entry_92>
	...

80012ba0 <osEE_tc_core2_isr_dummy_entry_93>:
80012ba0:	3c 00       	j 80012ba0 <osEE_tc_core2_isr_dummy_entry_93>
	...

80012bc0 <osEE_tc_core2_isr_dummy_entry_94>:
80012bc0:	3c 00       	j 80012bc0 <osEE_tc_core2_isr_dummy_entry_94>
	...

80012be0 <osEE_tc_core2_isr_dummy_entry_95>:
80012be0:	3c 00       	j 80012be0 <osEE_tc_core2_isr_dummy_entry_95>
	...

80012c00 <osEE_tc_core2_isr_dummy_entry_96>:
80012c00:	3c 00       	j 80012c00 <osEE_tc_core2_isr_dummy_entry_96>
	...

80012c20 <osEE_tc_core2_isr_dummy_entry_97>:
80012c20:	3c 00       	j 80012c20 <osEE_tc_core2_isr_dummy_entry_97>
	...

80012c40 <osEE_tc_core2_isr_dummy_entry_98>:
80012c40:	3c 00       	j 80012c40 <osEE_tc_core2_isr_dummy_entry_98>
	...

80012c60 <osEE_tc_core2_isr_dummy_entry_99>:
80012c60:	3c 00       	j 80012c60 <osEE_tc_core2_isr_dummy_entry_99>
	...

80012c80 <osEE_tc_core2_isr_dummy_entry_100>:
80012c80:	3c 00       	j 80012c80 <osEE_tc_core2_isr_dummy_entry_100>
	...

80012ca0 <osEE_tc_core2_isr_dummy_entry_101>:
80012ca0:	3c 00       	j 80012ca0 <osEE_tc_core2_isr_dummy_entry_101>
	...

80012cc0 <osEE_tc_core2_isr_dummy_entry_102>:
80012cc0:	3c 00       	j 80012cc0 <osEE_tc_core2_isr_dummy_entry_102>
	...

80012ce0 <osEE_tc_core2_isr_dummy_entry_103>:
80012ce0:	3c 00       	j 80012ce0 <osEE_tc_core2_isr_dummy_entry_103>
	...

80012d00 <osEE_tc_core2_isr_dummy_entry_104>:
80012d00:	3c 00       	j 80012d00 <osEE_tc_core2_isr_dummy_entry_104>
	...

80012d20 <osEE_tc_core2_isr_dummy_entry_105>:
80012d20:	3c 00       	j 80012d20 <osEE_tc_core2_isr_dummy_entry_105>
	...

80012d40 <osEE_tc_core2_isr_dummy_entry_106>:
80012d40:	3c 00       	j 80012d40 <osEE_tc_core2_isr_dummy_entry_106>
	...

80012d60 <osEE_tc_core2_isr_dummy_entry_107>:
80012d60:	3c 00       	j 80012d60 <osEE_tc_core2_isr_dummy_entry_107>
	...

80012d80 <osEE_tc_core2_isr_dummy_entry_108>:
80012d80:	3c 00       	j 80012d80 <osEE_tc_core2_isr_dummy_entry_108>
	...

80012da0 <osEE_tc_core2_isr_dummy_entry_109>:
80012da0:	3c 00       	j 80012da0 <osEE_tc_core2_isr_dummy_entry_109>
	...

80012dc0 <osEE_tc_core2_isr_dummy_entry_110>:
80012dc0:	3c 00       	j 80012dc0 <osEE_tc_core2_isr_dummy_entry_110>
	...

80012de0 <osEE_tc_core2_isr_dummy_entry_111>:
80012de0:	3c 00       	j 80012de0 <osEE_tc_core2_isr_dummy_entry_111>
	...

80012e00 <osEE_tc_core2_isr_dummy_entry_112>:
80012e00:	3c 00       	j 80012e00 <osEE_tc_core2_isr_dummy_entry_112>
	...

80012e20 <osEE_tc_core2_isr_dummy_entry_113>:
80012e20:	3c 00       	j 80012e20 <osEE_tc_core2_isr_dummy_entry_113>
	...

80012e40 <osEE_tc_core2_isr_dummy_entry_114>:
80012e40:	3c 00       	j 80012e40 <osEE_tc_core2_isr_dummy_entry_114>
	...

80012e60 <osEE_tc_core2_isr_dummy_entry_115>:
80012e60:	3c 00       	j 80012e60 <osEE_tc_core2_isr_dummy_entry_115>
	...

80012e80 <osEE_tc_core2_isr_dummy_entry_116>:
80012e80:	3c 00       	j 80012e80 <osEE_tc_core2_isr_dummy_entry_116>
	...

80012ea0 <osEE_tc_core2_isr_dummy_entry_117>:
80012ea0:	3c 00       	j 80012ea0 <osEE_tc_core2_isr_dummy_entry_117>
	...

80012ec0 <osEE_tc_core2_isr_dummy_entry_118>:
80012ec0:	3c 00       	j 80012ec0 <osEE_tc_core2_isr_dummy_entry_118>
	...

80012ee0 <osEE_tc_core2_isr_dummy_entry_119>:
80012ee0:	3c 00       	j 80012ee0 <osEE_tc_core2_isr_dummy_entry_119>
	...

80012f00 <osEE_tc_core2_isr_dummy_entry_120>:
80012f00:	3c 00       	j 80012f00 <osEE_tc_core2_isr_dummy_entry_120>
	...

80012f20 <osEE_tc_core2_isr_dummy_entry_121>:
80012f20:	3c 00       	j 80012f20 <osEE_tc_core2_isr_dummy_entry_121>
	...

80012f40 <osEE_tc_core2_isr_dummy_entry_122>:
80012f40:	3c 00       	j 80012f40 <osEE_tc_core2_isr_dummy_entry_122>
	...

80012f60 <osEE_tc_core2_isr_dummy_entry_123>:
80012f60:	3c 00       	j 80012f60 <osEE_tc_core2_isr_dummy_entry_123>
	...

80012f80 <osEE_tc_core2_isr_dummy_entry_124>:
80012f80:	3c 00       	j 80012f80 <osEE_tc_core2_isr_dummy_entry_124>
	...

80012fa0 <osEE_tc_core2_isr_dummy_entry_125>:
80012fa0:	3c 00       	j 80012fa0 <osEE_tc_core2_isr_dummy_entry_125>
	...

80012fc0 <osEE_tc_core2_isr_dummy_entry_126>:
80012fc0:	3c 00       	j 80012fc0 <osEE_tc_core2_isr_dummy_entry_126>
	...

80012fe0 <osEE_tc_core2_isr_dummy_entry_127>:
80012fe0:	3c 00       	j 80012fe0 <osEE_tc_core2_isr_dummy_entry_127>
	...

80013000 <osEE_tc_core2_isr_dummy_entry_128>:
80013000:	3c 00       	j 80013000 <osEE_tc_core2_isr_dummy_entry_128>
	...

80013020 <osEE_tc_core2_isr_dummy_entry_129>:
80013020:	3c 00       	j 80013020 <osEE_tc_core2_isr_dummy_entry_129>
	...

80013040 <osEE_tc_core2_isr_dummy_entry_130>:
80013040:	3c 00       	j 80013040 <osEE_tc_core2_isr_dummy_entry_130>
	...

80013060 <osEE_tc_core2_isr_dummy_entry_131>:
80013060:	3c 00       	j 80013060 <osEE_tc_core2_isr_dummy_entry_131>
	...

80013080 <osEE_tc_core2_isr_dummy_entry_132>:
80013080:	3c 00       	j 80013080 <osEE_tc_core2_isr_dummy_entry_132>
	...

800130a0 <osEE_tc_core2_isr_dummy_entry_133>:
800130a0:	3c 00       	j 800130a0 <osEE_tc_core2_isr_dummy_entry_133>
	...

800130c0 <osEE_tc_core2_isr_dummy_entry_134>:
800130c0:	3c 00       	j 800130c0 <osEE_tc_core2_isr_dummy_entry_134>
	...

800130e0 <osEE_tc_core2_isr_dummy_entry_135>:
800130e0:	3c 00       	j 800130e0 <osEE_tc_core2_isr_dummy_entry_135>
	...

80013100 <osEE_tc_core2_isr_dummy_entry_136>:
80013100:	3c 00       	j 80013100 <osEE_tc_core2_isr_dummy_entry_136>
	...

80013120 <osEE_tc_core2_isr_dummy_entry_137>:
80013120:	3c 00       	j 80013120 <osEE_tc_core2_isr_dummy_entry_137>
	...

80013140 <osEE_tc_core2_isr_dummy_entry_138>:
80013140:	3c 00       	j 80013140 <osEE_tc_core2_isr_dummy_entry_138>
	...

80013160 <osEE_tc_core2_isr_dummy_entry_139>:
80013160:	3c 00       	j 80013160 <osEE_tc_core2_isr_dummy_entry_139>
	...

80013180 <osEE_tc_core2_isr_dummy_entry_140>:
80013180:	3c 00       	j 80013180 <osEE_tc_core2_isr_dummy_entry_140>
	...

800131a0 <osEE_tc_core2_isr_dummy_entry_141>:
800131a0:	3c 00       	j 800131a0 <osEE_tc_core2_isr_dummy_entry_141>
	...

800131c0 <osEE_tc_core2_isr_dummy_entry_142>:
800131c0:	3c 00       	j 800131c0 <osEE_tc_core2_isr_dummy_entry_142>
	...

800131e0 <osEE_tc_core2_isr_dummy_entry_143>:
800131e0:	3c 00       	j 800131e0 <osEE_tc_core2_isr_dummy_entry_143>
	...

80013200 <osEE_tc_core2_isr_dummy_entry_144>:
80013200:	3c 00       	j 80013200 <osEE_tc_core2_isr_dummy_entry_144>
	...

80013220 <osEE_tc_core2_isr_dummy_entry_145>:
80013220:	3c 00       	j 80013220 <osEE_tc_core2_isr_dummy_entry_145>
	...

80013240 <osEE_tc_core2_isr_dummy_entry_146>:
80013240:	3c 00       	j 80013240 <osEE_tc_core2_isr_dummy_entry_146>
	...

80013260 <osEE_tc_core2_isr_dummy_entry_147>:
80013260:	3c 00       	j 80013260 <osEE_tc_core2_isr_dummy_entry_147>
	...

80013280 <osEE_tc_core2_isr_dummy_entry_148>:
80013280:	3c 00       	j 80013280 <osEE_tc_core2_isr_dummy_entry_148>
	...

800132a0 <osEE_tc_core2_isr_dummy_entry_149>:
800132a0:	3c 00       	j 800132a0 <osEE_tc_core2_isr_dummy_entry_149>
	...

800132c0 <osEE_tc_core2_isr_dummy_entry_150>:
800132c0:	3c 00       	j 800132c0 <osEE_tc_core2_isr_dummy_entry_150>
	...

800132e0 <osEE_tc_core2_isr_dummy_entry_151>:
800132e0:	3c 00       	j 800132e0 <osEE_tc_core2_isr_dummy_entry_151>
	...

80013300 <osEE_tc_core2_isr_dummy_entry_152>:
80013300:	3c 00       	j 80013300 <osEE_tc_core2_isr_dummy_entry_152>
	...

80013320 <osEE_tc_core2_isr_dummy_entry_153>:
80013320:	3c 00       	j 80013320 <osEE_tc_core2_isr_dummy_entry_153>
	...

80013340 <osEE_tc_core2_isr_dummy_entry_154>:
80013340:	3c 00       	j 80013340 <osEE_tc_core2_isr_dummy_entry_154>
	...

80013360 <osEE_tc_core2_isr_dummy_entry_155>:
80013360:	3c 00       	j 80013360 <osEE_tc_core2_isr_dummy_entry_155>
	...

80013380 <osEE_tc_core2_isr_dummy_entry_156>:
80013380:	3c 00       	j 80013380 <osEE_tc_core2_isr_dummy_entry_156>
	...

800133a0 <osEE_tc_core2_isr_dummy_entry_157>:
800133a0:	3c 00       	j 800133a0 <osEE_tc_core2_isr_dummy_entry_157>
	...

800133c0 <osEE_tc_core2_isr_dummy_entry_158>:
800133c0:	3c 00       	j 800133c0 <osEE_tc_core2_isr_dummy_entry_158>
	...

800133e0 <osEE_tc_core2_isr_dummy_entry_159>:
800133e0:	3c 00       	j 800133e0 <osEE_tc_core2_isr_dummy_entry_159>
	...

80013400 <osEE_tc_core2_isr_dummy_entry_160>:
80013400:	3c 00       	j 80013400 <osEE_tc_core2_isr_dummy_entry_160>
	...

80013420 <osEE_tc_core2_isr_dummy_entry_161>:
80013420:	3c 00       	j 80013420 <osEE_tc_core2_isr_dummy_entry_161>
	...

80013440 <osEE_tc_core2_isr_dummy_entry_162>:
80013440:	3c 00       	j 80013440 <osEE_tc_core2_isr_dummy_entry_162>
	...

80013460 <osEE_tc_core2_isr_dummy_entry_163>:
80013460:	3c 00       	j 80013460 <osEE_tc_core2_isr_dummy_entry_163>
	...

80013480 <osEE_tc_core2_isr_dummy_entry_164>:
80013480:	3c 00       	j 80013480 <osEE_tc_core2_isr_dummy_entry_164>
	...

800134a0 <osEE_tc_core2_isr_dummy_entry_165>:
800134a0:	3c 00       	j 800134a0 <osEE_tc_core2_isr_dummy_entry_165>
	...

800134c0 <osEE_tc_core2_isr_dummy_entry_166>:
800134c0:	3c 00       	j 800134c0 <osEE_tc_core2_isr_dummy_entry_166>
	...

800134e0 <osEE_tc_core2_isr_dummy_entry_167>:
800134e0:	3c 00       	j 800134e0 <osEE_tc_core2_isr_dummy_entry_167>
	...

80013500 <osEE_tc_core2_isr_dummy_entry_168>:
80013500:	3c 00       	j 80013500 <osEE_tc_core2_isr_dummy_entry_168>
	...

80013520 <osEE_tc_core2_isr_dummy_entry_169>:
80013520:	3c 00       	j 80013520 <osEE_tc_core2_isr_dummy_entry_169>
	...

80013540 <osEE_tc_core2_isr_dummy_entry_170>:
80013540:	3c 00       	j 80013540 <osEE_tc_core2_isr_dummy_entry_170>
	...

80013560 <osEE_tc_core2_isr_dummy_entry_171>:
80013560:	3c 00       	j 80013560 <osEE_tc_core2_isr_dummy_entry_171>
	...

80013580 <osEE_tc_core2_isr_dummy_entry_172>:
80013580:	3c 00       	j 80013580 <osEE_tc_core2_isr_dummy_entry_172>
	...

800135a0 <osEE_tc_core2_isr_dummy_entry_173>:
800135a0:	3c 00       	j 800135a0 <osEE_tc_core2_isr_dummy_entry_173>
	...

800135c0 <osEE_tc_core2_isr_dummy_entry_174>:
800135c0:	3c 00       	j 800135c0 <osEE_tc_core2_isr_dummy_entry_174>
	...

800135e0 <osEE_tc_core2_isr_dummy_entry_175>:
800135e0:	3c 00       	j 800135e0 <osEE_tc_core2_isr_dummy_entry_175>
	...

80013600 <osEE_tc_core2_isr_dummy_entry_176>:
80013600:	3c 00       	j 80013600 <osEE_tc_core2_isr_dummy_entry_176>
	...

80013620 <osEE_tc_core2_isr_dummy_entry_177>:
80013620:	3c 00       	j 80013620 <osEE_tc_core2_isr_dummy_entry_177>
	...

80013640 <osEE_tc_core2_isr_dummy_entry_178>:
80013640:	3c 00       	j 80013640 <osEE_tc_core2_isr_dummy_entry_178>
	...

80013660 <osEE_tc_core2_isr_dummy_entry_179>:
80013660:	3c 00       	j 80013660 <osEE_tc_core2_isr_dummy_entry_179>
	...

80013680 <osEE_tc_core2_isr_dummy_entry_180>:
80013680:	3c 00       	j 80013680 <osEE_tc_core2_isr_dummy_entry_180>
	...

800136a0 <osEE_tc_core2_isr_dummy_entry_181>:
800136a0:	3c 00       	j 800136a0 <osEE_tc_core2_isr_dummy_entry_181>
	...

800136c0 <osEE_tc_core2_isr_dummy_entry_182>:
800136c0:	3c 00       	j 800136c0 <osEE_tc_core2_isr_dummy_entry_182>
	...

800136e0 <osEE_tc_core2_isr_dummy_entry_183>:
800136e0:	3c 00       	j 800136e0 <osEE_tc_core2_isr_dummy_entry_183>
	...

80013700 <osEE_tc_core2_isr_dummy_entry_184>:
80013700:	3c 00       	j 80013700 <osEE_tc_core2_isr_dummy_entry_184>
	...

80013720 <osEE_tc_core2_isr_dummy_entry_185>:
80013720:	3c 00       	j 80013720 <osEE_tc_core2_isr_dummy_entry_185>
	...

80013740 <osEE_tc_core2_isr_dummy_entry_186>:
80013740:	3c 00       	j 80013740 <osEE_tc_core2_isr_dummy_entry_186>
	...

80013760 <osEE_tc_core2_isr_dummy_entry_187>:
80013760:	3c 00       	j 80013760 <osEE_tc_core2_isr_dummy_entry_187>
	...

80013780 <osEE_tc_core2_isr_dummy_entry_188>:
80013780:	3c 00       	j 80013780 <osEE_tc_core2_isr_dummy_entry_188>
	...

800137a0 <osEE_tc_core2_isr_dummy_entry_189>:
800137a0:	3c 00       	j 800137a0 <osEE_tc_core2_isr_dummy_entry_189>
	...

800137c0 <osEE_tc_core2_isr_dummy_entry_190>:
800137c0:	3c 00       	j 800137c0 <osEE_tc_core2_isr_dummy_entry_190>
	...

800137e0 <osEE_tc_core2_isr_dummy_entry_191>:
800137e0:	3c 00       	j 800137e0 <osEE_tc_core2_isr_dummy_entry_191>
	...

80013800 <osEE_tc_core2_isr_dummy_entry_192>:
80013800:	3c 00       	j 80013800 <osEE_tc_core2_isr_dummy_entry_192>
	...

80013820 <osEE_tc_core2_isr_dummy_entry_193>:
80013820:	3c 00       	j 80013820 <osEE_tc_core2_isr_dummy_entry_193>
	...

80013840 <osEE_tc_core2_isr_dummy_entry_194>:
80013840:	3c 00       	j 80013840 <osEE_tc_core2_isr_dummy_entry_194>
	...

80013860 <osEE_tc_core2_isr_dummy_entry_195>:
80013860:	3c 00       	j 80013860 <osEE_tc_core2_isr_dummy_entry_195>
	...

80013880 <osEE_tc_core2_isr_dummy_entry_196>:
80013880:	3c 00       	j 80013880 <osEE_tc_core2_isr_dummy_entry_196>
	...

800138a0 <osEE_tc_core2_isr_dummy_entry_197>:
800138a0:	3c 00       	j 800138a0 <osEE_tc_core2_isr_dummy_entry_197>
	...

800138c0 <osEE_tc_core2_isr_dummy_entry_198>:
800138c0:	3c 00       	j 800138c0 <osEE_tc_core2_isr_dummy_entry_198>
	...

800138e0 <osEE_tc_core2_isr_dummy_entry_199>:
800138e0:	3c 00       	j 800138e0 <osEE_tc_core2_isr_dummy_entry_199>
	...

80013900 <osEE_tc_core2_isr_dummy_entry_200>:
80013900:	3c 00       	j 80013900 <osEE_tc_core2_isr_dummy_entry_200>
	...

80013920 <osEE_tc_core2_isr_dummy_entry_201>:
80013920:	3c 00       	j 80013920 <osEE_tc_core2_isr_dummy_entry_201>
	...

80013940 <osEE_tc_core2_isr_dummy_entry_202>:
80013940:	3c 00       	j 80013940 <osEE_tc_core2_isr_dummy_entry_202>
	...

80013960 <osEE_tc_core2_isr_dummy_entry_203>:
80013960:	3c 00       	j 80013960 <osEE_tc_core2_isr_dummy_entry_203>
	...

80013980 <osEE_tc_core2_isr_dummy_entry_204>:
80013980:	3c 00       	j 80013980 <osEE_tc_core2_isr_dummy_entry_204>
	...

800139a0 <osEE_tc_core2_isr_dummy_entry_205>:
800139a0:	3c 00       	j 800139a0 <osEE_tc_core2_isr_dummy_entry_205>
	...

800139c0 <osEE_tc_core2_isr_dummy_entry_206>:
800139c0:	3c 00       	j 800139c0 <osEE_tc_core2_isr_dummy_entry_206>
	...

800139e0 <osEE_tc_core2_isr_dummy_entry_207>:
800139e0:	3c 00       	j 800139e0 <osEE_tc_core2_isr_dummy_entry_207>
	...

80013a00 <osEE_tc_core2_isr_dummy_entry_208>:
80013a00:	3c 00       	j 80013a00 <osEE_tc_core2_isr_dummy_entry_208>
	...

80013a20 <osEE_tc_core2_isr_dummy_entry_209>:
80013a20:	3c 00       	j 80013a20 <osEE_tc_core2_isr_dummy_entry_209>
	...

80013a40 <osEE_tc_core2_isr_dummy_entry_210>:
80013a40:	3c 00       	j 80013a40 <osEE_tc_core2_isr_dummy_entry_210>
	...

80013a60 <osEE_tc_core2_isr_dummy_entry_211>:
80013a60:	3c 00       	j 80013a60 <osEE_tc_core2_isr_dummy_entry_211>
	...

80013a80 <osEE_tc_core2_isr_dummy_entry_212>:
80013a80:	3c 00       	j 80013a80 <osEE_tc_core2_isr_dummy_entry_212>
	...

80013aa0 <osEE_tc_core2_isr_dummy_entry_213>:
80013aa0:	3c 00       	j 80013aa0 <osEE_tc_core2_isr_dummy_entry_213>
	...

80013ac0 <osEE_tc_core2_isr_dummy_entry_214>:
80013ac0:	3c 00       	j 80013ac0 <osEE_tc_core2_isr_dummy_entry_214>
	...

80013ae0 <osEE_tc_core2_isr_dummy_entry_215>:
80013ae0:	3c 00       	j 80013ae0 <osEE_tc_core2_isr_dummy_entry_215>
	...

80013b00 <osEE_tc_core2_isr_dummy_entry_216>:
80013b00:	3c 00       	j 80013b00 <osEE_tc_core2_isr_dummy_entry_216>
	...

80013b20 <osEE_tc_core2_isr_dummy_entry_217>:
80013b20:	3c 00       	j 80013b20 <osEE_tc_core2_isr_dummy_entry_217>
	...

80013b40 <osEE_tc_core2_isr_dummy_entry_218>:
80013b40:	3c 00       	j 80013b40 <osEE_tc_core2_isr_dummy_entry_218>
	...

80013b60 <osEE_tc_core2_isr_dummy_entry_219>:
80013b60:	3c 00       	j 80013b60 <osEE_tc_core2_isr_dummy_entry_219>
	...

80013b80 <osEE_tc_core2_isr_dummy_entry_220>:
80013b80:	3c 00       	j 80013b80 <osEE_tc_core2_isr_dummy_entry_220>
	...

80013ba0 <osEE_tc_core2_isr_dummy_entry_221>:
80013ba0:	3c 00       	j 80013ba0 <osEE_tc_core2_isr_dummy_entry_221>
	...

80013bc0 <osEE_tc_core2_isr_dummy_entry_222>:
80013bc0:	3c 00       	j 80013bc0 <osEE_tc_core2_isr_dummy_entry_222>
	...

80013be0 <osEE_tc_core2_isr_dummy_entry_223>:
80013be0:	3c 00       	j 80013be0 <osEE_tc_core2_isr_dummy_entry_223>
	...

80013c00 <osEE_tc_core2_isr_dummy_entry_224>:
80013c00:	3c 00       	j 80013c00 <osEE_tc_core2_isr_dummy_entry_224>
	...

80013c20 <osEE_tc_core2_isr_dummy_entry_225>:
80013c20:	3c 00       	j 80013c20 <osEE_tc_core2_isr_dummy_entry_225>
	...

80013c40 <osEE_tc_core2_isr_dummy_entry_226>:
80013c40:	3c 00       	j 80013c40 <osEE_tc_core2_isr_dummy_entry_226>
	...

80013c60 <osEE_tc_core2_isr_dummy_entry_227>:
80013c60:	3c 00       	j 80013c60 <osEE_tc_core2_isr_dummy_entry_227>
	...

80013c80 <osEE_tc_core2_isr_dummy_entry_228>:
80013c80:	3c 00       	j 80013c80 <osEE_tc_core2_isr_dummy_entry_228>
	...

80013ca0 <osEE_tc_core2_isr_dummy_entry_229>:
80013ca0:	3c 00       	j 80013ca0 <osEE_tc_core2_isr_dummy_entry_229>
	...

80013cc0 <osEE_tc_core2_isr_dummy_entry_230>:
80013cc0:	3c 00       	j 80013cc0 <osEE_tc_core2_isr_dummy_entry_230>
	...

80013ce0 <osEE_tc_core2_isr_dummy_entry_231>:
80013ce0:	3c 00       	j 80013ce0 <osEE_tc_core2_isr_dummy_entry_231>
	...

80013d00 <osEE_tc_core2_isr_dummy_entry_232>:
80013d00:	3c 00       	j 80013d00 <osEE_tc_core2_isr_dummy_entry_232>
	...

80013d20 <osEE_tc_core2_isr_dummy_entry_233>:
80013d20:	3c 00       	j 80013d20 <osEE_tc_core2_isr_dummy_entry_233>
	...

80013d40 <osEE_tc_core2_isr_dummy_entry_234>:
80013d40:	3c 00       	j 80013d40 <osEE_tc_core2_isr_dummy_entry_234>
	...

80013d60 <osEE_tc_core2_isr_dummy_entry_235>:
80013d60:	3c 00       	j 80013d60 <osEE_tc_core2_isr_dummy_entry_235>
	...

80013d80 <osEE_tc_core2_isr_dummy_entry_236>:
80013d80:	3c 00       	j 80013d80 <osEE_tc_core2_isr_dummy_entry_236>
	...

80013da0 <osEE_tc_core2_isr_dummy_entry_237>:
80013da0:	3c 00       	j 80013da0 <osEE_tc_core2_isr_dummy_entry_237>
	...

80013dc0 <osEE_tc_core2_isr_dummy_entry_238>:
80013dc0:	3c 00       	j 80013dc0 <osEE_tc_core2_isr_dummy_entry_238>
	...

80013de0 <osEE_tc_core2_isr_dummy_entry_239>:
80013de0:	3c 00       	j 80013de0 <osEE_tc_core2_isr_dummy_entry_239>
	...

80013e00 <osEE_tc_core2_isr_dummy_entry_240>:
80013e00:	3c 00       	j 80013e00 <osEE_tc_core2_isr_dummy_entry_240>
	...

80013e20 <osEE_tc_core2_isr_dummy_entry_241>:
80013e20:	3c 00       	j 80013e20 <osEE_tc_core2_isr_dummy_entry_241>
	...

80013e40 <osEE_tc_core2_isr_dummy_entry_242>:
80013e40:	3c 00       	j 80013e40 <osEE_tc_core2_isr_dummy_entry_242>
	...

80013e60 <osEE_tc_core2_isr_dummy_entry_243>:
80013e60:	3c 00       	j 80013e60 <osEE_tc_core2_isr_dummy_entry_243>
	...

80013e80 <osEE_tc_core2_isr_dummy_entry_244>:
80013e80:	3c 00       	j 80013e80 <osEE_tc_core2_isr_dummy_entry_244>
	...

80013ea0 <osEE_tc_core2_isr_dummy_entry_245>:
80013ea0:	3c 00       	j 80013ea0 <osEE_tc_core2_isr_dummy_entry_245>
	...

80013ec0 <osEE_tc_core2_isr_dummy_entry_246>:
80013ec0:	3c 00       	j 80013ec0 <osEE_tc_core2_isr_dummy_entry_246>
	...

80013ee0 <osEE_tc_core2_isr_dummy_entry_247>:
80013ee0:	3c 00       	j 80013ee0 <osEE_tc_core2_isr_dummy_entry_247>
	...

80013f00 <osEE_tc_core2_isr_dummy_entry_248>:
80013f00:	3c 00       	j 80013f00 <osEE_tc_core2_isr_dummy_entry_248>
	...

80013f20 <osEE_tc_core2_isr_dummy_entry_249>:
80013f20:	3c 00       	j 80013f20 <osEE_tc_core2_isr_dummy_entry_249>
	...

80013f40 <osEE_tc_core2_isr_dummy_entry_250>:
80013f40:	3c 00       	j 80013f40 <osEE_tc_core2_isr_dummy_entry_250>
	...

80013f60 <osEE_tc_core2_isr_dummy_entry_251>:
80013f60:	3c 00       	j 80013f60 <osEE_tc_core2_isr_dummy_entry_251>
	...

80013f80 <osEE_tc_core2_isr_dummy_entry_252>:
80013f80:	3c 00       	j 80013f80 <osEE_tc_core2_isr_dummy_entry_252>
	...

80013fa0 <osEE_tc_core2_isr_dummy_entry_253>:
80013fa0:	3c 00       	j 80013fa0 <osEE_tc_core2_isr_dummy_entry_253>
	...

80013fc0 <osEE_tc_core2_isr_dummy_entry_254>:
80013fc0:	3c 00       	j 80013fc0 <osEE_tc_core2_isr_dummy_entry_254>
	...

80013fe0 <osEE_tc_core2_isr_dummy_entry_255>:
80013fe0:	3c 00       	j 80013fe0 <osEE_tc_core2_isr_dummy_entry_255>
	...
